(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("photoeditorsdk/js/PhotoEditorSDK"), require("react"), require("react-dom"));
	else if(typeof define === 'function' && define.amd)
		define(["photoeditorsdk", "react", "react-dom"], factory);
	else if(typeof exports === 'object')
		exports["PhotoEditorReactUI"] = factory(require("photoeditorsdk/js/PhotoEditorSDK"), require("react"), require("react-dom"));
	else
		root["PhotoEditorReactUI"] = factory(root["PhotoEditorSDK"], root["React"], root["ReactDOM"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_16__, __WEBPACK_EXTERNAL_MODULE_62__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 59);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SharedConstants = exports.PropTypes = exports.ImageLoader = exports.ImageFormat = exports.ColorMatrix = exports.now = exports.Log = exports.cancelAnimationFrame = exports.requestAnimationFrame = exports.SDK = exports.EXIF = exports.ReactDOM = exports.UniformType = exports.OptionType = exports.RenderType = exports.Base64 = exports.Color = exports.SharedState = exports.Constants = exports.EventEmitter = exports.SDKUtils = exports.Vector2 = exports.ReactBEM = exports.BaseComponent = exports.Classnames = exports.BEM = exports.React = exports.Utils = exports.Promise = undefined;

var _photoeditorsdk = __webpack_require__(7);

var _photoeditorsdk2 = _interopRequireDefault(_photoeditorsdk);

var _react = __webpack_require__(16);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(62);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _propTypes = __webpack_require__(33);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(35);

var _classnames2 = _interopRequireDefault(_classnames);

var _bem = __webpack_require__(36);

var _bem2 = _interopRequireDefault(_bem);

var _reactBem = __webpack_require__(37);

var _reactBem2 = _interopRequireDefault(_reactBem);

var _baseComponent = __webpack_require__(67);

var _baseComponent2 = _interopRequireDefault(_baseComponent);

var _utils = __webpack_require__(68);

var _utils2 = _interopRequireDefault(_utils);

var _constants = __webpack_require__(84);

var _constants2 = _interopRequireDefault(_constants);

var _sharedState = __webpack_require__(85);

var _sharedState2 = _interopRequireDefault(_sharedState);

var _animationFrame = __webpack_require__(86);

var _log = __webpack_require__(20);

var _log2 = _interopRequireDefault(_log);

var _imageLoader = __webpack_require__(23);

var _imageLoader2 = _interopRequireDefault(_imageLoader);

var _constants3 = __webpack_require__(38);

var _constants4 = _interopRequireDefault(_constants3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Base64 = _photoeditorsdk2.default.Base64; /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var Color = _photoeditorsdk2.default.Color;
var ColorMatrix = _photoeditorsdk2.default.Math.ColorMatrix;
var EventEmitter = _photoeditorsdk2.default.EventEmitter;
var EXIF = _photoeditorsdk2.default.EXIF;
var OptionType = _photoeditorsdk2.default.OptionType;
var Promise = _photoeditorsdk2.default.Promise;
var SDKUtils = _photoeditorsdk2.default.Utils;
var RenderType = _photoeditorsdk2.default.RenderType;
var ImageFormat = _photoeditorsdk2.default.ImageFormat;
var SDK = _photoeditorsdk2.default;
var UniformType = _photoeditorsdk2.default.UniformType;
var Vector2 = _photoeditorsdk2.default.Math.Vector2;

var now = typeof window !== 'undefined' && window.performance && window.performance.now ? window.performance.now.bind(window.performance) : __webpack_require__(39);

exports.Promise = Promise;
exports.Utils = _utils2.default;
exports.React = _react2.default;
exports.BEM = _bem2.default;
exports.Classnames = _classnames2.default;
exports.BaseComponent = _baseComponent2.default;
exports.ReactBEM = _reactBem2.default;
exports.Vector2 = Vector2;
exports.SDKUtils = SDKUtils;
exports.EventEmitter = EventEmitter;
exports.Constants = _constants2.default;
exports.SharedState = _sharedState2.default;
exports.Color = Color;
exports.Base64 = Base64;
exports.RenderType = RenderType;
exports.OptionType = OptionType;
exports.UniformType = UniformType;
exports.ReactDOM = _reactDom2.default;
exports.EXIF = EXIF;
exports.SDK = SDK;
exports.requestAnimationFrame = _animationFrame.requestAnimationFrame;
exports.cancelAnimationFrame = _animationFrame.cancelAnimationFrame;
exports.Log = _log2.default;
exports.now = now;
exports.ColorMatrix = ColorMatrix;
exports.ImageFormat = ImageFormat;
exports.ImageLoader = _imageLoader2.default;
exports.PropTypes = _propTypes2.default;
exports.SharedConstants = _constants4.default;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var Modal = function (_EventEmitter) {
  _inherits(Modal, _EventEmitter);

  function Modal(type, title, text) {
    var overlay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    _classCallCheck(this, Modal);

    var _this = _possibleConstructorReturn(this, (Modal.__proto__ || Object.getPrototypeOf(Modal)).call(this));

    _this.type = type;
    _this.title = title;
    _this.text = text;
    _this.overlay = overlay;
    _this.data = null;
    return _this;
  }

  /**
   * Sets the data to the given one
   * @param {Object} data
   */


  _createClass(Modal, [{
    key: 'setData',
    value: function setData(data) {
      this.data = data;
      this.emit('update');
    }

    /**
     * Closes this modal
     */

  }, {
    key: 'close',
    value: function close() {
      this.emit('close');
    }
  }]);

  return Modal;
}(_globals.EventEmitter);

var ModalManager = function (_EventEmitter2) {
  _inherits(ModalManager, _EventEmitter2);

  function ModalManager() {
    _classCallCheck(this, ModalManager);

    var _this2 = _possibleConstructorReturn(this, (ModalManager.__proto__ || Object.getPrototypeOf(ModalManager)).call(this));

    _this2._modals = [];
    return _this2;
  }

  /**
   * Creates a loading modal
   * @param  {String} text
   * @return {Modal}
   */


  _createClass(ModalManager, [{
    key: 'displayLoading',
    value: function displayLoading(text) {
      var modal = new Modal('loading', null, text);
      this.addModal(modal);
      return modal;
    }

    /**
     * Creates a progress modal
     * @param  {String} text
     * @return {Modal}
     */

  }, {
    key: 'displayProgress',
    value: function displayProgress(text) {
      var progress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      var modal = new Modal('progress', null, text);
      modal.setData({ progress: progress });
      this.addModal(modal);
      return modal;
    }

    /**
     * Creats a warning modal
     * @param  {String} title
     * @param  {String} text
     * @return {Modal}
     */

  }, {
    key: 'displayWarning',
    value: function displayWarning(title, text) {
      var modal = new Modal('warning', title, text);
      this.addModal(modal);
      return modal;
    }

    /**
     * Creates an error modal
     * @param  {String} title
     * @param  {String} text
     * @param  {Boolean} overlay = true
     * @return {Modal}
     */

  }, {
    key: 'displayError',
    value: function displayError(title, text) {
      var overlay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var modal = new Modal('error', title, text, overlay);
      this.addModal(modal);
      return modal;
    }

    /**
     * Adds the given modal to the list of modals
     * @param {Modal} modal
     */

  }, {
    key: 'addModal',
    value: function addModal(modal) {
      var _this3 = this;

      this._modals.push(modal);
      modal.on('close', function () {
        _this3.removeModal(modal);
      });
      modal.on('update', function () {
        _this3.emit('update');
      });
      this.emit('update');
    }

    /**
     * Removes the given modal from the list of modals
     * @param  {Modal} modal
     */

  }, {
    key: 'removeModal',
    value: function removeModal(modal) {
      var index = this._modals.indexOf(modal);
      this._modals.splice(index, 1);
      this.emit('update');
    }

    /**
     * Returns the modals
     * @return {Array.<Modal>}
     */

  }, {
    key: 'getModals',
    value: function getModals() {
      return this._modals;
    }

    /**
     * Returns the one and only instance of this class
     * @return {ModalManager}
     */

  }], [{
    key: 'instance',
    get: function get() {
      if (!this._instance) {
        this._instance = new ModalManager();
      }
      return this._instance;
    }
  }]);

  return ModalManager;
}(_globals.EventEmitter);

exports.default = ModalManager;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _draggableComponent = __webpack_require__(5);

var _draggableComponent2 = _interopRequireDefault(_draggableComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var SCROLLBAR_WIDTH = 12;

var ScrollbarComponent = function (_BaseComponent) {
  _inherits(ScrollbarComponent, _BaseComponent);

  function ScrollbarComponent() {
    _classCallCheck(this, ScrollbarComponent);

    var _this = _possibleConstructorReturn(this, (ScrollbarComponent.__proto__ || Object.getPrototypeOf(ScrollbarComponent)).call(this));

    if (!_this.constructor.NATIVE_SCROLLBAR_WIDTH) {
      _this.constructor.NATIVE_SCROLLBAR_WIDTH = _globals.Utils.getScrollbarWidth();
    }

    _this._needsStyleFixes = true;
    _this._isDragging = false;
    _this._bindAll('_onButtonDragStart', '_onButtonDrag', '_onButtonDragStop', '_onBarDragStart', '_onBarDrag', '_onBarDragStop', '_onListScroll');
    _this.state = {
      buttonSize: 0,
      buttonPosition: 0,
      buttonVisible: false
    };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called after the component has been mounted
   */


  _createClass(ScrollbarComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      _get(ScrollbarComponent.prototype.__proto__ || Object.getPrototypeOf(ScrollbarComponent.prototype), 'componentDidMount', this).call(this);
      this.update();
    }
  }, {
    key: 'fixStyles',
    value: function fixStyles() {
      if (!_globals.Utils.isMobile()) {
        this._updateListSize();
      }
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the user scrolls the list
     * @private
     */

  }, {
    key: '_onListScroll',
    value: function _onListScroll() {
      if (this._isDragging) return;

      var direction = this._getDirection();

      var listScrollSize = void 0,
          listScrollPosition = void 0,
          backgroundScrollSize = void 0;
      if (direction === ScrollbarComponent.HORIZONTAL) {
        listScrollSize = this._list.scrollWidth - this._list.offsetWidth;
        listScrollPosition = this._list.scrollLeft;
        backgroundScrollSize = this._node.offsetWidth - this.state.buttonSize;
      } else if (direction === ScrollbarComponent.VERTICAL) {
        listScrollSize = this._list.scrollHeight - this._list.offsetHeight;
        listScrollPosition = this._list.scrollTop;
        backgroundScrollSize = this._node.offsetHeight - this.state.buttonSize;
      }

      var progress = listScrollPosition / listScrollSize;
      this.setState({
        buttonPosition: backgroundScrollSize * progress
      });
    }

    /**
     * Gets called when the user presses a mouse button on the bar
     * @private
     */

  }, {
    key: '_onButtonDragStart',
    value: function _onButtonDragStart(e) {
      this._isDragging = true;
      this._initialButtonPosition = this.state.buttonPosition || 0;
    }

    /**
     * Gets called while the user drags the button
     * @param {Vector2} diff
     * @private
     */

  }, {
    key: '_onButtonDrag',
    value: function _onButtonDrag(diff) {
      var direction = this._getDirection();

      var buttonPosition = void 0;
      if (direction === ScrollbarComponent.HORIZONTAL) {
        buttonPosition = this._initialButtonPosition + diff.x;
      } else if (direction === ScrollbarComponent.VERTICAL) {
        buttonPosition = this._initialButtonPosition + diff.y;
      }
      this._setButtonPosition(buttonPosition);
    }

    /**
     * Gets called when the user releases the button
     * @private
     */

  }, {
    key: '_onButtonDragStop',
    value: function _onButtonDragStop() {
      this._isDragging = false;
    }

    /**
     * Gets called when the user starts dragging the bar
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onBarDragStart',
    value: function _onBarDragStart(e) {
      var mousePosition = _globals.Utils.getEventPosition(e);
      this._initialPosition = mousePosition.clone();
      var boundingRect = this._node.getBoundingClientRect();
      var elementOffset = new _globals.Vector2(boundingRect.left, boundingRect.top);

      var relativePosition = mousePosition.clone().subtract(elementOffset);

      var direction = this._getDirection();
      if (direction === ScrollbarComponent.HORIZONTAL) {
        this._setButtonPosition(relativePosition.x - this.state.buttonSize / 2);
      } else if (direction === ScrollbarComponent.VERTICAL) {
        this._setButtonPosition(relativePosition.y - this.state.buttonSize / 2);
      }

      document.addEventListener('mousemove', this._onBarDrag);
      document.addEventListener('touchmove', this._onBarDrag);
      document.addEventListener('mouseup', this._onBarDragStop);
      document.addEventListener('touchend', this._onBarDragStop);
    }

    /**
     * Gets called while the user drags the bar
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onBarDrag',
    value: function _onBarDrag(e) {
      var mousePosition = _globals.Utils.getEventPosition(e);

      var boundingRect = this._node.getBoundingClientRect();
      var elementOffset = new _globals.Vector2(boundingRect.left, boundingRect.top);

      var relativePosition = mousePosition.clone().subtract(elementOffset);
      var direction = this._getDirection();
      if (direction === ScrollbarComponent.HORIZONTAL) {
        this._setButtonPosition(relativePosition.x - this.state.buttonSize / 2);
      } else if (direction === ScrollbarComponent.VERTICAL) {
        this._setButtonPosition(relativePosition.y - this.state.buttonSize / 2);
      }
    }

    /**
     * Gets called when the user releases the bar
     * @private
     */

  }, {
    key: '_onBarDragStop',
    value: function _onBarDragStop() {
      document.removeEventListener('mousemove', this._onBarDrag);
      document.removeEventListener('touchmove', this._onBarDrag);
      document.removeEventListener('mouseup', this._onBarDragStop);
      document.removeEventListener('touchend', this._onBarDragStop);
    }

    // -------------------------------------------------------------------------- MISC

    /**
     * Sets the button position to the given value
     * @param {Number} buttonPosition
     * @private
     */

  }, {
    key: '_setButtonPosition',
    value: function _setButtonPosition(buttonPosition) {
      var direction = this._getDirection();

      var scrollableButtonSize = void 0,
          scrollableListSize = void 0;
      if (direction === ScrollbarComponent.HORIZONTAL) {
        scrollableButtonSize = this._node.offsetWidth - this.state.buttonSize;
        scrollableListSize = this._list.scrollWidth - this._list.offsetWidth;
      } else if (direction === ScrollbarComponent.VERTICAL) {
        scrollableButtonSize = this._node.offsetHeight - this.state.buttonSize;
        scrollableListSize = this._list.scrollHeight - this._list.offsetHeight;
      }

      // Clamp button position
      buttonPosition = Math.max(0, buttonPosition);
      buttonPosition = Math.min(buttonPosition, scrollableButtonSize);

      // Set button position
      this.setState({ buttonPosition: buttonPosition });

      // Update list scroll position
      var progress = buttonPosition / scrollableButtonSize;
      var scrollPosition = scrollableListSize * progress;

      if (direction === ScrollbarComponent.HORIZONTAL) {
        this._list.scrollLeft = scrollPosition;
      } else if (direction === ScrollbarComponent.VERTICAL) {
        this._list.scrollTop = scrollPosition;
      }
    }

    /**
     * Updates the button position and size
     * @param {Function} cb
     * @private
     */

  }, {
    key: '_updateButtonSize',
    value: function _updateButtonSize(cb) {
      var buttonSize = 0;
      var buttonVisible = false;
      var parentSize = void 0,
          parentScrollSize = void 0;

      var direction = this._getDirection();
      if (direction === ScrollbarComponent.HORIZONTAL) {
        parentSize = this._list.clientWidth;
        parentScrollSize = this._list.scrollWidth;
      } else if (direction === ScrollbarComponent.VERTICAL) {
        parentSize = this._list.offsetHeight;
        parentScrollSize = this._list.scrollHeight;
      }

      buttonSize = parentSize / parentScrollSize * parentSize;
      buttonVisible = parentScrollSize > parentSize;

      this.setState({ buttonSize: buttonSize, buttonVisible: buttonVisible }, cb);
    }

    /**
     * Updates the list size
     * @private
     */

  }, {
    key: '_updateListSize',
    value: function _updateListSize() {
      if (!this._list) return;

      var direction = this._getDirection();
      if (direction === ScrollbarComponent.HORIZONTAL) {
        this._list.style.height = '';
        var fullDimensions = this._getFullListDimensions();
        this._listSize = fullDimensions.y;
        this._listContentSize = this._list.offsetHeight;
      } else if (direction === ScrollbarComponent.VERTICAL) {
        this._list.style.width = '';
        var _fullDimensions = this._getFullListDimensions();
        this._listSize = _fullDimensions.x;
        this._listContentSize = this._list.offsetWidth;
      }
    }

    /**
     * In order to get the absolute width and height of the list, including the scrollbar,
     * we need to make use of `getBoundingClientRect`
     * @return {PhotoEditorSDK.Math.Vector2}
     * @private
     */

  }, {
    key: '_getFullListDimensions',
    value: function _getFullListDimensions() {
      var rect = this._list.getBoundingClientRect();
      return new _globals.Vector2(rect.width, rect.height);
    }

    // -------------------------------------------------------------------------- PUBLIC API

    /**
     * Updates the dimensions and stuff
     */

  }, {
    key: 'update',
    value: function update() {
      var _this2 = this;

      if (_globals.Utils.isMobile()) {
        return;
      }

      var _refs = this.refs,
          root = _refs.root,
          list = _refs.list;

      this._node = root;
      this._list = list;

      var direction = this._getDirection();
      this._updateButtonSize(function () {
        if (!_this2._listSize) {
          _this2._updateListSize();
        }

        var newListSize = _this2._listSize;
        if (_this2.state.buttonVisible) {
          newListSize += _this2.constructor.NATIVE_SCROLLBAR_WIDTH;
        }

        if (direction === ScrollbarComponent.HORIZONTAL) {
          _this2._list.style.height = newListSize + 'px';
          _this2._node.style.top = _this2._listContentSize - SCROLLBAR_WIDTH + 'px';
          _this2._node.style.width = _this2._list.offsetWidth + 'px';
        } else if (direction === ScrollbarComponent.VERTICAL) {
          _this2._list.style.width = newListSize + 'px';
          _this2._node.style.left = _this2._listContentSize - SCROLLBAR_WIDTH + 'px';
          _this2._node.style.height = _this2._list.offsetHeight + 'px';
        }
      });

      this._list.addEventListener('scroll', this._onListScroll);
    }

    // -------------------------------------------------------------------------- MISC

    /**
     * Returns this scrollbar's direction
     * @return {String}
     * @private
     */

  }, {
    key: '_getDirection',
    value: function _getDirection() {
      return this.props.direction || 'horizontal';
    }

    // -------------------------------------------------------------------------- STYLING

    /**
     * Returns the button's style object
     * @return {Object}
     * @private
     */

  }, {
    key: '_getButtonStyle',
    value: function _getButtonStyle() {
      var direction = this._getDirection();
      if (direction === 'horizontal') {
        return {
          left: this.state.buttonPosition,
          width: this.state.buttonSize
        };
      } else {
        return {
          top: this.state.buttonPosition,
          height: this.state.buttonSize
        };
      }
    }

    // -------------------------------------------------------------------------- GETTERS

  }, {
    key: 'getList',
    value: function getList() {
      return this.refs.list;
    }
  }, {
    key: 'getRoot',
    value: function getRoot() {
      return this.refs.root;
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      if (_globals.Utils.isMobile()) {
        return this.props.children;
      }

      var buttonStyle = this._getButtonStyle();
      var scrollbarStyle = {
        display: this.state.buttonVisible ? 'block' : 'none'
      };

      var child = _globals.React.cloneElement(this.props.children, {
        ref: 'list'
      });

      return _globals.ReactBEM.createElement(
        'div',
        null,
        child,
        _globals.ReactBEM.createElement(
          'div',
          {
            bem: '$b:scrollbar m:' + (this.props.direction || 'horizontal') + ' m:' + (this.state.buttonVisible ? 'visible' : 'invisible'),
            ref: 'root',
            style: scrollbarStyle,
            onMouseDown: this._onBarDragStart,
            onTouchStart: this._onBarDragStart },
          _globals.ReactBEM.createElement(
            _draggableComponent2.default,
            {
              onStart: this._onButtonDragStart,
              onDrag: this._onButtonDrag,
              onStop: this._onButtonDragStop },
            _globals.ReactBEM.createElement('div', {
              bem: 'e:bar',
              style: buttonStyle,
              onMouseDown: this._onButtonDown })
          )
        )
      );
    }
  }]);

  return ScrollbarComponent;
}(_globals.BaseComponent);

exports.default = ScrollbarComponent;


ScrollbarComponent.HORIZONTAL = 'horizontal';
ScrollbarComponent.VERTICAL = 'vertical';

ScrollbarComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _backButtonComponent = __webpack_require__(111);

var _backButtonComponent2 = _interopRequireDefault(_backButtonComponent);

var _doneButtonComponent = __webpack_require__(112);

var _doneButtonComponent2 = _interopRequireDefault(_doneButtonComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ControlsComponent = function (_BaseComponent) {
  _inherits(ControlsComponent, _BaseComponent);

  function ControlsComponent() {
    var _ref;

    _classCallCheck(this, ControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = ControlsComponent.__proto__ || Object.getPrototypeOf(ControlsComponent)).call.apply(_ref, [this].concat(args)));

    _this._hasBackButton = true;
    _this._hasDoneButton = false;
    _this._backButtonClicked = false;

    _this._bindAll('_onBackClick', '_onDoneClick');
    return _this;
  }

  /**
   * Returns the global editor state data for this tool.
   *
   * @returns {Object}
   */


  _createClass(ControlsComponent, [{
    key: 'getGlobalToolState',
    value: function getGlobalToolState(identifier) {
      var globalState = this.context.globalState;

      return globalState.get(identifier);
    }

    /**
     * Sets the global editor state data for this tool.
     *
     * @returns {Object}
     */

  }, {
    key: 'setGlobalToolState',
    value: function setGlobalToolState(identifier, state) {
      var globalState = this.context.globalState;

      globalState.set(_defineProperty({}, identifier, state));
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the user clicks the back button
     * @param {Event} e
     * @private
     */

  }, {
    key: '_onBackClick',
    value: function _onBackClick(e) {
      this._backButtonClicked = true;
      this.props.onSwitchControls('back');
    }

    /**
     * Gets called when the user clicks the done button
     * @param {Event} e
     * @private
     */

  }, {
    key: '_onDoneClick',
    value: function _onDoneClick(e) {
      this._onBackClick();
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the controls of this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderControls',
    value: function renderControls() {
      return null;
    }

    /**
     * Renders the overlay controls of this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderOverlayControls',
    value: function renderOverlayControls() {
      return null;
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var forcedControl = this.props.options && this.props.options.forcedControl;
      var backButton = this._hasBackButton && !forcedControl ? _globals.ReactBEM.createElement(_backButtonComponent2.default, { onClick: this._onBackClick }) : null;

      var doneButton = this._hasDoneButton || forcedControl ? _globals.ReactBEM.createElement(_doneButtonComponent2.default, { onClick: this._onDoneClick }) : null;

      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:controls', ref: 'root' },
        this.renderOverlayControls(),
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:table' },
          backButton,
          this.renderControls(),
          doneButton
        )
      );
    }
  }]);

  return ControlsComponent;
}(_globals.BaseComponent);

exports.default = ControlsComponent;


ControlsComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

/**
 * The base class for all controls
 * @class
 * @memberof PhotoEditorSDK.UI.ReactUI
 */
var Control = function () {
  function Control() {
    _classCallCheck(this, Control);
  }

  _createClass(Control, [{
    key: "getInitialSharedState",

    /**
     * Returns the initial shared state for this control
     * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
     * @param  {Object} additionalState = {}
     * @return {Object}
     * @override
     */
    value: function getInitialSharedState() {
      return {};
    }

    /**
     * Returns the global editor state data for this tool.
     *
     * @returns {Object}
     */

  }, {
    key: "getGlobalToolState",
    value: function getGlobalToolState() {
      var globalState = this.context.globalState;

      return globalState.get(this.constructor.identifier);
    }

    /**
     * Sets the global editor state data for this tool.
     *
     * @returns {Object}
     */

  }, {
    key: "setGlobalToolState",
    value: function setGlobalToolState(state) {
      var globalState = this.context.globalState;

      globalState.set(_defineProperty({}, this.constructor.identifier, state));
    }

    /**
     * Checks if this control is available to the user
     * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
     * @return {Boolean}
     * @override
     */

  }, {
    key: "isAvailable",
    value: function isAvailable(editor) {
      return false;
    }

    /**
     * Returns the assets that should be preloaded for this control
     * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
     * @return {String[]}
     */

  }], [{
    key: "getPreloadAssets",
    value: function getPreloadAssets() {
      return [];
    }
  }]);

  return Control;
}();

/**
 * This control's top bar component. Used for the upper part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.TopBarControlsComponent}
 */


Control.topBarControlsComponent = null;

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 */
Control.controlsComponent = null;

/**
 * This control's canvas component. Used for the upper controls part of the editor (on
 * top of the canvas)
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 */
Control.canvasControlsComponent = null;

/**
 * This control's identifier
 * @type {String}
 * @default
 */
Control.identifier = null;

/**
 * This control's icon path
 * @type {String}
 */
Control.iconPath = null;

/**
 * The language key that should be used when displaying this filter
 * @type {String}
 */
Control.languageKey = null;

/**
 * The default options for this control
 * @type {Object}
 */
Control.defaultOptions = {};

exports.default = Control;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */


var DraggableComponent = function (_BaseComponent) {
  _inherits(DraggableComponent, _BaseComponent);

  function DraggableComponent() {
    var _ref;

    _classCallCheck(this, DraggableComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = DraggableComponent.__proto__ || Object.getPrototypeOf(DraggableComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onDragStart', '_onDragMove', '_onDragEnd');
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user stars dragging the child
   * @param {Event} e
   * @private
   */


  _createClass(DraggableComponent, [{
    key: '_onDragStart',
    value: function _onDragStart(e) {
      if (this.props.disabled) return;

      e.preventDefault();
      e.stopPropagation();

      this._initialMousePosition = _globals.Utils.getEventPosition(e);

      document.addEventListener('mousemove', this._onDragMove);
      document.addEventListener('touchmove', this._onDragMove);
      document.addEventListener('mouseup', this._onDragEnd);
      document.addEventListener('touchend', this._onDragEnd);

      var element = this.refs.element;

      var boundingRect = element.getBoundingClientRect();
      var elementOffset = new _globals.Vector2(boundingRect.left, boundingRect.top);

      var relativePosition = this._initialMousePosition.clone().subtract(elementOffset);
      this.props.onStart && this.props.onStart(relativePosition, e);
    }

    /**
     * Gets called while the user drags the child
     * @param {Event} e
     * @private
     */

  }, {
    key: '_onDragMove',
    value: function _onDragMove(e) {
      e.preventDefault();
      e.stopPropagation();

      var mousePosition = _globals.Utils.getEventPosition(e);
      if (!mousePosition) return;
      var mouseDiff = mousePosition.clone().subtract(this._initialMousePosition);

      this.props.onDrag && this.props.onDrag(mouseDiff, e);
    }

    /**
     * Gets called when the user stops dragging the child
     * @param {Event} e
     * @private
     */

  }, {
    key: '_onDragEnd',
    value: function _onDragEnd(e) {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();

      this._onDragMove(e);

      document.removeEventListener('mousemove', this._onDragMove);
      document.removeEventListener('touchmove', this._onDragMove);
      document.removeEventListener('mouseup', this._onDragEnd);
      document.removeEventListener('touchend', this._onDragEnd);

      this.props.onStop && this.props.onStop(e);
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {React.Element}
     */

  }, {
    key: 'render',
    value: function render() {
      if (!this.props.children || this.props.children instanceof Array) {
        throw new Error('DraggableComponent expects exactly one child.');
      }

      return _globals.React.cloneElement(this.props.children, {
        onMouseDown: this._onDragStart,
        onTouchStart: this._onDragStart,
        ref: 'element'
      });
    }
  }]);

  return DraggableComponent;
}(_globals.BaseComponent);

exports.default = DraggableComponent;


DraggableComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _sliderComponent = __webpack_require__(13);

var _sliderComponent2 = _interopRequireDefault(_sliderComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var SliderOverlayComponent = function (_BaseComponent) {
  _inherits(SliderOverlayComponent, _BaseComponent);

  function SliderOverlayComponent() {
    var _ref;

    _classCallCheck(this, SliderOverlayComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = SliderOverlayComponent.__proto__ || Object.getPrototypeOf(SliderOverlayComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onSliderValueChange');

    _this.state = { value: _this.props.value };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component receives new props
   * @param  {Object} props
   */


  _createClass(SliderOverlayComponent, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(props) {
      if (props.value !== this.state.value) {
        this.state.value = props.value;
      }
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the slider value has changed
     * @param  {Number} value
     * @private
     */

  }, {
    key: '_onSliderValueChange',
    value: function _onSliderValueChange(value) {
      this.props.onChange && this.props.onChange(value);
      this.setState({ value: value });
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the SliderComponent
     * @return {SliderComponent}
     * @private
     */

  }, {
    key: '_renderSlider',
    value: function _renderSlider() {
      var props = _globals.SDKUtils.defaults(this.props, {
        style: '',
        middleDot: false,
        minValue: 1,
        maxValue: 100,
        label: 'Label',
        onChange: this._onSliderValueChange,
        value: this.state.value
      });
      return _globals.ReactBEM.createElement(_sliderComponent2.default, props);
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:controls e:overlay m:slider m:dark' },
        this._renderSlider()
      );
    }
  }]);

  return SliderOverlayComponent;
}(_globals.BaseComponent);

exports.default = SliderOverlayComponent;


SliderOverlayComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_7__;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _headerComponent = __webpack_require__(89);

var _headerComponent2 = _interopRequireDefault(_headerComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ScreenComponent = function (_BaseComponent) {
  _inherits(ScreenComponent, _BaseComponent);

  function ScreenComponent() {
    _classCallCheck(this, ScreenComponent);

    return _possibleConstructorReturn(this, (ScreenComponent.__proto__ || Object.getPrototypeOf(ScreenComponent)).apply(this, arguments));
  }

  _createClass(ScreenComponent, [{
    key: '_renderHeader',

    /**
     * Renders the header (if enabled)
     * @return {ReactBEM.Element}
     * @private
     */
    value: function _renderHeader() {
      if (!this.context.options.showHeader) {
        return null;
      }
      return _globals.ReactBEM.createElement(_headerComponent2.default, null);
    }

    /**
     * Renders this screen
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderScreen',
    value: function _renderScreen() {
      return _globals.ReactBEM.createElement('div', null);
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var screenBEMSpecifier = 'b:screen';
      if (!this.context.options.showHeader) {
        screenBEMSpecifier += ' m:noHeader';
      }

      return _globals.ReactBEM.createElement(
        'div',
        { bem: screenBEMSpecifier, className: !this.props.visible ? 'is-hidden' : null },
        this._renderHeader(),
        this._renderScreen()
      );
    }
  }]);

  return ScreenComponent;
}(_globals.BaseComponent);

exports.default = ScreenComponent;


ScreenComponent.propTypes = {
  editor: _globals.PropTypes.any
};

ScreenComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var CanvasControlsComponent = function (_BaseComponent) {
  _inherits(CanvasControlsComponent, _BaseComponent);

  function CanvasControlsComponent() {
    var _ref;

    _classCallCheck(this, CanvasControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = CanvasControlsComponent.__proto__ || Object.getPrototypeOf(CanvasControlsComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onCanvasZoomDone');
    return _this;
  }

  // -------------------------------------------------------------------------- HIT TEST

  /**
   * Checks if any other control reacts to a click at the given position
   * @param  {Vector2} clickPosition
   * @private
   */


  _createClass(CanvasControlsComponent, [{
    key: '_performHitTest',
    value: function _performHitTest(clickPosition) {
      var container = this.refs.container;

      var containerRect = container.getBoundingClientRect();
      var containerPosition = new _globals.Vector2(containerRect.left, containerRect.top);

      var positionOnCanvas = clickPosition.subtract(containerPosition);

      var editor = this.context.editor;

      var controls = editor.controls.getAvailable();

      // Check if any of the controls responds to a click
      // at the given position
      for (var identifier in controls) {
        var control = controls[identifier];
        var clickResponse = control.clickAtPosition && control.clickAtPosition(positionOnCanvas, editor);

        if (clickResponse) {
          // Don't re-select an already selected item
          if (clickResponse.selectedSprite === this.getSharedState('selectedSprite')) {
            return true;
          }

          // Responds to click, switch to the controls
          this.props.onSwitchControls(control, clickResponse);
          return true;
        }
      }

      return false;
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called after the canvas has been zoomed in or out
     * @private
     */

  }, {
    key: '_onCanvasZoomDone',
    value: function _onCanvasZoomDone() {
      this.forceUpdate();
    }

    /**
     * Binds the events in _events
     * @protected
     */

  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      _get(CanvasControlsComponent.prototype.__proto__ || Object.getPrototypeOf(CanvasControlsComponent.prototype), '_bindEvents', this).call(this);
      this.context.mediator.on(_globals.Constants.EVENTS.ZOOM_DONE, this._onCanvasZoomDone);
    }

    /**
     * Unbinds the events in _events
     * @protected
     */

  }, {
    key: '_unbindEvents',
    value: function _unbindEvents() {
      _get(CanvasControlsComponent.prototype.__proto__ || Object.getPrototypeOf(CanvasControlsComponent.prototype), '_unbindEvents', this).call(this);
      this.context.mediator.off(_globals.Constants.EVENTS.ZOOM_DONE, this._onCanvasZoomDone);
    }
  }]);

  return CanvasControlsComponent;
}(_globals.BaseComponent);

exports.default = CanvasControlsComponent;


CanvasControlsComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _globals = __webpack_require__(0);

var _constants = __webpack_require__(38);

var _constants2 = _interopRequireDefault(_constants);

var _jsonLoader = __webpack_require__(22);

var _jsonLoader2 = _interopRequireDefault(_jsonLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StickerManager = function () {
  function StickerManager(ui, options) {
    _classCallCheck(this, StickerManager);

    this._ui = ui;
    this._options = options;
    this._categoriesById = {};
    this._categories = [];
    this._stickersById = {};

    this._addCategories(_constants2.default.DEFAULTS.STICKER_CATEGORIES);

    var _options = this._options,
        categories = _options.categories,
        replaceCategories = _options.replaceCategories;

    if (this._options.categories) {
      this._addCategories(categories, replaceCategories);
    } else {
      this._updateCategoriesMap();
      this._updateAllCategory();
    }
  }

  /**
   * Loads stickers from the given external URL
   * @param  {String} url
   * @return {Promise}
   */


  _createClass(StickerManager, [{
    key: 'loadExternal',
    value: function loadExternal(url) {
      var _this = this;

      var loader = new _jsonLoader2.default(url);
      return loader.load().then(function (result) {
        _this._addCategories(result.categories, _this._options.replaceCategories);
      });
    }

    /**
     * Initializes the categories
     * @param {Object[]} categories
     * @param {Boolean} replace = false
     * @private
     */

  }, {
    key: '_addCategories',
    value: function _addCategories(categories) {
      var replace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (replace) {
        this._categories = categories.slice(0);
      } else {
        this._categories = _globals.Utils.mergeCategories(this._categories, categories, 'stickers');
      }

      this._updateCategoriesMap();
      this._updateAllCategory();
    }

    /**
     * Updates the categories map
     * @private
     */

  }, {
    key: '_updateCategoriesMap',
    value: function _updateCategoriesMap() {
      var _this2 = this;

      this._categoriesById = {};
      this._categories.forEach(function (c) {
        _this2._categoriesById[c.identifier] = c;
      });

      // Build sticker id => sticker hash
      this._categories.forEach(function (c) {
        c.stickers.forEach(function (s) {
          _this2._stickersById[s.identifier] = s;
        });
      });

      // Filter stickers
      if (typeof this._options.availableStickers !== 'undefined' && this._options.availableStickers !== null) {
        this._categories.forEach(function (category) {
          category.stickers = category.stickers.filter(function (sticker) {
            return _this2._options.availableStickers.indexOf(sticker.identifier) !== -1;
          });
        });

        this._categories = this._categories.filter(function (category) {
          return category.stickers.length > 0;
        });
      }

      this._updateAllCategory();
    }

    /**
     * Updates the `all` category which contains all stickers
     * @private
     */

  }, {
    key: '_updateAllCategory',
    value: function _updateAllCategory() {
      this._allCategory = {
        identifier: 'all',
        defaultName: 'All',
        stickers: this._categories.map(function (c) {
          return c.stickers;
        }).reduce(function (a, b) {
          return a.concat(b);
        }, [])
      };
      this._categoriesById.all = this._allCategory;
    }

    /**
     * Returns the stickers for the category with the given name
     * @param  {String} categoryName
     * @return {Object[]}
     */

  }, {
    key: 'getStickersForCategory',
    value: function getStickersForCategory(categoryName) {
      if (!this._categoriesById[categoryName]) {
        throw new Error('Unknown sticker category \'' + categoryName + '\'');
      }
      return this._categoriesById[categoryName].stickers;
    }

    /**
     * Returns the sticker with the given identifier
     * @param  {String} identifier
     */

  }, {
    key: 'getStickerByIdentifier',
    value: function getStickerByIdentifier(identifier) {
      return this._stickersById[identifier];
    }

    /**
     * Returns the categories
     * @param {Boolean} includeAllCategory = false
     * @return {Object[]}
     */

  }, {
    key: 'getCategories',
    value: function getCategories() {
      var includeAllCategory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (includeAllCategory) {
        return [this._allCategory].concat(this._categories);
      }

      return this._categories;
    }

    /**
     * Returns the category object for the given id
     * @param  {String} id
     * @return {Object}
     */

  }, {
    key: 'getCategory',
    value: function getCategory(id) {
      return this._categoriesById[id];
    }

    /**
     * Returns the URL for the given sticker. If the user is using Internet Explorer, we
     * fall back to the svg variant (if present)
     * @param  {Object} sticker
     * @param  {String} size
     * @return {String}
     */

  }], [{
    key: 'getURLForSticker',
    value: function getURLForSticker(sticker) {
      var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'base';
      var images = sticker.images;

      var media = size === 'base' ? images.mediaBase || images.mediaThumb : images.mediaThumb;
      var uris = media.uris || [media.uri];
      if (typeof _globals.Utils.Browser !== 'undefined' && !_globals.Utils.Browser.getIEVersion()) {
        var svgs = uris.filter(function (f) {
          return (/\.svg$/i.test(f)
          );
        });
        return svgs.length ? svgs[0] : uris[0];
      } else {
        var notSvgs = uris.filter(function (f) {
          return !/\.svg$/i.test(f);
        });
        return notSvgs.length ? notSvgs[0] : uris[0];
      }
    }
  }]);

  return StickerManager;
}();

exports.default = StickerManager;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var TopBarComponent = function (_BaseComponent) {
  _inherits(TopBarComponent, _BaseComponent);

  function TopBarComponent() {
    _classCallCheck(this, TopBarComponent);

    return _possibleConstructorReturn(this, (TopBarComponent.__proto__ || Object.getPrototypeOf(TopBarComponent)).apply(this, arguments));
  }

  _createClass(TopBarComponent, [{
    key: 'renderContent',

    /**
     * Renders the content of this TopBarComponent
     * @return {ReactBEM.Element}
     */
    value: function renderContent() {
      return this.props.children;
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:topBar e:row' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:cell' },
          this.renderContent()
        )
      );
    }
  }]);

  return TopBarComponent;
}(_globals.BaseComponent);

exports.default = TopBarComponent;


TopBarComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _draggableComponent = __webpack_require__(5);

var _draggableComponent2 = _interopRequireDefault(_draggableComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */


var SliderComponent = function (_BaseComponent) {
  _inherits(SliderComponent, _BaseComponent);

  function SliderComponent() {
    var _ref;

    _classCallCheck(this, SliderComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = SliderComponent.__proto__ || Object.getPrototypeOf(SliderComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onKnobDragStart', '_onKnobDrag', '_onKnobDragStop', '_onBarDragStart', '_onBarDrag', '_onBarDragStop', '_onMiddleDotClick');

    _this.state = {
      value: _this.props.value || 0,
      sliderPosition: 0,
      foregroundLeft: 0,
      foregroundWidth: 0
    };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called after the component has been mounted
   */


  _createClass(SliderComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      // Trigger a re-render to position the knob
      this._setValue(this.state.value, false);
    }

    /**
     * Gets called when this component receives new props
     * @param  {Object} props
     */

  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(props) {
      if (props.value !== this.state.value) {
        this._setValue(props.value, false);
      }
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the user presses a mouse button on the middle dot
     * @private
     */

  }, {
    key: '_onMiddleDotClick',
    value: function _onMiddleDotClick() {
      this._previousValue = this.state.value;
      var newValue = this.props.minValue + (this.props.maxValue - this.props.minValue) / 2;
      this._setValue(newValue, true, true);
    }

    /**
     * Gets called when the user starts dragging the knob
     * @param  {Vector2} position
     * @private
     */

  }, {
    key: '_onKnobDragStart',
    value: function _onKnobDragStart(position) {
      this._previousValue = this.state.value;
      this._initialSliderPosition = this.state.sliderPosition;
      this._initialPosition = position;
    }

    /**
     * Gets called while the user drags the knob
     * @param  {Vector2} diff
     * @private
     */

  }, {
    key: '_onKnobDrag',
    value: function _onKnobDrag(diff) {
      var bar = this.refs.bar;

      var barWidth = bar.offsetWidth;

      var newSliderPosition = this._initialSliderPosition + diff.x;
      newSliderPosition = Math.max(0, Math.min(newSliderPosition, barWidth));
      var progress = newSliderPosition / barWidth;
      var newValue = this.props.minValue + (this.props.maxValue - this.props.minValue) * progress;

      this._setValue(newValue);
    }

    /**
     * Gets called when the user stops dragging the knob
     * @private
     */

  }, {
    key: '_onKnobDragStop',
    value: function _onKnobDragStop() {
      this._setValue(this.state.value, true, true);
    }

    /**
     * Gets called when the user starts dragging the bar
     * @param  {Vector2} position
     * @private
     */

  }, {
    key: '_onBarDragStart',
    value: function _onBarDragStart(position) {
      this._previousValue = this.state.value;
      this._initialPosition = position.clone();

      var bar = this.refs.bar;

      var barWidth = bar.offsetWidth;
      var progress = position.x / barWidth;
      var newValue = this.props.minValue + (this.props.maxValue - this.props.minValue) * progress;
      this._setValue(newValue);
    }

    /**
     * Gets called while the user drags the bar
     * @param  {Vector2} diff
     * @private
     */

  }, {
    key: '_onBarDrag',
    value: function _onBarDrag(diff) {
      var position = this._initialPosition.clone().add(diff);

      var bar = this.refs.bar;

      var barWidth = bar.offsetWidth;
      var progress = position.x / barWidth;
      var newValue = this.props.minValue + (this.props.maxValue - this.props.minValue) * progress;
      newValue = Math.max(this.props.minValue, Math.min(this.props.maxValue, newValue));
      this._setValue(newValue);
    }

    /**
     * Gets called when the user stops dragging the bar
     * @private
     */

  }, {
    key: '_onBarDragStop',
    value: function _onBarDragStop() {
      this._setValue(this.state.value, true, true);
    }

    // -------------------------------------------------------------------------- STYLING

    /**
     * Returns the style for the knob (position)
     * @return {Object}
     * @private
     */

  }, {
    key: '_getKnobStyle',
    value: function _getKnobStyle() {
      return { left: this.state.sliderPosition };
    }

    /**
     * Returns the style for the foreground bar
     * @return {Object}
     * @private
     */

  }, {
    key: '_getForegroundStyle',
    value: function _getForegroundStyle() {
      return {
        left: this.state.foregroundLeft,
        width: this.state.foregroundWidth
      };
    }

    // -------------------------------------------------------------------------- MISC

    /**
     * Decides whether or not this slider should have a middle dot on the bar
     * @private
     */

  }, {
    key: '_displayMiddleDot',
    value: function _displayMiddleDot() {
      return this.props.middleDot !== false;
    }

    /**
     * Sets the value to the given value, updates the slider position
     * @param {Number} value
     * @param {Boolean} emitChange = true
     * @param {Boolean} emitRelease = false
     * @private
     */

  }, {
    key: '_setValue',
    value: function _setValue(value) {
      var emitChange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var emitRelease = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      value = Math.round(value);
      var _props = this.props,
          minValue = _props.minValue,
          maxValue = _props.maxValue;

      var progress = (value - minValue) / (maxValue - minValue);

      // Calculate slider position
      var bar = this.refs.bar;

      var barWidth = bar.offsetWidth;
      var sliderPosition = barWidth * progress;

      // Calculate foreground position and width
      var foregroundWidth = progress * barWidth;
      var foregroundLeft = 0;
      if (this._displayMiddleDot()) {
        foregroundWidth = Math.abs(progress - 0.5) * barWidth;
        foregroundLeft = progress < 0.5 ? barWidth * 0.5 - foregroundWidth : '50%';
      }

      this.setState({ value: value, sliderPosition: sliderPosition, foregroundWidth: foregroundWidth, foregroundLeft: foregroundLeft });

      if (emitChange) {
        this.props.onChange && this.props.onChange(value, this._previousValue, emitRelease);
      }
    }

    /**
     * Builds a display value from the given props
     * @param {Number} value
     * @return {String}
     * @private
     */

  }, {
    key: '_buildValue',
    value: function _buildValue(value) {
      // Limit decimals to two digits, if present
      if (value % 1 !== 0) {
        value = value.toFixed(2);
      }

      // Add positive value prefix (+) if value is > 0
      if (this.props.positiveValuePrefix && value >= 0) {
        value = '' + this.props.positiveValuePrefix + value;
      }

      // Add unit if present
      if (this.props.valueUnit) {
        value += this.props.valueUnit;
      }

      return value;
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var middleDot = null;
      if (this._displayMiddleDot()) {
        middleDot = _globals.ReactBEM.createElement('div', { bem: 'e:middleDot', onClick: this._onMiddleDotClick });
      }

      var foregroundProps = {
        style: this._getForegroundStyle()
      };

      var componentBem = '$b:slider' + (this.props.style ? ' m:' + this.props.style : '');
      return _globals.ReactBEM.createElement(
        'div',
        { bem: componentBem },
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$e:bar', ref: 'bar' },
          _globals.ReactBEM.createElement(
            _draggableComponent2.default,
            {
              onStart: this._onBarDragStart,
              onDrag: this._onBarDrag,
              onStop: this._onBarDragStop },
            _globals.ReactBEM.createElement(
              'div',
              null,
              _globals.ReactBEM.createElement('div', { bem: '$e:background' }),
              _globals.ReactBEM.createElement('div', _extends({ bem: '$e:foreground' }, foregroundProps)),
              _globals.ReactBEM.createElement(
                _draggableComponent2.default,
                {
                  onStart: this._onKnobDragStart,
                  onDrag: this._onKnobDrag,
                  onStop: this._onKnobDragStop },
                _globals.ReactBEM.createElement('div', { bem: 'e:knob b:knob m:slider', style: this._getKnobStyle() })
              )
            )
          ),
          middleDot
        ),
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$e:labels' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:label m:lowerBoundary' },
            this._buildValue(this.props.minValue)
          ),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:label m:value' },
            this.props.label,
            ' ',
            this._buildValue(this.state.value)
          ),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:label m:upperBoundary' },
            this._buildValue(this.props.maxValue)
          )
        )
      );
    }
  }]);

  return SliderComponent;
}(_globals.BaseComponent);

exports.default = SliderComponent;


SliderComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _textItemComponent = __webpack_require__(145);

var _textItemComponent2 = _interopRequireDefault(_textItemComponent);

var _stickerItemComponent = __webpack_require__(146);

var _stickerItemComponent2 = _interopRequireDefault(_stickerItemComponent);

var _brushItemComponent = __webpack_require__(147);

var _brushItemComponent2 = _interopRequireDefault(_brushItemComponent);

var _canvasControlsComponent = __webpack_require__(10);

var _canvasControlsComponent2 = _interopRequireDefault(_canvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _SDK$Operations$Sprit = _globals.SDK.Operations.SpriteOperation,
    StickerSprite = _SDK$Operations$Sprit.StickerSprite,
    TextSprite = _SDK$Operations$Sprit.TextSprite,
    BrushSprite = _SDK$Operations$Sprit.BrushSprite;

var SpritesCanvasControlsComponent = function (_CanvasControlsCompon) {
  _inherits(SpritesCanvasControlsComponent, _CanvasControlsCompon);

  function SpritesCanvasControlsComponent() {
    var _ref, _this$_events;

    _classCallCheck(this, SpritesCanvasControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = SpritesCanvasControlsComponent.__proto__ || Object.getPrototypeOf(SpritesCanvasControlsComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onCanvasClick', '_onSpriteDragStart', '_onSpriteDragStop', '_onOperationUpdated', '_onOperationRemoved', '_onSpriteFlip', '_onSpriteTakeToFront', '_onSpriteRemove');

    _this._canvasClickDisabled = false;

    _this._events = (_this$_events = {}, _defineProperty(_this$_events, _globals.Constants.EVENTS.OPERATION_UPDATED, _this._onOperationUpdated), _defineProperty(_this$_events, _globals.Constants.EVENTS.OPERATION_REMOVED, _this._onOperationRemoved), _this$_events);
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when an operation has been removed
   * @param  {Operation} operation
   * @private
   */


  _createClass(SpritesCanvasControlsComponent, [{
    key: '_onOperationRemoved',
    value: function _onOperationRemoved(operation) {
      var selectedSprite = this.getSharedState('selectedSprite');
      if (operation !== this.getSharedState('operation') || !selectedSprite) return;

      // Operation can be removed by the undo button. We need
      // to make sure we re-create the operation for the lifetime
      // of this control
      var editor = this.context.editor;

      var newOperation = editor.operations.getOrCreate('sprite', {
        sprites: [selectedSprite],
        enabled: false
      });
      this.setSharedState({
        operation: newOperation,
        operationExistedBefore: false,
        initialOptions: {}
      });
    }

    /**
     * Gets called when an operation has been updated
     * @param  {Operation} operation
     * @private
     */

  }, {
    key: '_onOperationUpdated',
    value: function _onOperationUpdated(operation) {
      var selectedSprite = this.getSharedState('selectedSprite');
      if (operation !== this.getSharedState('operation') || !selectedSprite) return;

      // If the currently selected sprite is no longer existent,
      // re-add it
      var sprites = operation.getSprites();
      if (sprites.indexOf(selectedSprite) === -1) {
        sprites.push(selectedSprite);
      }

      this.forceUpdate();
    }

    /**
     * Gets called when the selected item is deselected
     * @private
     */

  }, {
    key: '_onItemBlur',
    value: function _onItemBlur() {}

    /**
     * Gets called when the user clicks somewhere on the canvas
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onCanvasClick',
    value: function _onCanvasClick(e) {
      if (this._canvasClickDisabled) return;

      var hitTest = this._performHitTest(_globals.Utils.getEventPosition(e));
      if (!hitTest) {
        if (this.getSharedState('selectedSprite')) {
          this._onItemBlur();
        }
        this.props.onSwitchControls('home');
      }
    }

    /**
     * Gets called when the user flips the selected sprite
     * @param  {String} direction
     * @private
     */

  }, {
    key: '_onSpriteFlip',
    value: function _onSpriteFlip(direction) {
      var selectedSprite = this.getSharedState('selectedSprite');
      switch (direction) {
        case 'h':
          selectedSprite.setFlipHorizontally(!selectedSprite.getFlipHorizontally());
          break;
        case 'v':
          selectedSprite.setFlipVertically(!selectedSprite.getFlipVertically());
          break;
      }
      var editor = this.context.editor;

      editor.render();
    }

    /**
     * Gets called when the user takes the selected sprite to front
     * @private
     */

  }, {
    key: '_onSpriteTakeToFront',
    value: function _onSpriteTakeToFront(direction) {
      var operation = this.getSharedState('operation');
      operation.takeSpriteToFront(this.getSharedState('selectedSprite'));
      this.forceSharedUpdate();
      var editor = this.context.editor;

      editor.render();
    }

    /**
     * Gets called when the user removes the selected sprite
     * @param  {String} direction
     * @private
     */

  }, {
    key: '_onSpriteRemove',
    value: function _onSpriteRemove() {
      var operation = this.getSharedState('operation');
      var selectedSprite = this.getSharedState('selectedSprite');
      operation.removeSprite(selectedSprite);
      selectedSprite.dispose();

      this.setSharedState({
        selectedSprite: null
      });
      var editor = this.context.editor;

      editor.render();
    }

    // -------------------------------------------------------------------------- DRAGGING

    /**
     * Gets called when a sprite has received a dragging event. Blocks the `_onCanvasClick`
     * handler until `_onSpriteDragStop`
     * @private
     */

  }, {
    key: '_onSpriteDragStart',
    value: function _onSpriteDragStart() {
      this._canvasClickDisabled = true;
    }

    /**
     * Since `_onCanvasClick` is triggered right after the drag end event for knobs is triggered,
     * we need to wait a short amount of time until we re-enabale the canvas click
     * @private
     */

  }, {
    key: '_onSpriteDragStop',
    value: function _onSpriteDragStop() {
      var _this2 = this;

      setTimeout(function () {
        _this2._canvasClickDisabled = false;
      }, 100);
    }

    // -------------------------------------------------------------------------- STYLING

    /**
     * Returns the container style
     * @return {Object}
     * @private
     */

  }, {
    key: '_getContainerStyle',
    value: function _getContainerStyle() {
      var editor = this.context.editor;

      var canvasDimensions = editor.getCanvasDimensions();
      var outputDimensions = editor.getOutputDimensions();

      var _canvasDimensions$clo = canvasDimensions.clone().divide(2).subtract(outputDimensions.clone().divide(2)),
          x = _canvasDimensions$clo.x,
          y = _canvasDimensions$clo.y;

      return {
        left: x,
        top: y,
        width: outputDimensions.x,
        height: outputDimensions.y
      };
    }

    // -------------------------------------------------------------------------- MISC

    /**
     * Returns the properties for the outer container
     * @return {Object}
     * @private
     */

  }, {
    key: '_getContainerProps',
    value: function _getContainerProps() {
      return {};
    }

    /**
     * Returns the properties for the canvas container
     * @return {Object}
     * @private
     */

  }, {
    key: '_getInnerContainerProps',
    value: function _getInnerContainerProps() {
      return {
        style: this._getContainerStyle(),
        onClick: this._onCanvasClick
      };
    }

    /**
     * Returns the props that are passed to the item component of the given sprite
     * @param  {Sprite} sprite
     * @return {Object}
     * @private
     */

  }, {
    key: '_getPropsForSprite',
    value: function _getPropsForSprite(sprite) {
      var props = { hideContent: true };
      return props;
    }

    /**
     * Returns the component-type for a given sprite
     * @param {Sprite} sprite
     * @return {ItemComponent}
     */

  }, {
    key: '_getComponentTypeForSprite',
    value: function _getComponentTypeForSprite(sprite) {
      if (sprite instanceof TextSprite) {
        return _textItemComponent2.default;
      } else if (sprite instanceof StickerSprite) {
        return _stickerItemComponent2.default;
      } else if (sprite instanceof BrushSprite) {
        return _brushItemComponent2.default;
      }
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the sprite items
     * @return {Array.<SpriteItemComponent>}
     * @private
     */

  }, {
    key: '_renderSpriteItems',
    value: function _renderSpriteItems() {
      var _this3 = this;

      var operation = this.getSharedState('operation');
      var sprites = operation.getSprites();
      var selectedSprite = this.getSharedState('selectedSprite');

      return sprites.map(function (sprite) {
        var isSelected = sprite === selectedSprite;
        var SpriteComponent = _this3._getComponentTypeForSprite(sprite);
        var spriteProps = _this3._getPropsForSprite(sprite);
        return _globals.ReactBEM.createElement(SpriteComponent, _extends({
          operation: operation,
          sharedState: _this3.props.sharedState,
          sprite: sprite,
          selected: isSelected,
          onDragStart: _this3._onSpriteDragStart,
          onDragStop: _this3._onSpriteDragStop,
          onRemove: _this3._onSpriteRemove.bind(_this3, sprite),
          options: _this3.props.options,
          ref: 'sprite-' + sprite.getId()
        }, spriteProps));
      });
    }

    /**
     * This renders controls on top of the sprites
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderOverlayControls',
    value: function _renderOverlayControls() {
      return null;
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'div',
        _extends({
          bem: '$b:canvasControls e:container m:full',
          ref: 'container'
        }, this._getContainerProps()),
        _globals.ReactBEM.createElement(
          'div',
          _extends({
            bem: 'b:canvasControls e:innerContainer',
            ref: 'innerContainer'
          }, this._getInnerContainerProps()),
          _globals.ReactBEM.createElement(
            'div',
            {
              bem: '$b:spritesCanvasControls',
              ref: 'container' },
            this._renderSpriteItems(),
            this._renderOverlayControls()
          )
        )
      );
    }
  }]);

  return SpritesCanvasControlsComponent;
}(_canvasControlsComponent2.default);

exports.default = SpritesCanvasControlsComponent;


SpritesCanvasControlsComponent.contextTypes = _canvasControlsComponent2.default.contextTypes;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _globals = __webpack_require__(0);

var _font = __webpack_require__(158);

var _font2 = _interopRequireDefault(_font);

var _log = __webpack_require__(20);

var _log2 = _interopRequireDefault(_log);

var _fontVariation = __webpack_require__(47);

var _fontVariation2 = _interopRequireDefault(_fontVariation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FontManager = function () {
  function FontManager(ui, options) {
    _classCallCheck(this, FontManager);

    this._ui = ui;
    this._options = options;
    this._fonts = [];
    this._variationsByIdentifier = {};
    this._fontsByFontFamily = {};

    this._initFonts();
  }

  /**
   * Initializes the fonts
   * @private
   */


  _createClass(FontManager, [{
    key: '_initFonts',
    value: function _initFonts() {
      var _this = this;

      var _options = this._options,
          additionalFonts = _options.fonts,
          replaceFonts = _options.replaceFonts,
          availableVariations = _options.availableVariations;

      // Replace or append fonts

      var fonts = _globals.Constants.DEFAULTS.FONTS;
      if (replaceFonts) {
        fonts = additionalFonts;
      } else {
        fonts = fonts.concat(additionalFonts || []);
      }

      // Turn fonts into actual Font objects with FontVariation objects
      var defaultVariation = void 0;
      fonts = fonts.map(function (font) {
        var fontFamily = font.fontFamily;

        var variations = font.variations;

        if (availableVariations) {
          variations = variations.filter(function (variation) {
            return availableVariations.indexOf(variation.identifier) !== -1;
          });
        }

        if (variations.length === 0) return null;

        var fontInstance = new _font2.default({
          fontFamily: fontFamily
        });
        variations = variations.map(function (variation) {
          var variationInstance = new _fontVariation2.default(variation);
          variationInstance.setFontFamily(fontFamily);
          variationInstance.setFont(fontInstance);
          if (variation.default && !defaultVariation) {
            defaultVariation = variationInstance;
          }

          if (variationInstance.getTextMetrics() == null) {
            _log2.default.warn('Missing font metrics for ' + variationInstance.getIdentifier() + '. The SDK will fall back to basic font rendering, which may lead to layout issues. Please provide font metrics for your custom fonts. See https://docs.photoeditorsdk.com/guides/html5/ for more details.');
          }

          _this._variationsByIdentifier[variationInstance.getIdentifier()] = variationInstance;
          return variationInstance;
        });
        fontInstance.setVariations(variations);
        _this._fontsByFontFamily[fontFamily] = fontInstance;
        return fontInstance;
      }).filter(function (f) {
        return f;
      });

      if (!defaultVariation) {
        defaultVariation = fonts[0].getVariations()[0];
      }

      this._defaultVariation = defaultVariation;
      this._fonts = fonts;
    }

    /**
     * Returns all available fonts
     * @return {PhotoEditorSDK.UI.DesktopUI.Font[]}
     */

  }, {
    key: 'getFonts',
    value: function getFonts() {
      return this._fonts;
    }

    /**
     * Returns the font for the given font family
     * @param  {String} fontFamily
     * @return {PhotoEditorSDK.UI.DesktopUI.Font}
     */

  }, {
    key: 'getFontByFontFamily',
    value: function getFontByFontFamily(fontFamily) {
      return this._fontsByFontFamily[fontFamily];
    }

    /**
     * Returns the font variation for the given identifier
     * @param  {String} identifier
     * @return {PhotoEditorSDK.UI.DesktopUI.FontVariation}
     */

  }, {
    key: 'getVariationByIdentifier',
    value: function getVariationByIdentifier(identifier) {
      return this._variationsByIdentifier[identifier];
    }
  }, {
    key: 'getVariationsByIdentifier',
    value: function getVariationsByIdentifier() {
      return _extends({}, this._variationsByIdentifier);
    }

    /**
     * Returns the default variation
     * @return {PhotoEditorSDK.UI.DesktopUI.FontVariation}
     */

  }, {
    key: 'getDefaultVariation',
    value: function getDefaultVariation() {
      return this._defaultVariation;
    }
  }]);

  return FontManager;
}();

exports.default = FontManager;

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_16__;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (({"ENV":"\"development\""}).NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Logger = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _utils = __webpack_require__(69);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultLevels = [{ name: 'trace', type: 'trace', background: '#EEEEEE', color: '#AAAAAA' }, { name: 'info', type: 'log', background: '#BDE5F8', color: '#00529B' }, { name: 'warn', type: 'warn', background: '#FEEFB3', color: '#9F6000' }, { name: 'error', type: 'error', background: '#FFBABA', color: '#D8000C' }, { name: 'log', type: 'log', background: '#EEEEEE', color: '#1f4f6b' }];

var hasConsoleGroups = function hasConsoleGroups() {
  return console && console.group && console.groupCollapsed && console.groupEnd;
};

var hasColorOutput = function hasColorOutput() {
  return (!process || process && process.browser) && typeof navigator !== 'undefined' && navigator.userAgent.match(/Gecko|WebKit/i) && !navigator.userAgent.match(/Trident/);
};

/* eslint-disable */
var getLogStyles = function getLogStyles(background, color) {
  return ['background: #2D7BFF; line-height: 20px; padding: 4px 0', 'background: #2B2B2B; color: white; line-height: 20px; padding: 4px 0', 'background: #2D7BFF; line-height: 20px; padding: 4px 0', 'background: ' + background + '; color: ' + color + '; line-height: 20px; padding: 4px 0; font-weight: bold', 'background: #2B2B2B; color: white; line-height: 20px; padding: 4px 0', 'background: #2D7BFF; line-height: 20px; padding: 4px 0'];
};
/* eslint-enable */

var Logger = function () {
  function Logger() {
    var _this = this;

    var maxLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'warn';
    var levels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultLevels;

    _classCallCheck(this, Logger);

    this._levels = [].concat(_toConsumableArray(levels));
    this._maxLevel = this.getLevelIndexByName(maxLevel);

    this._consoleFuncs = {
      trace: function trace() {
        if (hasConsoleGroups()) {
          var _console;

          (_console = console).groupCollapsed.apply(_console, arguments);
          console.trace();
          console.groupEnd();
        } else {
          var _console2;

          (_console2 = console).trace.apply(_console2, arguments);
        }
      }
    };

    this._levels.forEach(function (_ref) {
      var name = _ref.name;

      _this[name] = function (tag) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        _this._log.apply(_this, [name, tag].concat(args));
      };
    });
  }

  _createClass(Logger, [{
    key: 'getLevelIndexByName',
    value: function getLevelIndexByName(levelName) {
      return _utils2.default.Array.findIndex(this._levels, function (l) {
        return l.name === levelName;
      });
    }
  }, {
    key: 'getLevelObjectByName',
    value: function getLevelObjectByName(levelName) {
      return _utils2.default.Array.find(this._levels, function (l) {
        return l.name === levelName;
      });
    }

    /**
     * Checks if the given log level is currently enabled or not.
     *
     * @param {string} levelName
     */

  }, {
    key: 'canLog',
    value: function canLog(levelName) {
      var level = this.getLevelIndexByName(levelName);

      if (level < 0) {
        return false;
      }

      return level >= this._maxLevel;
    }

    /**
     * Sets the current log level.
     *
     * @param {string} levelName
     * @memberof Logger
     */

  }, {
    key: 'setLevel',
    value: function setLevel(levelName) {
      var level = this.getLevelIndexByName(levelName);

      if (level < 0) {
        return;
      }

      this._maxLevel = level;
    }

    /**
     * Create an entry in the console. The specific console method is determined
     * by the level `levelName`. If color is available, use colorized output. If
     * more than one argument is supplied in `args`, a console group is created.
     *
     * @param {Number} levelName
     * @param {String} tag
     * @param {Array<string>} args
     *
     */

  }, {
    key: '_log',
    value: function _log(levelName, tag) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      var level = this.getLevelObjectByName(levelName);

      if (!level || !this.canLog(levelName)) {
        return;
      }

      var name = level.name,
          type = level.type,
          background = level.background,
          color = level.color;


      var outputs = args.filter(function (arg) {
        return arg !== undefined;
      }).map(function (arg) {
        if (arg.toObject) {
          return JSON.parse(JSON.stringify(arg.toObject()));
        }

        return arg;
      });

      var consoleFunc = this._consoleFuncs[type] || console[type] ? function () {
        var _console3;

        return (_console3 = console)[type].apply(_console3, arguments);
      } : function () {
        var _console4;

        return (_console4 = console).log.apply(_console4, arguments);
      };
      var outputsLen = outputs.length;
      var styles = getLogStyles(background, color);

      if (!hasColorOutput()) {
        var _outputsLen = outputs.length;
        if (_outputsLen <= 0) {
          consoleFunc('PhotoEditorSDK | ' + tag + ' ');
          return;
        }

        if (_outputsLen === 1 && typeof outputs[0] === 'string') {
          consoleFunc('PhotoEditorSDK | ' + tag + ' | ' + outputs[0]);
          return;
        }

        consoleFunc.apply(undefined, ['PhotoEditorSDK | ' + tag + ' | '].concat(_toConsumableArray(outputs)));
        return;
      }

      if (outputsLen <= 0) {
        consoleFunc.apply(undefined, ['%c  %c PhotoEditorSDK %c  %c ' + tag + ' %c %c  '].concat(_toConsumableArray(styles)));
        return;
      }

      if (outputsLen === 1 && typeof outputs[0] === 'string') {
        consoleFunc.apply(undefined, ['%c  %c PhotoEditorSDK %c  %c ' + tag + ' %c  ' + outputs[0] + '  %c  '].concat(_toConsumableArray(styles)));
        return;
      }

      // If there is more than one argument, try to group the log
      if (hasConsoleGroups()) {
        var _console5;

        (_console5 = console).groupCollapsed.apply(_console5, ['%c  %c PhotoEditorSDK %c  %c ' + tag + ' %c'].concat(_toConsumableArray(_utils2.default.Array.init(styles))));
        consoleFunc.apply(undefined, _toConsumableArray(outputs));
        console.groupEnd();
      } else {
        consoleFunc.apply(undefined, ['%c  %c PhotoEditorSDK %c  %c ' + tag + ' %c'].concat(_toConsumableArray(_utils2.default.Array.init(styles)), _toConsumableArray(outputs)));
      }
    }

    /**
     * Logs an image into the browser's console. Does
     * nothing in a node environment.
     *
     * @param {Canvas|string} source
     * @param {string} tag
     */

  }, {
    key: 'image',
    value: function image() {
      var tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var source = arguments[1];

      var image = new window.Image();

      var onload = function onload() {
        var width = image.width;
        var height = image.height;
        tag && console.log(tag);
        console.log('%c+', '\n        font-size: 1px;\n        padding: 0px ' + Math.floor(width / 2) + 'px;\n        line-height: ' + height + 'px;\n        background: url(' + image.src + ');\n        color: transparent;\n        background-repeat: no-repeat;\n        background-size: ' + width + 'px ' + height + 'px;');
      };

      image.onload = onload;

      if (source instanceof window.HTMLCanvasElement) {
        image.src = source.toDataURL();
      } else if (source instanceof window.Image) {
        image = source;
        onload();
      } else if (typeof source === 'string') {
        image.src = source;
      } else {
        this.log(tag, source);
      }
      return image;
    }

    /**
     * Logs a `PhotoEditorSDK.Engine.Texture` into the browser's console. Does
     * nothing in a node environment.
     *
     * @param {PhotoEditorSDK.Engine.Texture`} texture
     * @param {string} tag
     *
     */

  }, {
    key: 'texture',
    value: function texture() {
      var tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var _texture = arguments[1];

      if (!_texture) {
        this.log(tag, 'texture: null or undefined');
        return;
      }

      var baseTexture = _texture.getBaseTexture();
      var renderers = baseTexture.getRenderers();

      var glRenderer = _utils2.default.Array.find(renderers, function (r) {
        return r && r.constructor.type === 'WebGL';
      });

      var _baseTexture$getFrame = baseTexture.getFrame(),
          width = _baseTexture$getFrame.width,
          height = _baseTexture$getFrame.height;

      if (glRenderer) {
        var gl = glRenderer.getContext();
        var glTexture = baseTexture.getGLTextureForRenderer(glRenderer);
        this.logGlTexture(gl, glTexture, width, height, tag);
      } else {
        Log.image(tag, baseTexture.getSource());
      }
    }

    /**
     * Logs a WebGLTexture into the browser's console. Does
     * nothing in a node environment.
     *
     * @param {WebGLRenderingContext} gl
     * @param {WebGLTexture} texture
     * @param {number} [width=150]
     * @param {number} [height=150]
     * @param {string} tag
     */

  }, {
    key: 'logGlTexture',
    value: function logGlTexture(gl, texture) {
      var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 150;
      var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 150;
      var tag = arguments[4];

      gl.bindTexture(gl.TEXTURE_2D, texture);
      var framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

      // Read the contents of the framebuffer
      var data = new Uint8Array(width * height * 4);
      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);

      gl.deleteFramebuffer(framebuffer);

      var canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;

      var context = canvas.getContext('2d');

      // Copy the pixels to a 2D canvas
      var imageData = context.createImageData(width, height);
      imageData.data.set(data);
      context.putImageData(imageData, 0, 0);

      return Log.image(tag, canvas);
    }
  }]);

  return Logger;
}();

exports.Logger = Logger;


var Log = new Logger('warn');

exports.default = Log;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))

/***/ }),
/* 21 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global XMLHttpRequest */
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _promise = __webpack_require__(73);

var _promise2 = _interopRequireDefault(_promise);

var _url = __webpack_require__(76);

var _url2 = _interopRequireDefault(_url);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TIMEOUT = 5000;

var root = typeof window !== 'undefined' ? window : global;

var JSONLoader = function () {
  function JSONLoader(url) {
    _classCallCheck(this, JSONLoader);

    this._url = url;
    this._parsedUrl = _url2.default.parse(this._url, true);
  }

  /**
   * Checks if this request is a JSONP request
   * @return {Boolean}
   */


  _createClass(JSONLoader, [{
    key: '_isJSONPRequest',
    value: function _isJSONPRequest() {
      var query = this._parsedUrl.query;

      for (var key in query) {
        var value = query[key];
        if (value === '?') {
          return true;
        }
      }
      return false;
    }

    /**
     * Loads the JSON(P) from the given URL
     * @return {Promise}
     */

  }, {
    key: 'load',
    value: function load() {
      if (this._isJSONPRequest()) {
        return this._loadJSONP();
      } else {
        return this._loadJSON();
      }
    }

    /**
     * Loads the URL as JSON
     * @return {Promise}
     */

  }, {
    key: '_loadJSON',
    value: function _loadJSON() {
      var _this = this;

      return new _promise2.default(function (resolve, reject) {
        var xhr = void 0;
        if (root.XDomainRequest) {
          xhr = new root.XDomainRequest();

          xhr.onload = function () {
            var json = JSON.parse(xhr.responseText);
            resolve(json);
          };
          xhr.onerror = function (e) {
            reject(e);
          };
          xhr.open('GET', _this._url, true);
          xhr.send();
        } else if (root.XMLHttpRequest) {
          xhr = new XMLHttpRequest();

          xhr.onreadystatechange = function (oEvent) {
            if (xhr.readyState === 4) {
              if (xhr.status === 200) {
                var json = JSON.parse(xhr.responseText);
                resolve(json);
              } else {
                reject(new Error('HTTP Status ' + xhr.status));
              }
            }
          };
          xhr.open('GET', _this._url, true);
          xhr.send();
        }
      });
    }

    /**
     * Loads the URL as JSONP
     * @return {Promise}
     */

  }, {
    key: '_loadJSONP',
    value: function _loadJSONP() {
      var _this2 = this;

      var failed = false;
      var succeeded = false;

      var fnName = 'pesdk' + Math.round(Math.random() * 99999999999999);
      return new _promise2.default(function (resolve, reject) {
        var node = _this2._createJSONPNode(fnName);
        root[fnName] = function (result) {
          _this2._removeJSONPNode(node);
          if (!failed) {
            succeeded = true;
            resolve(result);
          }
        };

        root.setTimeout(function () {
          if (!succeeded) {
            _this2._removeJSONPNode(node);
            failed = true;
            reject(new Error('Timeout of 5 seconds exceeded.'));
          }
        }, TIMEOUT);
      });
    }

    /**
     * Creates a JSONP <script> node inside the <head> element
     * @param  {String} fnName
     * @return {DOMElement}
     * @private
     */

  }, {
    key: '_createJSONPNode',
    value: function _createJSONPNode(fnName) {
      var JSONPUrl = this._buildJSONPUrl(fnName);
      var headNode = document.querySelector('head');
      var scriptNode = document.createElement('script');
      scriptNode.src = JSONPUrl;
      headNode.appendChild(scriptNode);
      return scriptNode;
    }

    /**
     * Removes the JSONP <script> node from the <head> element
     * @param  {DOMElement} node
     * @private
     */

  }, {
    key: '_removeJSONPNode',
    value: function _removeJSONPNode(node) {
      node.parentNode.removeChild(node);
    }

    /**
     * Builds a JSONP url for the given function name
     * @param  {String} fnName
     * @return {String}
     */

  }, {
    key: '_buildJSONPUrl',
    value: function _buildJSONPUrl(fnName) {
      // Find JSONP parameter
      var query = this._parsedUrl.query;

      var parameter = null;
      for (var param in query) {
        if (query[param] === '?') {
          parameter = param;
          break;
        }
      }

      delete this._parsedUrl.search;
      query[parameter] = fnName;

      return _url2.default.format(this._parsedUrl);
    }
  }]);

  return JSONLoader;
}();

exports.default = JSONLoader;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

/* eslint-disable brace-style */

exports.default = {
  load: function load(url) {
    var _this = this;

    var crossOrigin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { cors: true, value: 'anonymous' };

    var loadPromise = function loadPromise() {
      if (url.substr(0, 5) === 'data:' || "boolean" !== 'undefined') {
        return Promise.resolve([url, url]);
      }
    };

    return loadPromise().then(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          originalSrc = _ref2[0],
          src = _ref2[1];

      return _this._createAndLoadImage(originalSrc, src, crossOrigin);
    });
  },
  _createAndLoadImage: function _createAndLoadImage(originalSrc, src) {
    var crossOrigin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { cors: true, value: 'anonymous' };

    if (true) {
      return new Promise(function (resolve, reject) {
        var image = new window.Image();
        image.addEventListener('load', function () {
          resolve(image);
        });
        image.addEventListener('error', function () {
          reject(new Error('Failed to load image at ' + src));
        });

        if (crossOrigin.cors) {
          image.crossOrigin = crossOrigin.value;
        }

        image.src = src;
      });
    }
  },
  loadXHR: function loadXHR(url, mime) {
    return new Promise(function (resolve, reject) {
      var xhr = void 0;
      if (window.XDomainRequest) {
        xhr = new window.XDomainRequest();
        if (mime) xhr.overrideMimeType(mime);

        xhr.onload = function () {
          resolve(xhr);
        };
        xhr.onerror = function (e) {
          reject(e);
        };
      } else if (window.XMLHttpRequest) {
        xhr = new window.XMLHttpRequest();
        if (mime) xhr.overrideMimeType(mime);

        xhr.onreadystatechange = function (oEvent) {
          if (xhr.readyState === 4) {
            if (xhr.status === 200) {
              resolve(xhr);
            } else {
              reject(new Error('HTTP Status ' + xhr.status));
            }
          }
        };
      }

      xhr.open('GET', url, true);
      xhr.send();
    });
  }
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var RowComponent = function (_BaseComponent) {
  _inherits(RowComponent, _BaseComponent);

  function RowComponent() {
    var _ref;

    _classCallCheck(this, RowComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = RowComponent.__proto__ || Object.getPrototypeOf(RowComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onClick');
    return _this;
  }
  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user clicks the button
   * @param  {Event} e
   * @private
   */


  _createClass(RowComponent, [{
    key: '_onClick',
    value: function _onClick(e) {
      this.props.onClick && this.props.onClick();
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this row's content
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderContent',
    value: function _renderContent() {
      return null;
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var rowBEM = '$e:row m:' + this._modifier;
      if (this.props.totalRows) {
        rowBEM += ' m:row-' + this.props.totalRows;
      }

      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: 'b:splashScreen' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: rowBEM },
          this._renderContent()
        )
      );
    }
  }]);

  return RowComponent;
}(_globals.BaseComponent);

exports.default = RowComponent;


RowComponent.propTypes = {
  onClick: _globals.PropTypes.func
};

RowComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _fileLoader = __webpack_require__(93);

var _fileLoader2 = _interopRequireDefault(_fileLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var InvisibleUploadComponent = function (_BaseComponent) {
  _inherits(InvisibleUploadComponent, _BaseComponent);

  function InvisibleUploadComponent() {
    var _ref;

    _classCallCheck(this, InvisibleUploadComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = InvisibleUploadComponent.__proto__ || Object.getPrototypeOf(InvisibleUploadComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onNewFile');
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  _createClass(InvisibleUploadComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this._fileLoader = new _fileLoader2.default(this.refs.fileInput);
      this._fileLoader.on('file', this._onNewFile);
    }

    /**
     * Gets called when this component is about to be unmounted
     */

  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this._fileLoader.off('file', this._onNewFile);
      this._fileLoader.dispose();
      this._fileLoader = null;
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the FileLoader emits a new file
     * @param  {File} file
     * @private
     */

  }, {
    key: '_onNewFile',
    value: function _onNewFile(file) {
      this.props.onNewFile && this.props.onNewFile(file);
    }

    // -------------------------------------------------------------------------- PUBLIC API

    /**
     * Public method for opening the file loader
     */

  }, {
    key: 'open',
    value: function open() {
      this._fileLoader.open();
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement('input', { type: 'file', accept: 'image/*', bem: 'b:hiddenFileInput', ref: 'fileInput' });
    }
  }]);

  return InvisibleUploadComponent;
}(_globals.BaseComponent);

exports.default = InvisibleUploadComponent;


InvisibleUploadComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var TopBarButtonComponent = function (_BaseComponent) {
  _inherits(TopBarButtonComponent, _BaseComponent);

  function TopBarButtonComponent() {
    _classCallCheck(this, TopBarButtonComponent);

    return _possibleConstructorReturn(this, (TopBarButtonComponent.__proto__ || Object.getPrototypeOf(TopBarButtonComponent)).apply(this, arguments));
  }

  _createClass(TopBarButtonComponent, [{
    key: 'renderWithBEM',

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */
    value: function renderWithBEM() {
      // Build BEM specifier
      var bem = '$e:button';
      if (this.props.style) {
        bem += ' m:' + this.props.style;
      }
      if (this.props.icon) {
        bem += ' m:withIcon';
      }

      // Build icon
      var icon = null;
      if (this.props.icon) {
        icon = _globals.ReactBEM.createElement('img', {
          bem: 'e:icon',
          src: this._getAssetPath(this.props.icon, true) });
      }

      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:topBar' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: bem, onClick: this.props.onClick },
          icon,
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:label' },
            this.props.label || 'Button'
          )
        )
      );
    }
  }]);

  return TopBarButtonComponent;
}(_globals.BaseComponent);

exports.default = TopBarButtonComponent;


TopBarButtonComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FilterManager = function () {
  function FilterManager(ui, options) {
    _classCallCheck(this, FilterManager);

    this._ui = ui;
    this._options = options;
    this._categoriesById = {};
    this._filtersByIdentifier = {
      identity: _globals.SDK.Operations.FilterOperation.Filters.IdentityFilter
    };

    this._categories = _globals.SharedConstants.DEFAULTS.FILTERS.slice(0);

    this._initCategories();
  }

  _createClass(FilterManager, [{
    key: 'instantiateFilterWithIdentifier',
    value: function instantiateFilterWithIdentifier(identifier) {
      var _this = this;

      var Filter = this.getFilterByIdentifier(identifier);
      if (!Filter) {
        return Promise.reject(new Error('Unknown filter with identifier `' + identifier + '`!'));
      }

      if (!(Filter.prototype instanceof _globals.SDK.Operations.FilterOperation.Filter)) {
        var lutImage = Filter.lutImage,
            resolution = Filter.resolution,
            horizontalTileCount = Filter.horizontalTileCount,
            verticalTileCount = Filter.verticalTileCount;

        var preloadedImage = void 0;
        if (this._ui.getPreloader) {
          preloadedImage = this._ui.getPreloader().getAsset(lutImage);
        }
        var loadPromise = void 0;
        if (preloadedImage) {
          loadPromise = Promise.resolve(preloadedImage);
        } else {
          loadPromise = _globals.ImageLoader.load(this._ui.getAssetPath(lutImage));
        }

        return loadPromise.then(function (image) {
          return _globals.ImageLoader.load(_this._ui.getAssetPath(lutImage)).then(function (image) {
            return new _globals.SDK.Operations.FilterOperation.Filters.ThreeDLUTFilter({
              image: image, resolution: resolution, horizontalTileCount: horizontalTileCount, verticalTileCount: verticalTileCount
            });
          });
        });
      } else {
        return Promise.resolve(new Filter());
      }
    }

    /**
     * Initializes the categories
     * @private
     */

  }, {
    key: '_initCategories',
    value: function _initCategories() {
      var _this2 = this;

      // Should the categories passed in by the user replace the existing ones?
      if (this._options.categories) {
        if (this._options.replaceCategories) {
          this._categories = this._options.categories;
        } else {
          this._categories = _globals.Utils.mergeCategories(this._categories, this._options.categories, 'filters');
        }
      }

      // Remove filters that should not be selectable
      if (this._options.availableFilters) {
        var newCategories = [];
        this._categories.forEach(function (category) {
          var filters = category.filters.filter(function (f) {
            return _this2._options.availableFilters.indexOf(f.identifier) !== -1;
          });
          if (filters.length > 0) {
            newCategories.push({
              identifier: category.identifier,
              defaultName: category.defaultName,
              filters: filters
            });
          }
        });
        this._categories = newCategories;
      }

      var allCategory = {
        identifier: 'all',
        defaultName: 'All',
        filters: this._categories.length <= 0 ? [] : this._categories.map(function (c) {
          return c.filters;
        }).reduce(function (a, b) {
          return a.concat(b);
        })
      };
      this._categories.unshift(allCategory);
      this._categoriesById.all = allCategory;
      this._categories.forEach(function (c) {
        _this2._categoriesById[c.identifier] = c;
      });
      allCategory.filters.forEach(function (filter) {
        _this2._filtersByIdentifier[filter.identifier] = filter;
      });
    }

    /**
     * Returns the filters for the category with the given name
     * @param  {String} categoryIdentifier
     * @return {Object[]}
     */

  }, {
    key: 'getFiltersForCategory',
    value: function getFiltersForCategory(categoryIdentifier) {
      if (!this._categoriesById[categoryIdentifier]) {
        throw new Error('Unknown filter category \'' + categoryIdentifier + '\'');
      }
      return this._categoriesById[categoryIdentifier].filters;
    }

    /**
     * Returns the filter with the given identifier
     * @param  {String} identifier
     * @return {PhotoEditorSDK.Filter}
     */

  }, {
    key: 'getFilterByIdentifier',
    value: function getFilterByIdentifier(identifier) {
      return this._filtersByIdentifier[identifier];
    }

    /**
     * Returns the categories
     * @return {Object[]}
     */

  }, {
    key: 'getCategories',
    value: function getCategories() {
      return this._categories;
    }

    /**
     * Returns the category with the given identifier
     * @param  {String} identifier
     * @return {Object}
     */

  }, {
    key: 'getCategoryByIdentifier',
    value: function getCategoryByIdentifier(identifier) {
      return this._categoriesById[identifier];
    }
  }]);

  return FilterManager;
}();

exports.default = FilterManager;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ItemComponent = function (_BaseComponent) {
  _inherits(ItemComponent, _BaseComponent);

  function ItemComponent() {
    var _ref;

    _classCallCheck(this, ItemComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = ItemComponent.__proto__ || Object.getPrototypeOf(ItemComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onItemDragStart', '_onItemDragStop', '_onItemDrag', '_onSpriteUpdate');
    return _this;
  }

  // -------------------------------------------------------------------------- CALCULATIONS

  /**
   * Returns the absolute position of the sprite
   * @return {Vector2}
   * @private
   */


  _createClass(ItemComponent, [{
    key: '_getAbsoluteSpritePosition',
    value: function _getAbsoluteSpritePosition() {
      var editor = this.context.editor;

      var outputDimensions = editor.getOutputDimensions();

      return this.props.sprite.getPosition().clone().multiply(outputDimensions);
    }

    // -------------------------------------------------------------------------- LIFECYCLE

    /**
     * Gets called when this component has been mounted
     */

  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      _get(ItemComponent.prototype.__proto__ || Object.getPrototypeOf(ItemComponent.prototype), 'componentDidMount', this).call(this);
      this.props.sprite.on('update', this._onSpriteUpdate);
    }

    /**
     * Gets called when this component is about to be unmounted
     */

  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      _get(ItemComponent.prototype.__proto__ || Object.getPrototypeOf(ItemComponent.prototype), 'componentWillUnmount', this).call(this);
      this.props.sprite.off('update', this._onSpriteUpdate);
    }

    /**
     * Gets called when this component will receive new props
     * @param  {Object} nextProps
     */

  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      this.props.sprite.off('update', this._onSpriteUpdate);
      nextProps.sprite.on('update', this._onSpriteUpdate);
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when this component's sprite has been updated
     * @private
     */

  }, {
    key: '_onSpriteUpdate',
    value: function _onSpriteUpdate() {
      this.forceUpdate();
    }

    /**
     * Gets called when the user starts dragging this item
     * @private
     */

  }, {
    key: '_onItemDragStart',
    value: function _onItemDragStart() {
      var sprite = this.props.sprite;

      this._initialPosition = sprite.getPosition();

      this.props.onDragStart && this.props.onDragStart();
    }

    /**
     * Gets called while the user drags this item
     * @param  {Vector2} offset
     * @private
     */

  }, {
    key: '_onItemDrag',
    value: function _onItemDrag(offset) {
      var sprite = this.props.sprite;
      var editor = this.context.editor;


      var outputDimensions = editor.getOutputDimensions();
      var newPosition = this._initialPosition.clone().add(offset.divide(outputDimensions));

      sprite.setPosition(newPosition);
      editor.render();
    }

    /**
     * Gets called when the user stops dragging this item
     * @private
     */

  }, {
    key: '_onItemDragStop',
    value: function _onItemDragStop() {
      this.props.onDragStop && this.props.onDragStop();
    }
  }]);

  return ItemComponent;
}(_globals.BaseComponent);

exports.default = ItemComponent;


ItemComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _overlayComponent = __webpack_require__(153);

var _overlayComponent2 = _interopRequireDefault(_overlayComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ColorPickerComponent = function (_BaseComponent) {
  _inherits(ColorPickerComponent, _BaseComponent);

  function ColorPickerComponent() {
    var _ref;

    _classCallCheck(this, ColorPickerComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = ColorPickerComponent.__proto__ || Object.getPrototypeOf(ColorPickerComponent)).call.apply(_ref, [this].concat(args)));

    _this._value = _this.props.initialValue.clone();
    _this._bindAll('_onButtonClick', '_onValueChange', '_onColorPickerOpen', '_onColorPickerClose');

    _this._events = _defineProperty({}, _globals.Constants.EVENTS.COLORPICKER_OPEN, _this._onColorPickerOpen);

    _this.state = {
      overlayVisible: false
    };

    _this._transparentPatternCanvas = _globals.Utils.createTransparentPatternCanvas();
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component will receive new props
   * @param  {Object} nextProps
   */


  _createClass(ColorPickerComponent, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.initialValue !== this.props.initialValue) {
        this._value = nextProps.initialValue.clone();
        this._renderColor();
      }
    }

    /**
     * Gets called when this component has been mounted
     */

  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      _get(ColorPickerComponent.prototype.__proto__ || Object.getPrototypeOf(ColorPickerComponent.prototype), 'componentDidMount', this).call(this);
      this._renderColor();
    }

    /**
     * Gets called after this component has been updated
     */

  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      this._renderColor();
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when a colorpicker has been opened. If it is not the same
     * color picker as this, this one gets closed. This makes sure that there
     * is only one color picker open at a time
     * @param  {ColorPickerComponent} colorPicker
     * @private
     */

  }, {
    key: '_onColorPickerOpen',
    value: function _onColorPickerOpen(colorPicker) {
      if (colorPicker === this) return;
      this.setState({ overlayVisible: false });
    }

    /**
     * Gets called when the color picker overlay tries to close itself
     * @private
     */

  }, {
    key: '_onColorPickerClose',
    value: function _onColorPickerClose() {
      this.setState({ overlayVisible: false });
    }

    /**
     * Gets called when the color picker button has been clicked
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onButtonClick',
    value: function _onButtonClick(e) {
      e.preventDefault();
      e.stopPropagation();

      if (!this.state.overlayVisible) {
        this._emitEvent(_globals.Constants.EVENTS.COLORPICKER_OPEN, this);
      }

      this.setState({ overlayVisible: !this.state.overlayVisible });
    }

    /**
     * Gets called when the value changes
     * @param  {Color} value
     * @private
     */

  }, {
    key: '_onValueChange',
    value: function _onValueChange(value) {
      this._value = value;
      this._renderColor();
      this.forceUpdate();

      this.props.onChange && this.props.onChange(value);
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the current color on the preview canvas
     * @private
     */

  }, {
    key: '_renderColor',
    value: function _renderColor() {
      var canvas = this.refs.canvas;
      var context = canvas.getContext('2d');

      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;

      var pattern = context.createPattern(this._transparentPatternCanvas, 'repeat');
      context.fillStyle = pattern;
      context.fillRect(0, 0, canvas.width, canvas.height);

      context.fillStyle = this._value.toRGBA();
      context.fillRect(0, 0, canvas.width, canvas.height);
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var Overlay = null;
      if (this.state.overlayVisible) {
        Overlay = _globals.ReactBEM.createElement(_overlayComponent2.default, {
          initialValue: this._value,
          onChange: this._onValueChange,
          onClose: this._onColorPickerClose,
          alpha: this.props.alpha });
      }

      var className = this.state.overlayVisible ? 'is-active' : null;

      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:controls' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$b:colorPicker', className: className, onClick: this._onButtonClick },
          _globals.ReactBEM.createElement('canvas', { bem: 'e:preview', ref: 'canvas' }),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:label' },
            this.props.label || this._t('pesdk.common.text.color')
          ),
          Overlay
        )
      );
    }
  }]);

  return ColorPickerComponent;
}(_globals.BaseComponent);

exports.default = ColorPickerComponent;


ColorPickerComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */


var _googleFontLoader = __webpack_require__(177);

var _googleFontLoader2 = _interopRequireDefault(_googleFontLoader);

var _fileFontLoader = __webpack_require__(180);

var _fileFontLoader2 = _interopRequireDefault(_fileFontLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FontLoader = function () {
  function FontLoader(ui, fonts) {
    _classCallCheck(this, FontLoader);

    this._ui = ui;
    this._fonts = fonts;
    this._loadedFonts = [];
  }

  /**
   * Sets the fonts
   * @param {Font[]} fonts
   */


  _createClass(FontLoader, [{
    key: 'setFonts',
    value: function setFonts(fonts) {
      this._fonts = fonts;
    }

    /**
     * Checks if the font loader needs to load something
     * @return {Boolean}
     */

  }, {
    key: 'needsToLoad',
    value: function needsToLoad() {
      var _this = this;

      var _loop = function _loop(i) {
        var provider = void 0;
        _this._fonts[i].getVariations().forEach(function (variation) {
          provider = provider || variation.getProvider();
        });
        if (!provider) return 'continue';
        return {
          v: true
        };
      };

      for (var i = 0; i < this._fonts.length; i++) {
        var _ret = _loop(i);

        switch (_ret) {
          case 'continue':
            continue;

          default:
            if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
        }
      }
    }

    /**
     * Checks if the given font has already been loaded
     * @param  {Font} font
     */

  }, {
    key: 'fontLoaded',
    value: function fontLoaded(font) {
      var identifier = font.getFontFamily();
      return this._loadedFonts.indexOf(identifier) !== -1;
    }

    /**
     * Sets the given font to loaded
     * @param {Font} font
     */

  }, {
    key: 'setFontLoaded',
    value: function setFontLoaded(font) {
      if (!this.fontLoaded(font)) {
        var identifier = font.getFontFamily();
        this._loadedFonts.push(identifier);
      }
    }

    /**
     * Loads the given fonts
     * @param  {Object[]} fonts
     */

  }, {
    key: 'load',
    value: function load() {
      var _this2 = this;

      var fonts = this._fonts;
      var loaders = {
        google: new _googleFontLoader2.default(this._ui),
        file: new _fileFontLoader2.default(this._ui)
      };

      var disposeLoaders = function disposeLoaders() {
        for (var identifier in loaders) {
          var loader = loaders[identifier];
          loader.dispose();
        }
      };

      fonts.filter(function (font) {
        return !_this2.fontLoaded(font);
      }).forEach(function (font) {
        font.getVariations().forEach(function (variation) {
          var provider = variation.getProvider();
          if (!provider) return;

          var loader = loaders[provider];
          loader.add(variation);
        });
      });

      var promises = [];
      for (var name in loaders) {
        promises.push(loaders[name].load());
      }
      return Promise.all(promises).then(function () {
        disposeLoaders();
        fonts.forEach(function (font) {
          _this2.setFontLoaded(font);
        });
      }).catch(function (e) {
        disposeLoaders();
        throw e;
      });
    }
  }]);

  return FontLoader;
}();

exports.default = FontLoader;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _serializer = __webpack_require__(53);

var _serializer2 = _interopRequireDefault(_serializer);

var _blendModes = __webpack_require__(55);

var _blendModes2 = _interopRequireDefault(_blendModes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var v200Serializer = function (_PreviousSerializer) {
  _inherits(v200Serializer, _PreviousSerializer);

  function v200Serializer() {
    _classCallCheck(this, v200Serializer);

    return _possibleConstructorReturn(this, (v200Serializer.__proto__ || Object.getPrototypeOf(v200Serializer)).apply(this, arguments));
  }

  _createClass(v200Serializer, [{
    key: '_serializeSticker',

    /**
     * Serializes the given sticker
     * @param  {PhotoEditorSDK.Operation} operation
     * @param  {PhotoEditorSDK.Operations.SpriteOperation.StickerSprite} sprite
     * @return {Object}
     * @private
     */
    value: function _serializeSticker(operation, sprite) {
      var inputDimensions = operation.getInputDimensions(false);
      var response = _get(v200Serializer.prototype.__proto__ || Object.getPrototypeOf(v200Serializer.prototype), '_serializeSticker', this).call(this, operation, sprite);

      // New in 2.0.0: `tintColor`
      if (sprite.getTintMode() !== 'none') {
        response.options.tintColor = sprite.serializeOption('tintColor', true);
      }

      // Dimensions are relative, not absolute anymore
      response.options.dimensions = sprite.getDimensions().clone().divide(inputDimensions.min()).toObject();

      // `name` is now `identifier`
      response.options.identifier = response.options.name;
      delete response.options.name;

      return response;
    }

    /**
     * Serializes the given path
     * @param  {PhotoEditorSDK.Operations.SpriteOperation.BrushSprite.Path} path
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializePath',
    value: function _serializePath(path) {
      var response = _get(v200Serializer.prototype.__proto__ || Object.getPrototypeOf(v200Serializer.prototype), '_serializePath', this).call(this, path);

      var brush = path.getBrush();
      if (brush.hasOption('hardness')) {
        response.hardness = brush.getOption('hardness');
      }

      return response;
    }

    /**
     * Serializes the given operation
     * @param  {PhotoEditorSDK.Operation} operation
     * @param  {PhotoEditorSDK.Operation[]} operations
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeOperation',
    value: function _serializeOperation(operation, operations) {
      if (operation.constructor.identifier === 'frame') {
        this._serializeFrameOperation(operation, operations);
        return null;
      }

      if (operation.constructor.identifier === 'overlay') {
        this._serializeOverlayOperation(operation, operations);
        return null;
      }

      return _get(v200Serializer.prototype.__proto__ || Object.getPrototypeOf(v200Serializer.prototype), '_serializeOperation', this).call(this, operation, operations);
    }

    /**
     * Serializes the frame operation
     * @param {PhotoEditorSDK.Operation.FrameOperation} operation
     * @param {PhotoEditorSDK.Operation[]} operations
     * @private
     */

  }, {
    key: '_serializeFrameOperation',
    value: function _serializeFrameOperation(operation, operations) {
      // Since serialization 2.0.0 stores frames as part of the SpriteOperation, we need
      // to check if a sprite operation is present and extend its `sprites` option
      var spriteOperations = operations.filter(function (o) {
        return o.type === 'sprite';
      });
      var spriteOperation = void 0;
      if (spriteOperations.length) {
        spriteOperation = spriteOperations.pop();
      } else {
        // No sprite operation exists, create a new one
        spriteOperation = {
          type: 'sprite',
          options: {
            sprites: []
          }
        };
        operations.push(spriteOperation);
      }

      spriteOperation.options.sprites.push({
        type: 'frame',
        options: this._getFrameOptions(operation)
      });
    }

    /**
     * Serializes the overlay operation
     * @param {PhotoEditorSDK.Operation.OverlayOperation} operation
     * @param {PhotoEditorSDK.Operation[]} operations
     * @private
     */

  }, {
    key: '_serializeOverlayOperation',
    value: function _serializeOverlayOperation(operation, operations) {
      if (!operation.getIdentifier()) return;

      // Since serialization 2.0.0 stores overlays as part of the SpriteOperation, we need
      // to check if a sprite operation is present and extend its `sprites` option
      var spriteOperations = operations.filter(function (o) {
        return o.type === 'sprite';
      });
      var spriteOperation = void 0;
      if (spriteOperations.length) {
        spriteOperation = spriteOperations.pop();
      } else {
        // No sprite operation exists, create a new one
        spriteOperation = {
          type: 'sprite',
          options: {
            sprites: []
          }
        };
        operations.push(spriteOperation);
      }

      spriteOperation.options.sprites.push({
        type: 'overlay',
        options: {
          identifier: operation.getIdentifier(),
          intensity: operation.getAlpha(),
          blendMode: _blendModes2.default[operation.getBlendMode()]
        }
      });
    }

    /**
     * Returns the options object for the given FrameOperation
     * @param  {PhotoEditorSDK.Operations.FrameOperation} operation
     * @return {Object}
     * @private
     */

  }, {
    key: '_getFrameOptions',
    value: function _getFrameOptions(operation) {
      return {
        identifier: operation.getFrame().identifier
      };
    }
  }, {
    key: '_serializeOrientationOperation',
    value: function _serializeOrientationOperation(operation) {
      var response = _get(v200Serializer.prototype.__proto__ || Object.getPrototypeOf(v200Serializer.prototype), '_serializeOrientationOperation', this).call(this, operation);

      // For some unknown reason, we start this "first rotate, then flip" thing with 2.0.0
      if (response.options.rotation === 90 || response.options.rotation === 270) {
        response.options.flipHorizontally = !response.options.flipHorizontally;
        response.options.flipVertically = !response.options.flipVertically;
      }

      return response;
    }

    /**
     * Serializes the given transform operation
     * @param  {PhotoEditorSDK.Operation.TransformOperation} operation
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeTransformOperation',
    value: function _serializeTransformOperation(operation) {
      var operations = this._editor.operations;

      // Version 2.0 and up has different operation order: First transform, then orientation.

      if (operations.exists('orientation')) {
        // Updating the original operation will mess up the editor state
        operation = operation.clone();

        // Undo orientation that has been applied to the transforms
        var orientationOperation = operations.get('orientation');
        operation.rotate(-orientationOperation.getRotation());
        if (orientationOperation.getFlipVertically()) {
          operation.flip('vertical');
          operation.setRotation(operation.getRotation() * -1);
        }
        if (orientationOperation.getFlipHorizontally()) {
          operation.flip('horizontal');
          operation.setRotation(operation.getRotation() * -1);
        }
      }

      // Version 2.0 and up: Crop operation is now called transform operation
      var response = _get(v200Serializer.prototype.__proto__ || Object.getPrototypeOf(v200Serializer.prototype), '_serializeTransformOperation', this).call(this, operation);

      response.type = 'transform';
      return response;
    }

    /**
     * Serializes the given text sprite
     * @param  {PhotoEditorSDK.Operation} operation
     * @param  {PhotoEditorSDK.Operations.SpriteOperation.TextSprite} sprite
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeText',
    value: function _serializeText(operation, sprite) {
      var response = _get(v200Serializer.prototype.__proto__ || Object.getPrototypeOf(v200Serializer.prototype), '_serializeText', this).call(this, operation, sprite);

      var inputDimensions = operation.getInputDimensions(false);
      response.options.fontIdentifier = sprite.getFontIdentifier();

      // For whatever reason, max width is relative to shortest side, while font size isn't
      response.options.maxWidth = response.options.maxWidth * inputDimensions.x / inputDimensions.min();
      delete response.options.fontFamily;

      return response;
    }

    /**
     * Serializes the given filter operation
     * @param  {PhotoEditorSDK.Operations.FilterOperation} operation
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeFilterOperation',
    value: function _serializeFilterOperation(operation) {
      var response = _get(v200Serializer.prototype.__proto__ || Object.getPrototypeOf(v200Serializer.prototype), '_serializeFilterOperation', this).call(this, operation);
      if (!response) return null;

      response.options.identifier = response.options.name;
      delete response.options.name;

      return response;
    }

    /**
     * Serializes the given radial focus operation
     * @param  {PhotoEditorSDK.Operations.RadialFocusOperation} operation
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeRadialFocusOperation',
    value: function _serializeRadialFocusOperation(operation) {
      var response = _get(v200Serializer.prototype.__proto__ || Object.getPrototypeOf(v200Serializer.prototype), '_serializeRadialFocusOperation', this).call(this, operation);

      var focusOptions = response.options.options;
      focusOptions.start = focusOptions.position;
      delete focusOptions.position;
      focusOptions.end = {
        x: focusOptions.start.x + focusOptions.radius,
        y: focusOptions.start.y
      };
      delete focusOptions.radius;

      return response;
    }
  }]);

  return v200Serializer;
}(_serializer2.default);

exports.default = v200Serializer;


v200Serializer.version = '2.0.0';

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _deserializer = __webpack_require__(54);

var _deserializer2 = _interopRequireDefault(_deserializer);

var _frameManager = __webpack_require__(48);

var _frameManager2 = _interopRequireDefault(_frameManager);

var _overlayManager = __webpack_require__(183);

var _overlayManager2 = _interopRequireDefault(_overlayManager);

var _stickerManager = __webpack_require__(11);

var _stickerManager2 = _interopRequireDefault(_stickerManager);

var _frame = __webpack_require__(49);

var _frame2 = _interopRequireDefault(_frame);

var _fontLoader = __webpack_require__(30);

var _fontLoader2 = _interopRequireDefault(_fontLoader);

var _imageLoader = __webpack_require__(23);

var _imageLoader2 = _interopRequireDefault(_imageLoader);

var _blendModes = __webpack_require__(55);

var _blendModes2 = _interopRequireDefault(_blendModes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var blendModeByName = _globals.SDKUtils.flipObject(_blendModes2.default);

var v200Deserializer = function (_PreviousDeserializer) {
  _inherits(v200Deserializer, _PreviousDeserializer);

  function v200Deserializer() {
    var _ref;

    _classCallCheck(this, v200Deserializer);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = v200Deserializer.__proto__ || Object.getPrototypeOf(v200Deserializer)).call.apply(_ref, [this].concat(args)));

    _this._frameManager = new _frameManager2.default(_this._ui, _this._getOptions('frame'));

    var overlayOptions = _this._getOptions('overlay');
    if (overlayOptions) {
      _this._overlayManager = new _overlayManager2.default(_this._ui, overlayOptions);
    }
    return _this;
  }

  /**
   * Deserializes the given sprite
   * @param  {PhotoEditorSDK.Operations.SpriteOperation} spriteOperation
   * @param  {PhotoEditorSDK.Operations.SpriteOperation.Sprite} sprite
   * @return {Promise}
   * @private
   */


  _createClass(v200Deserializer, [{
    key: '_deserializeSprite',
    value: function _deserializeSprite(spriteOperation, sprite) {
      if (sprite.type === 'frame') {
        return this._deserializeFrame(spriteOperation, sprite);
      }
      if (sprite.type === 'overlay') {
        return this._deserializeOverlay(spriteOperation, sprite);
      }
      return _get(v200Deserializer.prototype.__proto__ || Object.getPrototypeOf(v200Deserializer.prototype), '_deserializeSprite', this).call(this, spriteOperation, sprite);
    }

    /**
     * Deserializes the given operation
     * @param  {PhotoEditorSDK.Operation} operation
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeOperation',
    value: function _deserializeOperation(operation) {
      if (operation.type === 'transform') {
        return this._deserializeTransformOperation(operation);
      }
      return _get(v200Deserializer.prototype.__proto__ || Object.getPrototypeOf(v200Deserializer.prototype), '_deserializeOperation', this).call(this, operation);
    }
  }, {
    key: '_deserializeOrientationOperation',
    value: function _deserializeOrientationOperation(operationData) {
      if (operationData.options.rotation === 90 || operationData.options.rotation === 270) {
        operationData.options.flipHorizontally = !operationData.options.flipHorizontally;
        operationData.options.flipVertically = !operationData.options.flipVertically;
      }

      return _get(v200Deserializer.prototype.__proto__ || Object.getPrototypeOf(v200Deserializer.prototype), '_deserializeOrientationOperation', this).call(this, operationData);
    }

    /**
     * Deserializes the given transform operation
     * @param  {Object} operationData
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeTransformOperation',
    value: function _deserializeTransformOperation(operationData) {
      var _this2 = this;

      // Version 2.0 and up: Crop operation is now called transform operation
      return _get(v200Deserializer.prototype.__proto__ || Object.getPrototypeOf(v200Deserializer.prototype), '_deserializeCropOperation', this).call(this, operationData).then(function (operation) {
        if (!operation) return;

        var orientationData = _globals.SDKUtils.Array.find(_this2._data.operations, function (op) {
          return op.type === 'orientation';
        });
        if (orientationData) {
          var options = orientationData.options;
          var rotation = options.rotation,
              flipHorizontally = options.flipHorizontally,
              flipVertically = options.flipVertically;


          if (rotation === 90 || rotation === 270) {
            if (!flipHorizontally && flipVertically || flipHorizontally && !flipVertically) {
              flipHorizontally = !flipHorizontally;
              flipVertically = !flipVertically;
            }
          }

          operation.rotate(options.rotation);
          if (flipHorizontally) {
            operation.flip('horizontal');
            operation.setRotation(operation.getRotation() * -1);
          }
          if (flipVertically) {
            operation.flip('vertical');
            operation.setRotation(operation.getRotation() * -1);
          }
        }

        return operation;
      });
    }

    /**
     * Deserializes the given frame sprite
     * @param  {PhotoEditorSDK.Operations.SpriteOperation} spriteOperation
     * @param  {Object} frame
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeFrame',
    value: function _deserializeFrame(spriteOperation, frame) {
      var _this3 = this;

      var identifier = frame.options.identifier;


      var frameData = this._frameManager.getFrameByIdentifier(identifier);
      if (!frameData) {
        _globals.Log.warn('Deserializer', 'Unknown frame `' + identifier + '`. Skipping frame.');
        return Promise.resolve();
      }
      var frameInstance = new _frame2.default(this._ui, frameData);
      return frameInstance.load().then(function () {
        _this3._editor.operations.getOrCreate('frame', {
          frame: frameInstance.getFrame()
        });
      });
    }

    /**
     * Deserializes the given overlay sprite
     * @param  {PhotoEditorSDK.Operations.SpriteOperation} spriteOperation
     * @param  {Object} overlay
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeOverlay',
    value: function _deserializeOverlay(spriteOperation, overlay) {
      var _this4 = this;

      var _overlay$options = overlay.options,
          blendMode = _overlay$options.blendMode,
          intensity = _overlay$options.intensity,
          identifier = _overlay$options.identifier;


      var overlayData = this._overlayManager.getOverlayByIdentifier(identifier);
      if (!overlayData) {
        _globals.Log.warn('Deserializer', 'Unknown overlay `' + identifier + '`. Skipping overlay.');
        return Promise.resolve();
      }

      var overlayPath = this._editor.getUI().getAssetPath(overlayData.image);
      return _imageLoader2.default.load(overlayPath).then(function (image) {
        _this4._editor.operations.getOrCreate('overlay', {
          alpha: intensity,
          identifier: identifier,
          blendMode: parseInt(blendModeByName[blendMode || overlayData.blendMode], 10),
          image: image
        });
      });
    }

    /**
     * Creates a brush face with the given options
     * @param  {PhotoEditorSDK.Operations.SpriteOperation.Sprites.BrushSprite.Path} path
     * @return {PhotoEditorSDK.Operations.SpriteOperation.Sprites.BrushSprite.Brush}
     */

  }, {
    key: '_createBrushForPath',
    value: function _createBrushForPath(path) {
      var brush = _get(v200Deserializer.prototype.__proto__ || Object.getPrototypeOf(v200Deserializer.prototype), '_createBrushForPath', this).call(this, path);
      if (typeof path.hardness !== 'undefined' && brush.hasOption('hardness')) {
        brush.setHardness(path.hardness);
      }
      return brush;
    }

    /**
     * Deserializes the given sticker for the given operation
     * @param  {PhotoEditorSDK.Operations.SpriteOperation} operation
     * @param  {Object} sprite
     * @return {PhotoEditorSDK.Operations.SpriteOperation.StickerSprite}
     * @private
     */

  }, {
    key: '_deserializeSticker',
    value: function _deserializeSticker(operation, sprite) {
      var _this5 = this;

      var SpriteOperation = _globals.SDK.Operations.SpriteOperation;
      var options = sprite.options;

      var sticker = this._stickerManager.getStickerByIdentifier(options.identifier);
      var url = _stickerManager2.default.getURLForSticker(sticker, 'base');
      if (!sticker) {
        _globals.Log.warn('Deserializer', 'Unknown sticker `' + options.identifier + '`. Skipping sprite.');
        return Promise.resolve();
      }
      var inputDimensions = operation.getInputDimensions(false);
      return new Promise(function (resolve, reject) {
        var image = new window.Image();
        image.addEventListener('load', function () {
          var adjustments = SpriteOperation.StickerSprite.prototype.availableOptions.adjustments.structure;
          var rotation = options.rotation,
              flipHorizontally = options.flipHorizontally,
              flipVertically = options.flipVertically;

          var stickerOptions = {
            identifier: options.identifier,
            image: image,
            position: _globals.Vector2.fromObject(options.position),
            dimensions: _globals.Vector2.fromObject(options.dimensions).multiply(inputDimensions.min()),
            rotation: rotation,
            flipHorizontally: flipHorizontally,
            flipVertically: flipVertically,
            adjustments: {}
          };

          if (typeof options.adjustments !== 'undefined') {
            ['brightness', 'contrast', 'saturation'].forEach(function (option) {
              if (typeof options.adjustments[option] !== 'undefined') {
                stickerOptions.adjustments[option] = options.adjustments[option] + adjustments[option].default;
              }
            });
          }

          if (typeof options.tintColor !== 'undefined' && typeof sticker.tintMode !== 'undefined') {
            stickerOptions.tintColor = _globals.Color.fromArray(options.tintColor);
            stickerOptions.tintMode = sticker.tintMode;
          }
          resolve(operation.createSticker(stickerOptions));
        });
        image.crossOrigin = _this5._editor.getCrossOrigin();
        image.src = _this5._editor.getUI().getAssetPath(url);
      });
    }

    /**
     * Deserializes the given filter operation
     * @param  {Object} operation
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeFilterOperation',
    value: function _deserializeFilterOperation(operation) {
      var _this6 = this;

      var options = operation.options;


      if (!this._filterManager.getFilterByIdentifier(options.identifier)) {
        _globals.Log.warn('Deserializer', 'Unknown filter `' + options.identifier + '`');
        return Promise.resolve();
      }

      return this._filterManager.instantiateFilterWithIdentifier(options.identifier).then(function (filter) {
        var filterOperation = _this6._editor.operations.getOrCreate('filter');
        if (!filterOperation) return;
        filterOperation.set({
          identifier: options.identifier,
          filter: filter,
          intensity: options.intensity
        });
        return filterOperation;
      });
    }

    /**
     * Deserializes the given focus operation
     * @param  {Object} operation
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeFocusOperation',
    value: function _deserializeFocusOperation(operation) {
      var _operation$options = operation.options,
          options = _operation$options.options,
          type = _operation$options.type;

      if (type !== 'radial') return _get(v200Deserializer.prototype.__proto__ || Object.getPrototypeOf(v200Deserializer.prototype), '_deserializeFocusOperation', this).call(this, operation);

      var start = options.start,
          end = options.end,
          gradientRadius = options.gradientRadius,
          blurRadius = options.blurRadius;

      var radius = _globals.Vector2.fromObject(end).subtract(_globals.Vector2.fromObject(start)).len();
      return Promise.resolve(this._editor.operations.getOrCreate('radial-focus', {
        position: _globals.Vector2.fromObject(start),
        radius: radius,
        gradientRadius: gradientRadius,
        blurRadius: blurRadius
      }));
    }

    /**
     * Deserializes the given text for the given operation
     * @param  {PhotoEditorSDK.Operations.SpriteOperation} operation
     * @param  {Object} text
     * @return {PhotoEditorSDK.Operations.SpriteOperation.TextSprite}
     * @private
     */

  }, {
    key: '_deserializeText',
    value: function _deserializeText(operation, text) {
      var options = text.options;
      var fontSize = options.fontSize,
          lineHeight = options.lineHeight,
          fontIdentifier = options.fontIdentifier,
          alignment = options.alignment,
          rotation = options.rotation,
          maxWidth = options.maxWidth,
          color = options.color,
          backgroundColor = options.backgroundColor;


      var fontLoader = new _fontLoader2.default(this._ui);
      var variation = this._fontManager.getVariationByIdentifier(fontIdentifier);
      if (!variation) {
        variation = this._fontManager.getDefaultFont();
      } else {
        fontLoader.setFonts([variation.getFont()]);
      }
      return fontLoader.load().then(function () {
        var inputDimensions = operation.getInputDimensions(false);

        // For whatever reason, max width is relative to shortest side, while font size isn't
        var fixedMaxWidth = maxWidth * inputDimensions.min() / inputDimensions.x;
        return operation.createText({
          fontSize: fontSize,
          lineHeight: lineHeight,
          fontFamily: variation.getFontFamily(),
          fontWeight: variation.getFontWeight(),
          fontIdentifier: variation.getIdentifier(),
          alignment: alignment,
          rotation: rotation,
          maxWidth: fixedMaxWidth,
          text: options.text,
          color: _globals.Color.fromArray(color),
          backgroundColor: _globals.Color.fromArray(backgroundColor),
          position: _globals.Vector2.fromObject(options.position)
        });
      });
    }
  }]);

  return v200Deserializer;
}(_deserializer2.default);

exports.default = v200Deserializer;


v200Deserializer.version = '2.0.0';

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (({"ENV":"\"development\""}).NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(63)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(66)();
}


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(17);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (({"ENV":"\"development\""}).NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var elementSeparator = '__';
var modifierSeparator = '--';
var blockPrefix = 'pesdk-react-';

/**
 * @class BEMObject
 * @ignore
 */

var BEMObject = function () {
  function BEMObject(parent, type, name) {
    _classCallCheck(this, BEMObject);

    this._parent = parent;
    this._type = type;
    this._name = name;
  }

  /**
   * Creates a BEMObject of type "element" that has this element as parent
   * @param  {String} name
   * @return {BEMObject}
   */


  _createClass(BEMObject, [{
    key: 'element',
    value: function element(name) {
      return new BEMObject(this, 'element', name);
    }

    /**
     * Creates a BEMObject of type "modifier" that has this element as parent
     * @param  {String} name
     * @return {BEMObject}
     */

  }, {
    key: 'modifier',
    value: function modifier(name) {
      return new BEMObject(this, 'modifier', name);
    }

    /**
     * Builds the class name for this BEMObject
     * @return {String}
     */

  }, {
    key: 'str',
    get: function get() {
      var response = this._parent ? this._parent.str : '';
      switch (this._type) {
        case 'block':
          response += '' + blockPrefix + this._name;
          break;
        case 'element':
          response += '' + elementSeparator + this._name;
          break;
        case 'modifier':
          response += '' + modifierSeparator + this._name;
          break;
      }
      return response;
    }
  }]);

  return BEMObject;
}();

exports.default = {
  /**
   * Creates a BEMObject of type "block" that has this element as parent
   * @param  {String} name
   * @return {BEMObject}
   * @ignore
   */
  block: function block(name) {
    return new BEMObject(null, 'block', name);
  }
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _react = __webpack_require__(16);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(35);

var _classnames2 = _interopRequireDefault(_classnames);

var _bem = __webpack_require__(36);

var _bem2 = _interopRequireDefault(_bem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function flatten(arr) {
  var result = [];
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] instanceof Array) {
      result = result.concat(flatten(arr[i]));
    } else {
      result.push(arr[i]);
    }
  }
  return result;
}

var BEM_TYPES = {
  b: 'block',
  e: 'element',
  m: 'modifier'
};
var ReactBEM = {
  /**
   * Parses the given ReactBEM specifier and returns an array of
   * BEM information (type, name, pass)
   * @param  {string} specifier
   * @return {Array.<Object>}
   * @private
   */
  _parseBemSpecifier: function _parseBemSpecifier(specifier) {
    if (!specifier) return [];

    var parts = specifier.split(' ');
    var data = parts.map(function (part) {
      var match = part.match(/^(\$)?([bem]):(.*)$/i);
      if (!match) {
        throw new Error('Invalid BEM specifier: ' + part);
      }

      var pass = typeof match[1] !== 'undefined';
      var type = BEM_TYPES[match[2]];
      var name = match[3];
      return { type: type, name: name, pass: pass };
    });
    return data;
  },


  /**
   * Returns the BEM info for the given node
   * @param  {Object} node
   * @return {Object}
   * @private
   */
  _getBemInfoForNode: function _getBemInfoForNode(node) {
    var isBemNode = node.type === 'bem';
    var specifier = isBemNode ? node.props.specifier : node.props.bem;

    if (isBemNode && !specifier) {
      throw new Error('<bem> elements should always have a `specifier` property');
    }

    var data = this._parseBemSpecifier(specifier);

    // <bem> nodes pass all bem information to the children
    if (isBemNode) {
      data.forEach(function (obj) {
        obj.pass = true;
      });
    }

    return { data: data, isBemNode: isBemNode };
  },


  /**
   * Used in React.Component's `render` method
   *
   * @param  {String} type
   * @param  {Object} props
   * @param  {Array.<Object>} [...children]
   * @return {Object}
   */
  createElement: function createElement(type, props) {
    for (var _len = arguments.length, children = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      children[_key - 2] = arguments[_key];
    }

    props = props || {};
    children = children.filter(function (child) {
      return child !== null && typeof child !== 'undefined';
    });
    return { type: type, props: props, children: children };
  },


  /**
   * Checks whether we can apply a bem class to the given node
   * @param  {?}  node
   * @return {Boolean}
   * @private
   */
  _isNodeBEMable: function _isNodeBEMable(node) {
    return node !== null && (typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object' && !_react2.default.isValidElement(node);
  },


  /**
   * Sets the BEM class for the given node. Iterates through its
   * children and sets their BEM class as well
   * @param  {Object} node
   * @return {Object}
   * @private
   */
  _applyBEMClasses: function _applyBEMClasses(node) {
    var _this = this;

    if (!this._isNodeBEMable(node)) return node;

    var classNames = node.props.className ? [node.props.className] : [];

    // Prepare BEM objects
    var bemInfo = this._getBemInfoForNode(node);
    var ownBemObject = node.props.__bemObject;
    var childrenBemObject = node.props.__bemObject;
    bemInfo.data.forEach(function (obj) {
      if (obj.type === 'block') {
        ownBemObject = _bem2.default.block(obj.name);
        if (obj.pass) {
          childrenBemObject = _bem2.default.block(obj.name);
        }
        classNames.push(ownBemObject.str);
      } else if (obj.type === 'element') {
        if (!ownBemObject) {
          throw new Error('Tried to create an element, but no parent block has been found.');
        }

        ownBemObject = ownBemObject.element(obj.name);
        if (obj.pass) {
          childrenBemObject = childrenBemObject.element(obj.name);
        }
        classNames.push(ownBemObject.str);
      } else if (obj.type === 'modifier') {
        if (!ownBemObject) {
          throw new Error('Tried to create a modifier, but no parent block has been found.');
        }

        if (obj.pass) {
          childrenBemObject = childrenBemObject.modifier(obj.name);
        }
        classNames.push(ownBemObject.modifier(obj.name).str);
      }
    });

    // Apply classname (if necessary)
    var className = (0, _classnames2.default)(classNames);
    if (className) {
      node.props.className = className;
    }

    node.children = flatten(node.children);

    // Pass `childrenBemObject` to child nodes
    node.children.forEach(function (child) {
      if (!_this._isNodeBEMable(child)) return;
      child.props.__bemObject = childrenBemObject;
    });

    // Apply BEM objects to children
    node.children = node.children.map(function (child) {
      return _this._applyBEMClasses(child);
    });

    node.children = flatten(node.children);

    // Remove unnecessary props
    delete node.props.__bemObject;
    delete node.props.bem;

    if (bemInfo.isBemNode) {
      if (node.children instanceof Array && node.children.length === 1) {
        node = node.children[0];
      } else {
        node = node.children;
      }
    }

    return node;
  },


  /**
   * Transforms the given ReactBEM element and its children into
   * actual ReactJS elements
   * @param  {Object} node
   * @return {React.Element}
   */
  _transformToReact: function _transformToReact(node) {
    var _this2 = this;

    if (!this._isNodeBEMable(node)) return node;

    node.children = node.children.map(function (child) {
      return _this2._transformToReact(child);
    });

    return _react2.default.createElement.apply(_react2.default, [node.type, node.props].concat(_toConsumableArray(node.children)));
  },


  /**
   * Transforms the given ReactBEM object and its children
   * @param  {Object} root
   * @return {React.Element}
   */
  transform: function transform(root) {
    root = this._applyBEMClasses(root);

    // Root node should be a single node, not an array. Returning the array
    // here will cause React to throw an error saying that this is a no-go
    /* istanbul ignore next */
    if (root instanceof Array) {
      return root;
    }

    root = this._transformToReact(root);
    return root;
  }
};

exports.default = ReactBEM;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = {
  DEFAULTS: {
    FILTERS: [
    // {
    //   identifier: 'imgly_filters_test',
    //   defaultName: 'Test',
    //   filters: [
    //     {
    //       identifier: 'imgly_lut_identity_5_5',
    //       defaultName: 'Identity 5x5',
    //       lutImage: 'filters/imgly_lut_identity_5_5_128.png'
    //     }
    //   ]
    // },
    {
      identifier: 'imgly_filters_analog',
      defaultName: 'Analog',
      filters: [{
        identifier: 'imgly_lut_cool',
        defaultName: 'Cool',
        lutImage: 'filters/imgly_lut_cool_5_5_128.png'
      }, {
        identifier: 'imgly_lut_blues',
        defaultName: 'Blues',
        lutImage: 'filters/imgly_lut_blues_5_5_128.png'
      }, {
        identifier: 'imgly_lut_blueshadows',
        defaultName: 'Blue Shadows',
        lutImage: 'filters/imgly_lut_blueshadows_5_5_128.png'
      }, {
        identifier: 'imgly_lut_k6',
        defaultName: 'K6',
        lutImage: 'filters/imgly_lut_k6_5_5_128.png'
      }, {
        identifier: 'imgly_lut_kdynamic',
        defaultName: 'KDynamic',
        lutImage: 'filters/imgly_lut_kdynamic_5_5_128.png'
      }, {
        identifier: 'imgly_lut_lucid',
        defaultName: 'Lucid',
        lutImage: 'filters/imgly_lut_lucid_5_5_128.png'
      }, {
        identifier: 'imgly_lut_pale',
        defaultName: 'Pale',
        lutImage: 'filters/imgly_lut_pale_5_5_128.png'
      }]
    }, {
      identifier: 'imgly_filters_bw',
      defaultName: 'Black & White',
      filters: [{
        identifier: 'imgly_lut_sin',
        defaultName: 'Sin',
        lutImage: 'filters/imgly_lut_sin_8_8_512.png',
        resolution: 512,
        horizontalTileCount: 8,
        verticalTileCount: 8
      }, {
        identifier: 'imgly_lut_ad1920',
        defaultName: '1920 A.D.',
        lutImage: 'filters/imgly_lut_ad1920_5_5_128.png'
      }, {
        identifier: 'imgly_lut_bw',
        defaultName: 'B & W',
        lutImage: 'filters/imgly_lut_bw_5_5_128.png'
      }, {
        identifier: 'imgly_lut_litho',
        defaultName: 'Litho',
        lutImage: 'filters/imgly_lut_litho_5_5_128.png'
      }, {
        identifier: 'imgly_lut_plate',
        defaultName: 'Plate',
        lutImage: 'filters/imgly_lut_plate_5_5_128.png'
      }, {
        identifier: 'imgly_lut_x400',
        defaultName: 'X400',
        lutImage: 'filters/imgly_lut_x400_5_5_128.png'
      }]
    }, {
      identifier: 'imgly_filters_retro',
      defaultName: 'Retro',
      filters: [{
        identifier: 'imgly_lut_celsius',
        defaultName: 'Celsius',
        lutImage: 'filters/imgly_lut_celsius_8_8_512.png',
        resolution: 512,
        horizontalTileCount: 8,
        verticalTileCount: 8
      }, {
        identifier: 'imgly_lut_k2',
        defaultName: 'K2',
        lutImage: 'filters/imgly_lut_k2_8_8_512.png',
        resolution: 512,
        horizontalTileCount: 8,
        verticalTileCount: 8
      }, {
        identifier: 'imgly_lut_sepiahigh',
        defaultName: 'Sepia High',
        lutImage: 'filters/imgly_lut_sepiahigh_5_5_128.png'
      }, {
        identifier: 'imgly_lut_ancient',
        defaultName: 'Ancient',
        lutImage: 'filters/imgly_lut_ancient_5_5_128.png'
      }, {
        identifier: 'imgly_lut_classic',
        defaultName: 'Classic',
        lutImage: 'filters/imgly_lut_classic_5_5_128.png'
      }, {
        identifier: 'imgly_lut_eighties',
        defaultName: 'Eighties',
        lutImage: 'filters/imgly_lut_eighties_5_5_128.png'
      }, {
        identifier: 'imgly_lut_elder',
        defaultName: 'Elder',
        lutImage: 'filters/imgly_lut_elder_5_5_128.png'
      }, {
        identifier: 'imgly_lut_glam',
        defaultName: 'Glam',
        lutImage: 'filters/imgly_lut_glam_5_5_128.png'
      }, {
        identifier: 'imgly_lut_gobblin',
        defaultName: 'Gobblin',
        lutImage: 'filters/imgly_lut_gobblin_5_5_128.png'
      }, {
        identifier: 'imgly_lut_orchid',
        defaultName: 'Orchid',
        lutImage: 'filters/imgly_lut_orchid_5_5_128.png'
      }, {
        identifier: 'imgly_lut_seventies',
        defaultName: 'Seventies',
        lutImage: 'filters/imgly_lut_seventies_5_5_128.png'
      }]
    }, {
      identifier: 'imgly_filters_special',
      defaultName: 'Special',
      filters: [{
        identifier: 'imgly_lut_fixie',
        defaultName: 'Fixie',
        lutImage: 'filters/imgly_lut_fixie_8_8_512.png',
        resolution: 512,
        horizontalTileCount: 8,
        verticalTileCount: 8
      }, {
        identifier: 'imgly_lut_colorful',
        defaultName: 'Colorful',
        lutImage: 'filters/imgly_lut_colorful_5_5_128.png'
      }, {
        identifier: 'imgly_lut_cottoncandy',
        defaultName: 'Cotton Candy',
        lutImage: 'filters/imgly_lut_cottoncandy_5_5_128.png'
      }, {
        identifier: 'imgly_lut_food',
        defaultName: 'Food',
        lutImage: 'filters/imgly_lut_food_5_5_128.png'
      }, {
        identifier: 'imgly_lut_highcontrast',
        defaultName: 'High Contrast',
        lutImage: 'filters/imgly_lut_highcontrast_5_5_128.png'
      }, {
        identifier: 'imgly_lut_k1',
        defaultName: 'K1',
        lutImage: 'filters/imgly_lut_k1_5_5_128.png'
      }, {
        identifier: 'imgly_lut_lomo100',
        defaultName: 'Lomo 100',
        lutImage: 'filters/imgly_lut_lomo100_5_5_128.png'
      }, {
        identifier: 'imgly_lut_neat',
        defaultName: 'Neat',
        lutImage: 'filters/imgly_lut_neat_5_5_128.png'
      }, {
        identifier: 'imgly_lut_nogreen',
        defaultName: 'No Green',
        lutImage: 'filters/imgly_lut_nogreen_5_5_128.png'
      }, {
        identifier: 'imgly_lut_pola669',
        defaultName: 'Pola 669',
        lutImage: 'filters/imgly_lut_pola669_5_5_128.png'
      }, {
        identifier: 'imgly_lut_polasx',
        defaultName: 'Pola SX',
        lutImage: 'filters/imgly_lut_polasx_5_5_128.png'
      }, {
        identifier: 'imgly_lut_pro400',
        defaultName: 'Pro 400',
        lutImage: 'filters/imgly_lut_pro400_5_5_128.png'
      }, {
        identifier: 'imgly_lut_twilight',
        defaultName: 'Twilight',
        lutImage: 'filters/imgly_lut_twilight_5_5_128.png'
      }, {
        identifier: 'imgly_lut_settled',
        defaultName: 'Settled',
        lutImage: 'filters/imgly_lut_settled_5_5_128.png'
      }, {
        identifier: 'imgly_lut_steel',
        defaultName: 'Steel',
        lutImage: 'filters/imgly_lut_steel_5_5_128.png'
      }]
    }, {
      identifier: 'imgly_filters_summer',
      defaultName: 'Summer',
      filters: [{
        identifier: 'imgly_lut_texas',
        defaultName: 'Texas',
        lutImage: 'filters/imgly_lut_texas_8_8_512.png',
        resolution: 512,
        horizontalTileCount: 8,
        verticalTileCount: 8
      }, {
        identifier: 'imgly_lut_mellow',
        defaultName: 'Mellow',
        lutImage: 'filters/imgly_lut_mellow_8_8_512.png',
        resolution: 512,
        horizontalTileCount: 8,
        verticalTileCount: 8
      }, {
        identifier: 'imgly_lut_chest',
        defaultName: 'Chest',
        lutImage: 'filters/imgly_lut_chest_8_8_512.png',
        resolution: 512,
        horizontalTileCount: 8,
        verticalTileCount: 8
      }, {
        identifier: 'imgly_lut_creamy',
        defaultName: 'Creamy',
        lutImage: 'filters/imgly_lut_creamy_5_5_128.png'
      }, {
        identifier: 'imgly_lut_evening',
        defaultName: 'Evening',
        lutImage: 'filters/imgly_lut_evening_5_5_128.png'
      }, {
        identifier: 'imgly_lut_fall',
        defaultName: 'Fall',
        lutImage: 'filters/imgly_lut_fall_5_5_128.png'
      }, {
        identifier: 'imgly_lut_front',
        defaultName: 'Front',
        lutImage: 'filters/imgly_lut_front_8_8_512.png',
        resolution: 512,
        horizontalTileCount: 8,
        verticalTileCount: 8
      }, {
        identifier: 'imgly_lut_highcarb',
        defaultName: 'High Carb',
        lutImage: 'filters/imgly_lut_highcarb_5_5_128.png'
      }, {
        identifier: 'imgly_lut_keen',
        defaultName: 'Keen',
        lutImage: 'filters/imgly_lut_keen_5_5_128.png'
      }, {
        identifier: 'imgly_lut_pitched',
        defaultName: 'Pitched',
        lutImage: 'filters/imgly_lut_pitched_5_5_128.png'
      }, {
        identifier: 'imgly_lut_soft',
        defaultName: 'Soft',
        lutImage: 'filters/imgly_lut_soft_5_5_128.png'
      }, {
        identifier: 'imgly_lut_summer',
        defaultName: 'Summer',
        lutImage: 'filters/imgly_lut_summer_5_5_128.png'
      }, {
        identifier: 'imgly_lut_sunset',
        defaultName: 'Sunset',
        lutImage: 'filters/imgly_lut_sunset_5_5_128.png'
      }, {
        identifier: 'imgly_lut_tender',
        defaultName: 'Tender',
        lutImage: 'filters/imgly_lut_tender_5_5_128.png'
      }]
    }, {
      identifier: 'imgly_filters_winter',
      defaultName: 'Winter',
      filters: [{
        identifier: 'imgly_lut_fridge',
        defaultName: 'Fridge',
        lutImage: 'filters/imgly_lut_fridge_8_8_512.png',
        resolution: 512,
        horizontalTileCount: 8,
        verticalTileCount: 8
      }, {
        identifier: 'imgly_lut_bleached',
        defaultName: 'Bleached',
        lutImage: 'filters/imgly_lut_bleached_5_5_128.png'
      }, {
        identifier: 'imgly_lut_bleachedblue',
        defaultName: 'Bleached Blue',
        lutImage: 'filters/imgly_lut_bleachedblue_5_5_128.png'
      }, {
        identifier: 'imgly_lut_breeze',
        defaultName: 'Breeze',
        lutImage: 'filters/imgly_lut_breeze_5_5_128.png'
      }, {
        identifier: 'imgly_lut_lenin',
        defaultName: 'Lenin',
        lutImage: 'filters/imgly_lut_lenin_5_5_128.png'
      }, {
        identifier: 'imgly_lut_quozi',
        defaultName: 'Quozi',
        lutImage: 'filters/imgly_lut_quozi_5_5_128.png'
      }, {
        identifier: 'imgly_lut_winter',
        defaultName: 'Winter',
        lutImage: 'filters/imgly_lut_winter_5_5_128.png'
      }]
    }],
    OVERLAYS: [{
      identifier: 'imgly_overlay_golden',
      defaultName: 'Golden',
      image: 'overlays/imgly_overlay_golden.jpg',
      thumbnail: 'overlays/imgly_overlay_golden_thumb.jpg',
      blendMode: 'lighten'
    }, {
      identifier: 'imgly_overlay_bokeh',
      defaultName: 'Bokeh',
      image: 'overlays/imgly_overlay_bokeh.jpg',
      thumbnail: 'overlays/imgly_overlay_bokeh_thumb.jpg',
      blendMode: 'lighten'
    }, {
      identifier: 'imgly_overlay_hearts',
      defaultName: 'Hearts',
      image: 'overlays/imgly_overlay_hearts.jpg',
      thumbnail: 'overlays/imgly_overlay_hearts_thumb.jpg',
      blendMode: 'screen'
    }, {
      identifier: 'imgly_overlay_lightleak1',
      defaultName: 'Light Leak',
      image: 'overlays/imgly_overlay_lightleak1.jpg',
      thumbnail: 'overlays/imgly_overlay_lightleak1_thumb.jpg',
      blendMode: 'screen'
    }, {
      identifier: 'imgly_overlay_lightleak2',
      defaultName: 'Light Leak 2',
      image: 'overlays/imgly_overlay_lightleak2.jpg',
      thumbnail: 'overlays/imgly_overlay_lightleak2_thumb.jpg',
      blendMode: 'lighten'
    }, {
      identifier: 'imgly_overlay_rain',
      defaultName: 'Rain',
      image: 'overlays/imgly_overlay_rain.jpg',
      thumbnail: 'overlays/imgly_overlay_rain_thumb.jpg',
      blendMode: 'overlay'
    }, {
      identifier: 'imgly_overlay_wood',
      defaultName: 'Wood',
      image: 'overlays/imgly_overlay_wood.jpg',
      thumbnail: 'overlays/imgly_overlay_wood_thumb.jpg',
      blendMode: 'multiply'
    }, {
      identifier: 'imgly_overlay_mosaic',
      defaultName: 'Mosaic',
      image: 'overlays/imgly_overlay_mosaic.jpg',
      thumbnail: 'overlays/imgly_overlay_mosaic_thumb.jpg',
      blendMode: 'multiply'
    }, {
      identifier: 'imgly_overlay_chop',
      defaultName: 'Chop',
      image: 'overlays/imgly_overlay_chop.jpg',
      thumbnail: 'overlays/imgly_overlay_chop_thumb.jpg',
      blendMode: 'multiply'
    }, {
      identifier: 'imgly_overlay_vintage',
      defaultName: 'Vintage',
      image: 'overlays/imgly_overlay_vintage.jpg',
      thumbnail: 'overlays/imgly_overlay_vintage_thumb.jpg',
      blendMode: 'darken'
    }, {
      identifier: 'imgly_overlay_metal',
      defaultName: 'Metal',
      image: 'overlays/imgly_overlay_metal.jpg',
      thumbnail: 'overlays/imgly_overlay_metal_thumb.jpg',
      blendMode: 'overlay'
    }, {
      identifier: 'imgly_overlay_paper',
      defaultName: 'Paper',
      image: 'overlays/imgly_overlay_paper.jpg',
      thumbnail: 'overlays/imgly_overlay_paper_thumb.jpg',
      blendMode: 'multiply'
    }, {
      identifier: 'imgly_overlay_painting',
      defaultName: 'Painting',
      image: 'overlays/imgly_overlay_painting.jpg',
      thumbnail: 'overlays/imgly_overlay_painting_thumb.jpg',
      blendMode: 'overlay'
    }, {
      identifier: 'imgly_overlay_grain',
      defaultName: 'Grain',
      image: 'overlays/imgly_overlay_grain.jpg',
      thumbnail: 'overlays/imgly_overlay_grain_thumb.jpg',
      blendMode: 'overlay'
    }, {
      identifier: 'imgly_overlay_clouds',
      defaultName: 'Clouds',
      image: 'overlays/imgly_overlay_clouds.jpg',
      thumbnail: 'overlays/imgly_overlay_clouds_thumb.jpg',
      blendMode: 'softLight'
    }, {
      identifier: 'imgly_overlay_wall1',
      defaultName: 'Wall',
      image: 'overlays/imgly_overlay_wall1.jpg',
      thumbnail: 'overlays/imgly_overlay_wall1_thumb.jpg',
      blendMode: 'lighten'
    }, {
      identifier: 'imgly_overlay_wall2',
      defaultName: 'Wall 2',
      image: 'overlays/imgly_overlay_wall2.jpg',
      thumbnail: 'overlays/imgly_overlay_wall2_thumb.jpg',
      blendMode: 'overlay'
    }],
    FRAME_CATEGORIES: [{
      identifier: 'imgly_frame_generic',
      defaultName: 'Generic',
      metaData: {
        backgroundImage: 'frames/generic.png' // Not used yet
      },
      frames: [{
        identifier: 'imgly_frame_dia',
        defaultName: 'Dia',
        layoutMode: 'horizontal-inside',
        thumbnail: 'frames/imgly_frame_dia/imgly_frame_dia_thumb.png',
        imageGroups: {
          top: {
            mid: {
              image: 'frames/imgly_frame_dia/imgly_frame_dia_top.png',
              mode: 'repeat'
            }
          },
          left: {
            start: 'frames/imgly_frame_dia/imgly_frame_dia_top_corner_left.png',
            mid: 'frames/imgly_frame_dia/imgly_frame_dia_left.png',
            end: 'frames/imgly_frame_dia/imgly_frame_dia_bottom_corner_left.png'
          },
          right: {
            start: 'frames/imgly_frame_dia/imgly_frame_dia_top_corner_right.png',
            mid: 'frames/imgly_frame_dia/imgly_frame_dia_right.png',
            end: 'frames/imgly_frame_dia/imgly_frame_dia_bottom_corner_right.png'
          },
          bottom: {
            mid: {
              image: 'frames/imgly_frame_dia/imgly_frame_dia_bottom.png',
              mode: 'repeat'
            }
          }
        }
      }, {
        identifier: 'imgly_frame_art_decor',
        defaultName: 'Art Decor',
        tintable: true,
        layoutMode: 'horizontal-inside',
        thumbnail: 'frames/imgly_frame_art_decor/imgly_frame_art_decor_thumb.png',
        imageGroups: {
          top: {
            start: 'frames/imgly_frame_art_decor/imgly_frame_art_decor_top_corner_left.png',
            mid: {
              image: 'frames/imgly_frame_art_decor/imgly_frame_art_decor_top.png',
              mode: 'stretch'
            },
            end: 'frames/imgly_frame_art_decor/imgly_frame_art_decor_top_corner_right.png'
          },
          left: {
            mid: {
              image: 'frames/imgly_frame_art_decor/imgly_frame_art_decor_left.png',
              mode: 'stretch'
            }
          },
          right: {
            mid: {
              image: 'frames/imgly_frame_art_decor/imgly_frame_art_decor_right.png',
              mode: 'stretch'
            }
          },
          bottom: {
            start: 'frames/imgly_frame_art_decor/imgly_frame_art_decor_bottom_corner_left.png',
            mid: {
              image: 'frames/imgly_frame_art_decor/imgly_frame_art_decor_bottom.png',
              mode: 'stretch'
            },
            end: 'frames/imgly_frame_art_decor/imgly_frame_art_decor_bottom_corner_right.png'
          }
        }
      }, {
        identifier: 'imgly_frame_black_passepartout',
        defaultName: 'Black Passepartout',
        layoutMode: 'horizontal-inside',
        thumbnail: 'frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_thumb.png',
        imageGroups: {
          top: {
            start: 'frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_top_corner_left.png',
            mid: {
              image: 'frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_top.png',
              mode: 'stretch'
            },
            end: 'frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_top_corner_right.png'
          },
          left: {
            mid: {
              image: 'frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_left.png',
              mode: 'stretch'
            }
          },
          right: {
            mid: {
              image: 'frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_right.png',
              mode: 'stretch'
            }
          },
          bottom: {
            start: 'frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_bottom_corner_left.png',
            mid: {
              image: 'frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_bottom.png',
              mode: 'stretch'
            },
            end: 'frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_bottom_corner_right.png'
          }
        }
      }, {
        identifier: 'imgly_frame_lowpoly_shadow',
        defaultName: 'Low Poly',
        layoutMode: 'horizontal-inside',
        thumbnail: 'frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_thumb.png',
        imageGroups: {
          top: {
            start: 'frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_top_corner_left.png',
            mid: {
              image: 'frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_top.png',
              mode: 'stretch'
            },
            end: 'frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_top_corner_right.png'
          },
          left: {
            mid: {
              image: 'frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_left.png',
              mode: 'stretch'
            }
          },
          right: {
            mid: {
              image: 'frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_right.png',
              mode: 'stretch'
            }
          },
          bottom: {
            start: 'frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_bottom_corner_left.png',
            mid: {
              image: 'frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_bottom.png',
              mode: 'stretch'
            },
            end: 'frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_bottom_corner_right.png'
          }
        }
      }, {
        identifier: 'imgly_frame_wood_passepartout',
        defaultName: 'Wood Passepartout',
        layoutMode: 'horizontal-inside',
        thumbnail: 'frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_thumb.png',
        imageGroups: {
          top: {
            start: 'frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_top_corner_left.png',
            mid: {
              image: 'frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_top.png',
              mode: 'stretch'
            },
            end: 'frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_top_corner_right.png'
          },
          left: {
            mid: {
              image: 'frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_left.png',
              mode: 'stretch'
            }
          },
          right: {
            mid: {
              image: 'frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_right.png',
              mode: 'stretch'
            }
          },
          bottom: {
            start: 'frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_bottom_corner_left.png',
            mid: {
              image: 'frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_bottom.png',
              mode: 'stretch'
            },
            end: 'frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_bottom_corner_right.png'
          }
        }
      }]
    }],
    STICKER_CATEGORIES: [{
      identifier: 'imgly_sticker_emoticons',
      defaultName: 'Emoticons',
      'metaData': {
        'backgroundImage': 'stickers/emoticons/background.png'
      },
      'stickers': [{
        identifier: 'imgly_sticker_emoticons_alien',
        defaultName: 'Alien',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_alien.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_alien.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_alien.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_alien.png'],
            width: 1000,
            height: 935
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_angel',
        defaultName: 'Angel',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_angel.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_angel.png'],
            width: 62,
            height: 64
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_angel.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_angel.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_angry',
        defaultName: 'Angry',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_angry.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_angry.png'],
            width: 62,
            height: 62
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_angry.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_angry.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_anxious',
        defaultName: 'Anxious',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_anxious.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_anxious.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_anxious.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_anxious.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_asleep',
        defaultName: 'Asleep',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_asleep.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_asleep.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_asleep.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_asleep.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_attention',
        defaultName: 'Attention',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_attention.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_attention.png'],
            width: 62,
            height: 60
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_attention.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_attention.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_baby_chicken',
        defaultName: 'Baby Chicken',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_baby_chicken.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_baby_chicken.png'],
            width: 61,
            height: 42
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_baby_chicken.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_baby_chicken.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_batman',
        defaultName: 'Batman',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_batman.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_batman.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_batman.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_batman.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_beer',
        defaultName: 'Beer',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_beer.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_beer.png'],
            width: 62,
            height: 59
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_beer.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_beer.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_blush',
        defaultName: 'Blush',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_blush.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_blush.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_blush.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_blush.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_boxer',
        defaultName: 'Boxer',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_boxer.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_boxer.png'],
            width: 62,
            height: 62
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_boxer.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_boxer.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_business',
        defaultName: 'Business',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_business.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_business.png'],
            width: 60,
            height: 63
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_business.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_business.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_chicken',
        defaultName: 'Chicken',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_chicken.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_chicken.png'],
            width: 63,
            height: 55
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_chicken.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_chicken.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_cool',
        defaultName: 'Cool',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_cool.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_cool.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_cool.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_cool.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_cry',
        defaultName: 'Cry',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_cry.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_cry.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_cry.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_cry.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_deceased',
        defaultName: 'Deceased',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_deceased.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_deceased.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_deceased.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_deceased.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_devil',
        defaultName: 'Devil',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_devil.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_devil.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_devil.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_devil.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_duckface',
        defaultName: 'Duckface',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_duckface.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_duckface.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_duckface.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_duckface.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_furious',
        defaultName: 'Furious',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_furious.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_furious.png'],
            width: 62,
            height: 61
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_furious.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_furious.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_grin',
        defaultName: 'Grin',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_grin.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_grin.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_grin.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_grin.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_guitar',
        defaultName: 'Guitar',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_guitar.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_guitar.png'],
            width: 64,
            height: 60
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_guitar.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_guitar.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_harry_potter',
        defaultName: 'Harry Potter',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_harry_potter.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_harry_potter.png'],
            width: 64,
            height: 62
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_harry_potter.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_harry_potter.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_hippie',
        defaultName: 'Hippie',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_hippie.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_hippie.png'],
            width: 62,
            height: 62
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_hippie.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_hippie.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_hitman',
        defaultName: 'Hitman',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_hitman.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_hitman.png'],
            width: 64,
            height: 60
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_hitman.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_hitman.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_humourous',
        defaultName: 'Humourous',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_humourous.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_humourous.png'],
            width: 64,
            height: 64
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_humourous.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_humourous.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_idea',
        defaultName: 'Idea',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_idea.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_idea.png'],
            width: 64,
            height: 62
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_idea.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_idea.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_impatient',
        defaultName: 'Impatient',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_impatient.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_impatient.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_impatient.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_impatient.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_kiss',
        defaultName: 'Kiss',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_kiss.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_kiss.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_kiss.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_kiss.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_kisses',
        defaultName: 'Kisses',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_kisses.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_kisses.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_kisses.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_kisses.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_laugh',
        defaultName: 'Laugh',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_laugh.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_laugh.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_laugh.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_laugh.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_loud_cry',
        defaultName: 'Loud Cry',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_loud_cry.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_loud_cry.png'],
            width: 64,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_loud_cry.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_loud_cry.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_loving',
        defaultName: 'Loving',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_loving.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_loving.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_loving.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_loving.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_masked',
        defaultName: 'Masked',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_masked.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_masked.png'],
            width: 62,
            height: 62
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_masked.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_masked.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_music',
        defaultName: 'Music',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_music.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_music.png'],
            width: 62,
            height: 54
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_music.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_music.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_nerd',
        defaultName: 'Nerd',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_nerd.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_nerd.png']
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_nerd.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_nerd.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_ninja',
        defaultName: 'Ninja',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_ninja.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_ninja.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_ninja.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_ninja.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_not_speaking_to_you',
        defaultName: 'Not Speaking To You',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_not_speaking_to_you.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_not_speaking_to_you.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_not_speaking_to_you.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_not_speaking_to_you.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_pig',
        defaultName: 'Pig',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_pig.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_pig.png'],
            width: 63,
            height: 41
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_pig.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_pig.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_pumpkin',
        defaultName: 'Pumpkin',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_pumpkin.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_pumpkin.png'],
            width: 62,
            height: 60
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_pumpkin.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_pumpkin.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_question',
        defaultName: 'Question',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_question.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_question.png'],
            width: 62,
            height: 62
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_question.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_question.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_rabbit',
        defaultName: 'Rabbit',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_rabbit.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_rabbit.png'],
            width: 65,
            height: 47
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_rabbit.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_rabbit.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_sad',
        defaultName: 'Sad',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_sad.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_sad.png']
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_sad.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_sad.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_sick',
        defaultName: 'Sick',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_sick.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_sick.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_sick.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_sick.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_skateboard',
        defaultName: 'Skateboard',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_skateboard.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_skateboard.png'],
            width: 62,
            height: 64
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_skateboard.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_skateboard.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_skull',
        defaultName: 'Skull',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_skull.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_skull.png'],
            width: 62,
            height: 62
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_skull.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_skull.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_sleepy',
        defaultName: 'Sleepy',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_sleepy.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_sleepy.png'],
            width: 62,
            height: 60
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_sleepy.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_sleepy.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_smile',
        defaultName: 'Smile',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_smile.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_smile.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_smile.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_smile.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_smoking',
        defaultName: 'Smoking',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_smoking.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_smoking.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_smoking.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_smoking.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_sobbing',
        defaultName: 'Sobbing',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_sobbing.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_sobbing.png'],
            width: 62,
            height: 59
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_sobbing.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_sobbing.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_star',
        defaultName: 'Star',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_star.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_star.png'],
            width: 64,
            height: 64
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_star.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_star.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_steaming_furious',
        defaultName: 'Steaming Furious',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_steaming_furious.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_steaming_furious.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_steaming_furious.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_steaming_furious.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_sunbathing',
        defaultName: 'Sunbathing',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_sunbathing.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_sunbathing.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_sunbathing.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_sunbathing.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_tired',
        defaultName: 'Tired',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_tired.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_tired.png'],
            width: 62,
            height: 60
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_tired.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_tired.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_tongue_out_wink',
        defaultName: 'Tongue Out Wink',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_tongue_out_wink.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_tongue_out_wink.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_tongue_out_wink.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_tongue_out_wink.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_wave',
        defaultName: 'Wave',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_wave.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_wave.png'],
            width: 62,
            height: 60
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_wave.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_wave.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_wide_grin',
        defaultName: 'Wide Grin',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_wide_grin.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_wide_grin.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_wide_grin.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_wide_grin.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_wink',
        defaultName: 'Wink',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_wink.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_wink.png'],
            width: 62,
            height: 58
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_wink.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_wink.png']
          }
        }
      }, {
        identifier: 'imgly_sticker_emoticons_wrestler',
        defaultName: 'Wrestler',
        images: {
          mediaThumb: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_wrestler.svg', 'stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_wrestler.png'],
            width: 62,
            height: 60
          },
          mediaBase: {
            uris: ['stickers/emoticons/stickers/imgly_sticker_emoticons_wrestler.svg', 'stickers/emoticons/stickers/base/imgly_sticker_emoticons_wrestler.png']
          }
        }
      }]
    }, {
      identifier: 'imgly_sticker_shapes',
      defaultName: 'Shapes',
      'metaData': {
        'backgroundImage': 'stickers/shapes/background.png'
      },
      'stickers': [{
        identifier: 'imgly_sticker_shapes_arrow_02',
        defaultName: 'Arrow 1',
        tintMode: 'solid',
        images: {
          mediaThumb: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_arrow_02.svg', 'stickers/shapes/stickers/thumbs/imgly_sticker_shapes_arrow_02.png'],
            width: 2000,
            height: 1236
          },
          mediaBase: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_arrow_02.svg', 'stickers/shapes/stickers/base/imgly_sticker_shapes_arrow_02.png'],
            width: 2000,
            height: 1236
          }
        }
      }, {
        identifier: 'imgly_sticker_shapes_arrow_03',
        defaultName: 'Arrow 2',
        tintMode: 'solid',
        images: {
          mediaThumb: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_arrow_03.svg', 'stickers/shapes/stickers/thumbs/imgly_sticker_shapes_arrow_03.png'],
            width: 2000,
            height: 2000
          },
          mediaBase: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_arrow_03.svg', 'stickers/shapes/stickers/base/imgly_sticker_shapes_arrow_03.png'],
            width: 2000,
            height: 2000
          }
        }
      }, {
        identifier: 'imgly_sticker_shapes_badge_01',
        defaultName: 'Badge 1',
        tintMode: 'solid',
        images: {
          mediaThumb: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_01.svg', 'stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_01.png'],
            width: 2000,
            height: 2000
          },
          mediaBase: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_01.svg', 'stickers/shapes/stickers/base/imgly_sticker_shapes_badge_01.png'],
            width: 2000,
            height: 2000
          }
        }
      }, {
        identifier: 'imgly_sticker_shapes_badge_04',
        defaultName: 'Badge 2',
        tintMode: 'solid',
        images: {
          mediaThumb: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_04.svg', 'stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_04.png'],
            width: 2000,
            height: 1589
          },
          mediaBase: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_04.svg', 'stickers/shapes/stickers/base/imgly_sticker_shapes_badge_04.png'],
            width: 2000,
            height: 1589
          }
        }
      }, {
        identifier: 'imgly_sticker_shapes_badge_06',
        defaultName: 'Badge 3',
        tintMode: 'solid',
        images: {
          mediaThumb: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_06.svg', 'stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_06.png'],
            width: 2000,
            height: 1733
          },
          mediaBase: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_06.svg', 'stickers/shapes/stickers/base/imgly_sticker_shapes_badge_06.png'],
            width: 2000,
            height: 1733
          }
        }
      }, {
        identifier: 'imgly_sticker_shapes_badge_08',
        defaultName: 'Badge 4',
        tintMode: 'solid',
        images: {
          mediaThumb: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_08.svg', 'stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_08.png'],
            width: 2000,
            height: 2000
          },
          mediaBase: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_08.svg', 'stickers/shapes/stickers/base/imgly_sticker_shapes_badge_08.png'],
            width: 2000,
            height: 2000
          }
        }
      }, {
        identifier: 'imgly_sticker_shapes_badge_11',
        defaultName: 'Badge 5',
        tintMode: 'solid',
        images: {
          mediaThumb: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_11.svg', 'stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_11.png'],
            width: 2000,
            height: 2000
          },
          mediaBase: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_11.svg', 'stickers/shapes/stickers/base/imgly_sticker_shapes_badge_11.png'],
            width: 2000,
            height: 2000
          }
        }
      }, {
        identifier: 'imgly_sticker_shapes_badge_12',
        defaultName: 'Badge 6',
        tintMode: 'solid',
        images: {
          mediaThumb: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_12.svg', 'stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_12.png'],
            width: 2001,
            height: 1903
          },
          mediaBase: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_12.svg', 'stickers/shapes/stickers/base/imgly_sticker_shapes_badge_12.png'],
            width: 2001,
            height: 1903
          }
        }
      }, {
        identifier: 'imgly_sticker_shapes_badge_13',
        defaultName: 'Badge 7',
        tintMode: 'solid',
        images: {
          mediaThumb: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_13.svg', 'stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_13.png'],
            width: 2000,
            height: 1718
          },
          mediaBase: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_13.svg', 'stickers/shapes/stickers/base/imgly_sticker_shapes_badge_13.png'],
            width: 2000,
            height: 1718
          }
        }
      }, {
        identifier: 'imgly_sticker_shapes_badge_15',
        defaultName: 'Badge 8',
        tintMode: 'solid',
        images: {
          mediaThumb: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_15.svg', 'stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_15.png'],
            width: 1618,
            height: 2000
          },
          mediaBase: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_15.svg', 'stickers/shapes/stickers/base/imgly_sticker_shapes_badge_15.png'],
            width: 1618,
            height: 2000
          }
        }
      }, {
        identifier: 'imgly_sticker_shapes_badge_18',
        defaultName: 'Badge 9',
        tintMode: 'solid',
        images: {
          mediaThumb: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_18.svg', 'stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_18.png'],
            width: 1198,
            height: 2000
          },
          mediaBase: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_18.svg', 'stickers/shapes/stickers/base/imgly_sticker_shapes_badge_18.png'],
            width: 1198,
            height: 2000
          }
        }
      }, {
        identifier: 'imgly_sticker_shapes_badge_19',
        defaultName: 'Badge 10',
        tintMode: 'solid',
        images: {
          mediaThumb: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_19.svg', 'stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_19.png'],
            width: 2127,
            height: 481
          },
          mediaBase: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_19.svg', 'stickers/shapes/stickers/base/imgly_sticker_shapes_badge_19.png'],
            width: 2127,
            height: 481
          }
        }
      }, {
        identifier: 'imgly_sticker_shapes_badge_20',
        defaultName: 'Badge 11',
        tintMode: 'solid',
        images: {
          mediaThumb: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_20.svg', 'stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_20.png'],
            width: 2000,
            height: 1404
          },
          mediaBase: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_20.svg', 'stickers/shapes/stickers/base/imgly_sticker_shapes_badge_20.png'],
            width: 2000,
            height: 1404
          }
        }
      }, {
        identifier: 'imgly_sticker_shapes_badge_28',
        defaultName: 'Badge 12',
        tintMode: 'solid',
        images: {
          mediaThumb: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_28.svg', 'stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_28.png'],
            width: 2000,
            height: 2000
          },
          mediaBase: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_28.svg', 'stickers/shapes/stickers/base/imgly_sticker_shapes_badge_28.png'],
            width: 2000,
            height: 2000
          }
        }
      }, {
        identifier: 'imgly_sticker_shapes_badge_32',
        defaultName: 'Badge 13',
        tintMode: 'solid',
        images: {
          mediaThumb: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_32.svg', 'stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_32.png'],
            width: 1960,
            height: 2000
          },
          mediaBase: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_32.svg', 'stickers/shapes/stickers/base/imgly_sticker_shapes_badge_32.png'],
            width: 1960,
            height: 2000
          }
        }
      }, {
        identifier: 'imgly_sticker_shapes_badge_35',
        defaultName: 'Badge 14',
        tintMode: 'solid',
        images: {
          mediaThumb: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_35.svg', 'stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_35.png'],
            width: 2000,
            height: 2002
          },
          mediaBase: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_35.svg', 'stickers/shapes/stickers/base/imgly_sticker_shapes_badge_35.png'],
            width: 2000,
            height: 2002
          }
        }
      }, {
        identifier: 'imgly_sticker_shapes_badge_36',
        defaultName: 'Badge 15',
        tintMode: 'solid',
        images: {
          mediaThumb: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_36.svg', 'stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_36.png'],
            width: 2000,
            height: 1668
          },
          mediaBase: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_badge_36.svg', 'stickers/shapes/stickers/base/imgly_sticker_shapes_badge_36.png'],
            width: 2000,
            height: 1668
          }
        }
      }, {
        identifier: 'imgly_sticker_shapes_spray_01',
        defaultName: 'Spray 1',
        tintMode: 'solid',
        images: {
          mediaThumb: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_spray_01.svg', 'stickers/shapes/stickers/thumbs/imgly_sticker_shapes_spray_01.png'],
            width: 1912,
            height: 2039
          },
          mediaBase: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_spray_01.svg', 'stickers/shapes/stickers/base/imgly_sticker_shapes_spray_01.png'],
            width: 1912,
            height: 2039
          }
        }
      }, {
        identifier: 'imgly_sticker_shapes_spray_03',
        defaultName: 'Spray 2',
        tintMode: 'solid',
        images: {
          mediaThumb: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_spray_03.svg', 'stickers/shapes/stickers/thumbs/imgly_sticker_shapes_spray_03.png'],
            width: 1681,
            height: 1779
          },
          mediaBase: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_spray_03.svg', 'stickers/shapes/stickers/base/imgly_sticker_shapes_spray_03.png'],
            width: 1681,
            height: 1779
          }
        }
      }, {
        identifier: 'imgly_sticker_shapes_spray_04',
        defaultName: 'Spray 3',
        tintMode: 'solid',
        images: {
          mediaThumb: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_spray_04.svg', 'stickers/shapes/stickers/thumbs/imgly_sticker_shapes_spray_04.png'],
            width: 1407,
            height: 2248
          },
          mediaBase: {
            uris: ['stickers/shapes/stickers/imgly_sticker_shapes_spray_04.svg', 'stickers/shapes/stickers/base/imgly_sticker_shapes_spray_04.png'],
            width: 1407,
            height: 2248
          }
        }
      }]
    }]
  }
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Generated by CoffeeScript 1.7.1
(function() {
  var getNanoSeconds, hrtime, loadTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - loadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var SearchSuggestionComponent = function (_BaseComponent) {
  _inherits(SearchSuggestionComponent, _BaseComponent);

  function SearchSuggestionComponent() {
    var _ref;

    _classCallCheck(this, SearchSuggestionComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = SearchSuggestionComponent.__proto__ || Object.getPrototypeOf(SearchSuggestionComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onClick');
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user clicks the search suggestion
   * @private
   */


  _createClass(SearchSuggestionComponent, [{
    key: '_onClick',
    value: function _onClick() {
      this.props.onClick && this.props.onClick(this.props.searchSuggestion);
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var searchSuggestion = this.props.searchSuggestion;

      var style = {
        backgroundImage: 'url(' + searchSuggestion.coverImage + ')'
      };

      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: 'b:photoRoll e:libraryList' },
        _globals.ReactBEM.createElement(
          'li',
          { bem: 'e:item', style: style, onClick: this._onClick },
          _globals.ReactBEM.createElement('div', { bem: 'e:overlay' }),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:name' },
            searchSuggestion.query
          )
        )
      );
    }
  }]);

  return SearchSuggestionComponent;
}(_globals.BaseComponent);

exports.default = SearchSuggestionComponent;


SearchSuggestionComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _modalManager = __webpack_require__(1);

var _modalManager2 = _interopRequireDefault(_modalManager);

var _photoComponent = __webpack_require__(104);

var _photoComponent2 = _interopRequireDefault(_photoComponent);

var _scrollbarComponent = __webpack_require__(2);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */


var COLUMN_WIDTH = 240;

var PhotoListComponent = function (_BaseComponent) {
  _inherits(PhotoListComponent, _BaseComponent);

  function PhotoListComponent() {
    var _ref;

    _classCallCheck(this, PhotoListComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = PhotoListComponent.__proto__ || Object.getPrototypeOf(PhotoListComponent)).call.apply(_ref, [this].concat(args)));

    _this._needsStyleFixes = true;
    _this._totalPhotosHeight = 0;
    _this.state = {
      loading: false,
      photos: []
    };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  _createClass(PhotoListComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      _get(PhotoListComponent.prototype.__proto__ || Object.getPrototypeOf(PhotoListComponent.prototype), 'componentDidMount', this).call(this);
      this._loadPhotos();
    }

    /**
     * Gets called when this component has been updated
     */

  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      if (this.refs.scrollbar) {
        this.refs.scrollbar.update();
      }
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the user clicks on a photo
     * @param  {PhotoEditorSDK.UI.ReactUI.PhotoRoll.Photo} photo
     * @private
     */

  }, {
    key: '_onPhotoClicked',
    value: function _onPhotoClicked(photo) {
      this.props.onPhotoClicked && this.props.onPhotoClicked(photo);
    }

    // -------------------------------------------------------------------------- MISC

    /**
     * Returns the headline for this view
     * @return {String}
     * @private
     */

  }, {
    key: '_getHeadline',
    value: function _getHeadline() {
      return this.props.library.name;
    }

    /**
     * A method that is called whenever styles need to be fixed by the JavaScript.
     * This needs to be done thanks to older Internet Explorer browsers which have
     * a bunch of CSS bugs.
     */

  }, {
    key: 'fixStyles',
    value: function fixStyles() {
      if (_globals.Utils.Browser.isIElte(11)) {
        var cell = this.refs.cell;

        var list = this.refs.scrollbar.getList();
        if (!(cell && list)) {
          return;
        }
        var cellHeight = cell.offsetHeight;
        list.style.height = cellHeight + 'px';
      }

      if (this.refs.scrollbar) {
        this.refs.scrollbar.update();
      }
    }

    // -------------------------------------------------------------------------- LOADING

  }, {
    key: '_renderColumns',
    value: function _renderColumns() {
      var _this2 = this;

      var photos = this.state.photos;

      var columnCount = 3;
      var columnHeights = [];

      var columns = [];
      for (var i = 0; i < columnCount; i++) {
        columns.push([]);
        columnHeights.push(0);
      }

      photos.forEach(function (photo) {
        var dimensions = photo.dimensions;

        // Find shortest column

        var shortestColumnIndex = null;
        var shortestColumnHeight = Infinity;
        for (var _i = 0; _i < columnCount; _i++) {
          if (columnHeights[_i] < shortestColumnHeight) {
            shortestColumnIndex = _i;
            shortestColumnHeight = columnHeights[_i];
          }
        }

        columns[shortestColumnIndex].push(_globals.ReactBEM.createElement(_photoComponent2.default, {
          photo: photo.obj,
          onClick: _this2._onPhotoClicked.bind(_this2, photo.obj) }));
        columnHeights[shortestColumnIndex] += dimensions.y;
      });

      return columns;
    }

    /**
     * Renders the content for this component
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderPhotos',
    value: function _renderPhotos() {
      var columns = this._renderColumns();
      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:photoRoll e:row m:fullHeight' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:cell', ref: 'cell' },
          _globals.ReactBEM.createElement(
            _scrollbarComponent2.default,
            { direction: 'vertical', ref: 'scrollbar' },
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:container', ref: 'container' },
              _globals.ReactBEM.createElement(
                'div',
                { bem: 'e:innerContainer' },
                _globals.ReactBEM.createElement(
                  'div',
                  { bem: 'e:headline' },
                  this._getHeadline()
                ),
                _globals.ReactBEM.createElement(
                  'bem',
                  { specifier: 'e:photoList' },
                  columns.map(function (column) {
                    return _globals.ReactBEM.createElement(
                      'ul',
                      { bem: '$e:list' },
                      column
                    );
                  })
                )
              )
            )
          )
        )
      );
    }

    /**
     * Loads the photos
     * @private
     */

  }, {
    key: '_loadPhotos',
    value: function _loadPhotos() {
      var _this3 = this;

      this._totalPhotosHeight = 0;

      var modal = _modalManager2.default.instance.displayProgress(this._t('pesdk.common.text.loading'));
      var PhotoRollProvider = this.context.options.photoRoll.provider;
      var provider = new PhotoRollProvider();

      provider.getPhotosForLibrary(this.props.library).then(function (photos) {
        return _this3._preloadPhotos(photos, modal);
      }).then(function (photos) {
        _this3.setState({ photos: photos, loading: false });
        modal.close();
      }).catch(function (e) {
        modal.close();
        _modalManager2.default.instance.displayError(_this3._t('pesdk.library.title.photoRollLoadFail'), _this3._t('pesdk.library.text.photoRollLoadFail', { error: e.message }));
      });
    }

    /**
     * Preloads the photos
     * @param {PhotoEditorSDK.UI.ReactUI.PhotoRoll.Photo[]} photos
     * @param {Modal} modal
     * @return {Promise}
     * @private
     */

  }, {
    key: '_preloadPhotos',
    value: function _preloadPhotos(photos, modal) {
      var _this4 = this;

      var totalPhotos = photos.length;
      var loadedPhotos = 0;
      return Promise.all(photos.map(function (photo) {
        return _this4._preloadPhoto(photo).then(function (image) {
          var photoDimensions = new _globals.Vector2(image.width, image.height);
          photoDimensions.multiply(COLUMN_WIDTH / image.width);
          _this4._totalPhotosHeight += photoDimensions.y;

          loadedPhotos++;
          modal.setData({ progress: loadedPhotos / totalPhotos });

          return {
            obj: photo,
            dimensions: photoDimensions
          };
        });
      }));
    }

    /**
     * Preloads the given photo
     * @param  {PhotoEditorSDK.UI.ReactUI.PhotoRoll.Photo} photo
     * @return {Promise}
     * @private
     */

  }, {
    key: '_preloadPhoto',
    value: function _preloadPhoto(photo) {
      var _this5 = this;

      return new Promise(function (resolve, reject) {
        var image = new window.Image();
        image.addEventListener('load', function () {
          resolve(image);
        });
        image.addEventListener('error', function () {
          resolve(image);
        });
        image.crossOrigin = _this5.props.crossOrigin || 'anonymous';
        image.src = photo.urls.thumb;
      });
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      if (!this.state.loading) {
        return this._renderPhotos();
      } else {
        return _globals.ReactBEM.createElement('div', null);
      }
    }
  }]);

  return PhotoListComponent;
}(_globals.BaseComponent);

exports.default = PhotoListComponent;


PhotoListComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _controlsComponent = __webpack_require__(3);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _scrollbarComponent = __webpack_require__(2);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OverviewControlsComponent = function (_ControlsComponent) {
  _inherits(OverviewControlsComponent, _ControlsComponent);

  function OverviewControlsComponent() {
    var _ref;

    _classCallCheck(this, OverviewControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = OverviewControlsComponent.__proto__ || Object.getPrototypeOf(OverviewControlsComponent)).call.apply(_ref, [this].concat(args)));

    _this._hasBackButton = false;
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when an item has been clicked
   * @param  {Event} e
   * @private
   */


  _createClass(OverviewControlsComponent, [{
    key: '_onItemClick',
    value: function _onItemClick(controls) {
      this.props.onSwitchControls(controls);
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the list items for this control
     * @return {Array.<ReactBEM.Element>}
     * @private
     */

  }, {
    key: '_renderListItems',
    value: function _renderListItems() {
      var _this2 = this;

      var editor = this.context.editor;


      var items = [];
      var makeItem = function makeItem(identifier) {
        var control = editor.controls.get(identifier);
        return _globals.ReactBEM.createElement(
          'li',
          {
            bem: 'e:item',
            key: control.identifier,
            'data-identifier': control.identifier,
            onClick: _this2._onItemClick.bind(_this2, control) },
          _globals.ReactBEM.createElement(
            'bem',
            { specifier: '$b:controls' },
            _globals.ReactBEM.createElement(
              'div',
              { bem: '$e:button m:withLabel' },
              _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: _this2._getAssetPath(control.iconPath, true) }),
              _globals.ReactBEM.createElement(
                'div',
                { bem: 'e:label' },
                _this2._t(control.languageKey)
              )
            )
          )
        );
      };

      var controlsOrder = this.context.options.editor.controlsOrder;

      controlsOrder.forEach(function (groupOrIdentifier) {
        if (Array.isArray(groupOrIdentifier)) {
          var group = groupOrIdentifier;

          var groupItems = [];
          group.forEach(function (identifier) {
            if (!editor.controls.isEnabled(identifier)) return;
            groupItems.push(makeItem(identifier));
          });

          if (groupItems.length) {
            items.push(groupItems);
          }
        } else {
          var identifier = groupOrIdentifier;
          if (!editor.controls.isEnabled(identifier)) return;
          items.push(makeItem(identifier));
        }
      });

      var finalItems = [];
      items.forEach(function (itemOrGroup) {
        finalItems = finalItems.concat(itemOrGroup);
        if (itemOrGroup !== items[items.length - 1]) {
          finalItems.push(_globals.ReactBEM.createElement('li', { bem: 'e:separator' }));
        }
      });

      return finalItems;
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderControls',
    value: function renderControls() {
      var listItems = this._renderListItems();

      return _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell m:list' },
        _globals.ReactBEM.createElement(
          _scrollbarComponent2.default,
          null,
          _globals.ReactBEM.createElement(
            'ul',
            { bem: '$e:list' },
            listItems
          )
        )
      );
    }
  }]);

  return OverviewControlsComponent;
}(_controlsComponent2.default);

exports.default = OverviewControlsComponent;


OverviewControlsComponent.contextTypes = _controlsComponent2.default.contextTypes;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _exporter = __webpack_require__(121);

var _exporter2 = _interopRequireDefault(_exporter);

var _imageResizer = __webpack_require__(123);

var _imageResizer2 = _interopRequireDefault(_imageResizer);

var _operations = __webpack_require__(124);

var _operations2 = _interopRequireDefault(_operations);

var _controls = __webpack_require__(125);

var _controls2 = _interopRequireDefault(_controls);

var _features = __webpack_require__(169);

var _features2 = _interopRequireDefault(_features);

var _zoom = __webpack_require__(170);

var _zoom2 = _interopRequireDefault(_zoom);

var _history = __webpack_require__(171);

var _history2 = _interopRequireDefault(_history);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

/**
 * The Editor class is an interface to the SDK, managing operations, rendering,
 * history, zoom etc.
 * @class
 * @memberof PhotoEditorSDK.UI.ReactUI
 */
var Editor = function (_EventEmitter) {
  _inherits(Editor, _EventEmitter);

  function Editor(ui, options, mediator) {
    var shallow = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    _classCallCheck(this, Editor);

    var _this = _possibleConstructorReturn(this, (Editor.__proto__ || Object.getPrototypeOf(Editor)).call(this));

    _this._ui = ui;
    _this._options = options;
    _this._mediator = mediator;
    _this._ready = false;
    _this._padding = [0, 0, 0, 0];
    _this._shallow = shallow;

    if (!shallow) {
      _this._initSDK();

      _this._onZoom = _this._onZoom.bind(_this);
      _this._onUndo = _this._onUndo.bind(_this);

      _this.history = new _history2.default(_this, _this._sdk, _this._mediator);
      _this.history.on('undo', _this._onUndo);
      _this.zoom = new _zoom2.default(_this, _this._sdk, _this._mediator);
      _this.zoom.on('set', _this._onZoom);

      _this._initSerializers();
    }

    _this.operations = new _operations2.default(_this, _this._sdk, _this._mediator);
    _this.controls = new _controls2.default(_this, _this._sdk, _this._mediator);
    _this.features = new _features2.default(_this, _this._sdk, _this._mediator);

    // Rendering
    _this._running = false;
    _this._renderRequested = true;
    _this._renderCallbacks = [];
    _this._animationFrameRequest = null;

    _this.render = _this.render.bind(_this);
    _this._tick = _this._tick.bind(_this);
    return _this;
  }

  // -------------------------------------------------------------------------- INITIALIZATION

  /**
   * Sets the given image to be rendered. If the image needs to be resized to fit into a
   * WebGL texture or to match the `maxMegaPixels` option, resizing is done before setting
   * the image.
   * @param {Image} image
   * @param {Boolean} resetEditor
   */


  _createClass(Editor, [{
    key: 'setImage',
    value: function setImage() {
      var _this2 = this;

      var image = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._options.editor.image;
      var resetEditor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var renderer = this._sdk.getRenderer();
      var initialDimensions = new _globals.Vector2(image.naturalWidth, image.naturalHeight);
      var maxPixels = this.getMaxMegapixels() * 1000000;
      var maxDimensions = renderer.getMaxDimensions();

      if (resetEditor) {
        this.reset();
      }

      var imageResizer = new _imageResizer2.default(image, maxPixels, maxDimensions);
      var exif = null;

      var done = function done(image) {
        var dimensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : initialDimensions;
        var resizeReason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        _this2._setImage(image, exif, dimensions);

        _this2._initWatermark();

        _this2._ready = true;
        _this2.emit('ready');
      };

      if (!imageResizer.needsResize()) {
        done(image);
      } else {
        this.emit('resize');
        exif = this._sdk.parseExif(image);
        imageResizer.resize().then(function (_ref) {
          var canvas = _ref.canvas,
              dimensions = _ref.dimensions,
              reason = _ref.reason;

          // Flag canvas as JPEG so that export will recognize that
          // it needs to restore EXIF data
          canvas.src = 'data:image/jpeg;base64,';

          _this2.emit('resized', { dimensions: dimensions, reason: reason });
          done(canvas, dimensions, reason);
        });
      }
    }

    /**
     * Initializes the watermark operation
     * @private
     */

  }, {
    key: '_initWatermark',
    value: function _initWatermark() {
      if (this._options.editor.watermarkImage) {
        this._watermarkOperation = this.operations.getOrCreate('watermark', {
          image: this._options.editor.watermarkImage
        });
      }
    }

    /**
     * Initializes the SDK
     * @private
     */

  }, {
    key: '_initSDK',
    value: function _initSDK() {
      var _options = this._options,
          logLevel = _options.logLevel,
          displayWelcomeMessage = _options.displayWelcomeMessage,
          debug = _options.debug,
          license = _options.license,
          crossOrigin = _options.crossOrigin;
      var _options$editor = this._options.editor,
          smoothDownscaling = _options$editor.smoothDownscaling,
          smoothUpscaling = _options$editor.smoothUpscaling,
          preferredRenderer = _options$editor.preferredRenderer,
          pixelRatio = _options$editor.pixelRatio;

      var rendererOptions = {
        logLevel: logLevel,
        debug: debug,
        displayWelcomeMessage: displayWelcomeMessage,
        pixelRatio: pixelRatio,
        smoothDownscaling: smoothDownscaling,
        smoothUpscaling: smoothUpscaling,
        crossOrigin: crossOrigin,
        transparent: true,
        license: license
      };
      this._sdk = new _globals.SDK(preferredRenderer, rendererOptions);
    }

    // -------------------------------------------------------------------------- ZOOMING

    /**
     * Gets called after a new zoom level has been set. Re-renders the editor.
     * @param  {Number} zoom
     * @param  {Function} [callback]
     * @private
     */

  }, {
    key: '_onZoom',
    value: function _onZoom(zoom) {
      var _this3 = this;

      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      this.fixOffset();
      this.render(function () {
        _this3._mediator.emit(_globals.Constants.EVENTS.ZOOM_DONE);
        callback && callback();
      });
    }

    /**
     * Gets called after an undo happened
     * @private
     */

  }, {
    key: '_onUndo',
    value: function _onUndo() {
      this.render();
    }

    /**
     * Returns the current rotation
     * @return {Number}
     */

  }, {
    key: 'getRotation',
    value: function getRotation() {
      return this._sdk.getRotation();
    }

    /**
     * Sets the rotation to the given value
     * @param {Number} rotation
     */

  }, {
    key: 'setRotation',
    value: function setRotation(rotation) {
      this._sdk.setRotation(rotation);
    }

    /**
     * Returns the current sprite scale
     * @return {Number}
     */

  }, {
    key: 'getSpriteScale',
    value: function getSpriteScale() {
      return this._sdk.getSpriteScale();
    }

    /**
     * Sets the sprite scale to the given value
     * @param {Number} spriteScale
     */

  }, {
    key: 'setSpriteScale',
    value: function setSpriteScale(spriteScale) {
      this._sdk.setSpriteScale(spriteScale);
    }

    /**
     * Returns the crossOrigin value to be set to image elements, according
     * to the passed `crossOrigin` option.
     *
     * @returns String
     */

  }, {
    key: 'getCrossOrigin',
    value: function getCrossOrigin() {
      return _globals.SDKUtils.getCrossOriginValue(this._options.crossOrigin || 'anonymous');
    }

    // -------------------------------------------------------------------------- MISC PRIVATE API

    /**
     * Checks if the given tool is allowed by the license
     * @param  {String}  identifier
     * @return {Boolean}
     */

  }, {
    key: 'isToolAllowed',
    value: function isToolAllowed(identifier) {
      if (this._shallow) return true;

      return this._sdk._l.isToolAllowed(identifier);
    }

    /**
     * Checks if the control with the tool identifier is enabled
     * @param  {String}  identifier
     * @return {Boolean}
     */

  }, {
    key: 'isToolEnabled',
    value: function isToolEnabled(identifier) {
      return this._options.editor.tools.indexOf(identifier) !== -1;
    }

    /**
     * Returns the maximum mega pixels
     * @return {Number}
     * @private
     */

  }, {
    key: 'getMaxMegapixels',
    value: function getMaxMegapixels() {
      var maxMegaPixels = this._options.editor.maxMegaPixels;

      return _globals.Utils.isMobile() ? maxMegaPixels.mobile : maxMegaPixels.desktop;
    }

    // -------------------------------------------------------------------------- MISC PUBLIC API

    /**
     * Returns the output sprite's current dimensions
     * @param {Boolean} incorporateSpriteScale = false
     * @return {PhotoEditorSDK.Math.Vector2}
     */

  }, {
    key: 'getOutputDimensions',
    value: function getOutputDimensions() {
      var incorporateSpriteScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      return this._sdk.getOutputDimensions(incorporateSpriteScale);
    }

    /**
     * Returns the output texture's current dimensions
     * @param  {Boolean} incorporateSpriteScale = false
     * @return {PhotoEditorSDK.Math.Vector2}
     */

  }, {
    key: 'getOutputTextureDimensions',
    value: function getOutputTextureDimensions() {
      var incorporateSpriteScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      return this._sdk.getOutputTextureDimensions(incorporateSpriteScale);
    }

    /**
     * Returns the final dimensions that the input image would have
     * after all existing operations have been applied
     * @param {Boolean} incorporateSpriteScale = false
     * @return {PhotoEditorSDK.Math.Vector2}
     */

  }, {
    key: 'getFinalDimensions',
    value: function getFinalDimensions() {
      var incorporateSpriteScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      return this._sdk.getFinalDimensions(incorporateSpriteScale);
    }

    /**
     * Returns the canvas dimensions
     * @param  {Boolean} subtractPadding = true
     * @return {PhotoEditorSDK.Math.Vector2}
     */

  }, {
    key: 'getCanvasDimensions',
    value: function getCanvasDimensions() {
      var subtractPadding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      var canvas = this._sdk.getCanvas();
      var dimensions = new _globals.Vector2(canvas.offsetWidth, canvas.offsetHeight);
      if (subtractPadding) {
        dimensions.subtract(this._padding[1] + this._padding[3], this._padding[0] + this._padding[2]);
      }
      return dimensions;
    }

    /**
     * Sets the given image
     * @param {Image} image
     * @param {PhotoEditorSDK.EXIF} [exif]
     * @param {PhotoEditorSDK.Math.Vector2} [dimensions]
     * @private
     */

  }, {
    key: '_setImage',
    value: function _setImage() {
      var image = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._options.editor.image;
      var exif = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var dimensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      // Invalidate caches
      this._sdk.setAllOperationsToDirty();

      this._options.editor.image = image;
      this._sdk.setImage(image, exif, dimensions);

      this.zoom.set('auto');

      this.emit('new-image');
    }

    /**
     * Exports an image
     * @param {Boolean} download = false
     * @return {Promise}
     */

  }, {
    key: 'export',
    value: function _export() {
      var _this4 = this;

      var download = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this._watermarkOperation) {
        this._watermarkOperation.setEnabled(false);
      }

      // Invalidate caches
      this._sdk.setAllOperationsToDirty();

      var options = this._options.editor.export;
      var exporter = new _exporter2.default(this._sdk, options, download);
      return exporter.export().then(function (output) {
        _this4.emit('export', output);
        _this4._mediator.emit(_globals.Constants.EVENTS.EXPORT, output, _this4);

        if (_this4._watermarkOperation) {
          _this4._watermarkOperation.setEnabled(true);
          _this4._sdk.render();
        }

        // Invalidate caches
        _this4._sdk.setAllOperationsToDirty();

        return output;
      });
    }

    // -------------------------------------------------------------------------- SERIALIZATION

    /**
     * Initializes the serializers and deserializers
     * @private
     */

  }, {
    key: '_initSerializers',
    value: function _initSerializers() {
      this._serializers = {
        '1.0.0': __webpack_require__(172).default,
        '1.0.1': __webpack_require__(181).default,
        '2.0.0': __webpack_require__(182).default,
        '2.0.1': __webpack_require__(184).default,
        '3.0.0': __webpack_require__(187).default,
        '3.1.0': __webpack_require__(188).default
      };
    }

    /**
     * Serializes the editor state for the given version
     * @param  {Object} options = {}
     * @param  {String} version = '3.1.0'
     * @return {Promise}
     */

  }, {
    key: 'serialize',
    value: function serialize() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '3.1.0';

      var Serializer = this._serializers[version];
      if (!Serializer) {
        return _globals.Promise.reject(new Error('No serializer for version ' + version + ' found.'));
      }
      var serializer = new Serializer(this);
      return serializer.serialize(options);
    }

    /**
     * Deserializes the given data
     * @param  {Object} data
     * @return {Promise}
     */

  }, {
    key: 'deserialize',
    value: function deserialize(data) {
      var _this5 = this;

      var Serializer = this._serializers[data.version];
      if (!Serializer) {
        return _globals.Promise.reject(new Error('No serializer for version ' + data.version + ' found.'));
      }
      var serializer = new Serializer(this);
      return serializer.deserialize(data).then(function () {
        _this5.zoom.set('auto');
      });
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Applies the rendering offset
     * @private
     */

  }, {
    key: '_applyOffset',
    value: function _applyOffset() {
      var offset = this._offset.clone();

      offset.x -= this._padding[1] / 2;
      offset.x += this._padding[3] / 2;

      offset.y -= this._padding[2] / 2;
      offset.y += this._padding[0] / 2;

      this._sdk.setOffset(offset);
    }

    /**
     * Starts the render loop
     */

  }, {
    key: 'start',
    value: function start() {
      this.zoom.set('auto');
      this._animationFrameRequest = (0, _globals.requestAnimationFrame)(this._tick);
    }

    /**
     * Stops the render loop
     */

  }, {
    key: 'stop',
    value: function stop() {
      this._running = false;
      if (this._animationFrameRequest) {
        (0, _globals.cancelAnimationFrame)(this._animationFrameRequest);
        this._renderCallbacks = [];
      }
    }

    /**
     * Requests a render, adds `callback` to the render callbacks
     * @param  {Function} [callback]
     */

  }, {
    key: 'render',
    value: function render(callback) {
      this._renderRequested = true;
      if (callback) {
        this._renderCallbacks.push(callback);
      }
    }

    /**
     * Sets the offset to the given one
     * @param {PhotoEditorSDK.Math.Vector2} offset
     */

  }, {
    key: 'setOffset',
    value: function setOffset(offset) {
      this._offset = this._clampOffset(offset);
    }

    /**
     * Returns the current offset
     * @returns {PhotoEditorSDK.Math.Vector2}
     */

  }, {
    key: 'getOffset',
    value: function getOffset() {
      return this._offset;
    }

    /**
     * Makes sure the image stays inside the viewport
     */

  }, {
    key: 'fixOffset',
    value: function fixOffset() {
      this.setOffset(this._sdk.getOffset());
    }

    /**
     * Fixes the given offset to make sure the image stays inside the viewport
     * @private
     */

  }, {
    key: '_clampOffset',
    value: function _clampOffset(offset) {
      var renderer = this._sdk.getRenderer();
      var rendererDimensions = new _globals.Vector2(renderer.getWidth(), renderer.getHeight());
      var outputDimensions = this._sdk.getOutputDimensions(false);

      var minOffset = rendererDimensions.clone().subtract(outputDimensions).divide(2).clamp(null, new _globals.Vector2(0, 0));

      var maxOffset = outputDimensions.clone().subtract(rendererDimensions).divide(2).clamp(new _globals.Vector2(0, 0), null);

      var newOffset = offset.clone().clamp(minOffset, maxOffset).round();

      return newOffset;
    }

    /**
     * Gets called when an animation frame is being processed. Renders the
     * canvas if necessary, requests another animation frame callbacks
     * @private
     */

  }, {
    key: '_tick',
    value: function _tick() {
      var _this6 = this;

      if (this._renderRequested) {
        var callbacks = this._renderCallbacks.slice(0);
        this._renderCallbacks = [];

        this._render().then(function () {
          callbacks.forEach(function (r) {
            return r();
          });
          _this6._animationFrameRequest = (0, _globals.requestAnimationFrame)(_this6._tick);
        }).catch(function (e) {
          _globals.Log.error('An error occurred while rendering: ' + e.message);
        });
        this._renderRequested = false;
      } else {
        this._animationFrameRequest = (0, _globals.requestAnimationFrame)(this._tick);
      }
    }

    /**
     * Triggers a render
     * @private
     */

  }, {
    key: '_render',
    value: function _render() {
      var _this7 = this;

      if (!this._ready) return _globals.Promise.resolve();

      this._applyOffset();

      return this._sdk.render().then(function () {
        _this7._lastOutputBounds = _this7._sdk.getSprite().getBounds();
      }).catch(function (e) {
        _this7.emit('render-error', e);
      });
    }

    /**
     * Resets everything
     */

  }, {
    key: 'reset',
    value: function reset() {
      this._sdk.reset();

      this.history.reset();
      this.operations.reset();
    }

    // -------------------------------------------------------------------------- DISPOSAL

    /**
     * Cleans this instance up
     */

  }, {
    key: 'dispose',
    value: function dispose() {
      this.stop();

      this._sdk.dispose();
    }

    // -------------------------------------------------------------------------- GETTERS / SETTERS

    /**
     * Checks if the Editor is ready to render
     * @return {Boolean}
     */

  }, {
    key: 'isReady',
    value: function isReady() {
      return this._ready;
    }

    /**
     * Returns the renderer
     * @return {PhotoEditorSDK.Engine.BaseRenderer}
     */

  }, {
    key: 'getRenderer',
    value: function getRenderer() {
      return this._sdk.getRenderer();
    }

    /**
     * Returns the SDK
     * @return {PhotoEditorSDK}
     */

  }, {
    key: 'getSDK',
    value: function getSDK() {
      return this._sdk;
    }

    /**
     * Returns the input image dimensions
     * @return {PhotoEditorSDK.Math.Vector2}
     */

  }, {
    key: 'getInputDimensions',
    value: function getInputDimensions() {
      return this._sdk.getInputDimensions(false);
    }

    /**
     * Returns the padding values
     * @return {Number[]}
     */

  }, {
    key: 'getPadding',
    value: function getPadding() {
      return this._padding;
    }

    /**
     * Sets the padding (top, right, bottom, left)
     * @param {Number[]} padding
     */

  }, {
    key: 'setPadding',
    value: function setPadding(padding) {
      if (!padding) {
        this._padding = [0, 0, 0, 0];
      } else {
        this._padding = padding;
      }
    }

    /**
     * Returns the image
     * @return {Image}
     */

  }, {
    key: 'getImage',
    value: function getImage() {
      return this._options.editor.image;
    }

    /**
     * Returns the options
     * @return {Object}
     */

  }, {
    key: 'getOptions',
    value: function getOptions() {
      return this._options;
    }

    /**
     * Returns the UI
     * @return {ReactUI}
     */

  }, {
    key: 'getUI',
    value: function getUI() {
      return this._ui;
    }
  }, {
    key: 'getMediator',
    value: function getMediator() {
      return this._mediator;
    }

    /**
     * Broadcasts a transform to all operations that need to be changed
     * @param  {PhotoEditorSDK.Operations.TransformOperation} transformOperation
     * @param  {Object} options
     */

  }, {
    key: 'broadcastTransform',
    value: function broadcastTransform(transformOperation, options) {
      var _this8 = this;

      var transformChange = new _globals.SDK.Operations.TransformOperation.TransformChange(transformOperation, options);
      var transformableOperations = ['sprite', 'selective-blur', 'radial-focus', 'mirrored-focus', 'linear-focus', 'blur'];
      transformableOperations.forEach(function (identifier) {
        var operation = _this8.operations.get(identifier);
        if (!operation) {
          return;
        }
        operation.transform(transformChange);
      });
    }

    /**
     * Broadcasts a flip to all operations that need to be changed
     * @param  {String} direction
     */

  }, {
    key: 'broadcastFlip',
    value: function broadcastFlip(direction) {
      var _this9 = this;

      var flippableOperations = ['mirrored-focus', 'radial-focus', 'sprite', 'selective-blur'];
      flippableOperations.forEach(function (identifier) {
        var operation = _this9.operations.get(identifier);
        if (!operation) {
          return;
        }
        operation.flip(direction);
      });
    }

    /**
     * Broadcasts a rotation to all operations that need to be changed
     * @param  {Number} degrees
     */

  }, {
    key: 'broadcastRotate',
    value: function broadcastRotate(degrees) {
      var _this10 = this;

      var flippableOperations = ['transform', 'mirrored-focus', 'radial-focus', 'sprite', 'selective-blur'];
      flippableOperations.forEach(function (identifier) {
        var operation = _this10.operations.get(identifier);
        if (!operation) {
          return;
        }
        operation.rotate(degrees);
      });
    }
  }]);

  return Editor;
}(_globals.EventEmitter);

exports.default = Editor;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _adjustments = __webpack_require__(126);

Object.defineProperty(exports, 'adjustments', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_adjustments).default;
  }
});

var _transform = __webpack_require__(129);

Object.defineProperty(exports, 'transform', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_transform).default;
  }
});

var _filter = __webpack_require__(133);

Object.defineProperty(exports, 'filter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_filter).default;
  }
});

var _focus = __webpack_require__(136);

Object.defineProperty(exports, 'focus', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_focus).default;
  }
});

var _sticker = __webpack_require__(141);

Object.defineProperty(exports, 'sticker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_sticker).default;
  }
});

var _text = __webpack_require__(149);

Object.defineProperty(exports, 'text', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_text).default;
  }
});

var _brush = __webpack_require__(159);

Object.defineProperty(exports, 'brush', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_brush).default;
  }
});

var _selectiveBlur = __webpack_require__(163);

Object.defineProperty(exports, 'selectiveBlur', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_selectiveBlur).default;
  }
});

var _frame = __webpack_require__(166);

Object.defineProperty(exports, 'frame', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_frame).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _overlayComponent = __webpack_require__(135);

var _overlayComponent2 = _interopRequireDefault(_overlayComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var CategoryDropdownComponent = function (_BaseComponent) {
  _inherits(CategoryDropdownComponent, _BaseComponent);

  function CategoryDropdownComponent() {
    _classCallCheck(this, CategoryDropdownComponent);

    var _this = _possibleConstructorReturn(this, (CategoryDropdownComponent.__proto__ || Object.getPrototypeOf(CategoryDropdownComponent)).call(this));

    _this._bindAll('_onButtonClick');

    _this.state = {
      overlayVisible: false
    };
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the color picker button has been clicked
   * @param  {Event} e
   * @private
   */


  _createClass(CategoryDropdownComponent, [{
    key: '_onButtonClick',
    value: function _onButtonClick(e) {
      e.preventDefault();
      e.stopPropagation();

      this.setState({ overlayVisible: !this.state.overlayVisible });
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var Overlay = null;

      if (this.state.overlayVisible) {
        Overlay = _globals.ReactBEM.createElement(_overlayComponent2.default, {
          items: this.props.items,
          selectedItem: this.props.selectedItem,
          onChange: this.props.onChange });
      }

      var className = this.state.overlayVisible ? 'is-active' : null;

      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:controls' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$e:categoryDropdown', className: className, onClick: this._onButtonClick },
          _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this.props.selectedItem.icon }),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:label' },
            this.props.selectedItem.label
          ),
          Overlay
        )
      );
    }
  }]);

  return CategoryDropdownComponent;
}(_globals.BaseComponent);

exports.default = CategoryDropdownComponent;


CategoryDropdownComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FontPreviewComponent = function (_BaseComponent) {
  _inherits(FontPreviewComponent, _BaseComponent);

  function FontPreviewComponent() {
    _classCallCheck(this, FontPreviewComponent);

    return _possibleConstructorReturn(this, (FontPreviewComponent.__proto__ || Object.getPrototypeOf(FontPreviewComponent)).apply(this, arguments));
  }

  _createClass(FontPreviewComponent, [{
    key: 'componentDidMount',

    // -------------------------------------------------------------------------- LIFECYCLE

    /**
     * Gets called after the component has been mounted
     */
    value: function componentDidMount() {
      _get(FontPreviewComponent.prototype.__proto__ || Object.getPrototypeOf(FontPreviewComponent.prototype), 'componentDidMount', this).call(this);
      this._renderCanvas();
    }

    /**
     * Gets called after this component has been updated
     */

  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      this._renderCanvas();
    }

    // -------------------------------------------------------------------------- CANVAS RENDERING

    /**
     * Renders the current font family onto the canvas
     * @private
     */

  }, {
    key: '_renderCanvas',
    value: function _renderCanvas() {
      var canvas = this.refs.canvas;
      var editor = this.context.editor;

      var sdk = editor.getSDK();

      var pixelRatio = sdk.getPixelRatio();
      canvas.width = canvas.offsetWidth * pixelRatio;
      canvas.height = canvas.offsetHeight * pixelRatio;

      canvas.style.width = canvas.offsetWidth + 'px';
      canvas.style.height = canvas.offsetHeight + 'px';

      var context = canvas.getContext('2d');

      context.fillStyle = 'red';
      context.clearRect(0, 0, canvas.width, canvas.height);

      context.font = (this.props.fontStyle || '') + ' ' + (this.props.fontWeight || '') + ' ' + 24 * pixelRatio + 'px ' + this.props.fontFamily;
      context.textBaseline = 'middle';
      context.textAlign = 'center';
      context.fillStyle = 'white';

      context.fillText('Abc', canvas.width / 2, canvas.height / 2);
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement('canvas', { bem: 'b:fontFamily e:canvas', ref: 'canvas' });
    }
  }]);

  return FontPreviewComponent;
}(_globals.BaseComponent);

exports.default = FontPreviewComponent;


FontPreviewComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _photoeditorsdk = __webpack_require__(7);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FONT_WEIGHTS = {
  100: 'Extra Light',
  200: 'Light',
  300: 'Book',
  400: 'Regular',
  500: 'Medium',
  600: 'Semibold',
  700: 'Bold',
  800: 'Black',
  900: 'Extra Black',
  bold: 'Bold',
  normal: 'Regular'
};

var FontVariation = function (_Configurable) {
  _inherits(FontVariation, _Configurable);

  function FontVariation() {
    _classCallCheck(this, FontVariation);

    return _possibleConstructorReturn(this, (FontVariation.__proto__ || Object.getPrototypeOf(FontVariation)).apply(this, arguments));
  }

  _createClass(FontVariation, [{
    key: 'getLabel',

    /**
     * Returns the label for this variation
     * @return {String}
     */
    value: function getLabel() {
      var label = FONT_WEIGHTS[this._options.fontWeight];

      switch (this._options.fontStyle) {
        case 'italic':
          label += ' Italic';
          break;
      }

      return label;
    }
  }]);

  return FontVariation;
}(_photoeditorsdk.Configurable);

/**
 * Specifies the available options for the FontVariation class
 * @type {Object}
 * @ignore
 */


exports.default = FontVariation;
FontVariation.prototype.availableOptions = {
  identifier: { type: _photoeditorsdk.OptionType.STRING, required: true },
  fontFamily: { type: _photoeditorsdk.OptionType.STRING, required: true },
  fontWeight: { type: _photoeditorsdk.OptionType.ALL, default: 400 },
  fontStyle: { type: _photoeditorsdk.OptionType.STRING, default: 'normal' },
  textMetrics: { type: _photoeditorsdk.OptionType.OBJECT, default: null },
  provider: { type: _photoeditorsdk.OptionType.STRING, available: ['google', 'file'] },
  filePath: { type: _photoeditorsdk.OptionType.STRING },
  default: { type: _photoeditorsdk.OptionType.BOOLEAN, default: false },
  font: { type: _photoeditorsdk.OptionType.OBJECT }
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FrameManager = function () {
  function FrameManager(ui, options) {
    _classCallCheck(this, FrameManager);

    this._ui = ui;
    this._options = options;

    this._categoriesById = {};
    this._categories = [];
    this._framesById = {};

    this._addCategories(_globals.SharedConstants.DEFAULTS.FRAME_CATEGORIES);

    var _options = this._options,
        categories = _options.categories,
        replaceCategories = _options.replaceCategories;

    if (this._options.categories) {
      this._addCategories(categories, replaceCategories);
    } else {
      this._updateAllCategory();
    }
  }

  /**
   * Initializes the categories
   * @param {Object[]} categories
   * @param {Boolean} replace = false
   * @private
   */


  _createClass(FrameManager, [{
    key: '_addCategories',
    value: function _addCategories(categories) {
      var _this = this;

      var replace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (replace) {
        this._categories = categories.slice(0);
      } else {
        this._categories = _globals.Utils.mergeCategories(this._categories, categories, 'frames');
      }

      // Build cat id => category hash
      this._categoriesById = {};
      this._categories.forEach(function (c) {
        _this._categoriesById[c.identifier] = c;
      });

      // Filter frames
      var availableFrames = this._options.availableFrames;

      if (availableFrames) {
        this._categories.forEach(function (c) {
          c.frames = c.frames.filter(function (f) {
            return availableFrames.indexOf(f.identifier) !== -1;
          });
        });
      }

      // Build frame id => frame hash
      this._categories.forEach(function (c) {
        c.frames.forEach(function (s) {
          _this._framesById[s.identifier] = s;
        });
      });

      this._updateAllCategory();
    }

    /**
     * Updates the `all` category which contains all frames
     * @private
     */

  }, {
    key: '_updateAllCategory',
    value: function _updateAllCategory() {
      this._allCategory = {
        identifier: 'all',
        defaultName: 'All',
        frames: this._categories.map(function (c) {
          return c.frames;
        }).reduce(function (a, b) {
          return a.concat(b);
        }, [])
      };
      this._categoriesById.all = this._allCategory;
    }

    /**
     * Returns the frames for the category with the given name
     * @param  {String} categoryName
     * @return {Object[]}
     */

  }, {
    key: 'getFramesForCategory',
    value: function getFramesForCategory(categoryName) {
      if (!this._categoriesById[categoryName]) {
        throw new Error('Unknown frame category \'' + categoryName + '\'');
      }
      return this._categoriesById[categoryName].frames;
    }

    /**
     * Returns the frame with the given identifier
     * @param  {String} identifier
     */

  }, {
    key: 'getFrameByIdentifier',
    value: function getFrameByIdentifier(identifier) {
      return this._framesById[identifier];
    }

    /**
     * Returns the categories
     * @return {Object[]}
     */

  }, {
    key: 'getCategories',
    value: function getCategories() {
      return this._categories;
    }

    /**
     * Returns the category object for the given id
     * @param  {String} id
     * @return {Object}
     */

  }, {
    key: 'getCategory',
    value: function getCategory(id) {
      return this._categoriesById[id];
    }
  }]);

  return FrameManager;
}();

exports.default = FrameManager;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OptionType = _globals.SDK.OptionType;

var Frame = function (_SDK$Configurable) {
  _inherits(Frame, _SDK$Configurable);

  function Frame(ui) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Frame);

    var _this = _possibleConstructorReturn(this, (Frame.__proto__ || Object.getPrototypeOf(Frame)).call(this, options));

    _this._loaded = false;
    _this._loading = false;
    _this._ui = ui;
    _this._frame = _globals.SDK.Utils.deepClone(_this._options);
    return _this;
  }

  /**
   * Loads the images of this frame
   * @return {Promise}
   */


  _createClass(Frame, [{
    key: 'load',
    value: function load() {
      var _this2 = this;

      if (this._loaded) return Promise.resolve();
      if (this._loading) return Promise.reject(new Error('Called Frame#load while it\'s already loading'));

      this._loading = true;
      var imageGroups = this._frame.imageGroups;


      var promises = [];
      ['top', 'left', 'right', 'bottom'].forEach(function (groupName) {
        if (!(groupName in imageGroups)) return;

        var group = imageGroups[groupName];
        ['start', 'mid', 'end'].forEach(function (partName) {
          if (!(partName in group)) return;

          promises.push(_this2._loadPart(groupName, partName));
        });
      });

      return Promise.all(promises).then(function () {
        _this2._loaded = true;
        _this2._loading = false;
      }).catch(function (e) {
        _this2._loaded = false;
        _this2._loading = false;
      });
    }

    /**
     * Loads the given part of the given group
     * @param  {String} groupName
     * @param  {String} partName
     * @return {Promise}
     * @private
     */

  }, {
    key: '_loadPart',
    value: function _loadPart(groupName, partName) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        var imageGroups = _this3._frame.imageGroups;


        var part = imageGroups[groupName][partName];
        var imageUrl = part;
        // `part` can also be an object containing `mode` and `image`
        if (typeof part !== 'string' && 'image' in part) {
          imageUrl = part.image;
        }

        var image = new window.Image();
        image.addEventListener('load', function () {
          if (typeof part !== 'string') {
            _this3._frame.imageGroups[groupName][partName].image = image;
          } else {
            _this3._frame.imageGroups[groupName][partName] = image;
          }

          resolve(image);
        });
        image.addEventListener('error', function () {
          reject(new Error('Failed to load image at ' + imageUrl));
        });
        image.crossOrigin = _this3._ui.getEditor().getCrossOrigin();
        image.src = _this3._ui.getAssetPath(imageUrl);
      });
    }

    /**
     * Returns the frame
     * @return {Object}
     */

  }, {
    key: 'getFrame',
    value: function getFrame() {
      return this._frame;
    }
  }]);

  return Frame;
}(_globals.SDK.Configurable);

/**
 * Specifies the available options for the Frame class
 * @type {Object}
 * @ignore
 */


exports.default = Frame;
Frame.prototype.availableOptions = {
  identifier: { type: OptionType.STRING, required: true },
  defaultName: { type: OptionType.STRING },
  thumbnail: { type: OptionType.STRING },
  tintable: { type: OptionType.BOOLEAN, default: false },
  layoutMode: {
    type: OptionType.STRING,
    default: 'horizontal-inside',
    available: ['horizontal-inside', 'vertical-inside']
  },
  imageGroups: { type: OptionType.OBJECT, required: true }
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TWICE_PI = Math.PI * 2;

var v100Serializer = function () {
  function v100Serializer(editor) {
    _classCallCheck(this, v100Serializer);

    this._editor = editor;

    this._serializeOperations = this._serializeOperations.bind(this);
  }

  // -------------------------------------------------------------------------- SERIALIZATION

  /**
   * Serializes the editor state
   * @param {Object} options = {}
   * @return {Promise}
   */


  _createClass(v100Serializer, [{
    key: 'serialize',
    value: function serialize() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this._options = _globals.SDKUtils.defaults(options, {
        image: true
      });

      var data = {
        version: this.constructor.version
      };

      return this._serializeInputImage(data).then(this._serializeOperations);
    }

    /**
     * Serializes the input image as base64 and attaches it to `data`
     * @param  {Object} data
     * @return {Promise}
     * @private
     */

  }, {
    key: '_serializeInputImage',
    value: function _serializeInputImage(data) {
      var image = this._editor.getImage();
      var width = image.width,
          height = image.height;


      if (!this._options.image) {
        data.inputImage = { width: width, height: height };
        return Promise.resolve(data);
      }

      var canvas = _globals.SDKUtils.createCanvas();
      canvas.width = image.width;
      canvas.height = image.height;
      var context = canvas.getContext('2d');
      context.drawImage(image, 0, 0);

      var dataUrl = canvas.toDataURL(_globals.ImageFormat.PNG);
      data.inputImage = {
        type: _globals.ImageFormat.PNG,
        data: dataUrl.replace(/^data:image\/(.*?);base64,/, ''),
        width: width,
        height: height
      };
      return Promise.resolve(data);
    }

    /**
     * Serializes the operations and attaches them to `data`
     * @param  {Object} data
     * @return {Promise}
     * @private
     */

  }, {
    key: '_serializeOperations',
    value: function _serializeOperations(data) {
      var _this = this;

      var operations = [];
      var stack = this._editor.operations.getStack();
      stack.forEach(function (operation) {
        var data = _this._serializeOperation(operation, operations);
        if (data) {
          operations.push(data);
        }
      });
      data.operations = operations.filter(function (o) {
        return o;
      }); // Remove possible `null` operations
      return Promise.resolve(data);
    }

    /**
     * Serializes the given operation
     * @param  {PhotoEditorSDK.Operation} operation
     * @param  {PhotoEditorSDK.Operation[]} operations
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeOperation',
    value: function _serializeOperation(operation, operations) {
      switch (operation.constructor.identifier) {
        case 'transform':
          return this._serializeTransformOperation(operation);
        case 'orientation':
          return this._serializeOrientationOperation(operation);
        case 'filter':
          return this._serializeFilterOperation(operation);
        case 'adjustments':
          return this._serializeAdjustmentsOperation(operation);
        case 'sprite':
          return this._serializeSpriteOperation(operation, operations);
        case 'radial-focus':
          return this._serializeRadialFocusOperation(operation);
        case 'mirrored-focus':
          return this._serializeLinearFocusOperation(operation);
        default:
          _globals.Log.warn('Unable to serialize operation of type ' + operation.constructor.identifier);
      }
    }

    /**
     * Serializes the given transform operation
     * @param  {PhotoEditorSDK.Operation.TransformOperation} operation
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeTransformOperation',
    value: function _serializeTransformOperation(operation) {
      var options = operation.serializeOptions(['start', 'end', 'rotation'], true);
      options.rotation = (options.rotation + TWICE_PI) % TWICE_PI;
      return {
        type: 'crop',
        options: options
      };
    }

    /**
     * Serializes the given orientation operation
     * @param  {PhotoEditorSDK.Operation.OrientationOperation} operation
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeOrientationOperation',
    value: function _serializeOrientationOperation(operation) {
      return {
        type: 'orientation',
        options: operation.serializeOptions(['flipVertically', 'flipHorizontally', 'rotation'], true)
      };
    }

    /**
     * Serializes the given filter operation
     * @param  {PhotoEditorSDK.Operations.FilterOperation} operation
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeFilterOperation',
    value: function _serializeFilterOperation(operation) {
      if (operation.getIdentifier() === 'identity') return null;

      return {
        type: 'filter',
        options: {
          intensity: operation.getIntensity(),
          name: operation.getIdentifier()
        }
      };
    }

    /**
     * Serializes the given adjustments operation
     * @param  {PhotoEditorSDK.Operations.AdjustmentsOperation} operation
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeAdjustmentsOperation',
    value: function _serializeAdjustmentsOperation(operation) {
      var availableOptions = operation.availableOptions;


      var optionNames = ['brightness', 'saturation', 'contrast', 'exposure', 'shadows', 'highlights', 'clarity'];
      var options = {};
      optionNames.forEach(function (optionName) {
        var option = availableOptions[optionName];
        var value = operation.getOption(optionName);
        var minValue = option.minValue,
            midValue = option.midValue,
            maxValue = option.maxValue;

        options[optionName] = value <= midValue ? (value - minValue) / (midValue - minValue) - 1 : (value - midValue) / (maxValue - midValue);
      });
      return {
        type: 'adjustments',
        options: options
      };
    }

    /**
     * Serializes the given sprite operation
     * @return {PhotoEditorSDK.Operations.SpriteOperation} operation
     * @private
     */

  }, {
    key: '_serializeSpriteOperation',
    value: function _serializeSpriteOperation(operation, operations) {
      var _this2 = this;

      var spriteOperations = operations.filter(function (o) {
        return o.type === 'sprite';
      });
      var spriteOperation = void 0;
      var returnOperation = true;
      if (spriteOperations.length) {
        spriteOperation = spriteOperations.pop();
        returnOperation = false;
      } else {
        // No sprite operation exists, create a new one
        spriteOperation = {
          type: 'sprite',
          options: {
            sprites: []
          }
        };
      }

      operation.getSprites().forEach(function (sprite) {
        var spriteItem = null;
        if (sprite instanceof operation.constructor.StickerSprite) {
          spriteItem = _this2._serializeSticker(operation, sprite);
        } else if (sprite instanceof operation.constructor.TextSprite) {
          spriteItem = _this2._serializeText(operation, sprite);
        } else if (sprite instanceof operation.constructor.BrushSprite) {
          spriteItem = _this2._serializeBrush(operation, sprite);
        } else if (sprite instanceof operation.constructor.TextDesignSprite) {
          spriteItem = _this2._serializeTextDesign && _this2._serializeTextDesign(operation, sprite);
        }

        if (spriteItem) {
          spriteOperation.options.sprites.push(spriteItem);
        }
      });

      if (returnOperation) {
        return spriteOperation;
      }
    }

    /**
     * Serializes the given sticker
     * @param  {PhotoEditorSDK.Operation} operation
     * @param  {PhotoEditorSDK.Operations.SpriteOperation.StickerSprite} sprite
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeSticker',
    value: function _serializeSticker(operation, sprite) {
      var adjustments = sprite.getAdjustments();

      var options = sprite.serializeOptions(['identifier', 'position', 'dimensions', 'flipVertically', 'flipHorizontally', 'rotation'], true);

      options.name = options.identifier;
      delete options.identifier;

      options.rotation = (options.rotation + TWICE_PI) % TWICE_PI;

      var adjustmentsOptions = adjustments.availableOptions;
      options.adjustments = {
        brightness: adjustments.getBrightness() - adjustmentsOptions.brightness.default,
        saturation: adjustments.getSaturation() - adjustmentsOptions.saturation.default,
        contrast: adjustments.getContrast() - adjustmentsOptions.contrast.default
      };

      return {
        type: 'sticker',
        options: options
      };
    }

    /**
     * Serializes the given text sprite
     * @param  {PhotoEditorSDK.Operation} operation
     * @param  {PhotoEditorSDK.Operations.SpriteOperation.TextSprite} sprite
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeText',
    value: function _serializeText(operation, sprite) {
      var options = sprite.serializeOptions(['fontSize', 'lineHeight', 'fontFamily', 'fontWeight', 'alignment', 'color', 'backgroundColor', 'position', 'rotation', 'text', 'maxWidth'], true);
      options.rotation = (options.rotation + TWICE_PI) % TWICE_PI;

      return {
        type: 'text',
        options: options
      };
    }

    /**
     * Serializes the given brush sprite
     * @param  {PhotoEditorSDK.Operation} operation
     * @param  {PhotoEditorSDK.Operations.SpriteOperation.BrushSprite} sprite
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeBrush',
    value: function _serializeBrush(operation, sprite) {
      var _this3 = this;

      return {
        type: 'brush',
        options: {
          paths: sprite.getPaths().map(function (path) {
            return _this3._serializePath(path);
          })
        }
      };
    }

    /**
     * Serializes the given path
     * @param  {PhotoEditorSDK.Operations.SpriteOperation.BrushSprite.Path} path
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializePath',
    value: function _serializePath(path) {
      var options = path.getBrush().serializeOptions(['color', 'size'], true);

      options.points = path.getControlPoints().map(function (point) {
        return point.getPosition().toObject();
      });
      return options;
    }

    /**
     * Serializes the given radial focus operation
     * @param  {PhotoEditorSDK.Operations.RadialFocusOperation} operation
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeRadialFocusOperation',
    value: function _serializeRadialFocusOperation(operation) {
      return {
        type: 'focus',
        options: {
          type: 'radial',
          options: operation.serializeOptions(['position', 'radius', 'gradientRadius', 'blurRadius'], true)
        }
      };
    }

    /**
     * Serializes the given linear focus operation
     * @param  {PhotoEditorSDK.Operations.MirroredFocusOperation} operation
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeLinearFocusOperation',
    value: function _serializeLinearFocusOperation(operation) {
      return {
        type: 'focus',
        options: {
          type: 'linear',
          options: operation.serializeOptions(['start', 'end', 'blurRadius', 'size', 'gradientSize'], true)
        }
      };
    }

    /**
     * Returns the input dimensions for the given operation
     * @param  {PhotoEditorSDK.Operation} operation
     * @return {PhotoEditorSDK.Math.Vector2}
     * @private
     */

  }, {
    key: '_getInputDimensionsForOperation',
    value: function _getInputDimensionsForOperation(operation) {
      var operationFound = false;
      var inputDimensions = this._editor.getInputDimensions();

      this._editor.operations.getStack().forEach(function (op) {
        if (op === operation) operationFound = true;
        if (operationFound) return;
        inputDimensions = op.getNewDimensions(inputDimensions);
      });

      return inputDimensions;
    }
  }]);

  return v100Serializer;
}();

exports.default = v100Serializer;


v100Serializer.version = '1.0.0';

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = __webpack_require__(173);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _globals = __webpack_require__(0);

var _filterManager = __webpack_require__(27);

var _filterManager2 = _interopRequireDefault(_filterManager);

var _stickerManager = __webpack_require__(11);

var _stickerManager2 = _interopRequireDefault(_stickerManager);

var _brushManager = __webpack_require__(176);

var _brushManager2 = _interopRequireDefault(_brushManager);

var _fontManager = __webpack_require__(15);

var _fontManager2 = _interopRequireDefault(_fontManager);

var _fontLoader = __webpack_require__(30);

var _fontLoader2 = _interopRequireDefault(_fontLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Brush = void 0;
if (typeof _globals.SDK.Operations.SpriteOperation !== 'undefined') {
  Brush = _globals.SDK.Operations.SpriteOperation.BrushSprite;
}

var v100Deserializer = function () {
  function v100Deserializer(editor, data) {
    _classCallCheck(this, v100Deserializer);

    this._editor = editor;
    this._ui = this._editor.getUI();
    this._data = data;

    this._filterManager = new _filterManager2.default(this._ui, this._getOptions('filter'));
    this._stickerManager = new _stickerManager2.default(this._ui, this._getOptions('sticker'));
    this._brushManager = new _brushManager2.default(this._ui, this._getOptions('brush'));
    this._fontManager = new _fontManager2.default(this._ui, this._getOptions('text'));
  }

  _createClass(v100Deserializer, [{
    key: '_getOptions',
    value: function _getOptions(control) {
      var controls = this._editor.controls;

      var defaultOptions = {};
      if (controls && controls.get(control)) {
        defaultOptions = controls.get(control).defaultOptions;
      }

      var editorOptions = this._editor.getOptions();
      return _globals.SDKUtils.deepDefaults({}, editorOptions.editor.controlsOptions[control] || {}, defaultOptions);
    }

    /**
     * Deserializes the given data
     * @return {Promise}
     */

  }, {
    key: 'deserialize',
    value: function deserialize() {
      var _this = this;

      return this._validateVersion().then(function () {
        return _this._deserializeInputImage();
      }).then(function () {
        return _this._deserializeOperations();
      });
    }

    /**
     * Validates the version
     * @return {Promise}
     */

  }, {
    key: '_validateVersion',
    value: function _validateVersion() {
      if (this._data.version !== this.constructor.version) {
        return Promise.reject(new Error('Invalid version ' + this._data.version + ', expected ' + this.constructor.version));
      }
      return Promise.resolve();
    }

    /**
     * Deserializes the input image (if present)
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeInputImage',
    value: function _deserializeInputImage() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var _data$inputImage = _this2._data.inputImage,
            data = _data$inputImage.data,
            type = _data$inputImage.type;

        if (data && type) {
          var image = new window.Image();
          image.addEventListener('load', function () {
            _this2._editor.setImage(image);
            resolve();
          });
          image.src = 'data:' + type + ';base64,' + data;
        } else {
          resolve();
        }
      });
    }

    /**
     * Deserializes the operations
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeOperations',
    value: function () {
      var _ref = _asyncToGenerator(_regenerator2.default.mark(function _callee() {
        var operations, instances, i, operation, instance;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                operations = this._data.operations;
                instances = [];
                i = 0;

              case 3:
                if (!(i < operations.length)) {
                  _context.next = 12;
                  break;
                }

                operation = operations[i];
                _context.next = 7;
                return this._deserializeOperation(operation);

              case 7:
                instance = _context.sent;

                instances.push(instance);

              case 9:
                i++;
                _context.next = 3;
                break;

              case 12:
                return _context.abrupt('return', instances);

              case 13:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _deserializeOperations() {
        return _ref.apply(this, arguments);
      }

      return _deserializeOperations;
    }()

    /**
     * Deserializes the given operation
     * @param  {PhotoEditorSDK.Operation} operation
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeOperation',
    value: function _deserializeOperation(operation) {
      switch (operation.type) {
        case 'crop':
          return this._deserializeCropOperation(operation);
        case 'orientation':
          return this._deserializeOrientationOperation(operation);
        case 'filter':
          return this._deserializeFilterOperation(operation);
        case 'adjustments':
          return this._deserializeAdjustmentsOperation(operation);
        case 'sprite':
          return this._deserializeSpriteOperation(operation);
        case 'focus':
          return this._deserializeFocusOperation(operation);
      }
    }

    /**
     * Deserializes the given crop operation
     * @param  {Object} operation
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeCropOperation',
    value: function _deserializeCropOperation(operation) {
      var options = operation.options;
      var rotation = options.rotation;

      var start = _globals.Vector2.fromObject(options.start);
      var end = _globals.Vector2.fromObject(options.end);

      // Normalize rotation
      if (rotation > Math.PI) {
        rotation -= Math.PI * 2;
      }

      var cropOptions = { start: start, end: end };
      if (typeof rotation !== 'undefined') {
        cropOptions.rotation = rotation;
      }

      var transformOperation = this._editor.operations.getOrCreate('transform');
      this._editor.broadcastTransform(transformOperation, cropOptions);
      transformOperation.set(cropOptions);
      return Promise.resolve(transformOperation);
    }

    /**
     * Deserializes the given orientation operation
     * @param  {Object} operation
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeOrientationOperation',
    value: function _deserializeOrientationOperation(operation) {
      var options = operation.options;

      var orientationOperation = this._editor.operations.getOrCreate('orientation');
      if (!orientationOperation) return Promise.resolve();
      orientationOperation.set(options);
      return Promise.resolve(orientationOperation);
    }

    /**
     * Deserializes the given filter operation
     * @param  {Object} operation
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeFilterOperation',
    value: function _deserializeFilterOperation(operation) {
      var _this3 = this;

      var options = operation.options;


      if (!this._filterManager.getFilterByIdentifier(options.name)) {
        _globals.Log.warn('Deserializer', 'Unknown filter `' + options.name + '`');
        return Promise.resolve();
      }

      return this._filterManager.instantiateFilterWithIdentifier(options.name).then(function (filter) {
        var filterOperation = _this3._editor.operations.getOrCreate('filter');
        filterOperation.set({
          identifier: options.name,
          filter: filter,
          intensity: options.intensity
        });
        return filterOperation;
      });
    }

    /**
     * Deserializes the given adjustments operation
     * @param  {Object} operation
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeAdjustmentsOperation',
    value: function _deserializeAdjustmentsOperation(operation) {
      var AdjustmentsOperation = _globals.SDK.Operations.AdjustmentsOperation;
      var options = operation.options;


      var knownOptions = ['brightness', 'saturation', 'contrast', 'exposure', 'shadows', 'highlights', 'clarity'];

      var operationOptions = {};

      knownOptions.forEach(function (optionName) {
        if (typeof options[optionName] === 'undefined') return;

        var _AdjustmentsOperation = AdjustmentsOperation.prototype.availableOptions[optionName],
            minValue = _AdjustmentsOperation.minValue,
            midValue = _AdjustmentsOperation.midValue,
            maxValue = _AdjustmentsOperation.maxValue;

        var value = options[optionName];

        value = value < 0 ? midValue + (midValue - minValue) * value : midValue + (maxValue - midValue) * value;
        operationOptions[optionName] = value;
      });

      return Promise.resolve(this._editor.operations.getOrCreate('adjustments', operationOptions));
    }

    /**
     * Deserializes the given sprite operation
     * @param  {Object} operation
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeSpriteOperation',
    value: function _deserializeSpriteOperation(operation) {
      var _this4 = this;

      var options = operation.options;

      var spriteOperation = this._editor.operations.getOrCreate('sprite');
      if (!spriteOperation) return Promise.resolve();

      var promises = options.sprites.map(function (sprite) {
        return _this4._deserializeSprite(spriteOperation, sprite);
      }).filter(function (p) {
        return p;
      });
      return Promise.all(promises).then(function (sprites) {
        spriteOperation.setSprites(sprites.filter(function (s) {
          return s;
        }));
        return spriteOperation;
      });
    }

    /**
     * Deserializes the given sprite
     * @param  {PhotoEditorSDK.Operations.SpriteOperation} spriteOperation
     * @param  {PhotoEditorSDK.Operations.SpriteOperation.Sprite} sprite
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeSprite',
    value: function _deserializeSprite(spriteOperation, sprite) {
      switch (sprite.type) {
        case 'sticker':
          return this._deserializeSticker(spriteOperation, sprite);
        case 'text':
          return this._deserializeText(spriteOperation, sprite);
        case 'brush':
          return this._deserializeBrush(spriteOperation, sprite);
        case 'textdesign':
          return this._deserializeTextDesign && this._deserializeTextDesign(spriteOperation, sprite);
      }
    }

    /**
     * Deserializes the given sticker for the given operation
     * @param  {PhotoEditorSDK.Operations.SpriteOperation} operation
     * @param  {Object} sprite
     * @return {PhotoEditorSDK.Operations.SpriteOperation.StickerSprite}
     * @private
     */

  }, {
    key: '_deserializeSticker',
    value: function _deserializeSticker(operation, sprite) {
      var _this5 = this;

      var SpriteOperation = _globals.SDK.Operations.SpriteOperation;
      var options = sprite.options;


      var sticker = this._stickerManager.getStickerByIdentifier(options.name);
      var url = this._stickerManager.getURLForSticker(sticker);
      if (!sticker) {
        _globals.Log.warn('Deserializer', 'Unknown sticker \'' + options.name + '\'. Skipping sprite.');
        return Promise.resolve();
      }
      return new Promise(function (resolve, reject) {
        var image = new window.Image();
        image.addEventListener('load', function () {
          var adjustments = SpriteOperation.StickerSprite.prototype.availableOptions.adjustments.structure;
          var rotation = options.rotation,
              flipHorizontally = options.flipHorizontally,
              flipVertically = options.flipVertically;

          var stickerOptions = {
            identifier: options.name,
            image: image,
            position: _globals.Vector2.fromObject(options.position),
            dimensions: _globals.Vector2.fromObject(options.dimensions),
            rotation: rotation,
            flipHorizontally: flipHorizontally,
            flipVertically: flipVertically,
            adjustments: {}
          };

          if (typeof options.adjustments !== 'undefined') {
            ['brightness', 'contrast', 'saturation'].forEach(function (option) {
              if (typeof options.adjustments[option] !== 'undefined') {
                stickerOptions.adjustments[option] = options.adjustments[option] + adjustments[option].default;
              }
            });
          }

          resolve(operation.createSticker(stickerOptions));
        });
        image.crossOrigin = _this5._editor.getCrossOrigin();
        image.src = _this5._editor.getUI().getAssetPath(url);
      });
    }

    /**
     * Deserializes the given text for the given operation
     * @param  {PhotoEditorSDK.Operations.SpriteOperation} operation
     * @param  {Object} text
     * @return {PhotoEditorSDK.Operations.SpriteOperation.TextSprite}
     * @private
     */

  }, {
    key: '_deserializeText',
    value: function _deserializeText(operation, text) {
      var options = text.options;
      var fontSize = options.fontSize,
          lineHeight = options.lineHeight,
          fontFamily = options.fontFamily,
          fontWeight = options.fontWeight,
          alignment = options.alignment,
          rotation = options.rotation,
          maxWidth = options.maxWidth,
          color = options.color,
          backgroundColor = options.backgroundColor;


      var fontLoader = new _fontLoader2.default(this._ui);
      var font = this._fontManager.getFontByFontFamily(fontFamily);
      if (!font) font = this._fontManager.getDefaultFont();
      fontLoader.setFonts([font]);
      return fontLoader.load().then(function () {
        return operation.createText({
          fontSize: fontSize,
          lineHeight: lineHeight,
          fontFamily: fontFamily,
          fontWeight: fontWeight,
          alignment: alignment,
          rotation: rotation,
          maxWidth: maxWidth,
          text: options.text,
          color: _globals.Color.fromArray(color),
          backgroundColor: _globals.Color.fromArray(backgroundColor),
          position: _globals.Vector2.fromObject(options.position)
        });
      });
    }

    /**
     * Deserializes the given brush for the given operation
     * @param  {PhotoEditorSDK.Operations.SpriteOperation} operation
     * @param  {Object} brush
     * @return {PhotoEditorSDK.Operations.SpriteOperation.BrushSprite}
     * @private
     */

  }, {
    key: '_deserializeBrush',
    value: function _deserializeBrush(operation, brush) {
      var _this6 = this;

      var options = brush.options;
      var paths = options.paths;


      var brushSprite = operation.createBrush();
      paths.forEach(function (path) {
        _this6._deserializeBrushPath(brushSprite, path);
      });
      return Promise.resolve(brushSprite);
    }
  }, {
    key: '_deserializeBrushPath',
    value: function _deserializeBrushPath(brushSprite, path) {
      var points = path.points;


      var brushInstance = this._createBrushForPath(path);
      var pathObject = brushSprite.createPath(brushInstance);
      pathObject.setClosed(true);
      points.forEach(function (point) {
        pathObject.addControlPoint(_globals.Vector2.fromObject(point));
      });
    }

    /**
     * Creates a brush face with the given options
     * @param  {PhotoEditorSDK.Operations.SpriteOperation.Sprites.BrushSprite.Path} path
     * @return {PhotoEditorSDK.Operations.SpriteOperation.Sprites.BrushSprite.Brush}
     */

  }, {
    key: '_createBrushForPath',
    value: function _createBrushForPath(path) {
      var color = path.color,
          size = path.size;

      var colorObject = _globals.Color.fromArray(color);

      var brushOptions = {
        color: colorObject,
        size: size
      };

      var rawBrush = this._brushManager.getFirstBrush();
      if (rawBrush.prototype && rawBrush.prototype instanceof Brush) {
        // Custom Brush instance, used for special brushes such as radial brush, which has
        // an additional hardness option
        var BrushClass = rawBrush;
        return new BrushClass(brushOptions);
      } else {
        var _brush = _globals.SDKUtils.extend({}, rawBrush);
        delete _brush.image;

        var _BrushClass = function (_Brush) {
          _inherits(_BrushClass, _Brush);

          function _BrushClass() {
            _classCallCheck(this, _BrushClass);

            return _possibleConstructorReturn(this, (_BrushClass.__proto__ || Object.getPrototypeOf(_BrushClass)).apply(this, arguments));
          }

          return _BrushClass;
        }(Brush);

        _BrushClass.identifier = rawBrush.identifier;

        // Plain JS object, used for simple image brushes
        return new _BrushClass(_globals.SDKUtils.extend({}, _brush, brushOptions));
      }
    }

    /**
     * Deserializes the given focus operation
     * @param  {Object} operation
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeFocusOperation',
    value: function _deserializeFocusOperation(operation) {
      var options = operation.options.options;

      switch (operation.options.type) {
        case 'radial':
          {
            var position = options.position,
                radius = options.radius,
                gradientRadius = options.gradientRadius,
                blurRadius = options.blurRadius;

            return Promise.resolve(this._editor.operations.getOrCreate('radial-focus', {
              position: _globals.Vector2.fromObject(position),
              radius: radius,
              gradientRadius: gradientRadius,
              blurRadius: blurRadius
            }));
          }
        case 'linear':
          {
            var start = options.start,
                end = options.end,
                size = options.size,
                gradientSize = options.gradientSize,
                _blurRadius = options.blurRadius;

            return Promise.resolve(this._editor.operations.getOrCreate('mirrored-focus', {
              start: _globals.Vector2.fromObject(start),
              end: _globals.Vector2.fromObject(end),
              size: size,
              gradientSize: gradientSize,
              blurRadius: _blurRadius
            }));
          }
      }
    }

    /**
     * Returns the input dimensions for the given operation
     * @param  {PhotoEditorSDK.Operation} operation
     * @return {PhotoEditorSDK.Math.Vector2}
     * @private
     */

  }, {
    key: '_getInputDimensionsForOperation',
    value: function _getInputDimensionsForOperation(operation) {
      var operationFound = false;
      var inputDimensions = this._editor.getInputDimensions();

      this._editor.operations.getStack().forEach(function (op) {
        if (op === operation) operationFound = true;
        if (operationFound) return;
        inputDimensions = op.getNewDimensions(inputDimensions);
      });

      return inputDimensions;
    }
  }]);

  return v100Deserializer;
}();

exports.default = v100Deserializer;


v100Deserializer.version = '1.0.0';

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _fontObserver = __webpack_require__(178);

var _fontObserver2 = _interopRequireDefault(_fontObserver);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BaseFontLoader = function () {
  function BaseFontLoader(ui) {
    _classCallCheck(this, BaseFontLoader);

    this._ui = ui;
    this._fonts = [];
    this._observers = [];
  }

  /**
   * Adds the given font to the list of fonts to load
   * @param {Object} variation
   */


  _createClass(BaseFontLoader, [{
    key: 'add',
    value: function add(variation) {
      this._fonts.push(variation);
    }

    /**
     * Loads the fonts
     */

  }, {
    key: 'load',
    value: function load() {
      var _this = this;

      if (this._fonts.length === 0) {
        return Promise.resolve();
      }

      this._observers = [];
      this._fonts.forEach(function (variation) {
        _this._observers.push(new _fontObserver2.default(variation));
      });

      return Promise.all(this._observers.map(function (observer) {
        return observer.observe();
      }));
    }

    /**
     * Disposes the observers
     */

  }, {
    key: 'dispose',
    value: function dispose() {
      this._observers.forEach(function (observer) {
        return observer.dispose();
      });
    }
  }]);

  return BaseFontLoader;
}();

exports.default = BaseFontLoader;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _serializer = __webpack_require__(50);

var _serializer2 = _interopRequireDefault(_serializer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var TWICE_PI = Math.PI * 2;

var v101Serializer = function (_PreviousSerializer) {
  _inherits(v101Serializer, _PreviousSerializer);

  function v101Serializer() {
    _classCallCheck(this, v101Serializer);

    return _possibleConstructorReturn(this, (v101Serializer.__proto__ || Object.getPrototypeOf(v101Serializer)).apply(this, arguments));
  }

  _createClass(v101Serializer, [{
    key: '_serializeTransformOperation',

    /**
     * Serializes the given transform operation
     * @param  {PhotoEditorSDK.Operation.TransformOperation} operation
     * @return {Object}
     * @private
     */
    value: function _serializeTransformOperation(operation) {
      var options = operation.serializeOptions(['start', 'end', 'rotation', 'textureScale'], true);
      options.rotation = (options.rotation + TWICE_PI) % TWICE_PI;
      if (options.textureScale !== 1) {
        options.dimensions = operation.getNewDimensions(operation.getInputDimensions(false));
      }

      delete options.textureScale;
      return {
        type: 'crop',
        options: options
      };
    }
  }]);

  return v101Serializer;
}(_serializer2.default);

exports.default = v101Serializer;


v101Serializer.version = '1.0.1';

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _deserializer = __webpack_require__(51);

var _deserializer2 = _interopRequireDefault(_deserializer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var v101Deserializer = function (_PreviousDeserializer) {
  _inherits(v101Deserializer, _PreviousDeserializer);

  function v101Deserializer() {
    _classCallCheck(this, v101Deserializer);

    return _possibleConstructorReturn(this, (v101Deserializer.__proto__ || Object.getPrototypeOf(v101Deserializer)).apply(this, arguments));
  }

  _createClass(v101Deserializer, [{
    key: '_deserializeOperation',

    /**
     * Deserializes the given operation
     * @param  {PhotoEditorSDK.Operation} operation
     * @return {Promise}
     * @private
     */
    value: function _deserializeOperation(operation) {
      if (operation.type === 'selective-blur') {
        return this._deserializeSelectiveBlurOperation(operation);
      }
      return _get(v101Deserializer.prototype.__proto__ || Object.getPrototypeOf(v101Deserializer.prototype), '_deserializeOperation', this).call(this, operation);
    }

    /**
     * Deserializes the given crop operation
     * @param  {PhotoEditorSDK.Operation} operation
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeCropOperation',
    value: function _deserializeCropOperation(operation) {
      // New in 1.0.1: `dimensions` option
      var options = operation.options;
      var rotation = options.rotation;

      var start = _globals.Vector2.fromObject(options.start);
      var end = _globals.Vector2.fromObject(options.end);
      var dimensions = options.dimensions ? _globals.Vector2.fromObject(options.dimensions) : null;

      // Normalize rotation
      if (rotation > Math.PI) {
        rotation -= Math.PI * 2;
      }

      var cropOptions = {
        start: start, end: end
      };

      if (typeof rotation !== 'undefined') cropOptions.rotation = rotation;

      var transformOperation = this._editor.operations.getOrCreate('transform');
      if (!transformOperation) return Promise.resolve();

      this._editor.broadcastTransform(transformOperation, cropOptions);
      transformOperation.set(cropOptions);

      if (dimensions) {
        var size = end.clone().subtract(start);
        var transformDimensions = transformOperation.getInputDimensions(false).multiply(size);
        transformOperation.setTextureScale(dimensions.x / transformDimensions.x);
      }

      return Promise.resolve(transformOperation);
    }
  }]);

  return v101Deserializer;
}(_deserializer2.default);

exports.default = v101Deserializer;


v101Deserializer.version = '1.0.1';

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _OverlayFilter$BLEND_;

var _globals = __webpack_require__(0);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OverlayFilter = _globals.SDK.Engine.Filters.OverlayFilter;
exports.default = (_OverlayFilter$BLEND_ = {}, _defineProperty(_OverlayFilter$BLEND_, OverlayFilter.BLEND_MODES.NORMAL, 'normal'), _defineProperty(_OverlayFilter$BLEND_, OverlayFilter.BLEND_MODES.OVERLAY, 'overlay'), _defineProperty(_OverlayFilter$BLEND_, OverlayFilter.BLEND_MODES.HARD_LIGHT, 'hard light'), _defineProperty(_OverlayFilter$BLEND_, OverlayFilter.BLEND_MODES.SOFT_LIGHT, 'soft light'), _defineProperty(_OverlayFilter$BLEND_, OverlayFilter.BLEND_MODES.MULTIPLY, 'multiply'), _defineProperty(_OverlayFilter$BLEND_, OverlayFilter.BLEND_MODES.DARKEN, 'darken'), _defineProperty(_OverlayFilter$BLEND_, OverlayFilter.BLEND_MODES.LIGHTEN, 'lighten'), _defineProperty(_OverlayFilter$BLEND_, OverlayFilter.BLEND_MODES.SCREEN, 'screen'), _defineProperty(_OverlayFilter$BLEND_, OverlayFilter.BLEND_MODES.COLOR_BURN, 'color burn'), _OverlayFilter$BLEND_);

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _serializer = __webpack_require__(31);

var _serializer2 = _interopRequireDefault(_serializer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var v300Serializer = function (_PreviousSerializer) {
  _inherits(v300Serializer, _PreviousSerializer);

  function v300Serializer() {
    _classCallCheck(this, v300Serializer);

    return _possibleConstructorReturn(this, (v300Serializer.__proto__ || Object.getPrototypeOf(v300Serializer)).apply(this, arguments));
  }

  _createClass(v300Serializer, [{
    key: 'serialize',

    /**
     * Serializes the editor state
     * @param {Object} options = {}
     * @return {Promise}
     */
    value: function serialize() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return _get(v300Serializer.prototype.__proto__ || Object.getPrototypeOf(v300Serializer.prototype), 'serialize', this).call(this, options).then(function (data) {
        data.meta = {
          platform: 'html5',
          version: _this2._editor.getSDK().version,
          createdAt: _globals.SDKUtils.ISODateString(new Date())
        };
        data.image = data.inputImage;
        delete data.inputImage;
        return data;
      });
    }

    /**
     * Serializes the given sticker
     * @param  {PhotoEditorSDK.Operation} operation
     * @param  {PhotoEditorSDK.Operations.SpriteOperation.StickerSprite} sprite
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeSticker',
    value: function _serializeSticker(operation, sprite) {
      var response = _get(v300Serializer.prototype.__proto__ || Object.getPrototypeOf(v300Serializer.prototype), '_serializeSticker', this).call(this, operation, sprite);
      response.options.alpha = sprite.getAlpha();

      if (response.options.tintColor) {
        response.options.tintColor = {
          rgba: response.options.tintColor
        };
      }

      return response;
    }

    /**
     * Serializes the given text sprite
     * @param  {PhotoEditorSDK.Operation} operation
     * @param  {PhotoEditorSDK.Operations.SpriteOperation.TextSprite} sprite
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeText',
    value: function _serializeText(operation, sprite) {
      var response = _get(v300Serializer.prototype.__proto__ || Object.getPrototypeOf(v300Serializer.prototype), '_serializeText', this).call(this, operation, sprite);
      response.options.color = {
        rgba: response.options.color
      };
      response.options.backgroundColor = {
        rgba: response.options.backgroundColor
      };
      response.options.flipHorizontally = false;
      response.options.flipVertically = false;
      delete response.options.fontWeight;
      return response;
    }

    /**
     * Serializes the given path
     * @param  {PhotoEditorSDK.Operations.SpriteOperation.BrushSprite.Path} path
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializePath',
    value: function _serializePath(path) {
      var response = _get(v300Serializer.prototype.__proto__ || Object.getPrototypeOf(v300Serializer.prototype), '_serializePath', this).call(this, path);

      delete response.hardness;
      delete response.size;
      delete response.color;

      var brush = path.getBrush();
      response.brush = brush.serializeOptions(['identifier', 'size', 'color'], true);
      if (typeof response.brush.identifier === 'undefined') {
        delete response.brush.identifier;
      }
      response.brush.color = {
        rgba: response.brush.color
      };

      var hardness = brush.getOption('hardness');
      if (hardness !== 'undefined') {
        response.brush.hardness = hardness;
      }
      return response;
    }

    /**
     * Serializes the frame operation
     * @param {PhotoEditorSDK.Operation.FrameOperation} operation
     * @param {PhotoEditorSDK.Operation[]} operations
     * @private
     */

  }, {
    key: '_serializeFrameOperation',
    value: function _serializeFrameOperation(operation, operations) {
      _get(v300Serializer.prototype.__proto__ || Object.getPrototypeOf(v300Serializer.prototype), '_serializeFrameOperation', this).call(this, operation, operations);

      // Find sprite operation and frame sprite from serialized data
      var spriteOperations = operations.filter(function (o) {
        return o.type === 'sprite';
      });
      var spriteOperation = void 0;
      if (spriteOperations.length) {
        spriteOperation = spriteOperations.pop();
        var frame = spriteOperation.options.sprites.filter(function (s) {
          return s.type === 'frame';
        })[0];

        var tintColor = operation.getTintColor();
        if (!tintColor.equals(new _globals.Color(1, 1, 1, 0))) {
          frame.options.tintColor = {
            rgba: operation.serializeOption('tintColor', true)
          };
        }

        var options = operation.serializeOptions(['scale', 'alpha'], true);
        frame.options = _globals.SDKUtils.extend(frame.options, options);
        frame.options.size = frame.options.scale;
        delete frame.options.scale;
      }
    }

    /**
     * Serializes the given transform operation
     * @param  {PhotoEditorSDK.Operation.TransformOperation} operation
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeTransformOperation',
    value: function _serializeTransformOperation(operation) {
      var response = _get(v300Serializer.prototype.__proto__ || Object.getPrototypeOf(v300Serializer.prototype), '_serializeTransformOperation', this).call(this, operation);

      if (operation._ratio) {
        response.options.meta = {
          identifier: operation._ratio.identifier
        };
      }
      delete response.options.scale;

      return response;
    }

    /**
     * Serializes the given adjustments operation
     * @param  {PhotoEditorSDK.Operations.AdjustmentsOperation} operation
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeAdjustmentsOperation',
    value: function _serializeAdjustmentsOperation(operation) {
      var response = _get(v300Serializer.prototype.__proto__ || Object.getPrototypeOf(v300Serializer.prototype), '_serializeAdjustmentsOperation', this).call(this, operation);

      var optionNames = ['gamma', 'whites', 'blacks', 'temperature'];

      var availableOptions = operation.availableOptions;

      var options = {};
      optionNames.forEach(function (optionName) {
        var option = availableOptions[optionName];
        var value = operation.getOption(optionName);
        var minValue = option.minValue,
            midValue = option.midValue,
            maxValue = option.maxValue;

        options[optionName] = value <= midValue ? (value - minValue) / (midValue - minValue) - 1 : (value - midValue) / (maxValue - midValue);
      });

      response.options = _extends({}, response.options, options);

      return response;
    }

    /**
     * Serializes the given operation
     * @param  {PhotoEditorSDK.Operation} operation
     * @param  {PhotoEditorSDK.Operation[]} operations
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeOperation',
    value: function _serializeOperation(operation, operations) {
      switch (operation.constructor.identifier) {
        case 'mirrored-focus':
          return this._serializeMirroredFocusOperation(operation);
        case 'linear-focus':
          return this._serializeLinearFocusOperation(operation);
        case 'blur':
          return this._serializeBlurOperation(operation);
        default:
          return _get(v300Serializer.prototype.__proto__ || Object.getPrototypeOf(v300Serializer.prototype), '_serializeOperation', this).call(this, operation, operations);
      }
    }

    /**
     * Serializes the given mirrored focus operation
     * @param  {PhotoEditorSDK.Operations.MirroredFocusOperation} operation
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeMirroredFocusOperation',
    value: function _serializeMirroredFocusOperation(operation) {
      return {
        type: 'focus',
        options: {
          type: 'mirrored',
          options: operation.serializeOptions(['start', 'end', 'blurRadius', 'size', 'gradientSize'], true)
        }
      };
    }

    /**
     * Serializes the given linear focus operation
     * @param  {PhotoEditorSDK.Operations.LinearFocusOperation} operation
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeLinearFocusOperation',
    value: function _serializeLinearFocusOperation(operation) {
      var options = operation.serializeOptions(['controlPoint1', 'controlPoint2', 'blurRadius'], true);
      options.start = options.controlPoint1;
      delete options.controlPoint1;
      options.end = options.controlPoint2;
      delete options.controlPoint2;

      return {
        type: 'focus',
        options: {
          type: 'linear',
          options: options
        }
      };
    }

    /**
     * Serializes the given blur operation
     * @param  {PhotoEditorSDK.Operations.BlurOperation} operation
     * @return {Object}
     * @private
     */

  }, {
    key: '_serializeBlurOperation',
    value: function _serializeBlurOperation(operation) {
      return {
        type: 'focus',
        options: {
          type: 'gaussian',
          options: operation.serializeOptions(['blurRadius'], true)
        }
      };
    }
  }]);

  return v300Serializer;
}(_serializer2.default);

exports.default = v300Serializer;


v300Serializer.version = '3.0.0';

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _deserializer = __webpack_require__(32);

var _deserializer2 = _interopRequireDefault(_deserializer);

var _stickerManager = __webpack_require__(11);

var _stickerManager2 = _interopRequireDefault(_stickerManager);

var _textDesignManager = __webpack_require__(58);

var _textDesignManager2 = _interopRequireDefault(_textDesignManager);

var _imageLoader = __webpack_require__(23);

var _imageLoader2 = _interopRequireDefault(_imageLoader);

var _fontManager = __webpack_require__(15);

var _fontManager2 = _interopRequireDefault(_fontManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var Brush = void 0;
if (typeof _globals.SDK.Operations.SpriteOperation !== 'undefined') {
  Brush = _globals.SDK.Operations.SpriteOperation.BrushSprite.Brush;
}

var v300Deserializer = function (_PreviousDeserializer) {
  _inherits(v300Deserializer, _PreviousDeserializer);

  function v300Deserializer() {
    _classCallCheck(this, v300Deserializer);

    return _possibleConstructorReturn(this, (v300Deserializer.__proto__ || Object.getPrototypeOf(v300Deserializer)).apply(this, arguments));
  }

  _createClass(v300Deserializer, [{
    key: '_deserializeSticker',

    /**
     * Deserializes the given sticker for the given operation
     * @param  {Object} operation
     * @param  {Object} sprite
     * @return {PhotoEditorSDK.Operations.SpriteOperation.StickerSprite}
     * @private
     */
    value: function _deserializeSticker(operation, sprite) {
      var SpriteOperation = _globals.SDK.Operations.SpriteOperation;
      var options = sprite.options;

      var sticker = this._stickerManager.getStickerByIdentifier(options.identifier);
      if (!sticker) {
        _globals.Log.warn('Deserializer', 'Unknown sticker `' + options.identifier + '`. Skipping sprite.');
        return Promise.resolve();
      }
      var url = _stickerManager2.default.getURLForSticker(sticker, 'base');
      var resolvedUrl = this._editor.getUI().getAssetPath(url);
      var inputDimensions = operation.getInputDimensions(false);
      return _imageLoader2.default.load(resolvedUrl).then(function (image) {
        var adjustments = SpriteOperation.StickerSprite.prototype.availableOptions.adjustments.structure;
        var rotation = options.rotation,
            flipHorizontally = options.flipHorizontally,
            flipVertically = options.flipVertically;

        var stickerOptions = {
          identifier: options.identifier,
          image: image,
          position: _globals.Vector2.fromObject(options.position),
          dimensions: _globals.Vector2.fromObject(options.dimensions).multiply(inputDimensions.min()),
          rotation: rotation || 0,
          flipHorizontally: flipHorizontally,
          flipVertically: flipVertically,
          adjustments: {}
        };

        if (typeof options.adjustments !== 'undefined') {
          ['brightness', 'contrast', 'saturation'].forEach(function (option) {
            if (typeof options.adjustments[option] !== 'undefined') {
              stickerOptions.adjustments[option] = options.adjustments[option] + adjustments[option].default;
            }
          });
        }

        if (typeof options.tintColor !== 'undefined' && typeof sticker.tintMode !== 'undefined') {
          stickerOptions.tintColor = _globals.Color.fromArray(options.tintColor.rgba);
          stickerOptions.tintMode = sticker.tintMode;
        }

        if (typeof options.alpha !== 'undefined') {
          stickerOptions.alpha = options.alpha;
        }

        return operation.createSticker(stickerOptions);
      });
    }

    /**
     * Deserializes the given transform operation
     * @param  {Object} operationData
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeTransformOperation',
    value: function _deserializeTransformOperation(operationData) {
      return _get(v300Deserializer.prototype.__proto__ || Object.getPrototypeOf(v300Deserializer.prototype), '_deserializeTransformOperation', this).call(this, operationData).then(function (operation) {
        if (!operation) return;

        // TODO: Get correct ratio
        operation._ratio = null;
        return operation;
      });
    }

    /**
     * Deserializes the input image (if present)
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeInputImage',
    value: function _deserializeInputImage() {
      var _this2 = this;

      var _data$image = this._data.image,
          data = _data$image.data,
          type = _data$image.type,
          uri = _data$image.uri;


      if (data && type) {
        uri = 'data:' + type + ';base64,' + data;
      }

      if (uri) {
        return _imageLoader2.default.load(uri).then(function (image) {
          _this2._editor.setImage(image);
        });
      } else {
        return Promise.resolve();
      }
    }

    /**
     * Deserializes the given adjustments operation
     * @param  {Object} operationData
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeAdjustmentsOperation',
    value: function _deserializeAdjustmentsOperation(operationData) {
      var AdjustmentsOperation = _globals.SDK.Operations.AdjustmentsOperation;

      return _get(v300Deserializer.prototype.__proto__ || Object.getPrototypeOf(v300Deserializer.prototype), '_deserializeAdjustmentsOperation', this).call(this, operationData).then(function (operation) {
        if (!operation) return null;

        var options = operationData.options;

        var knownOptions = ['gamma', 'whites', 'blacks', 'temperature'];
        var operationOptions = {};

        knownOptions.forEach(function (optionName) {
          if (typeof options[optionName] === 'undefined') return;

          var _AdjustmentsOperation = AdjustmentsOperation.prototype.availableOptions[optionName],
              minValue = _AdjustmentsOperation.minValue,
              midValue = _AdjustmentsOperation.midValue,
              maxValue = _AdjustmentsOperation.maxValue;

          var value = options[optionName];

          value = value < 0 ? midValue + (midValue - minValue) * value : midValue + (maxValue - midValue) * value;
          operationOptions[optionName] = value;
        });

        operation.set(operationOptions);

        return operation;
      });
    }

    /**
     * Deserializes the given focus operation
     * @param  {Object} operationData
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeFocusOperation',
    value: function _deserializeFocusOperation(operationData) {
      var options = operationData.options.options;

      switch (operationData.options.type) {
        case 'radial':
          return _get(v300Deserializer.prototype.__proto__ || Object.getPrototypeOf(v300Deserializer.prototype), '_deserializeFocusOperation', this).call(this, operationData);
        case 'linear':
          {
            var start = options.start,
                end = options.end,
                blurRadius = options.blurRadius;

            return Promise.resolve(this._editor.operations.getOrCreate('linear-focus', {
              controlPoint1: _globals.Vector2.fromObject(start),
              controlPoint2: _globals.Vector2.fromObject(end),
              blurRadius: blurRadius
            }));
          }
        case 'mirrored':
          {
            var _start = options.start,
                _end = options.end,
                size = options.size,
                gradientSize = options.gradientSize,
                _blurRadius = options.blurRadius;

            return Promise.resolve(this._editor.operations.getOrCreate('mirrored-focus', {
              start: _globals.Vector2.fromObject(_start),
              end: _globals.Vector2.fromObject(_end),
              size: size,
              gradientSize: gradientSize,
              blurRadius: _blurRadius
            }));
          }
        case 'gaussian':
          {
            var _blurRadius2 = options.blurRadius;

            return Promise.resolve(this._editor.operations.getOrCreate('blur', {
              blurRadius: _blurRadius2
            }));
          }
      }
    }

    /**
     * Deserializes the given text for the given operation
     * @param  {PhotoEditorSDK.Operations.SpriteOperation} operation
     * @param  {Object} text
     * @return {PhotoEditorSDK.Operations.SpriteOperation.TextSprite}
     * @private
     */

  }, {
    key: '_deserializeText',
    value: function _deserializeText(operation, text) {
      var options = text.options;
      var fontSize = options.fontSize,
          lineHeight = options.lineHeight,
          fontIdentifier = options.fontIdentifier,
          alignment = options.alignment,
          rotation = options.rotation,
          maxWidth = options.maxWidth,
          color = options.color,
          backgroundColor = options.backgroundColor;


      var fontLoader = this._ui.getFontLoader();
      var variation = this._fontManager.getVariationByIdentifier(fontIdentifier);
      if (!variation) {
        variation = this._fontManager.getDefaultVariation();
      } else {
        fontLoader.setFonts([variation.getFont()]);
      }
      return fontLoader.load().then(function () {
        var inputDimensions = operation.getInputDimensions(false);

        // For whatever reason, max width is relative to shortest side, while font size isn't
        var fixedMaxWidth = maxWidth * inputDimensions.min() / inputDimensions.x;
        return operation.createText({
          fontSize: fontSize,
          lineHeight: lineHeight,
          fontFamily: variation.getFontFamily(),
          fontWeight: variation.getFontWeight(),
          fontIdentifier: variation.getIdentifier(),
          textMetrics: variation.getTextMetrics(),
          alignment: alignment,
          rotation: rotation,
          maxWidth: fixedMaxWidth,
          text: options.text,
          color: _globals.Color.fromArray(color.rgba),
          backgroundColor: _globals.Color.fromArray(backgroundColor.rgba),
          position: _globals.Vector2.fromObject(options.position)
        });
      });
    }

    /**
     * Creates a brush face with the given options
     * @param  {PhotoEditorSDK.Operations.SpriteOperation.Sprites.BrushSprite.Path} path
     * @return {PhotoEditorSDK.Operations.SpriteOperation.Sprites.BrushSprite.Brush}
     */

  }, {
    key: '_createBrushForPath',
    value: function _createBrushForPath(path) {
      var _path$brush = path.brush,
          identifier = _path$brush.identifier,
          color = _path$brush.color,
          size = _path$brush.size,
          hardness = _path$brush.hardness;

      var colorObject = _globals.Color.fromArray(color.rgba);

      var brushOptions = {
        color: colorObject,
        size: size
      };

      if (typeof hardness !== 'undefined') {
        brushOptions.hardness = hardness;
      }

      var rawBrush = this._brushManager.getBrushByIdentifier(identifier);
      if (!rawBrush) {
        rawBrush = this._brushManager.getFirstBrush();
      }

      if (rawBrush.prototype && rawBrush.prototype instanceof Brush) {
        // Custom Brush instance, used for special brushes such as radial brush, which has
        // an additional hardness option
        var BrushClass = rawBrush;
        return new BrushClass(brushOptions);
      } else {
        var _brush = _globals.SDKUtils.extend({}, rawBrush);
        delete _brush.image;

        var _BrushClass = function (_Brush) {
          _inherits(_BrushClass, _Brush);

          function _BrushClass() {
            _classCallCheck(this, _BrushClass);

            return _possibleConstructorReturn(this, (_BrushClass.__proto__ || Object.getPrototypeOf(_BrushClass)).apply(this, arguments));
          }

          return _BrushClass;
        }(Brush);

        _BrushClass.identifier = rawBrush.identifier;

        // Plain JS object, used for simple image brushes
        return new _BrushClass(_globals.SDKUtils.extend({}, _brush, brushOptions));
      }
    }

    /**
     * Deserializes the given frame sprite
     * @param  {PhotoEditorSDK.Operations.SpriteOperation}
     * @param  {Object} framespriteOperation
     * @return {Promise}
     * @private
     */

  }, {
    key: '_deserializeFrame',
    value: function _deserializeFrame(spriteOperation, frame) {
      var _this4 = this;

      return _get(v300Deserializer.prototype.__proto__ || Object.getPrototypeOf(v300Deserializer.prototype), '_deserializeFrame', this).call(this, spriteOperation, frame).then(function () {
        var frameOperation = _this4._editor.operations.get('frame');

        var _frame$options = frame.options,
            size = _frame$options.size,
            alpha = _frame$options.alpha,
            tintColor = _frame$options.tintColor;

        var options = {};
        if (typeof size !== 'undefined') {
          options.scale = size;
        }
        if (typeof alpha !== 'undefined') {
          options.alpha = alpha;
        }
        if (typeof tintColor !== 'undefined') {
          options.tintColor = _globals.Color.fromArray(tintColor.rgba);
        }
        frameOperation.set(options);
      });
    }
  }, {
    key: '_deserializeTextDesign',
    value: function _deserializeTextDesign(operation, sprite) {
      var _this5 = this;

      var options = sprite.options;
      var position = options.position,
          rotation = options.rotation,
          flipHorizontally = options.flipHorizontally,
          flipVertically = options.flipVertically,
          text = options.text,
          color = options.color,
          width = options.width,
          seed = options.seed,
          inverted = options.inverted,
          identifier = options.identifier;


      var textDesignManager = new _textDesignManager2.default(this._ui, this._getOptions('textdesign'));
      var fontManager = new _fontManager2.default(this._ui, { fonts: _globals.Constants.DEFAULTS.TEXT_DESIGN_FONTS, replaceFonts: true });
      var AssetManager = operation.constructor.TextDesignSprite.AssetManager;
      var fontLoader = this._ui.getFontLoader();

      var Layout = textDesignManager.getLayoutByIdentifier(identifier);

      var layout = new Layout();

      fontLoader.setFonts(fontManager.getFonts());

      AssetManager.setFonts(_extends({}, AssetManager.getFonts(), fontManager.getVariationsByIdentifier()));

      return fontLoader.load().then(function () {
        var images = layout.getImagePaths().map(function (path) {
          return { path: path, fullPath: _this5._ui.getAssetPath(path), image: null };
        });
        return AssetManager.loadImages(images).then(function () {
          layout.onImagesLoaded();

          return operation.createTextDesign({
            position: position,
            rotation: rotation,
            flipHorizontally: flipHorizontally,
            flipVertically: flipVertically,
            text: text,
            color: _globals.Color.fromArray(color.rgba),
            width: width,
            seed: seed,
            inverted: inverted,
            layout: layout
          });
        });
      });
    }
  }]);

  return v300Deserializer;
}(_deserializer2.default);

exports.default = v300Deserializer;


v300Deserializer.version = '3.0.0';

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _globals = __webpack_require__(0);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TextDesignManager = function () {
  function TextDesignManager(ui) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, TextDesignManager);

    this._ui = ui;
    this._options = options;

    this._defaultLayouts = _globals.SDK.Operations.SpriteOperation.TextDesignSprite.Layouts;
    this._layouts = [];
    this._init();
  }

  _createClass(TextDesignManager, [{
    key: '_init',
    value: function _init() {
      var _this = this;

      var availableLayouts = this._options.availableLayouts;

      this._layouts = Object.keys(this._defaultLayouts).map(function (k) {
        return {
          identifier: _this._defaultLayouts[k].identifier,
          layout: _this._defaultLayouts[k]
        };
      });

      if (availableLayouts) {
        this._layouts = this._layouts.filter(function (item) {
          return availableLayouts.indexOf(item.identifier) >= 0;
        });
      }
    }
  }, {
    key: 'getLayoutByIdentifier',
    value: function getLayoutByIdentifier(identifier) {
      var item = _globals.SDKUtils.Array.find(this._layouts, function (l) {
        return l.identifier === identifier;
      });
      return item && item.layout;
    }
  }, {
    key: 'getLayouts',
    value: function getLayouts() {
      return [].concat(_toConsumableArray(this._layouts));
    }
  }]);

  return TextDesignManager;
}();

exports.default = TextDesignManager;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* @module */
/*!
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

__webpack_require__(60);

module.exports = __webpack_require__(61).default;

/***/ }),
/* 60 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _appComponent = __webpack_require__(87);

var _appComponent2 = _interopRequireDefault(_appComponent);

var _scrollbarComponent = __webpack_require__(2);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

var _controlsComponent = __webpack_require__(3);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _modalManager = __webpack_require__(1);

var _modalManager2 = _interopRequireDefault(_modalManager);

var _jsonLoader = __webpack_require__(22);

var _jsonLoader2 = _interopRequireDefault(_jsonLoader);

var _preloader = __webpack_require__(196);

var _preloader2 = _interopRequireDefault(_preloader);

var _photoRoll = __webpack_require__(197);

var PhotoRoll = _interopRequireWildcard(_photoRoll);

var _controls = __webpack_require__(4);

var _controls2 = _interopRequireDefault(_controls);

var _controls3 = __webpack_require__(44);

var Controls = _interopRequireWildcard(_controls3);

var _sliderComponent = __webpack_require__(13);

var _sliderComponent2 = _interopRequireDefault(_sliderComponent);

var _sliderOverlayComponent = __webpack_require__(6);

var _sliderOverlayComponent2 = _interopRequireDefault(_sliderOverlayComponent);

var _fontLoader = __webpack_require__(30);

var _fontLoader2 = _interopRequireDefault(_fontLoader);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 * @license
 */


var bd = function bd(str) {
  return _globals.SDKUtils.byteArrayToString(_globals.Base64.decode(str));
};

/**
 * The React UI
 * @class
 * @extends PhotoEditorSDK.EventEmitter
 * @memberof PhotoEditorSDK.UI
 */

var ReactUI = function (_EventEmitter) {
  _inherits(ReactUI, _EventEmitter);

  /**
   * Creates an UI instance
   * @param  {Object} options
   * @param  {String} options.license - Your license
   * @param  {DOMElement} options.container - The container that the UI should be rendered to
   * @param  {String} [options.title = 'PhotoEditor SDK']
   * @param  {String} [options.language = 'en'] - Currently `en` and `de` are supported
   * @param  {String} [options.logLevel] - `trace`, `info`, `warn`, `error` or `log`
   * @param  {Boolean} [options.responsive = false] - Should the editor re-render on window resize?
   *
   * @param  {Boolean} [options.enableUpload = true] - Should the user be able to upload their own photos?
   * @param  {Boolean} [options.enableWebcam = true] - Enables webcam support. Disabled on mobile devices.
   *
   * @param  {Boolean} [options.showCloseButton = false] - Should the close button be displayed?
   * @param  {Boolean} [options.showHeader = true] - Should the header (with title text) be displayed?
   *                                                 Should only be set to `false` by licensees.
   * @param  {Boolean} [options.showTopBar = true] - Should the top bar (new / zoom / undo / export) be displayed?
   * @param  {String} [options.crossOrigin = 'anonymous'] - 'anonymous', 'use-credentials' or 'none'
    * @param  {Object} [options.photoRoll]
   * @param  {PhotoEditorSDK.UI.ReactUI.PhotoRoll.Provider} provider - The class providing all data
   *                                                                 for the photo roll
   *
   * @param  {Object} [options.editor]
   * @param  {Image} [options.editor.image] - The image that the user can edit
   * @param  {Image} [options.editor.watermarkImage] - An image that should be placed on top as a watermark
   * @param  {String} [options.editor.preferredRenderer = 'webgl'] - `webgl` or `canvas`
   * @param  {Number} [options.editor.pixelRatio = 1] - If none is given, PhotoEditorSDK automatically
   *   detects the current device's pixel ratio
   * @param  {Boolean} [options.editor.enableDrag = true] - Should dragging the canvas be enabled?
   * @param  {Boolean} [options.editor.enableZoom = true] - Should zooming be enabled?
   * @param  {Boolean} [options.editor.smoothDownscaling = false] - Toggles smooth downscaling
   * @param  {Boolean} [options.editor.smoothUpscaling = false] - Toggles smooth upscaling
   * @param  {Boolean} [options.editor.displayResizeMessage = true] - Should a message be displayed
   *                                                       when the image has been scaled down
   *                                                       for performance?
   * @param  {(String[]|Array[])} [options.editor.controlsOrder] - The order in which the controls are displayed.
   *                                           Available are `transform`, `filter`,
   *                                           `adjustments`, `text`, `sticker`, `brush`, `focus`,
   *                                           `frame`. Can be grouped in arrays which will be
   *                                           displayed with separators.
   * @param  {String[]} [options.editor.operationsOrder] - The order in which operations are added to
   *                                              the stack. Changing this may affect the
   *                                              performance.
   * @param  {Object} [options.editor.controlsOptions] - Options that are passed to specific controls. See
   *                                            the documentation for each control to learn more
   *                                            about available values.
   * @param {Object[]} [options.editor.forceControls] - An array of objects specifying the controls
   *                                                  the user needs to use before being able to
   *                                                  use the actual editor.
   * @param {Object[]} [options.editor.forceCrop] - If true, the editor will lauch to the transform tool
   *                                                for cropping, before any other tool is allowed.
   *
   * @param  {Object} [options.editor.maxMegaPixels] - Maximum amount of megapixels per device type
   * @param  {Number} [options.editor.maxMegaPixels.desktop = 10]
   * @param  {Number} [options.editor.maxMegaPixels.mobile = 5]
   *
   * @param  {Object} [options.editor.export]
   * @param  {Boolean} [options.editor.export.showButton = true] - Should the `export` button be displayed?
   * @param  {String} [options.editor.export.format = 'image/png'] - The export format. Available formats
   * @param  {PhotoEditorSDK.RenderType} [options.editor.export.type] - The export type (image or data url)
   * @param  {Boolean} [options.editor.export.download] - Should the result be presented as a download?
   * @param  {String} [options.editor.export.fileBasename = 'photoeditorsdk-export'] - The basename
   *                                                      of the exported file (file extension will
   *                                                      be added automatically)
   * @param {Number} [options.editor.export.quality = 0.8] - The export quality (0...1, only supported
   *                                                for JPG images)
   *
   * @param  {Object} [options.assets]
   * @param  {String} [options.assets.baseUrl = '/assets'] - Path that is prepended to all asset paths
   * @param  {Function} [options.assets.resolver] - A function resolving a path to another path.
   */
  function ReactUI() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ReactUI);

    var _this = _possibleConstructorReturn(this, (ReactUI.__proto__ || Object.getPrototypeOf(ReactUI)).call(this));

    _this._mediator = new _globals.EventEmitter();
    _this._fontLoader = new _fontLoader2.default(_this);
    _this._options = options;
    _this._initOptions();
    _this._initLanguage();
    _this._initEvents();
    _this._disposed = false;

    _this._isReady = false;
    _this._mediator.once(_globals.Constants.EVENTS.EDITOR_READY, function () {
      _this._isReady = true;
    });

    _this._globalState = new _globals.SharedState();

    _this._preloader = new _preloader2.default(_this, _this._options, _this._mediator);

    _globals.Log.setLevel(_this._options.logLevel);

    if (!_this._options.license || _this._v()) {
      _this.run();
    }
    return _this;
  }

  /**
   * Main entry point for the UI
   * @private
   */


  _createClass(ReactUI, [{
    key: 'run',
    value: function run() {
      this._registerWebFonts();

      // Container has to be position: relative
      this._options.container.style.position = 'relative';
      this._render();
    }

    /**
     * Renders the UI
     * @private
     */

  }, {
    key: '_render',
    value: function _render() {
      var _this2 = this;

      var component = _globals.React.createElement(_appComponent2.default, {
        ui: this,
        mediator: this._mediator,
        ref: function ref(c) {
          _this2._component = c;
        },
        globalState: this._globalState,
        options: this._options });

      if (this._options.renderReturnsComponent) {
        return component;
      } else {
        _globals.ReactDOM.render(component, this._options.container);
      }
    }

    /**
     * Exports an image
     * @param {Boolean} download = false
     * @return {Promise}
     */

  }, {
    key: 'export',
    value: function _export() {
      var _component;

      return (_component = this._component).export.apply(_component, arguments);
    }

    /**
     * Serializes the editor state
     * @return {Promise}
     */

  }, {
    key: 'serialize',
    value: function serialize() {
      var _component2;

      return (_component2 = this._component).serialize.apply(_component2, arguments);
    }

    /**
     * Deserializes the given data
     * @param  {Object} data
     * @return {Promise}
     */

  }, {
    key: 'deserialize',
    value: function deserialize(data) {
      return this._component.deserialize(data);
    }

    /**
     * Returns the editor
     * @return {PhotoEditorSDK.UI.ReactUI.Editor}
     */

  }, {
    key: 'getEditor',
    value: function getEditor() {
      return this._component.getEditor();
    }

    /**
     * Returns true if the editor is ready for doing operations, e.g.,
     * serializing, deserializing and exporting.
     *
     * @returns {Boolean}
     */

  }, {
    key: 'isReady',
    value: function isReady() {
      return this._isReady;
    }

    /**
     * Calls a callback when the editor is ready, or immeditially if it's already
     * in a ready state.
     *
     * @param {Function} cb
     */

  }, {
    key: 'onReady',
    value: function onReady(cb) {
      if (!this._isReady) {
        this._mediator.once(_globals.Constants.EVENTS.EDITOR_READY, cb);
        this._isReady = true;
      } else {
        cb();
      }
    }

    // -------------------------------------------------------------------------- INITIALIZATION

    /**
     * Initializes the default options
     * @private
     */

  }, {
    key: '_initOptions',
    value: function _initOptions() {
      this._options = _globals.SDKUtils.defaults(this._options, {
        language: 'en',
        title: 'PhotoEditor SDK',
        logLevel: 'warn',
        crossOrigin: 'anonymous',

        preloader: true,

        editor: {},
        assets: {},
        photoRoll: {},

        enableUpload: true,
        enableWebcam: true,

        showCloseButton: false,
        showHeader: true,
        showTopBar: true,
        responsive: false
      });

      this._options.editor = _globals.SDKUtils.defaults(this._options.editor || {}, {
        pixelRatio: typeof window !== 'undefined' && window.devicePixelRatio || 1,
        preferredRenderer: 'webgl',
        enableZoom: true,
        enableDrag: true,
        smoothDownscaling: false,
        smoothUpscaling: false,
        displayResizeMessage: true,
        maxMegaPixels: {},
        forceControls: [],
        forceCrop: false,
        watermarkImage: null,
        tools: ['transform', 'filter', 'brightness', 'saturation', 'contrast', 'clarity', 'exposure', 'shadows', 'highlights', 'gamma', 'whites', 'blacks', 'temperature', 'text', 'sticker', 'brush', 'radial-focus', 'mirrored-focus', 'frame'],
        controlsOrder: ['transform', ['filter', 'adjustments'], ['text', 'sticker', 'brush'], ['selectiveBlur', 'focus', 'frame']],
        operationsOrder: [
        // First, all operations that affect the image dimensions
        'exif-orientation', // Automatically created by SDK
        'orientation', 'transform',

        // Then color operations (first filter, then fine-tuning)
        'filter', 'adjustments',

        // Then post-processing
        'radial-focus', 'mirrored-focus', 'selective-blur', 'sprite', 'frame', 'watermark'],
        controlsOptions: {}
      });

      this._options.editor.maxMegaPixels = _globals.SDKUtils.defaults(this._options.editor.maxMegaPixels, {
        mobile: 5,
        desktop: 10
      });

      this._options.editor.export = _globals.SDKUtils.defaults(this._options.editor.export || {}, {
        showButton: true,
        format: 'image/png',
        type: _globals.RenderType.IMAGE,
        download: true,
        fileBasename: 'photoeditorsdk-export',
        quality: 0.8
      });

      this._options.photoRoll = _globals.SDKUtils.defaults(this._options.photoRoll || {}, {
        provider: null
      });

      this._options.extensions = _globals.SDKUtils.defaults(this._options.extensions || {}, {
        languages: {},
        operations: [],
        controls: []
      });

      this._options.assets = _globals.SDKUtils.defaults(this._options.assets || {}, {
        baseUrl: 'assets',
        resolver: null
      });
    }

    /**
     * Validates presence of the API key
     * @return {Boolean}
     * @private
     */

  }, {
    key: '_v',
    value: function _v() {
      if (!this[bd('X29wdGlvbnM=')][bd('bGljZW5zZQ==')]) {
        // Log.error('license', 'No `license` option given.')
        _globals.Log.error(bd('TGljZW5zaW5n'), bd('Tm8gYGxpY2Vuc2VgIG9wdGlvbiBnaXZlbi4='));
        _globals.Log.error(bd('TGljZW5zaW5n'), bd('SW4gY2FzZSB5b3UgZG9uJ3QgaGF2ZSBhIGxpY2Vuc2UgeWV0LCBwbGVhc2UgY29udGFjdCBvdXIgc2FsZXMgc3RhZmYgYXQgc2FsZXNAcGhvdG9lZGl0b3JzZGsuY29tIHRvIG9idGFpbiBhIGxpY2Vuc2Ugb3IgbG9nIGluIHRvIHlvdXIgY3VzdG9tZXIgZGFzaGJvYXJkLg=='));
        return false;
      }
      return true;
    }

    /**
     * Creates a <style> block in <head> that specifies the web fonts
     * that we use in this UI. We're doing this in JS because the assets
     * path is dynamic.
     * @private
     */

  }, {
    key: '_registerWebFonts',
    value: function _registerWebFonts() {
      var regularFontPath = this.getAssetPath('fonts/montserrat-regular.woff', true, true);
      var lightFontPath = this.getAssetPath('fonts/montserrat-light.woff', true, true);

      var css = '\n      // Injected by PhotoEditorSDK\n      @font-face {\n        font-family: "__pesdk_Montserrat";\n        src: url(\'' + regularFontPath + '\') format(\'woff\');\n        font-weight: normal;\n        font-style: normal;\n      }\n\n      @font-face {\n        font-family: "__pesdk_Montserrat";\n        src: url(\'' + lightFontPath + '\') format(\'woff\');\n        font-weight: 100;\n        font-style: normal;\n      }\n    ';

      this._webFontsStyle = document.createElement('style');
      this._webFontsStyle.innerHTML = css;

      var head = document.getElementsByTagName('head')[0];
      head.appendChild(this._webFontsStyle);
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Catches mediator events and emits them here
     * @private
     */

  }, {
    key: '_initEvents',
    value: function _initEvents() {
      this._mediator.pipeEvents(this);
    }

    /**
     * Unpipes the vents
     * @private
     */

  }, {
    key: '_disposeEvents',
    value: function _disposeEvents() {
      this._mediator.unpipeEvents(this);
    }

    // -------------------------------------------------------------------------- I18N

    /**
     * Initializes the internationalization
     * @private
     */

  }, {
    key: '_initLanguage',
    value: function _initLanguage() {
      this._languages = _globals.SDKUtils.deepDefaults(this._options.extensions.languages, {
        de: __webpack_require__(202),
        en: __webpack_require__(203)
      });
      this._language = this._languages[this._options.language];
      if (!this._language) {
        _globals.Log.error(this.constructor.name, 'Language `' + this._options.language + '` not found!');
      }
    }

    /**
     * Returns the translation for `key`
     * @param  {String} key
     * @param  {Object} [interpolationOptions]
     * @return {String}
     */

  }, {
    key: 'translate',
    value: function translate(key, interpolationOptions) {
      return _globals.Utils.translate(this._language, key, interpolationOptions);
    }

    /**
     * Sets the image to the given one
     * @param {Image} image
     */

  }, {
    key: 'setImage',
    value: function setImage(image) {
      if (!this._component) return;
      this._component.setImage(image);
    }

    /**
     * Returns the resolved asset path for the given asset name
     * @param  {String} asset
     * @param  {Boolean} uiAsset = false
     * @param  {Boolean} disableRetina = false
     * @return {String}
     */

  }, {
    key: 'getAssetPath',
    value: function getAssetPath(asset) {
      var uiAsset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var disableRetina = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var _options$assets = this._options.assets,
          baseUrl = _options$assets.baseUrl,
          resolver = _options$assets.resolver;

      var path = baseUrl + '/' + asset;

      // Don't prepend baseUrl to absolute urls
      if (asset.match(/(ftp|http|https):\/\//)) {
        path = asset;
      }

      if (uiAsset) {
        if (!disableRetina) {
          // Append @2x if device's pixel ratio > 1
          var pixelRatio = typeof window !== 'undefined' && window.devicePixelRatio || 1;
          if (pixelRatio > 1) {
            var regex = /\.[\w?=]+$/;
            asset = asset.replace(regex, function (match) {
              return '@2x' + match;
            });
          }
        }

        path = baseUrl + '/ui/react/' + asset;
      }

      if (typeof resolver !== 'undefined' && resolver !== null) {
        path = resolver(path);
      }

      return path;
    }

    /**
     * Returns the font loader
     * @return {FontLoader}
     */

  }, {
    key: 'getFontLoader',
    value: function getFontLoader() {
      return this._fontLoader;
    }

    /**
     * Returns the preloader
     * @return {PhotoEditorSDK.Preloader}
     */

  }, {
    key: 'getPreloader',
    value: function getPreloader() {
      return this._preloader;
    }

    /**
     * Disposes the UI
     */

  }, {
    key: 'dispose',
    value: function dispose() {
      if (this._disposed) {
        throw new Error('This instance of PhotoEditorSDK is already disposed.');
      }
      this._disposed = true;

      // Remove web fonts style
      this._webFontsStyle.parentNode.removeChild(this._webFontsStyle);

      // Unmount AppComponent
      _globals.ReactDOM.unmountComponentAtNode(this._options.container);

      this._disposeEvents();
    }
  }]);

  return ReactUI;
}(_globals.EventEmitter);

/**
 * Export event
 *
 * @event PhotoEditorSDK.UI.ReactUI#export
 * @type {Image|String|Blob}
 */

/**
 * Operation created event
 *
 * @event PhotoEditorSDK.UI.ReactUI#operation:created
 * @type {PhotoEditorSDK.Operation}
 */

/**
 * Operation removed event
 *
 * @event PhotoEditorSDK.UI.ReactUI#operation:removed
 * @type {PhotoEditorSDK.Operation}
 */

/**
 * History undo event
 *
 * @event PhotoEditorSDK.UI.ReactUI#history:undo
 */

/**
 * Controls switched event
 *
 * @event PhotoEditorSDK.UI.ReactUI#controls:switched
 * @type {PhotoEditorSDK.UI.ReactUI.Controls}
 */

/**
 * A unique string that represents this UI
 * @type {String}
 */


ReactUI.prototype.identifier = 'react';

// Export extendable stuff
ReactUI.BaseComponent = _globals.BaseComponent;
ReactUI.BaseControls = _controls2.default;
ReactUI.ControlsComponent = _controlsComponent2.default;
ReactUI.React = _globals.React;
ReactUI.ReactBEM = _globals.ReactBEM;
ReactUI.SharedState = _globals.SharedState;
ReactUI.Constants = _globals.Constants;
ReactUI.Utils = _globals.Utils;
ReactUI.ScrollbarComponent = _scrollbarComponent2.default;
ReactUI.ModalManager = _modalManager2.default;
ReactUI.JSONLoader = _jsonLoader2.default;
ReactUI.PhotoRoll = PhotoRoll;
ReactUI.Controls = Controls;
ReactUI.SliderComponent = _sliderComponent2.default;
ReactUI.SliderOverlayComponent = _sliderOverlayComponent2.default;

/**
 * The PhotoEditorSDK UI can also be integrated as a React.js component
 * @class
 * @extends React.Component
 * @memberof PhotoEditorSDK.UI.ReactUI
 */

var ReactComponent = function (_React$Component) {
  _inherits(ReactComponent, _React$Component);

  function ReactComponent() {
    _classCallCheck(this, ReactComponent);

    return _possibleConstructorReturn(this, (ReactComponent.__proto__ || Object.getPrototypeOf(ReactComponent)).apply(this, arguments));
  }

  _createClass(ReactComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this._ui = new ReactUI(_globals.SDKUtils.extend({}, this.props, {
        container: this.refs.container
      }));

      if (this.props.onEditorReady) {
        this._ui.onReady(this.props.onEditorReady);
      }
    }
  }, {
    key: 'render',


    /**
     * Renders this component
     * @return {React.Element}
     */
    value: function render() {
      var containerStyle = _globals.SDKUtils.extend({}, this.props.style || {});
      return _globals.React.createElement('div', { style: containerStyle, ref: 'container' });
    }
  }, {
    key: 'ui',
    get: function get() {
      return this._ui;
    }
  }]);

  return ReactComponent;
}(_globals.React.Component);

ReactUI.ReactComponent = ReactComponent;

// Extend PhotoEditorSDK object
_globals.SDK.UI = _globals.SDK.UI || {};
_globals.SDK.UI.ReactUI = ReactUI;

exports.default = ReactUI;

/***/ }),
/* 62 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_62__;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(17);
var invariant = __webpack_require__(18);
var warning = __webpack_require__(34);
var assign = __webpack_require__(64);

var ReactPropTypesSecret = __webpack_require__(19);
var checkPropTypes = __webpack_require__(65);

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (({"ENV":"\"development\""}).NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(
            false,
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
        } else if (({"ENV":"\"development\""}).NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            warning(
              false,
              'You are manually calling a React.PropTypes validation ' +
              'function for the `%s` prop on `%s`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
              propFullName,
              componentName
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      ({"ENV":"\"development\""}).NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      ({"ENV":"\"development\""}).NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(
          false,
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received %s at index %s.',
          getPostfixForTypeWarning(checker),
          i
        );
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (({"ENV":"\"development\""}).NODE_ENV !== 'production') {
  var invariant = __webpack_require__(18);
  var warning = __webpack_require__(34);
  var ReactPropTypesSecret = __webpack_require__(19);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (({"ENV":"\"development\""}).NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(17);
var invariant = __webpack_require__(18);
var ReactPropTypesSecret = __webpack_require__(19);

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(16);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(33);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactBem = __webpack_require__(37);

var _reactBem2 = _interopRequireDefault(_reactBem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var BaseComponent = function (_React$Component) {
  _inherits(BaseComponent, _React$Component);

  function BaseComponent() {
    var _ref;

    _classCallCheck(this, BaseComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = BaseComponent.__proto__ || Object.getPrototypeOf(BaseComponent)).call.apply(_ref, [this].concat(args)));

    _this._events = {};
    _this._needsStyleFixes = false;

    _this._bindAll('_onSharedStateUpdate', 'fixStyles');
    return _this;
  }

  // -------------------------------------------------------------------------- WORKAROUNDS

  /**
   * A method that is called whenever styles need to be fixed by the JavaScript.
   * This needs to be done thanks to older Internet Explorer browsers which have
   * a bunch of CSS bugs.
   */


  _createClass(BaseComponent, [{
    key: 'fixStyles',
    value: function fixStyles() {}

    // -------------------------------------------------------------------------- LIFECYCLE

    /**
     * Gets called when this component has been mounted
     */

  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this._bindEvents();
      if (this.props.sharedState) {
        this.props.sharedState.on('update', this._onSharedStateUpdate);
      }

      if (this._needsStyleFixes) {
        this.fixStyles();
        if (this.context.options.responsive) {
          window.addEventListener('resize', this.fixStyles);
        }
      }
    }

    /**
     * Gets called before this component is unmounted
     */

  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this._unbindEvents();

      if (this.props.sharedState) {
        this.props.sharedState.off('update', this._onSharedStateUpdate);
      }

      if (this.context.options.responsive && this._needsStyleFixes) {
        window.removeEventListener('resize', this.fixStyles);
      }
    }

    /**
     * Gets called when this component is about to receive new properties
     * @param  {Object} nextProps
     */

  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.sharedState) {
        if (this.props.sharedState) {
          this.props.sharedState.off('update', this._onSharedStateUpdate);
        }
        nextProps.sharedState.on('update', this._onSharedStateUpdate);
      }
    }

    // -------------------------------------------------------------------------- HELPER FUNCTIONS

    /**
     * Binds the instance methods with the given names
     * to the class context
     * @param  {Array.<String>} ...fnNames
     * @protected
     */

  }, {
    key: '_bindAll',
    value: function _bindAll() {
      var _this2 = this;

      for (var _len2 = arguments.length, fnNames = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        fnNames[_key2] = arguments[_key2];
      }

      fnNames.forEach(function (name) {
        if (typeof _this2[name] !== 'function') {
          throw new Error('_bindAll: ' + _this2.constructor.name + '.' + name + ' is not a function.');
        }
        _this2[name] = _this2[name].bind(_this2);
      });
    }

    /**
     * Returns the translation for `key`
     * @param  {String} key
     * @param  {Object} [interpolationOptions]
     * @return {String}
     */

  }, {
    key: '_t',
    value: function _t(key, interpolationOptions) {
      return this.context.ui.translate(key, interpolationOptions);
    }

    /**
     * A helper method for UI.helpers.assetPath
     * @param {?} ...args
     * @protected
     */

  }, {
    key: '_getAssetPath',
    value: function _getAssetPath() {
      var _context$ui;

      return (_context$ui = this.context.ui).getAssetPath.apply(_context$ui, arguments);
    }

    // -------------------------------------------------------------------------- SHARED STATE

    /**
     * Gets called when the shared state did change
     * @param  {Object} oldState
     * @param  {Object} newState
     * @private
     */

  }, {
    key: '_onSharedStateUpdate',
    value: function _onSharedStateUpdate(oldState, newState) {
      this.sharedStateDidChange(newState);

      if (this.shouldSharedComponentUpdate(oldState, newState)) {
        this.forceUpdate();
      }
    }

    /**
     * Checks if the component should change from the given state
     * @param  {Object} oldState
     * @param  {Object} newState
     * @return {Boolean}
     */

  }, {
    key: 'shouldSharedComponentUpdate',
    value: function shouldSharedComponentUpdate(oldState, newState) {
      return true;
    }

    /**
     * Gets called when the shared state did change
     * @param {Object} newState
     */

  }, {
    key: 'sharedStateDidChange',
    value: function sharedStateDidChange(newState) {}

    /**
     * Sets the given state on the shared state
     * @param {Object} state
     * @param {Boolean} update
     */

  }, {
    key: 'setSharedState',
    value: function setSharedState(state, update) {
      this.props.sharedState.set(state, update);
    }

    /**
     * Returns the shared state value for the given property
     * @param {String} prop
     * @return {*}
     */

  }, {
    key: 'getSharedState',
    value: function getSharedState(prop) {
      return this.props.sharedState.get(prop);
    }

    /**
     * Forces an update of the shared state
     */

  }, {
    key: 'forceSharedUpdate',
    value: function forceSharedUpdate() {
      this.props.sharedState.broadcastUpdate();
    }

    // -------------------------------------------------------------------------- EVENT HANDLING

    /**
     * Binds the events in _events
     * @protected
     */

  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      for (var eventName in this._events) {
        var handler = this._events[eventName];
        this.context.mediator.on(eventName, handler);
      }
    }

    /**
     * Unbinds the events in _events
     * @protected
     */

  }, {
    key: '_unbindEvents',
    value: function _unbindEvents() {
      for (var eventName in this._events) {
        var handler = this._events[eventName];
        this.context.mediator.off(eventName, handler);
      }
    }

    /**
     * Emits an event with the given event name and arguments through
     * the mediator
     * @param  {String} eventName
     * @param  {Array.<*>} ...args
     * @protected
     */

  }, {
    key: '_emitEvent',
    value: function _emitEvent(eventName) {
      var _context$mediator;

      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      (_context$mediator = this.context.mediator).emit.apply(_context$mediator, [eventName].concat(args));
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this element
     * @return {ReactBEM.element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _reactBem2.default.createElement('div');
    }

    /**
     * Transforms the ReactBEM.element returned by `renderWithBEM` into
     * React.Element objects with proper class names
     * @return {React.Element}
     */

  }, {
    key: 'render',
    value: function render() {
      return _reactBem2.default.transform(this.renderWithBEM());
    }
  }]);

  return BaseComponent;
}(_react2.default.Component);

exports.default = BaseComponent;


BaseComponent.contextTypes = {
  editor: _propTypes2.default.object,
  ui: _propTypes2.default.object,
  options: _propTypes2.default.object,
  mediator: _propTypes2.default.object,
  editorScreen: _propTypes2.default.object,
  globalState: _propTypes2.default.object
};

BaseComponent.propTypes = {
  sharedState: _propTypes2.default.any
};

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _photoeditorsdk = __webpack_require__(7);

var _photoeditorsdk2 = _interopRequireDefault(_photoeditorsdk);

var _log = __webpack_require__(20);

var _log2 = _interopRequireDefault(_log);

var _browser = __webpack_require__(72);

var _browser2 = _interopRequireDefault(_browser);

var _jsonLoader = __webpack_require__(22);

var _jsonLoader2 = _interopRequireDefault(_jsonLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var SDKUtils = _photoeditorsdk2.default.Utils;
var Vector2 = _photoeditorsdk2.default.Math.Vector2;


var UIUtils = {
  /**
   * Returns the inner dimensions (size - padding) of the given
   * DOM element
   * @param  {DOMElement} element
   * @return {Vector2}
   */
  getInnerDimensionsForElement: function getInnerDimensionsForElement(element) {
    var size = new Vector2(element.offsetWidth, element.offsetHeight);
    var computedStyle = window.getComputedStyle(element, null);
    size.x -= parseInt(computedStyle.getPropertyValue('padding-left'), 10);
    size.x -= parseInt(computedStyle.getPropertyValue('padding-right'), 10);
    size.y -= parseInt(computedStyle.getPropertyValue('padding-top'), 10);
    size.y -= parseInt(computedStyle.getPropertyValue('padding-bottom'), 10);
    return size;
  },


  /**
   * Gets the x and y position for the given event.
   * @param {Event} e
   * @return {Vector2}
   */
  getEventPosition: function getEventPosition(e) {
    var x = e.clientX;
    var y = e.clientY;
    if (e.type.indexOf('touch') !== -1) {
      if (!e.touches.length) return;

      x = e.touches[0].clientX;
      y = e.touches[0].clientY;
    }
    return new Vector2(x, y);
  },


  /**
   * Creates a canvas with a transparency pattern
   * @return {Canvas}
   */
  createTransparentPatternCanvas: function createTransparentPatternCanvas() {
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');

    canvas.width = 10;
    canvas.height = 10;

    context.fillStyle = 'white';
    context.fillRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = '#cccccc';
    context.fillRect(0, 0, canvas.width / 2, canvas.height / 2);
    context.fillRect(canvas.width / 2, canvas.height / 2, canvas.width, canvas.height);

    return canvas;
  },


  /**
   * Checks if the browser supports canvas.msToBlob
   * @return {Boolean}
   */
  supportsMSBlob: function supportsMSBlob() {
    var canvas = document.createElement('canvas');
    return typeof canvas.msToBlob !== 'undefined';
  },


  /**
   * Translates the given key using the given options
   * @param  {Object} phrases
   * @param  {String} key
   * @param  {Object} interpolationOptions = {}
   * @return {String}
   */
  translate: function translate(phrases, key) {
    var interpolationOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var response = this.fetch(phrases, key);
    if (!response) {
      _log2.default.info('Utils#translate', 'Unable to translate `' + key + '`');

      // ------------------------------------------------------------------------------------------
      // Remove this part in the next major version update
      var newToOldLocalizationKeyMap = __webpack_require__(83);
      var oldKey = newToOldLocalizationKeyMap[key];
      if (oldKey != null) {
        _log2.default.warn('Utils#translate', 'Trying to find localized string for old key: `' + oldKey + '`. Please update your localization to use the new key as soon as possible. Support for the old, deprecated key will be dropped with the next major version update.');
        return this.translate(phrases, oldKey, interpolationOptions);
      }
      // ------------------------------------------------------------------------------------------

      return null;
    }
    for (var _key in interpolationOptions) {
      response = response.replace('${' + _key + '}', interpolationOptions[_key]);
    }
    return response;
  },


  /**
   * Gets the property value at `path` of `object`
   * @param  {Object} object
   * @param  {String} path
   * @param  {?} [defaultValue]
   * @return {?}
   */
  fetch: function fetch(object, path, defaultValue) {
    // Replace indexes with property accessors
    path = path.replace(/\[(\w+)]/g, '.$1');
    // Strip leading dot (when path begins with [0] for example)
    path = path.replace(/^\./, '');

    var pathSegments = path.split('.');
    for (var i = 0; i < pathSegments.length; i++) {
      var segment = pathSegments[i];
      object = object[segment];
      if (!object) {
        break;
      }
    }

    if (typeof object === 'undefined') {
      return false;
    }

    return object;
  },


  /**
   * Checks whether the user agent represents a mobile device
   * @return {Boolean}
   */
  isMobile: function isMobile() {
    var a = navigator.userAgent || navigator.vendor || window.opera;
    /* eslint-disable */
    return (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))
    );
    /* eslint-enable */
  },


  /**
   * Checks whether the device supports touch events
   * @return {Boolean} [description]
   */
  isTouchDevice: function isTouchDevice() {
    /* eslint-disable no-mixed-operators */
    return !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch);
    /* eslint-enable no-mixed-operators */
  },


  /**
   * Selects the `selectedItems` from `items`. `selector` is called for every item, return value
   * is matched against `selectedItems`
   * @param  {Array} items
   * @param  {Array} selectedItems
   * @param  {Function} [selector = null]
   * @return {Array}
   */
  select: function select(items, selectedItems) {
    var selector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    if (!selector) selector = function selector(i) {
      return i;
    };

    var newItems = [];
    selectedItems.forEach(function (selectedItem) {
      items.forEach(function (item) {
        var itemIdentifier = selector(item);
        if (itemIdentifier === selectedItem) {
          newItems.push(item);
        }
      });
    });
    return newItems;
  },


  /**
   * Gets the given URL using JSON(P)
   * @param  {String} url
   * @return {Promise}
   */
  getJSONP: function getJSONP(url) {
    var loader = new _jsonLoader2.default(url);
    return loader.load();
  },


  /**
   * Clones the given `categories` array
   * @param  {Object[]} categories
   * @param {String} itemsProperty
   * @return {Object[]}
   */
  cloneCategories: function cloneCategories(categories, itemsProperty) {
    return categories.map(function (category) {
      category = SDKUtils.clone(category);
      category[itemsProperty] = category[itemsProperty].slice(0);
      return category;
    });
  },


  /**
   * Merges the given `newCategories` into the given `categories`
   * @param  {Object[]} categories
   * @param  {Object[]} newCategories
   * @param  {String} itemsProperty
   * @private
   */
  mergeCategories: function mergeCategories(categories, newCategories, itemsProperty) {
    categories = this.cloneCategories(categories, itemsProperty);

    var existingCategory = null;
    newCategories.forEach(function (newCategory) {
      categories.forEach(function (category) {
        if (newCategory.identifier === category.identifier) {
          existingCategory = category;
        }
      });

      if (!existingCategory) {
        categories.push(newCategory);
      } else {
        existingCategory[itemsProperty] = existingCategory[itemsProperty].concat(newCategory[itemsProperty]);
      }
    });

    return categories;
  },


  /**
   * Returns a camelized style object for the given DOMElement
   * @param  {DOMElement} el
   * @return {Object}
   */
  getStyleObject: function getStyleObject(el) {
    var styleProperties = window.getComputedStyle(el);
    var styleObject = {};
    for (var property in styleProperties) {
      var value = styleProperties.getPropertyValue(property);
      var camelizedAttr = property.replace(/-([a-z])/g, function (a, b) {
        return b.toUpperCase();
      });
      if (value !== '') {
        styleObject[camelizedAttr] = value;
      }
    }
    return styleObject;
  },


  /**
   * Debounces the given function to trigger only every so often
   * @param  {Function} fn
   * @param  {Number}   wait
   * @param  {Boolean}
   * @return {Function}
   */
  debounce: function debounce(fn, wait, immediate) {
    var timeout;
    return function () {
      var _this = this;

      var args = arguments;
      var later = function later() {
        timeout = null;
        if (!immediate) fn.apply(_this, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) fn.apply(this, args);
    };
  },


  /**
   * Finds the native scrollbar width for the current browser
   * @return {Number}
   */
  getScrollbarWidth: function getScrollbarWidth() {
    var outer = document.createElement('div');
    outer.style.visibility = 'hidden';
    outer.style.width = '100px';
    outer.style.msOverflowStyle = 'scrollbar';
    document.body.appendChild(outer);

    var widthNoScroll = outer.offsetWidth;
    outer.style.overflow = 'scroll';

    var inner = document.createElement('div');
    inner.style.width = '100%';
    outer.appendChild(inner);

    var widthWithScroll = inner.offsetWidth;
    outer.parentNode.removeChild(outer);

    return widthNoScroll - widthWithScroll;
  },


  /**
   * Returns the given string with the first character uppercased
   * @param  {String} str
   * @return {String}
   */
  capitalize: function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  },


  Browser: _browser2.default
};

exports.default = UIUtils;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global HTMLElement, WEBPACK */
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _base = __webpack_require__(70);

var _base2 = _interopRequireDefault(_base);

var _arrayUtils = __webpack_require__(71);

var _arrayUtils2 = _interopRequireDefault(_arrayUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Provides utility functions for internal use
 * @class
 * @memberof PhotoEditorSDK
 * @private
 */
var Utils = function () {
  function Utils() {
    _classCallCheck(this, Utils);
  }

  _createClass(Utils, null, [{
    key: 'isArray',

    /**
     * Checks if the given object is an Array
     * @param  {Object}  object
     * @return {Boolean}
     */
    value: function isArray(object) {
      return Object.prototype.toString.call(object) === '[object Array]';
    }

    /**
     * Checks if a given object is a plain object (i.e., a literal object) or not.
     * @param {any} object
     * @returns Boolean
     */

  }, {
    key: 'isPlainObject',
    value: function isPlainObject(object) {
      if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object' || !object) {
        return false;
      }

      if (typeof Object.getPrototypeOf === 'function') {
        var proto = Object.getPrototypeOf(object);
        return proto === Object.prototype || proto === null;
      }

      return Object.prototype.toString.call(object) === '[object Object]';
    }

    /**
     * Checks whether the user agent represents a mobile device
     * @return {Boolean}
     */

  }, {
    key: 'isMobile',
    value: function isMobile() {
      if (typeof navigator === 'undefined') return false;

      var a = navigator.userAgent || navigator.vendor || window.opera;
      /* eslint-disable */
      return (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od|ad)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))
      );
      /* eslint-enable */
    }

    /**
     * Checks wether the platform target is a browser
     * @return {Boolean}
     */

  }, {
    key: 'isBrowser',
    value: function isBrowser() {
      return typeof window !== 'undefined';
    }

    /**
     * Checks wether the platform target is Nodejs
     * @return {Boolean}
     */

  }, {
    key: 'isNode',
    value: function isNode() {
      return typeof window === 'undefined' && typeof global !== 'undefined';
    }

    /**
     * Returns the given object's values as an array
     * @param {Object} object
     * @returns {Array<*>}
     */

  }, {
    key: 'values',
    value: function values(object) {
      var values = [];
      for (var key in object) {
        values.push(object[key]);
      }
      return values;
    }

    /**
     * Checks if the given object is a DOM element
     * @param  {Object}  o
     * @return {Boolean}
     */
    /* istanbul ignore next */

  }, {
    key: 'isDOMElement',
    value: function isDOMElement(o) {
      return (typeof HTMLElement === 'undefined' ? 'undefined' : _typeof(HTMLElement)) === 'object' ? o instanceof HTMLElement : o && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string';
    }

    /**
     * Checks if th given event is a touch event
     * @param  {Event}  e
     * @return {Boolean}
     */

  }, {
    key: 'isTouchEvent',
    value: function isTouchEvent(e) {
      return e.type.indexOf('touch') !== -1;
    }

    /**
     * Resizes the given vector to fit inside the given max size while maintaining
     * the aspect ratio
     * @param  {Vector2} vector
     * @param  {Vector2} max
     * @return {Vector2}
     */

  }, {
    key: 'resizeVectorToFit',
    value: function resizeVectorToFit(vector, max) {
      var scale = Math.min(max.x / vector.x, max.y / vector.y);
      var newSize = vector.clone().multiply(scale);
      return newSize;
    }
  }, {
    key: 'resizeVectorToFill',
    value: function resizeVectorToFill(vector, container) {
      var vectorRatio = vector.x / vector.y;
      var containerRatio = container.x / container.y;
      if (vectorRatio > containerRatio) {
        return container.clone().set(container.y * vectorRatio, container.y);
      } else {
        return container.clone().set(container.x, container.x / vectorRatio);
      }
    }

    /**
     * Checks if this value is extendable / can have keys
     * @param  {*}  val
     * @return {Boolean}
     */

  }, {
    key: 'isExtendable',
    value: function isExtendable(val) {
      return typeof val !== 'undefined' && val !== null && ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' || typeof val === 'function');
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to undefined. Once a
     * property is set, additional values of the same property are ignored.
     * @param  {Object} object
     * @param  {Object} ...sources
     * @return {Object}
     */

  }, {
    key: 'defaults',
    value: function defaults(object) {
      // Shallow clone
      var newObject = {};
      for (var key in object) {
        newObject[key] = object[key];
      }

      // Clone sources

      for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        sources[_key - 1] = arguments[_key];
      }

      for (var i = 0; i < sources.length; i++) {
        var source = sources[i];
        for (var _key2 in source) {
          if (typeof newObject[_key2] === 'undefined') {
            newObject[_key2] = source[_key2];
          }
        }
      }

      return newObject;
    }

    /**
     * Does a deep merge between a set of objects, from left to right. The merge is
     * deep in the sense that it goes recurseviley trough the objects own
     * properties. When it encounters an array, it only does a shallow copy of it.
     *
     * @param {Object} dest
     * @param {Object[]} sources
     * @returns {Object}
     */

  }, {
    key: 'deepMerge',
    value: function deepMerge(dest) {
      // deep merge between two objects only
      var _deepMerge = function _deepMerge(dest, source) {
        // If the source is undefined, return a copy of dest
        if (source === undefined) {
          return _deepMerge(null, dest);
        }

        // If the source is an array, return a shallow copy
        if (Array.isArray(source)) {
          return [].concat(_toConsumableArray(source));
        }

        // If the source is not a plain object, just return it
        if (!Utils.isPlainObject(source)) {
          return source;
        }

        // If dest is an not a plain object, return a shallow copy of the source
        if (!Utils.isPlainObject(dest)) {
          return _extends({}, source);
        }

        // Shallow-copy the original object
        var result = _extends({}, dest);

        // Go trough each source key
        Object.keys(source).forEach(function (key) {
          var value = source[key];
          if (value === undefined) {
            return;
          }
          result[key] = _deepMerge(dest[key], value);
        });
        return result;
      };

      for (var _len2 = arguments.length, sources = Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
        sources[_key3 - 1] = arguments[_key3];
      }

      return sources.reduce(_deepMerge, dest);
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties and their properties that resolve to
     * undefined. Once a property is set, additional value sof the same property
     * are ignored.
     * @param  {Object} object
     * @param  {Object} ...sources
     * @return {Object}
     */

  }, {
    key: 'deepDefaults',
    value: function deepDefaults(object) {
      for (var _len3 = arguments.length, sources = Array(_len3 > 1 ? _len3 - 1 : 0), _key4 = 1; _key4 < _len3; _key4++) {
        sources[_key4 - 1] = arguments[_key4];
      }

      var reversedSources = [].concat(sources).reverse();
      return Utils.deepMerge.apply(Utils, _toConsumableArray(reversedSources).concat([object]));
    }

    /**
     * Creates a deep clone of the given object
     * @param  {Object}    object
     * @return {Object}
     */

  }, {
    key: 'deepClone',
    value: function deepClone(object) {
      var newObject = {};
      for (var key in object) {
        if (Utils.isExtendable(object[key])) {
          newObject[key] = Utils.deepClone(object[key]);
        } else {
          newObject[key] = object[key];
        }
      }
      return newObject;
    }

    /**
     * Get a deep property inside an object.
     *
     * @param {Object} object - the object
     * @param {String[]} path - Either a string with the prop's
     *  name, or an array of prop names and/or functions describing a path in a
     *  nested object. Any function passed in the array should function as a getter
     *  for a prop.
     *
     * @returns {(any|undefined)} - The prop's value, or undefined if the prop is
     * not found
     */

  }, {
    key: 'getDeepProperty',
    value: function getDeepProperty(object, path) {
      if (typeof path === 'string') {
        return object[path];
      }

      if (!Array.isArray(path)) {
        return undefined;
      }

      // When we have a getter function inside the array, call it as a getter,
      // ignoring any type errors thrown by it (just return undefined.)
      var callPropName = function callPropName(object, propName) {
        var value = void 0;
        try {
          value = propName(object);
        } catch (e) {
          if (!(e instanceof TypeError)) {
            throw e;
          }
        }

        return value;
      };

      return path.reduce(function (object, propName) {
        return object ? typeof propName === 'function' ? callPropName(object, propName) : object[propName] : null;
      }, object);
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources overwrite property assignments of previous
     * sources.
     * @param {Object} object
     * @param {Object} ...sources
     * @return {Object}
     */

  }, {
    key: 'extend',
    value: function extend(object) {
      // Shallow clone
      var newObject = {};
      for (var key in object) {
        newObject[key] = object[key];
      }

      // Extend sources

      for (var _len4 = arguments.length, sources = Array(_len4 > 1 ? _len4 - 1 : 0), _key5 = 1; _key5 < _len4; _key5++) {
        sources[_key5 - 1] = arguments[_key5];
      }

      for (var i = 0; i < sources.length; i++) {
        var source = sources[i];
        for (var _key6 in source) {
          newObject[_key6] = source[_key6];
        }
      }

      return newObject;
    }

    /**
     * Creates a shallow clone of the given object
     * @param {Object} object
     * @returns {Object}
     */

  }, {
    key: 'clone',
    value: function clone(object) {
      return this.extend({}, object);
    }

    /**
     * Creates a Blob URI from the given Data URI
     * @param {String} data
     */

  }, {
    key: 'createBlobURIFromDataURI',
    value: function createBlobURIFromDataURI(data) {
      var root = typeof window === 'undefined' ? global : window;
      if (!root.Blob || !root.URL || !ArrayBuffer || !Uint8Array) {
        return data;
      }

      var rawData = _base2.default.decode(data.split(',')[1]);
      var mimeString = data.split(',')[0].split(':')[1].split(';')[0];

      // write the bytes of the string to an ArrayBuffer
      var arrayBuffer = new ArrayBuffer(rawData.length);
      var intArray = new Uint8Array(arrayBuffer);
      for (var i = 0; i < rawData.length; i++) {
        intArray[i] = rawData[i];
      }

      // write the ArrayBuffer to a blob, and you're done
      var blob = new root.Blob([arrayBuffer], {
        type: mimeString
      });
      return root.URL.createObjectURL(blob);
    }

    /**
     * Generates a UUID
     * @return {String}
     */

  }, {
    key: 'getUUID',
    value: function getUUID() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0;
        var v = c === 'x' ? r : r & 0x3 | 0x8;
        return v.toString(16);
      });
    }

    /**
     * Creates a canvas DOM element (browser) or a node-canvas canvas (node)
     * @return {Canvas}
     */

  }, {
    key: 'createCanvas',
    value: function createCanvas() {
      return document.createElement('canvas');
    }
  }, {
    key: 'convertHtmlImageToRGBACanvas',
    value: function convertHtmlImageToRGBACanvas(htmlImage) {
      // Workaround fro non-RGB images
      var canvas = Utils.createCanvas();
      canvas.width = htmlImage.width;
      canvas.height = htmlImage.height;
      var context = canvas.getContext('2d');
      context.drawImage(htmlImage, 0, 0, htmlImage.width, htmlImage.height);

      return canvas;
    }
    /**
     * Checks if the given dimensions are POT
     * @param  {PhotoEditorSDK.Math.Vector2}  dimensions
     * @return {Boolean}
     */

  }, {
    key: 'isPowerOfTwo',
    value: function isPowerOfTwo(dimensions) {
      return (dimensions.x & dimensions.x - 1) === 0 && (dimensions.y & dimensions.y - 1) === 0;
    }

    /**
     * Returns the next lowest power of two of the given number
     * @param  {Number} x
     * @return {Number}
     */

  }, {
    key: 'nextLowestPOT',
    value: function nextLowestPOT(x) {
      for (var i = 1; i < 32; i <<= 1) {
        x = x | x >> i;
      }
      return x - (x >> 1);
    }

    /**
     * Returns the next highest power of two of the given number
     * @param  {Number} x
     * @return {Number}
     */

  }, {
    key: 'nextHighestPOT',
    value: function nextHighestPOT(x) {
      x--;
      for (var i = 1; i < 32; i <<= 1) {
        x = x | x >> i;
      }
      return x + 1;
    }

    /**
     * Moves the array item at `oldIndex` to `newIndex`
     * @param  {Array} arr
     * @param  {Number} oldIndex
     * @param  {Number} newIndex
     */

  }, {
    key: 'moveArrayItem',
    value: function moveArrayItem(arr, oldIndex, newIndex) {
      if (newIndex >= arr.length) {
        var k = newIndex - arr.length;
        while (k-- + 1) {
          arr.push(undefined);
        }
      }
      arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);
    }

    /**
     * Makes sure the given canvas has the given dimensions. If not, it does not change the
     * canvas dimensions.
     * @param  {Canvas} canvas
     * @param  {PhotoEditorSDK.Math.Vector2} dimensions
     */

  }, {
    key: 'ensureCanvasDimensions',
    value: function ensureCanvasDimensions(canvas, dimensions) {
      if (canvas.width !== dimensions.x || canvas.height !== dimensions.y) {
        canvas.width = dimensions.x;
        canvas.height = dimensions.y;
      }
    }

    /**
     * Converts the given array of bytes to a string
     * @param  {Number[]} byteArray
     * @return {String}
     */

  }, {
    key: 'byteArrayToString',
    value: function byteArrayToString(byteArray) {
      return byteArray.map(function (byte) {
        return String.fromCharCode(byte);
      }).join('');
    }

    /**
     * Clamps the given `number` into `min` and `max`
     * @param  {Number} number
     * @param  {Number} min
     * @param  {Number} max
     * @return {Number}
     */

  }, {
    key: 'clamp',
    value: function clamp(number, min, max) {
      return Math.max(min, Math.min(number, max));
    }

    /**
     * Checks if the given string matches the given wildcard
     * @param  {String} str
     * @param  {String} rule
     * @return {Boolean}
     */

  }, {
    key: 'wildCardMatch',
    value: function wildCardMatch(str, rule) {
      return new RegExp('^' + rule.split('*').join('.*') + '$').test(str);
    }

    /**
     * Returns a new object with flipped values and keys
     * @param  {Object} obj
     * @return {Object}
     */

  }, {
    key: 'flipObject',
    value: function flipObject(obj) {
      var newObj = {};
      for (var key in obj) {
        newObj[obj[key]] = key;
      }
      return newObj;
    }

    /**
     * Returns a clone of the given options object
     * @param  {Object} options
     * @return {Object}
     */

  }, {
    key: 'cloneOptions',
    value: function cloneOptions(options) {
      var newOptions = {};
      for (var key in options) {
        var value = options[key];
        if (Array.isArray(value)) {
          value = value.slice();
        } else if (value.clone) {
          value = value.clone();
        }
        newOptions[key] = value;
      }
      return newOptions;
    }

    /**
     * Returns the given date as RFC 3339
     * @param {Date} date
     * @return {String}
     */

  }, {
    key: 'ISODateString',
    value: function ISODateString(date) {
      function pad(n) {
        return n < 10 ? '0' + n : n;
      }
      return date.getUTCFullYear() + '-' + pad(date.getUTCMonth() + 1) + '-' + pad(date.getUTCDate()) + 'T' + pad(date.getUTCHours()) + ':' + pad(date.getUTCMinutes()) + ':' + pad(date.getUTCSeconds()) + 'Z';
    }
  }, {
    key: 'getCrossOriginValue',
    value: function getCrossOriginValue(crossOrigin) {
      if (!crossOrigin) {
        return 'anonymous';
      }

      if (crossOrigin === 'none') {
        return undefined;
      }

      return crossOrigin;
    }

    /**
     * Shallow equal compare two objects
     * @param {*} objA
     * @param {*} objB
     * @returns {Boolean}
     */

  }, {
    key: 'shallowEqual',
    value: function shallowEqual(objA, objB) {
      if (objA === objB) {
        return true;
      }

      if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
        return false;
      }

      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);

      if (keysA.length !== keysB.length) {
        return false;
      }
      // Test for A's keys different from B.
      var bHasOwnProperty = hasOwnProperty.bind(objB);
      for (var i = 0; i < keysA.length; i++) {
        if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
          return false;
        }
      }
      return true;
    }

    /**
     * Returns 'value' if condition is met else returns 'undefined'
     * @param {Boolean} condition
     * @param {*} value
     * @returns {*}
     */

  }, {
    key: 'enableIf',
    value: function enableIf(condition, value) {
      return condition ? value : undefined;
    }

    /**
      Throws an error if condition is not met
      @param {Boolean} condition
     */

  }, {
    key: 'invariant',
    value: function invariant(condition, message) {
      if (!condition) {
        var error = new Error(message);
        throw error;
      }
    }

    /**
     * Exectues all Promises in an array, returning a new Promise which
     * will fulfill with an array of the values returned by all promises in
     * the case all of them are resolved, or, with one or more are rejected,
     * rejects with an array containing all the error values.
     *
     * @param {Array<Promise>} promises
     * @returns {Promise<Array>}
     */

  }, {
    key: 'executePromises',
    // eslint-disable-line
    value: function executePromises(promises) {
      var count = promises.length;
      var counter = 0;

      var values = [];
      var errors = [];

      return new Promise(function (resolve, reject) {
        var onFinnish = function onFinnish() {
          counter++;
          if (counter >= count) {
            if (errors.length <= 0) {
              resolve(values);
            } else {
              reject(errors);
            }
          }
        };

        var onSuccess = function onSuccess(value) {
          values.push(value);
          onFinnish();
        };

        var onError = function onError(value) {
          errors.push(value);
          onFinnish();
        };

        promises.forEach(function (promise) {
          promise.then(onSuccess).catch(onError);
        });
      });
    }
  }]);

  return Utils;
}();

Utils.Array = _arrayUtils2.default;
exports.default = Utils;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * Extracted from MinifyJpeg (Copyright (c) 2014 Hiroaki Matoba, MIT License):
 * https://github.com/hMatoba/MinifyJpeg
 * @license
 */

var KEY_STR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

/**
 * Provides Base64 encode and decode methods
 * @type {Object}
 * @ignore
 */
/* istanbul ignore next */
var Base64 = {
  /**
   * Encodes the given input into a Base64 string
   * @param  {String} input
   * @return {String}
   */
  encode: function encode(input) {
    var output = '';
    var chr1 = void 0,
        chr2 = void 0,
        chr3 = void 0;
    var enc1 = void 0,
        enc2 = void 0,
        enc3 = void 0,
        enc4 = void 0;
    var i = 0;

    do {
      chr1 = input[i++];
      chr2 = input[i++];
      chr3 = input[i++];

      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = (chr2 & 15) << 2 | chr3 >> 6;
      enc4 = chr3 & 63;

      if (isNaN(chr2)) {
        enc3 = enc4 = 64;
      } else if (isNaN(chr3)) {
        enc4 = 64;
      }

      output = output + KEY_STR.charAt(enc1) + KEY_STR.charAt(enc2) + KEY_STR.charAt(enc3) + KEY_STR.charAt(enc4);
      chr1 = chr2 = chr3 = '';
      enc1 = enc2 = enc3 = enc4 = '';
    } while (i < input.length);

    return output;
  },


  /**
   * Decodes the given Base64 string
   * @param  {String} input
   * @return {String}
   */
  decode: function decode(input) {
    var chr1 = void 0,
        chr2 = void 0,
        chr3 = void 0;
    var enc1 = void 0,
        enc2 = void 0,
        enc3 = void 0,
        enc4 = void 0;
    var i = 0;
    var buf = [];

    // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
    var base64test = /[^A-Za-z0-9+/=]/g;
    if (base64test.exec(input)) {
      throw new Error('There were invalid base64 characters in the input text.\n' + 'Valid base64 characters are A-Z, a-z, 0-9, \'+\', \'/\',and \'=\'\n' + 'Expect errors in decoding.');
    }
    input = input.replace(/[^A-Za-z0-9+/=]/g, '');

    do {
      enc1 = KEY_STR.indexOf(input.charAt(i++));
      enc2 = KEY_STR.indexOf(input.charAt(i++));
      enc3 = KEY_STR.indexOf(input.charAt(i++));
      enc4 = KEY_STR.indexOf(input.charAt(i++));

      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;

      buf.push(chr1);

      if (enc3 !== 64) {
        buf.push(chr2);
      }
      if (enc4 !== 64) {
        buf.push(chr3);
      }

      chr1 = chr2 = chr3 = '';
      enc1 = enc2 = enc3 = enc4 = '';
    } while (i < input.length);

    return buf;
  }
};

exports.default = Base64;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ArrayUtils = function () {
  function ArrayUtils() {
    _classCallCheck(this, ArrayUtils);
  }

  _createClass(ArrayUtils, null, [{
    key: "head",

    /**
     * Returns the first element in an array
     * @param {Array<A>} arr
     * @returns {A}
     */
    value: function head(arr) {
      return arr[0];
    }

    /**
     * Returns a shallow copy of the array excluding the first element
     * @param {Array<A>} arr
     * @returns {Array<A>}
     */

  }, {
    key: "tail",
    value: function tail(arr) {
      return arr.slice(1);
    }

    /**
     * Returns the last element of an array
     * @param {Array<A>} arr
     * @returns {A}
     */

  }, {
    key: "last",
    value: function last(arr) {
      return arr[arr.length - 1];
    }

    /**
     * Returns a shallow copy of the array excluding the last element
     * @param {Array<A>} arr
     * @returns {Array<A>}
     */

  }, {
    key: "init",
    value: function init(arr) {
      return arr.slice(0, arr.length - 1);
    }

    /**
     * Returns a shallow copy of the array with the elements tha pass
     * the test function removed.
     * @param {Array<A>} arr
     * @param {Function} func - A test function
     */

  }, {
    key: "remove",
    value: function remove(arr, func) {
      return arr.filter(function (v, i, arr) {
        return !func(v, i, arr);
      });
    }

    /**
     * Finds the index first element of the Array to which the supplied function returns
     * a true value. If the element is not found it returns -1.
     *
     * @param {Array} array
     * @param {Function} func
     * @returns {number}
     */

  }, {
    key: "findIndex",
    value: function findIndex(array, func) {
      for (var i = 0; i < array.length; i++) {
        if (func(array[i])) {
          return i;
        }
      }

      return -1;
    }

    /**
     * Finds the first element of the Array to which the supplied function returns
     * a true value and returns it. Otherwise it returns undefined.
     *
     * @param {Array} array
     * @param {Function} func
     * @returns {any}
     */

  }, {
    key: "find",
    value: function find(array, func) {
      for (var i = 0; i < array.length; i++) {
        if (func(array[i])) {
          return array[i];
        }
      }

      return undefined;
    }

    /**
     * Flattens the given multidimensional array
     *
     * @return {Array}
     */

  }, {
    key: "flatten",
    value: function flatten(array) {
      return array.reduce(function (flat, toFlatten) {
        return flat.concat(Array.isArray(toFlatten) ? ArrayUtils.flatten(toFlatten) : toFlatten);
      }, []);
    }

    /**
     * Returns and array containing the numbers going from `start` (inclusive) to
     * `end` (exclusive)
     *
     * @param {number} start
     * @param {number} end
     * @returns Array
     */

  }, {
    key: "range",
    value: function range(start, end) {
      var arr = [];

      if (end > start) {
        for (var i = start; i < end; i++) {
          arr.push(i);
        }
      }

      return arr;
    }

    /**
     * Returns an array consisting of the value `val` repeated `n` times.
     *
     * @param {any} val
     * @param {number} n
     * @returns {Array}
     */

  }, {
    key: "repeat",
    value: function repeat(val, n) {
      var arr = [];

      for (var i = 0; i < n; i++) {
        arr[i] = val;
      }

      return arr;
    }

    /**
     * Returns an array which is an array of arrays of equally positioned items in both arrays,
     * e.g, zip([1, 2, 3], [4, 5, 6]) = [[1, 4], [2, 5], [3, 6]]
     *
     * @param {Array} a
     * @param {Array} b
     * @returns {Array}
     */

  }, {
    key: "zip",
    value: function zip(a, b) {
      var len = Math.min(a.length, b.length);
      var arr = [];

      for (var i = 0; i < len; i++) {
        arr[i] = [a[i], b[i]];
      }

      return arr;
    }
  }]);

  return ArrayUtils;
}();

exports.default = ArrayUtils;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = {
  getIEVersion: function getIEVersion() {
    var _navigator = navigator,
        userAgent = _navigator.userAgent,
        appVersion = _navigator.appVersion;

    if (appVersion.indexOf('MSIE') !== -1) {
      return appVersion.match(/MSIE\s+?([0-9]+)/i)[1];
    } else if (userAgent.indexOf('Trident') !== -1) {
      return userAgent.match(/rv:([0-9]+)/i)[1];
    } else {
      return false;
    }
  },
  isIE10: function isIE10() {
    var version = this.getIEVersion();
    return version !== false && version === 10;
  },
  isIE11: function isIE11() {
    var version = this.getIEVersion();
    return version !== false && version === 11;
  },
  isIElte: function isIElte(version) {
    var browserVersion = this.getIEVersion();
    if (browserVersion === false) return false;
    return browserVersion <= version;
  }
};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate, global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* eslint-disable */

/*!
 * Native Promise Only
 * v0.8.0-a (c) Kyle Simpson
 * MIT License: http://getify.mit-license.org
 */

/* istanbul ignore next */
var promiseFactory = function DEF() {
  /*jshint validthis:true */
  "use strict";

  var builtInProp,
      cycle,
      scheduling_queue,
      ToString = Object.prototype.toString,
      timer = typeof setImmediate != "undefined" ? function timer(fn) {
    return setImmediate(fn);
  } : setTimeout;

  // dammit, IE8.
  try {
    Object.defineProperty({}, "x", {});
    builtInProp = function builtInProp(obj, name, val, config) {
      return Object.defineProperty(obj, name, {
        value: val,
        writable: true,
        configurable: config !== false
      });
    };
  } catch (err) {
    builtInProp = function builtInProp(obj, name, val) {
      obj[name] = val;
      return obj;
    };
  }

  // Note: using a queue instead of array for efficiency
  scheduling_queue = function Queue() {
    var first, last, item;

    function Item(fn, self) {
      this.fn = fn;
      this.self = self;
      this.next = void 0;
    }

    return {
      add: function add(fn, self) {
        item = new Item(fn, self);
        if (last) {
          last.next = item;
        } else {
          first = item;
        }
        last = item;
        item = void 0;
      },
      drain: function drain() {
        var f = first;
        first = last = cycle = void 0;

        while (f) {
          f.fn.call(f.self);
          f = f.next;
        }
      }
    };
  }();

  function schedule(fn, self) {
    scheduling_queue.add(fn, self);
    if (!cycle) {
      cycle = timer(scheduling_queue.drain);
    }
  }

  // promise duck typing
  function isThenable(o) {
    var _then,
        o_type = typeof o === "undefined" ? "undefined" : _typeof(o);

    if (o != null && (o_type == "object" || o_type == "function")) {
      _then = o.then;
    }
    return typeof _then == "function" ? _then : false;
  }

  function notify() {
    for (var i = 0; i < this.chain.length; i++) {
      notifyIsolated(this, this.state === 1 ? this.chain[i].success : this.chain[i].failure, this.chain[i]);
    }
    this.chain.length = 0;
  }

  // NOTE: This is a separate function to isolate
  // the `try..catch` so that other code can be
  // optimized better
  function notifyIsolated(self, cb, chain) {
    var ret, _then;
    try {
      if (cb === false) {
        chain.reject(self.msg);
      } else {
        if (cb === true) {
          ret = self.msg;
        } else {
          ret = cb.call(void 0, self.msg);
        }

        if (ret === chain.promise) {
          chain.reject(TypeError("Promise-chain cycle"));
        } else if (_then = isThenable(ret)) {
          _then.call(ret, chain.resolve, chain.reject);
        } else {
          chain.resolve(ret);
        }
      }
    } catch (err) {
      chain.reject(err);
    }
  }

  function resolve(msg) {
    var _then,
        self = this;

    // already triggered?
    if (self.triggered) {
      return;
    }

    self.triggered = true;

    // unwrap
    if (self.def) {
      self = self.def;
    }

    try {
      if (_then = isThenable(msg)) {
        schedule(function () {
          var def_wrapper = new MakeDefWrapper(self);
          try {
            _then.call(msg, function $resolve$() {
              resolve.apply(def_wrapper, arguments);
            }, function $reject$() {
              reject.apply(def_wrapper, arguments);
            });
          } catch (err) {
            reject.call(def_wrapper, err);
          }
        });
      } else {
        self.msg = msg;
        self.state = 1;
        if (self.chain.length > 0) {
          schedule(notify, self);
        }
      }
    } catch (err) {
      reject.call(new MakeDefWrapper(self), err);
    }
  }

  function reject(msg) {
    var self = this;

    // already triggered?
    if (self.triggered) {
      return;
    }

    self.triggered = true;

    // unwrap
    if (self.def) {
      self = self.def;
    }

    self.msg = msg;
    self.state = 2;
    if (self.chain.length > 0) {
      schedule(notify, self);
    }
  }

  function iteratePromises(Constructor, arr, resolver, rejecter) {
    for (var idx = 0; idx < arr.length; idx++) {
      (function IIFE(idx) {
        Constructor.resolve(arr[idx]).then(function $resolver$(msg) {
          resolver(idx, msg);
        }, rejecter);
      })(idx);
    }
  }

  function MakeDefWrapper(self) {
    this.def = self;
    this.triggered = false;
  }

  function MakeDef(self) {
    this.promise = self;
    this.state = 0;
    this.triggered = false;
    this.chain = [];
    this.msg = void 0;
  }

  function Promise(executor) {
    if (typeof executor != "function") {
      throw TypeError("Not a function");
    }

    if (this.__NPO__ !== 0) {
      throw TypeError("Not a promise");
    }

    // instance shadowing the inherited "brand"
    // to signal an already "initialized" promise
    this.__NPO__ = 1;

    var def = new MakeDef(this);

    this["then"] = function then(success, failure) {
      var o = {
        success: typeof success == "function" ? success : true,
        failure: typeof failure == "function" ? failure : false
      };
      // Note: `then(..)` itself can be borrowed to be used against
      // a different promise constructor for making the chained promise,
      // by substituting a different `this` binding.
      o.promise = new this.constructor(function extractChain(resolve, reject) {
        if (typeof resolve != "function" || typeof reject != "function") {
          throw TypeError("Not a function");
        }

        o.resolve = resolve;
        o.reject = reject;
      });
      def.chain.push(o);

      if (def.state !== 0) {
        schedule(notify, def);
      }

      return o.promise;
    };
    this["catch"] = function $catch$(failure) {
      return this.then(void 0, failure);
    };

    try {
      executor.call(void 0, function publicResolve(msg) {
        resolve.call(def, msg);
      }, function publicReject(msg) {
        reject.call(def, msg);
      });
    } catch (err) {
      reject.call(def, err);
    }
  }

  var PromisePrototype = builtInProp({}, "constructor", Promise,
  /*configurable=*/false);

  // Note: Android 4 cannot use `Object.defineProperty(..)` here
  Promise.prototype = PromisePrototype;

  // built-in "brand" to signal an "uninitialized" promise
  builtInProp(PromisePrototype, "__NPO__", 0,
  /*configurable=*/false);

  builtInProp(Promise, "resolve", function Promise$resolve(msg) {
    var Constructor = this;

    // spec mandated checks
    // note: best "isPromise" check that's practical for now
    if (msg && (typeof msg === "undefined" ? "undefined" : _typeof(msg)) == "object" && msg.__NPO__ === 1) {
      return msg;
    }

    return new Constructor(function executor(resolve, reject) {
      if (typeof resolve != "function" || typeof reject != "function") {
        throw TypeError("Not a function");
      }

      resolve(msg);
    });
  });

  builtInProp(Promise, "reject", function Promise$reject(msg) {
    return new this(function executor(resolve, reject) {
      if (typeof resolve != "function" || typeof reject != "function") {
        throw TypeError("Not a function");
      }

      reject(msg);
    });
  });

  builtInProp(Promise, "all", function Promise$all(arr) {
    var Constructor = this;

    // spec mandated checks
    if (ToString.call(arr) != "[object Array]") {
      return Constructor.reject(TypeError("Not an array"));
    }
    if (arr.length === 0) {
      return Constructor.resolve([]);
    }

    return new Constructor(function executor(resolve, reject) {
      if (typeof resolve != "function" || typeof reject != "function") {
        throw TypeError("Not a function");
      }

      var len = arr.length,
          msgs = Array(len),
          count = 0;

      iteratePromises(Constructor, arr, function resolver(idx, msg) {
        msgs[idx] = msg;
        if (++count === len) {
          resolve(msgs);
        }
      }, reject);
    });
  });

  builtInProp(Promise, "race", function Promise$race(arr) {
    var Constructor = this;

    // spec mandated checks
    if (ToString.call(arr) != "[object Array]") {
      return Constructor.reject(TypeError("Not an array"));
    }

    return new Constructor(function executor(resolve, reject) {
      if (typeof resolve != "function" || typeof reject != "function") {
        throw TypeError("Not a function");
      }

      iteratePromises(Constructor, arr, function resolver(idx, msg) {
        resolve(msg);
      }, reject);
    });
  });

  return Promise;
};

var root = typeof global === 'undefined' ? window : global;
var _Promise = typeof Promise !== 'undefined' ? Promise : promiseFactory();
root.Promise = root.Promise || _Promise;
exports.default = _Promise;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(74).setImmediate, __webpack_require__(8)))

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(75);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8), __webpack_require__(21)))

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(77);
var util = __webpack_require__(79);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(80);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(78)(module), __webpack_require__(8)))

/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(81);
exports.encode = exports.stringify = __webpack_require__(82);


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports = {"pesdk.adjustments.text.brightness":"controls.adjustments.brightness","pesdk.adjustments.text.clarity":"controls.adjustments.clarity","pesdk.adjustments.text.contrast":"controls.adjustments.contrast","pesdk.adjustments.text.exposure":"controls.adjustments.exposure","pesdk.adjustments.text.gamma":"controls.adjustments.gamma","pesdk.adjustments.text.highlights":"controls.adjustments.highlights","pesdk.adjustments.text.saturation":"controls.adjustments.saturation","pesdk.adjustments.text.shadows":"controls.adjustments.shadows","pesdk.adjustments.title.name":"controls.overview.adjustments","pesdk.brush.text.size":"controls.brush.size","pesdk.brush.title.name":"controls.overview.brush","pesdk.camera.text.webcamUnavailable":"errors.webcamUnavailable.text","pesdk.camera.title.headline":"webcam.headline","pesdk.common.button.back":"generic.back","pesdk.common.button.cancel":"generic.cancel","pesdk.common.text.color":"generic.color","pesdk.common.text.imageLoadFailed":"errors.imageLoadFailed.text","pesdk.common.text.loading":"loading.loading","pesdk.common.title.error":"errors.title","pesdk.common.title.imageLoadFailed":"errors.imageLoadFailed.title","pesdk.editor.button.backgroundImage":"editor.backgroundImage","pesdk.editor.button.export":"editor.export","pesdk.editor.button.new":"editor.new","pesdk.editor.button.undo":"editor.undo","pesdk.editor.text.exporting":"loading.exporting","pesdk.editor.text.imageResized_maxDimensions":"warning.imageResized_maxDimensions.text","pesdk.editor.text.imageResized_maxMegaPixels":"warning.imageResized_maxMegaPixels.text","pesdk.editor.text.invalidFileType":"errors.invalidFileType.text","pesdk.editor.text.renderingError":"error.renderingError.text","pesdk.editor.text.resizing":"loading.resizing","pesdk.editor.title.imageResized_maxDimensions":"warnings.imageResized_maxDimensions.title","pesdk.editor.title.imageResized_maxMegaPixels":"warnings.imageResized_maxMegaPixels.title","pesdk.editor.title.renderingError":"errors.renderingError.title","pesdk.editor.title.zoom":"editor.zoom","pesdk.filter.asset.all":"controls.filter.categories.all","pesdk.filter.asset.identity":"controls.filter.filters.identity","pesdk.filter.asset.imgly_filters_analog":"controls.filter.categories.imgly_filters_analog","pesdk.filter.asset.imgly_filters_bw":"controls.filter.categories.imgly_filters_bw","pesdk.filter.asset.imgly_filters_retro":"controls.filter.categories.imgly_filters_retro","pesdk.filter.asset.imgly_filters_special":"controls.filter.categories.imgly_filters_special","pesdk.filter.asset.imgly_filters_summer":"controls.filter.categories.imgly_filters_summer","pesdk.filter.asset.imgly_filters_winter":"controls.filter.categories.imgly_filters_winter","pesdk.filter.asset.imgly_lut_ad1920":"controls.filter.filters.imgly_lut_ad1920","pesdk.filter.asset.imgly_lut_ancient":"controls.filter.filters.imgly_lut_ancient","pesdk.filter.asset.imgly_lut_bleached":"controls.filter.filters.imgly_lut_bleached","pesdk.filter.asset.imgly_lut_bleachedblue":"controls.filter.filters.imgly_lut_bleachedblue","pesdk.filter.asset.imgly_lut_blues":"controls.filter.filters.imgly_lut_blues","pesdk.filter.asset.imgly_lut_blueshadows":"controls.filter.filters.imgly_lut_blueshadows","pesdk.filter.asset.imgly_lut_breeze":"controls.filter.filters.imgly_lut_breeze","pesdk.filter.asset.imgly_lut_bw":"controls.filter.filters.imgly_lut_bw","pesdk.filter.asset.imgly_lut_celsius":"controls.filter.filters.imgly_lut_celsius","pesdk.filter.asset.imgly_lut_chest":"controls.filter.filters.imgly_lut_chest","pesdk.filter.asset.imgly_lut_classic":"controls.filter.filters.imgly_lut_classic","pesdk.filter.asset.imgly_lut_colorful":"controls.filter.filters.imgly_lut_colorful","pesdk.filter.asset.imgly_lut_cool":"controls.filter.filters.imgly_lut_cool","pesdk.filter.asset.imgly_lut_cottoncandy":"controls.filter.filters.imgly_lut_cottoncandy","pesdk.filter.asset.imgly_lut_creamy":"controls.filter.filters.imgly_lut_creamy","pesdk.filter.asset.imgly_lut_eighties":"controls.filter.filters.imgly_lut_eighties","pesdk.filter.asset.imgly_lut_elder":"controls.filter.filters.imgly_lut_elder","pesdk.filter.asset.imgly_lut_evening":"controls.filter.filters.imgly_lut_evening","pesdk.filter.asset.imgly_lut_fall":"controls.filter.filters.imgly_lut_fall","pesdk.filter.asset.imgly_lut_fixie":"controls.filter.filters.imgly_lut_fixie","pesdk.filter.asset.imgly_lut_food":"controls.filter.filters.imgly_lut_food","pesdk.filter.asset.imgly_lut_fridge":"controls.filter.filters.imgly_lut_fridge","pesdk.filter.asset.imgly_lut_front":"controls.filter.filters.imgly_lut_front","pesdk.filter.asset.imgly_lut_glam":"controls.filter.filters.imgly_lut_glam","pesdk.filter.asset.imgly_lut_gobblin":"controls.filter.filters.imgly_lut_gobblin","pesdk.filter.asset.imgly_lut_highcarb":"controls.filter.filters.imgly_lut_highcarb","pesdk.filter.asset.imgly_lut_highcontrast":"controls.filter.filters.imgly_lut_highcontrast","pesdk.filter.asset.imgly_lut_k1":"controls.filter.filters.imgly_lut_k1","pesdk.filter.asset.imgly_lut_k2":"controls.filter.filters.imgly_lut_k2","pesdk.filter.asset.imgly_lut_k6":"controls.filter.filters.imgly_lut_k6","pesdk.filter.asset.imgly_lut_kdynamic":"controls.filter.filters.imgly_lut_kdynamic","pesdk.filter.asset.imgly_lut_keen":"controls.filter.filters.imgly_lut_keen","pesdk.filter.asset.imgly_lut_lenin":"controls.filter.filters.imgly_lut_lenin","pesdk.filter.asset.imgly_lut_litho":"controls.filter.filters.imgly_lut_litho","pesdk.filter.asset.imgly_lut_lomo100":"controls.filter.filters.imgly_lut_lomo100","pesdk.filter.asset.imgly_lut_lucid":"controls.filter.filters.imgly_lut_lucid","pesdk.filter.asset.imgly_lut_mellow":"controls.filter.filters.imgly_lut_mellow","pesdk.filter.asset.imgly_lut_neat":"controls.filter.filters.imgly_lut_neat","pesdk.filter.asset.imgly_lut_nogreen":"controls.filter.filters.imgly_lut_nogreen","pesdk.filter.asset.imgly_lut_orchid":"controls.filter.filters.imgly_lut_orchid","pesdk.filter.asset.imgly_lut_pale":"controls.filter.filters.imgly_lut_pale","pesdk.filter.asset.imgly_lut_pitched":"controls.filter.filters.imgly_lut_pitched","pesdk.filter.asset.imgly_lut_plate":"controls.filter.filters.imgly_lut_plate","pesdk.filter.asset.imgly_lut_pola669":"controls.filter.filters.imgly_lut_pola669","pesdk.filter.asset.imgly_lut_polasx":"controls.filter.filters.imgly_lut_polasx","pesdk.filter.asset.imgly_lut_pro400":"controls.filter.filters.imgly_lut_pro400","pesdk.filter.asset.imgly_lut_quozi":"controls.filter.filters.imgly_lut_quozi","pesdk.filter.asset.imgly_lut_sepiahigh":"controls.filter.filters.imgly_lut_sepiahigh","pesdk.filter.asset.imgly_lut_settled":"controls.filter.filters.imgly_lut_settled","pesdk.filter.asset.imgly_lut_seventies":"controls.filter.filters.imgly_lut_seventies","pesdk.filter.asset.imgly_lut_sin":"controls.filter.filters.imgly_lut_sin","pesdk.filter.asset.imgly_lut_soft":"controls.filter.filters.imgly_lut_soft","pesdk.filter.asset.imgly_lut_steel":"controls.filter.filters.imgly_lut_steel","pesdk.filter.asset.imgly_lut_summer":"controls.filter.filters.imgly_lut_summer","pesdk.filter.asset.imgly_lut_sunset":"controls.filter.filters.imgly_lut_sunset","pesdk.filter.asset.imgly_lut_tender":"controls.filter.filters.imgly_lut_tender","pesdk.filter.asset.imgly_lut_texas":"controls.filter.filters.imgly_lut_texas","pesdk.filter.asset.imgly_lut_twilight":"controls.filter.filters.imgly_lut_twilight","pesdk.filter.asset.imgly_lut_winter":"controls.filter.filters.imgly_lut_winter","pesdk.filter.asset.imgly_lut_x400":"controls.filter.filters.imgly_lut_x400","pesdk.filter.text.intensity":"controls.filter.intensity","pesdk.filter.title.name":"controls.overview.filters","pesdk.focus.button.mirrored":"controls.focus.mirrored","pesdk.focus.button.none":"controls.focus.none","pesdk.focus.button.radial":"controls.focus.radial","pesdk.focus.text.blurRadius":"controls.focus.blurRadius","pesdk.focus.title.name":"controls.overview.focus","pesdk.frame.asset.imgly_frame_art_decor":"controls.frame.frames.imgly_frame_art_decor","pesdk.frame.asset.imgly_frame_black_passepartout":"controls.frame.frames.imgly_frame_black_passepartout","pesdk.frame.asset.imgly_frame_dia":"controls.frame.frames.imgly_frame_dia","pesdk.frame.asset.imgly_frame_lowpoly_shadow":"controls.frame.frames.imgly_frame_lowpoly_shadow","pesdk.frame.asset.imgly_frame_wood_passepartout":"controls.frame.frames.imgly_frame_wood_passepartout","pesdk.frame.button.none":"controls.frame.noFrame","pesdk.frame.text.scale":"controls.frame.scale","pesdk.frame.title.name":"controls.overview.frame","pesdk.library.placeholder.search":"photoRoll.search.placeholder","pesdk.library.text.noSearchResults":"photoRoll.search.noSearchResults","pesdk.library.text.photoRollLoadFail":"errors.photoRollLoadFail.text","pesdk.library.title.photoRollLoadFail":"errors.photoRollLoadFail.title","pesdk.library.title.seachResults":"photoRoll.search.results.headline","pesdk.splash.button.upload":"splash.upload.button","pesdk.splash.text.photoRoll":"splash.photoRoll.description","pesdk.splash.text.upload":"splash.upload.description","pesdk.splash.text.webcam":"splash.webcam.description","pesdk.splash.title.photoRoll":"splash.photoRoll.headline","pesdk.splash.title.webcam":"splash.webcam.headline","pesdk.sticker.asset.imgly_sticker_emoticons":"controls.sticker.categories.imgly_sticker_emoticons","pesdk.sticker.asset.imgly_sticker_shapes":"controls.sticker.categories.imgly_sticker_shapes","pesdk.sticker.title.loadingStickersFailed":"errors.loadingStickersFailed.title","pesdk.sticker.title.name":"controls.overview.sticker","pesdk.text.button.alignment":"controls.text.alignment","pesdk.text.button.background":"controls.text.background","pesdk.text.button.font":"controls.text.font","pesdk.text.button.foreground":"controls.text.foreground","pesdk.text.button.size":"controls.text.size","pesdk.text.button.takeToFront":"controls.text.takeToFront","pesdk.text.placeholder.defaultText":"controls.text.defaultText","pesdk.text.text.loadingFontsFailed":"errors.loadingFontsFailed.text","pesdk.text.title.loadingFontsFailed":"errors.loadingFontsFailed.title","pesdk.text.title.name":"controls.overview.text","pesdk.transform.asset.imgly_transform_common_16-9":"controls.transform.ratios.imgly_transform_common_16-9","pesdk.transform.asset.imgly_transform_common_4-3":"controls.transform.ratios.imgly_transform_common_4-3","pesdk.transform.asset.imgly_transform_common_custom":"controls.transform.ratios.imgly_transform_common_custom","pesdk.transform.asset.imgly_transform_common_square":"controls.transform.ratios.imgly_transform_common_square","pesdk.transform.asset.imgly_transform_facebook_ad":"controls.transform.ratios.imgly_transform_facebook_ad","pesdk.transform.asset.imgly_transform_facebook_cover":"controls.transform.ratios.imgly_transform_facebook_cover","pesdk.transform.asset.imgly_transform_facebook_post":"controls.transform.ratios.imgly_transform_facebook_post","pesdk.transform.asset.imgly_transform_facebook_profile":"controls.transform.ratios.imgly_transform_facebook_profile","pesdk.transform.button.none":"controls.transform.none","pesdk.transform.text.rotation":"controls.transform.rotation","pesdk.transform.title.name":"controls.overview.transform"}

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _photoeditorsdk = __webpack_require__(7);

var _photoeditorsdk2 = _interopRequireDefault(_photoeditorsdk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fonts = [{
  fontFamily: 'Aleo',
  variations: [{
    identifier: 'imgly_font_aleo_bold',
    fontWeight: 'bold',
    provider: 'file',
    filePath: 'fonts/imgly_font_aleo_bold.woff',
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1919,
      descender: -409
    }
  }]
}, {
  fontFamily: 'Amatic SC',
  variations: [{
    identifier: 'imgly_font_amaticsc',
    fontWeight: 'normal',
    provider: 'file',
    filePath: 'fonts/imgly_font_amaticsc.woff',
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 2332,
      descender: -583
    }
  }]
}, {
  fontFamily: 'Bernier',
  variations: [{
    identifier: 'imgly_font_bernier_regular',
    fontWeight: 'normal',
    provider: 'file',
    filePath: 'fonts/imgly_font_bernier_regular.woff',
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 2007,
      descender: -552
    }
  }]
}, {
  fontFamily: 'Cheque',
  variations: [{
    identifier: 'imgly_font_cheque_regular',
    fontWeight: 'normal',
    provider: 'file',
    filePath: 'fonts/imgly_font_cheque_regular.woff',
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1853,
      descender: -495
    }
  }]
}, {
  fontFamily: 'Open Sans',
  variations: [{
    identifier: 'imgly_font_open_sans_bold',
    fontWeight: 'bold',
    provider: 'file',
    filePath: 'fonts/imgly_font_open_sans_bold.woff',
    default: true,
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 2189,
      descender: -640
    }
  }]
}, {
  fontFamily: 'Gagalin',
  variations: [{
    identifier: 'imgly_font_gagalin_regular',
    fontWeight: 'normal',
    provider: 'file',
    filePath: 'fonts/imgly_font_gagalin_regular.woff',
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1987,
      descender: -628
    }
  }]
}, {
  fontFamily: 'Hagin',
  variations: [{
    identifier: 'imgly_font_hagin_caps_thin',
    fontWeight: 200,
    provider: 'file',
    filePath: 'fonts/imgly_font_hagin_caps_thin.woff',
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1964,
      descender: -482
    }
  }]
}, {
  fontFamily: 'Intro',
  variations: [{
    identifier: 'imgly_font_intro_inline',
    fontWeight: 'normal',
    provider: 'file',
    filePath: 'fonts/imgly_font_intro_inline.woff',
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1944,
      descender: -548
    }
  }]
}, {
  fontFamily: 'Lobster',
  variations: [{
    identifier: 'imgly_font_lobster',
    fontWeight: 'normal',
    provider: 'file',
    filePath: 'fonts/imgly_font_lobster.woff',
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 2048,
      descender: -552
    }
  }]
}, {
  fontFamily: 'Nexa',
  variations: [{
    identifier: 'imgly_font_nexa_script',
    fontWeight: 'normal',
    provider: 'file',
    filePath: 'fonts/imgly_font_nexa_script.woff',
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1835,
      descender: -663
    }
  }]
}, {
  fontFamily: 'Ostrich',
  variations: [{
    identifier: 'imgly_font_ostrich_sans_black',
    fontWeight: 800,
    provider: 'file',
    filePath: 'fonts/imgly_font_ostrich_sans_black.woff',
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1513,
      descender: -235
    }
  }, {
    identifier: 'imgly_font_ostrich_sans_bold',
    fontWeight: 'bold',
    provider: 'file',
    filePath: 'fonts/imgly_font_ostrich_sans_bold.woff',
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1513,
      descender: -235
    }
  }]
}, {
  fontFamily: 'Panton',
  variations: [{
    identifier: 'imgly_font_panton_black_italic_caps',
    fontWeight: 800,
    fontStyle: 'italic',
    provider: 'file',
    filePath: 'fonts/imgly_font_panton_blackitalic_caps.woff',
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 2033,
      descender: -572
    }
  }, {
    identifier: 'imgly_font_panton_light_italic_caps',
    fontWeight: 200,
    fontStyle: 'italic',
    provider: 'file',
    filePath: 'fonts/imgly_font_panton_lightitalic_caps.woff',
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1961,
      descender: -556
    }
  }]
}, {
  fontFamily: 'Perfograma',
  variations: [{
    identifier: 'imgly_font_perfograma',
    fontWeight: 'normal',
    provider: 'file',
    filePath: 'fonts/imgly_font_perfograma.woff',
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1982,
      descender: -842
    }
  }]
}, {
  fontFamily: 'Trashhand',
  variations: [{
    identifier: 'imgly_font_trash_hand',
    fontWeight: 'normal',
    provider: 'file',
    filePath: 'fonts/imgly_font_trash_hand.woff',
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1554,
      descender: -663
    }
  }]
}]; /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = {
  EVENTS: {
    RENDER: 'render',
    EXPORT: 'export',
    EDITOR_READY: 'editor:ready',
    CLOSE: 'close',
    ZOOM_DONE: 'zoom:done',
    OPERATION_CREATED: 'operation:created',
    OPERATION_UPDATED: 'operation:updated',
    OPERATION_REMOVED: 'operation:removed',
    FEATURES_DISABLED: 'editor:features:disabled',
    FEATURES_ENABLED: 'editor:features:enabled',
    FEATURES_UPDATED: 'editor:features:updated',
    COLORPICKER_OPEN: 'colorpicker:open',
    HISTORY_UPDATED: 'history:update',
    HISTORY_BEFORE_UNDO: 'history:before_undo',
    HISTORY_UNDO: 'history:undo',
    WINDOW_RESIZE: 'window:resize',
    CONTROLS_SWITCHED: 'controls:switched',
    TRANSFORM_REAPPLY_RATIO: 'transform:reapply_ratio'
  },
  DEFAULTS: {
    TRANSFORM_RATIOS: [[{
      identifier: 'imgly_transform_common_custom',
      defaultName: 'Custom',
      ratio: '*',
      selected: true
    }, {
      identifier: 'imgly_transform_common_square',
      defaultName: 'Square',
      ratio: 1
    }, {
      identifier: 'imgly_transform_common_4-3',
      defaultName: '4:3',
      ratio: 1.33
    }, {
      identifier: 'imgly_transform_common_16-9',
      defaultName: '16:9',
      ratio: 1.77
    }], [{
      identifier: 'imgly_transform_facebook_profile',
      defaultName: 'FB Profile',
      ratio: 1 / 1
    }, {
      identifier: 'imgly_transform_facebook_ad',
      defaultName: 'FB Ad',
      dimensions: new _photoeditorsdk2.default.Math.Vector2(1200, 627)
    }, {
      identifier: 'imgly_transform_facebook_post',
      defaultName: 'FB Post',
      dimensions: new _photoeditorsdk2.default.Math.Vector2(940, 788)
    }, {
      identifier: 'imgly_transform_facebook_cover',
      defaultName: 'FB Cover',
      dimensions: new _photoeditorsdk2.default.Math.Vector2(851, 315)
    }]],
    BRUSHES: [_photoeditorsdk2.default.Operations.SpriteOperation.BrushSprite.Brushes.RadialBrush],
    FONTS: fonts
  }
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _photoeditorsdk = __webpack_require__(7);

var _photoeditorsdk2 = _interopRequireDefault(_photoeditorsdk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var EventEmitter = _photoeditorsdk2.default.EventEmitter,
    Utils = _photoeditorsdk2.default.Utils,
    Log = _photoeditorsdk2.default.Log;

var SharedState = function (_EventEmitter) {
  _inherits(SharedState, _EventEmitter);

  function SharedState() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, SharedState);

    var _this = _possibleConstructorReturn(this, (SharedState.__proto__ || Object.getPrototypeOf(SharedState)).call(this));

    _this._state = state;
    return _this;
  }

  /**
   * Sets the given state
   * @param {Object} newState
   * @param {Boolean} update = true
   */


  _createClass(SharedState, [{
    key: 'set',
    value: function set() {
      var newState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if ((typeof newState === 'undefined' ? 'undefined' : _typeof(newState)) !== 'object') {
        Log.warn('SharedState#set expects an object as first parameter');
      }

      var oldState = Utils.extend({}, this._state);
      this._state = Utils.extend(this._state, newState);

      if (update) {
        this.broadcastUpdate(oldState, this._state);
      }
    }

    /**
     * Returns the state for the given property
     * @param {String} prop
     */

  }, {
    key: 'get',
    value: function get(prop) {
      return this._state[prop];
    }

    /**
     * Broadcasts an update
     * @param {Object} oldState
     * @param {Object} newState
     */

  }, {
    key: 'broadcastUpdate',
    value: function broadcastUpdate(oldState) {
      var newState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this.emit('update', oldState, newState);
    }

    /**
     * Clears the state
     */

  }, {
    key: 'clear',
    value: function clear() {
      this._state = {};
    }
  }]);

  return SharedState;
}(EventEmitter);

exports.default = SharedState;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
 * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
 * requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel
 * MIT license
 * @license
 */

/* eslint-disable standard/no-callback-literal */

var root = typeof window === 'undefined' ? global : window;
var rAF = root.requestAnimationFrame;
var cAF = root.cancelAnimationFrame;

var lastTime = 0;
var vendors = ['ms', 'moz', 'webkit', 'o'];
for (var x = 0; x < vendors.length && !rAF; ++x) {
  exports.requestAnimationFrame = rAF = root[vendors[x] + 'RequestAnimationFrame'];
  exports.cancelAnimationFrame = cAF = root[vendors[x] + 'CancelAnimationFrame'] || root[vendors[x] + 'CancelRequestAnimationFrame'];
}

/* Bind to root is necessary as the context must be valid */
if (rAF) {
  exports.requestAnimationFrame = rAF = rAF.bind(root);
}
if (cAF) {
  exports.cancelAnimationFrame = cAF = cAF.bind(root);
}

/* istanbul ignore next */
if (!rAF) {
  exports.requestAnimationFrame = rAF = function rAF(callback, element) {
    var currTime = new Date().getTime();
    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
    var id = setTimeout(function () {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };
}

/* istanbul ignore next */
if (!cAF) {
  exports.cancelAnimationFrame = cAF = function cAF(id) {
    clearTimeout(id);
  };
}

exports.requestAnimationFrame = rAF;
exports.cancelAnimationFrame = cAF;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _loadingScreenComponent = __webpack_require__(88);

var _loadingScreenComponent2 = _interopRequireDefault(_loadingScreenComponent);

var _splashScreenComponent = __webpack_require__(90);

var _splashScreenComponent2 = _interopRequireDefault(_splashScreenComponent);

var _photoRollScreenComponent = __webpack_require__(97);

var _photoRollScreenComponent2 = _interopRequireDefault(_photoRollScreenComponent);

var _webcamScreenComponent = __webpack_require__(107);

var _webcamScreenComponent2 = _interopRequireDefault(_webcamScreenComponent);

var _editorScreenComponent = __webpack_require__(110);

var _editorScreenComponent2 = _interopRequireDefault(_editorScreenComponent);

var _screenComponent = __webpack_require__(9);

var _screenComponent2 = _interopRequireDefault(_screenComponent);

var _modalContainerComponent = __webpack_require__(191);

var _modalContainerComponent2 = _interopRequireDefault(_modalContainerComponent);

var _modalManager = __webpack_require__(1);

var _modalManager2 = _interopRequireDefault(_modalManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var AppComponent = function (_React$Component) {
  _inherits(AppComponent, _React$Component);

  function AppComponent() {
    var _ref;

    _classCallCheck(this, AppComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = AppComponent.__proto__ || Object.getPrototypeOf(AppComponent)).call.apply(_ref, [this].concat(args)));

    _this._onScreenMounted = function (name, el) {
      _this._screenElements[name + 'Screen'] = el;

      if (name === 'editor' && !_this._isReady) {
        _this._isReady = true;
        _this.props.mediator.emit(_globals.Constants.EVENTS.EDITOR_READY);
      }
    };

    _this._screens = {
      loading: _loadingScreenComponent2.default,
      splash: _splashScreenComponent2.default,
      photoRoll: _photoRollScreenComponent2.default,
      webcam: _webcamScreenComponent2.default,
      editor: _editorScreenComponent2.default,
      empty: _screenComponent2.default
    };

    var initialScreen = void 0;
    if (_this.props.options.preloader) {
      initialScreen = 'loading';
    }

    _this._screenAfterLoading = 'splash';
    if (_this.props.options.editor.image) {
      _this._screenAfterLoading = 'editor';
    }

    if (!initialScreen) {
      initialScreen = _this._screenAfterLoading;
    }

    _this._screenElements = {};

    _this._isReady = false;

    _this._previousScreensStack = [];
    _this.state = {
      activeScreen: _this._screens[initialScreen],
      activeScreenName: initialScreen,
      screens: _defineProperty({}, initialScreen, _this._screens[initialScreen])
    };
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Checks if the app has a previous screen on the stack
   * @return {Boolean}
   */


  _createClass(AppComponent, [{
    key: 'hasPreviousScreen',
    value: function hasPreviousScreen() {
      return !!this._previousScreensStack.length;
    }

    /**
     * Returns the previous screen
     * @return {Screen}
     */

  }, {
    key: 'getPreviousScreen',
    value: function getPreviousScreen() {
      var stack = this._previousScreensStack;
      return stack[stack.length - 1];
    }

    /**
     * Switches to the screen with the given name
     * @param  {String} name
     */

  }, {
    key: 'switchToScreen',
    value: function switchToScreen(name) {
      var _this2 = this;

      var Screen = null;
      if (name === 'back') {
        Screen = this._previousScreensStack.pop();
        if (!Screen) {
          throw new Error('Unable to switch to previous screen - no previous screen found.');
        }
      } else {
        if (name === 'post-loading') name = this._screenAfterLoading;

        Screen = this._screens[name];
        if (!Screen) {
          throw new Error('Unknown screen `' + name + '`');
        }

        this._previousScreensStack.push(this.state.activeScreen);
      }

      if (!this.state.screens[name]) {
        this.state.screens[name] = Screen;
      }

      // Retain editor component
      if (this.state.activeScreenName !== 'editor') {
        delete this.state.screens[this.state.activeScreenName];
      }

      return new _globals.Promise(function (resolve) {
        _this2.setState({ activeScreen: Screen, activeScreenName: name }, function () {
          resolve();
        });
      });
    }

    /**
     * Gets called when an image is ready for editing
     * @param {Image} image
     * @param {Boolean} resetEditor
     */

  }, {
    key: 'setImage',
    value: function setImage(image, resetEditor) {
      var _this3 = this;

      var options = this.props.options;

      options.editor.image = image;

      var firstEditorLaunch = !this._screenElements.editorScreen;
      this.switchToScreen('editor').then(function () {
        if (!firstEditorLaunch) {
          _this3._screenElements.editorScreen.setImage(image, resetEditor);
        }
      });
    }

    /**
     * Exports an image
     * @param {Boolean} download = false
     * @return {Promise}
     */

  }, {
    key: 'export',
    value: function _export() {
      if (this.state.activeScreen !== this._screens.editor) {
        return _globals.Promise.reject(new Error('Unable to export: Active screen is not the editor screen.'));
      }

      if (this.state.screens.editor) {
        var _screenElements$edito;

        return (_screenElements$edito = this._screenElements.editorScreen).export.apply(_screenElements$edito, arguments);
      }
    }

    /**
     * Returns the editor
     * @return {PhotoEditorSDK.UI.ReactUI.Editor}
     */

  }, {
    key: 'getEditor',
    value: function getEditor() {
      if (this.state.activeScreen !== this._screens.editor) {
        return _globals.Promise.reject(new Error('Unable to get editor: Active screen is not the editor screen.'));
      }

      if (this.state.screens.editor) {
        return this._screenElements.editorScreen.getEditor();
      }
    }

    /**
     * Serializes the editor state
     * @return {Promise}
     */

  }, {
    key: 'serialize',
    value: function serialize() {
      var _screenElements$edito2;

      if (!this.state.screens.editor) {
        return _globals.Promise.reject(new Error('Editor screen unavailable'));
      }
      return (_screenElements$edito2 = this._screenElements.editorScreen).serialize.apply(_screenElements$edito2, arguments);
    }

    /**
     * Deserializes the given data
     * @param  {Object} data
     * @return {Promise}
     */

  }, {
    key: 'deserialize',
    value: function deserialize(data) {
      if (!this.state.screens.editor) {
        return _globals.Promise.reject(new Error('Editor screen unavailable'));
      }
      return this._screenElements.editorScreen.deserialize(data);
    }

    /**
     * Returns the context passed to all children
     * @return {Object}
     */

  }, {
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        ui: this.props.ui,
        options: this.props.options,
        mediator: this.props.mediator,
        globalState: this.props.globalState
      };
    }
  }, {
    key: '_renderScreens',


    /**
     * Renders the existing screens
     * @return {ScreenComponent[]}
     * @private
     */
    value: function _renderScreens() {
      var _this4 = this;

      var renderedScreens = [];

      var _loop = function _loop(name) {
        var Screen = _this4.state.screens[name];
        var visible = _this4.state.activeScreen === Screen;
        renderedScreens.push(_globals.ReactBEM.createElement(Screen, { ref: function ref(el) {
            return _this4._onScreenMounted(name, el);
          }, app: _this4, visible: visible }));
      };

      for (var name in this.state.screens) {
        _loop(name);
      }

      return renderedScreens;
    }

    /**
     * Renders this component
     * @return {React.Component}
     */

  }, {
    key: 'render',
    value: function render() {
      return _globals.ReactBEM.transform(_globals.ReactBEM.createElement(
        'div',
        { bem: 'b:editor' },
        _globals.ReactBEM.createElement(_modalContainerComponent2.default, {
          modalManager: _modalManager2.default.instance }),
        this._renderScreens()
      ));
    }
  }]);

  return AppComponent;
}(_globals.React.Component);

exports.default = AppComponent;


AppComponent.childContextTypes = {
  ui: _globals.PropTypes.object.isRequired,
  mediator: _globals.PropTypes.object.isRequired,
  options: _globals.PropTypes.object.isRequired,
  globalState: _globals.PropTypes.object.isRequired
};

AppComponent.propTypes = {
  ui: _globals.PropTypes.object.isRequired,
  mediator: _globals.PropTypes.object.isRequired,
  options: _globals.PropTypes.object.isRequired,
  globalState: _globals.PropTypes.object.isRequired
};

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _screenComponent = __webpack_require__(9);

var _screenComponent2 = _interopRequireDefault(_screenComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */


var LoadingScreenComponent = function (_ScreenComponent) {
  _inherits(LoadingScreenComponent, _ScreenComponent);

  function LoadingScreenComponent() {
    var _ref;

    _classCallCheck(this, LoadingScreenComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = LoadingScreenComponent.__proto__ || Object.getPrototypeOf(LoadingScreenComponent)).call.apply(_ref, [this].concat(args)));

    _this.state = { progress: 0 };

    _this._preloader = _this.context.ui.getPreloader();
    _this._preloader.on('progress', function (progress) {
      _this.state.progress = progress;
    });
    _this._preloader.on('done', function () {
      _this.props.app.switchToScreen('post-loading');
    });
    return _this;
  }

  /**
   * Gets called when this component has been mounted
   */


  _createClass(LoadingScreenComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      _get(LoadingScreenComponent.prototype.__proto__ || Object.getPrototypeOf(LoadingScreenComponent.prototype), 'componentDidMount', this).call(this);
      var _window = window,
          devicePixelRatio = _window.devicePixelRatio;

      this._canvas = this.refs.canvas;
      this._canvas.width = this._canvas.offsetWidth * devicePixelRatio;
      this._canvas.height = this._canvas.offsetHeight * devicePixelRatio;
      this._context = this._canvas.getContext('2d');

      this._preloaderImage = new window.Image();
      this._preloaderImage.addEventListener('load', function () {
        _this2._preloader.load();
        (0, _globals.requestAnimationFrame)(_this2._tick);
      });
      this._preloaderImage.crossOrigin = 'Anonymous';
      this._preloaderImage.src = this.context.ui.getAssetPath('preloader.png', true);

      this._running = true;
      this._tick = this._tick.bind(this);
    }

    /**
     * Gets called when this component is about to be unmounted
     */

  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      _get(LoadingScreenComponent.prototype.__proto__ || Object.getPrototypeOf(LoadingScreenComponent.prototype), 'componentWillUnmount', this).call(this);
      this._running = false;
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * @private
     */

  }, {
    key: '_tick',
    value: function _tick() {
      this._renderLoadingIndicator();
      if (this._running) {
        (0, _globals.requestAnimationFrame)(this._tick);
      }
    }

    /**
     * (Re-)Renders the loading indicator
     * @private
     */

  }, {
    key: '_renderLoadingIndicator',
    value: function _renderLoadingIndicator() {
      var _canvas = this._canvas,
          width = _canvas.width,
          height = _canvas.height;

      var ctx = this._context;
      ctx.clearRect(0, 0, width, height);

      ctx.save();
      ctx.beginPath();
      ctx.moveTo(width / 2, height / 2);
      ctx.arc(width / 2, height / 2, width / 2, -Math.PI * 0.5, Math.PI * 2 * this.state.progress - Math.PI * 0.5, false);
      ctx.lineTo(width / 2, height / 2);
      ctx.clip();
      ctx.drawImage(this._preloaderImage, 0, 0, this._preloaderImage.width, this._preloaderImage.height, 0, 0, width, height);
      ctx.restore();

      ctx.save();
      ctx.globalAlpha = 0.05;
      ctx.drawImage(this._preloaderImage, 0, 0, this._preloaderImage.width, this._preloaderImage.height, 0, 0, width, height);
      ctx.restore();
    }

    /**
     * Renders this screen
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderScreen',
    value: function _renderScreen() {
      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:loadingScreen' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:container' },
          _globals.ReactBEM.createElement('canvas', { bem: 'e:canvas', ref: 'canvas' })
        )
      );
    }
  }]);

  return LoadingScreenComponent;
}(_screenComponent2.default);

exports.default = LoadingScreenComponent;


LoadingScreenComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */


var HeaderComponent = function (_BaseComponent) {
  _inherits(HeaderComponent, _BaseComponent);

  function HeaderComponent() {
    var _ref;

    _classCallCheck(this, HeaderComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = HeaderComponent.__proto__ || Object.getPrototypeOf(HeaderComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onCloseClick');
    return _this;
  }

  /**
   * Gets called when the user clicks the close button
   * @private
   */


  _createClass(HeaderComponent, [{
    key: '_onCloseClick',
    value: function _onCloseClick() {
      this.context.mediator.emit(_globals.Constants.EVENTS.CLOSE);
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var closeButton = void 0;
      if (this.context.options.showCloseButton) {
        closeButton = _globals.ReactBEM.createElement(
          'div',
          { bem: '$e:close', onClick: this._onCloseClick },
          _globals.ReactBEM.createElement('img', { bem: 'e:image', src: this._getAssetPath('close.png', true) })
        );
      }

      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:header' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:label' },
          this.context.options.title
        ),
        closeButton
      );
    }
  }]);

  return HeaderComponent;
}(_globals.BaseComponent);

exports.default = HeaderComponent;


HeaderComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _screenComponent = __webpack_require__(9);

var _screenComponent2 = _interopRequireDefault(_screenComponent);

var _uploadComponent = __webpack_require__(91);

var _uploadComponent2 = _interopRequireDefault(_uploadComponent);

var _webcamComponent = __webpack_require__(95);

var _webcamComponent2 = _interopRequireDefault(_webcamComponent);

var _photoRollComponent = __webpack_require__(96);

var _photoRollComponent2 = _interopRequireDefault(_photoRollComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */


var SplashScreenComponent = function (_ScreenComponent) {
  _inherits(SplashScreenComponent, _ScreenComponent);

  function SplashScreenComponent() {
    _classCallCheck(this, SplashScreenComponent);

    var _this = _possibleConstructorReturn(this, (SplashScreenComponent.__proto__ || Object.getPrototypeOf(SplashScreenComponent)).call(this));

    _this._bindAll('_onWebcamClick', '_onPhotoRollClick', '_onImage');
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the PhotoRollComponent has received a click
   * @private
   */


  _createClass(SplashScreenComponent, [{
    key: '_onPhotoRollClick',
    value: function _onPhotoRollClick() {
      this.props.app.switchToScreen('photoRoll');
    }

    /**
     * Gets called when the WebcamComponent has received a click
     * @private
     */

  }, {
    key: '_onWebcamClick',
    value: function _onWebcamClick() {
      this.props.app.switchToScreen('webcam');
    }

    /**
     * Gets called when the UploadComponent has received an image file
     * @param  {image} image
     * @private
     */

  }, {
    key: '_onImage',
    value: function _onImage(image) {
      this.props.app.setImage(image);
    }

    // -------------------------------------------------------------------------- MISC

    /**
     * Checks if the webcam is available for the given device
     * @return {Boolean}
     * @private
     */

  }, {
    key: '_isWebcamAvailable',
    value: function _isWebcamAvailable() {
      return !_globals.Utils.isMobile() && this.context.options.enableWebcam !== false;
    }

    /**
     * Checks if the photo roll is available
     * @return {Boolean}
     * @private
     */

  }, {
    key: '_isPhotoRollAvailable',
    value: function _isPhotoRollAvailable() {
      return !!this.context.options.photoRoll.provider;
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this screen
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderScreen',
    value: function _renderScreen() {
      var items = [];
      var totalRows = 0;

      var uploadAvailable = this.context.options.enableUpload;
      if (uploadAvailable) totalRows++;

      var webcamAvailable = this._isWebcamAvailable();
      if (webcamAvailable) totalRows++;

      var photoRollAvailable = this._isPhotoRollAvailable();
      if (photoRollAvailable) totalRows++;

      if (uploadAvailable) {
        items.push(_globals.ReactBEM.createElement(_uploadComponent2.default, {
          onImage: this._onImage,
          totalRows: totalRows }));
      }

      if (webcamAvailable) {
        items.push(_globals.ReactBEM.createElement(_webcamComponent2.default, {
          onClick: this._onWebcamClick,
          totalRows: totalRows }));
      }

      if (photoRollAvailable) {
        items.push(_globals.ReactBEM.createElement(_photoRollComponent2.default, {
          onClick: this._onPhotoRollClick,
          totalRows: totalRows }));
      }

      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:splashScreen' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:container' },
          items
        )
      );
    }
  }]);

  return SplashScreenComponent;
}(_screenComponent2.default);

exports.default = SplashScreenComponent;


SplashScreenComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _modalManager = __webpack_require__(1);

var _modalManager2 = _interopRequireDefault(_modalManager);

var _rowComponent = __webpack_require__(24);

var _rowComponent2 = _interopRequireDefault(_rowComponent);

var _buttonComponent = __webpack_require__(92);

var _buttonComponent2 = _interopRequireDefault(_buttonComponent);

var _invisibleUploadComponent = __webpack_require__(25);

var _invisibleUploadComponent2 = _interopRequireDefault(_invisibleUploadComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var UploadComponent = function (_RowComponent) {
  _inherits(UploadComponent, _RowComponent);

  function UploadComponent() {
    _classCallCheck(this, UploadComponent);

    var _this = _possibleConstructorReturn(this, (UploadComponent.__proto__ || Object.getPrototypeOf(UploadComponent)).call(this));

    _this._modifier = 'upload';

    _this._bindAll('_onImage', '_onDragEnter', '_onDragOver', '_onDragLeave', '_onDrop');

    _this._dragCounter = 0;
    _this.state = { dragAreaHovered: false };
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the cell emits a `dragEnter` event. Highlights
   * the cell
   * @param {Event} e
   * @private
   */


  _createClass(UploadComponent, [{
    key: '_onDragEnter',
    value: function _onDragEnter(e) {
      e.preventDefault();

      this._dragCounter++;
      this.setState({ dragAreaHovered: true });
    }

    /**
     * Gets called when the cell emits a `dragOver` event. We need to
     * override the default behavior to get a drop event.
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onDragOver',
    value: function _onDragOver(e) {
      e.preventDefault();
    }

    /**
     * Gets called when the cell emits a `dragLeave` event
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onDragLeave',
    value: function _onDragLeave(e) {
      e.preventDefault();

      this._dragCounter--;
      if (this._dragCounter === 0) {
        this.setState({ dragAreaHovered: false });
      }
    }

    /**
     * Gets called when the cell emits a `drop` Event
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onDrop',
    value: function _onDrop(e) {
      var _this2 = this;

      e.stopPropagation();
      e.preventDefault();
      e = e.nativeEvent;
      e.returnValue = false;

      this.setState({ dragAreaHovered: false }, function () {
        if (!e.dataTransfer) return;

        if (!e.dataTransfer.files[0].type.match(/^image\//i)) {
          return _modalManager2.default.instance.displayError(_this2._t('pesdk.common.title.error'), _this2._t('pesdk.editor.text.invalidFileType', { fileType: e.dataTransfer.files[0].type }));
        }

        _this2._handleFile(e.dataTransfer.files[0]);
      });
    }

    /**
     * Gets called when the user clicks the button
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onClick',
    value: function _onClick(e) {
      this.refs.upload.open();
    }

    /**
     * Creates an image from the given file and passes it to the UI
     * @param  {File} file
     * @private
     */

  }, {
    key: '_handleFile',
    value: function _handleFile(file) {
      var _this3 = this;

      var reader = new window.FileReader();
      reader.onload = function () {
        return function (e) {
          var data = e.target.result;
          var image = new window.Image();

          image.addEventListener('load', function () {
            _this3._onImage(image);
          });

          image.src = data;
        };
      }(file);
      reader.readAsDataURL(file);
    }

    /**
     * Gets called when the image has been changed
     * @param  {Image} image
     * @private
     */

  }, {
    key: '_onImage',
    value: function _onImage(image) {
      this.props.onImage && this.props.onImage(image);
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this row's content
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderContent',
    value: function _renderContent() {
      var cellProps = {
        onDragEnter: this._onDragEnter,
        onDragOver: this._onDragOver,
        onDragLeave: this._onDragLeave,
        onDrop: this._onDrop
      };

      if (this.state.dragAreaHovered) {
        cellProps.className = 'is-hovered';
      }

      var contentCellBEM = 'e:contentCell';
      // @TODO We need some class that implements webcamEnabled() and photoRollEnabled()
      if (this.context.options.enableWebcam !== false || this.context.options.photoRoll.provider !== null) {
        contentCellBEM += ' m:withBorder';
      }

      return _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:contentWrapper' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:contentRow' },
          _globals.ReactBEM.createElement(
            'div',
            _extends({ bem: contentCellBEM, onClick: this._onClick }, cellProps),
            _globals.ReactBEM.createElement(_invisibleUploadComponent2.default, { ref: 'upload', onNewFile: this._onImage }),
            _globals.ReactBEM.createElement(
              _buttonComponent2.default,
              { bem: 'e:button', uppercase: true },
              this._t('pesdk.splash.button.upload')
            ),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:description' },
              this._t('pesdk.splash.text.upload')
            )
          )
        )
      );
    }
  }]);

  return UploadComponent;
}(_rowComponent2.default);

exports.default = UploadComponent;


UploadComponent.propTypes = {
  onImage: _globals.PropTypes.func.isRequired
};

UploadComponent.contextTypes = _rowComponent2.default.contextTypes;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ButtonComponent = function (_BaseComponent) {
  _inherits(ButtonComponent, _BaseComponent);

  function ButtonComponent() {
    _classCallCheck(this, ButtonComponent);

    return _possibleConstructorReturn(this, (ButtonComponent.__proto__ || Object.getPrototypeOf(ButtonComponent)).apply(this, arguments));
  }

  _createClass(ButtonComponent, [{
    key: 'renderWithBEM',

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */
    value: function renderWithBEM() {
      var bemSpecifier = 'b:button';
      if (this.props.uppercase) {
        bemSpecifier += ' m:uppercase';
      }

      return _globals.ReactBEM.createElement(
        'button',
        { bem: bemSpecifier, className: this.props.className, onClick: this.props.onClick },
        this.props.children
      );
    }
  }]);

  return ButtonComponent;
}(_globals.BaseComponent);

exports.default = ButtonComponent;


ButtonComponent.propTypes = {
  onClick: _globals.PropTypes.func,
  children: _globals.PropTypes.any.isRequired,
  className: _globals.PropTypes.string
};

ButtonComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _modalManager = __webpack_require__(94);

var _modalManager2 = _interopRequireDefault(_modalManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FileLoader = function (_EventEmitter) {
  _inherits(FileLoader, _EventEmitter);

  function FileLoader(input) {
    _classCallCheck(this, FileLoader);

    var _this = _possibleConstructorReturn(this, (FileLoader.__proto__ || Object.getPrototypeOf(FileLoader)).call(this));

    _this._input = input;
    _this._onFileChange = _this._onFileChange.bind(_this);
    _this._input.addEventListener('change', _this._onFileChange);
    return _this;
  }

  /**
   * Opens the file dialog
   */


  _createClass(FileLoader, [{
    key: 'open',
    value: function open() {
      this._input.value = null;
      this._input.click();
    }

    /**
     * Loads the file into an image
     * @param  {File} file
     * @private
     */

  }, {
    key: '_handleFile',
    value: function _handleFile(file) {
      var _this2 = this;

      var reader = new window.FileReader();
      reader.onload = function () {
        return function (e) {
          var data = e.target.result;
          var image = new window.Image();

          image.addEventListener('load', function () {
            _this2.emit('file', image);
          });

          image.addEventListener('error', function (e) {
            return _modalManager2.default.instance.displayError(_this2._t('errors.title'), _this2._t('errors.imageLoadingError.text'));
          });

          image.src = data;
        };
      }(file);
      reader.readAsDataURL(file);
    }

    /**
     * Gets called when the file input value changes
     * @private
     */

  }, {
    key: '_onFileChange',
    value: function _onFileChange() {
      var files = this._input.files;

      if (!files.length) return;

      this._handleFile(files[0]);
    }

    /**
     * Disposes all listeners
     */

  }, {
    key: 'dispose',
    value: function dispose() {
      this._input.removeEventListener('change', this._onFileChange);
    }
  }]);

  return FileLoader;
}(_globals.EventEmitter);

exports.default = FileLoader;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var Modal = function (_EventEmitter) {
  _inherits(Modal, _EventEmitter);

  function Modal(type, title, text) {
    var overlay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var closeOnOverlayClick = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    _classCallCheck(this, Modal);

    var _this = _possibleConstructorReturn(this, (Modal.__proto__ || Object.getPrototypeOf(Modal)).call(this));

    _this.id = _globals.SDKUtils.getUUID();
    _this.type = type;
    _this.title = title;
    _this.text = text;
    _this.overlay = overlay;
    _this.closeOnOverlayClick = closeOnOverlayClick;
    _this.visible = true;
    _this.data = null;
    return _this;
  }

  /**
   * Sets the data to the given one
   * @param {Object} data
   */


  _createClass(Modal, [{
    key: 'setData',
    value: function setData(data) {
      this.data = data;
      this.emit('update');
    }

    /**
     * Closes this modal
     */

  }, {
    key: 'close',
    value: function close() {
      this.visible = false;
      this.emit('close');
    }

    /**
     * Removes this modal
     */

  }, {
    key: 'remove',
    value: function remove() {
      this.emit('remove');
    }
  }]);

  return Modal;
}(_globals.EventEmitter);

var ModalManager = function (_EventEmitter2) {
  _inherits(ModalManager, _EventEmitter2);

  function ModalManager() {
    _classCallCheck(this, ModalManager);

    var _this2 = _possibleConstructorReturn(this, (ModalManager.__proto__ || Object.getPrototypeOf(ModalManager)).call(this));

    _this2._modals = [];
    return _this2;
  }

  /**
   * Creates a loading modal
   * @param  {String} title
   * @return {Modal}
   */


  _createClass(ModalManager, [{
    key: 'displayLoading',
    value: function displayLoading(title) {
      var overlay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var modal = new Modal('loading', title, null, overlay);
      this.addModal(modal);
      return modal;
    }

    /**
     * Creates a progress modal
     * @param  {String} text
     * @return {Modal}
     */

  }, {
    key: 'displayProgress',
    value: function displayProgress(text) {
      var progress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      var modal = new Modal('progress', null, text);
      modal.setData({ progress: progress });
      this.addModal(modal);
      return modal;
    }
  }, {
    key: 'displayInput',
    value: function displayInput(title) {
      var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var overlay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var modal = new Modal('input', title, null, overlay, true);
      modal.setData({ text: text });
      this.addModal(modal);
      return modal;
    }

    /**
     * Creates a warning modal
     * @param  {String} title
     * @param  {String} text
     * @param  {Boolean} overlay = true
     * @return {Modal}
     */

  }, {
    key: 'displayWarning',
    value: function displayWarning(title, text) {
      var buttons = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['OK'];
      var overlay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      var modal = new Modal('warning', title, text, overlay);
      modal.setData({ buttons: buttons });
      this.addModal(modal);
      return modal;
    }

    /**
     * Creates an error modal
     * @param  {String} title
     * @param  {String} text
     * @param  {Boolean} overlay = true
     * @return {Modal}
     */

  }, {
    key: 'displayError',
    value: function displayError(title, text) {
      var overlay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var modal = new Modal('error', title, text, overlay);
      this.addModal(modal);
      return modal;
    }

    /**
     * Adds the given modal to the list of modals
     * @param {Modal} modal
     */

  }, {
    key: 'addModal',
    value: function addModal(modal) {
      var _this3 = this;

      this._modals.push(modal);
      modal.on('close', function () {
        _this3.emit('update');
      });
      modal.on('remove', function () {
        _this3.removeModal(modal);
      });
      modal.on('update', function () {
        _this3.emit('update');
      });
      this.emit('update');
    }

    /**
     * Removes the given modal from the list of modals
     * @param  {Modal} modal
     */

  }, {
    key: 'removeModal',
    value: function removeModal(modal) {
      var index = this._modals.indexOf(modal);
      this._modals.splice(index, 1);
      this.emit('update');
    }

    /**
     * Returns the modals
     * @return {Array.<Modal>}
     */

  }, {
    key: 'getModals',
    value: function getModals() {
      return this._modals;
    }

    /**
     * Returns the one and only instance of this class
     * @return {ModalManager}
     */

  }], [{
    key: 'instance',
    get: function get() {
      if (!this._instance) {
        this._instance = new ModalManager();
      }
      return this._instance;
    }
  }]);

  return ModalManager;
}(_globals.EventEmitter);

exports.default = ModalManager;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _rowComponent = __webpack_require__(24);

var _rowComponent2 = _interopRequireDefault(_rowComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var WebcamComponent = function (_RowComponent) {
  _inherits(WebcamComponent, _RowComponent);

  function WebcamComponent() {
    var _ref;

    _classCallCheck(this, WebcamComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = WebcamComponent.__proto__ || Object.getPrototypeOf(WebcamComponent)).call.apply(_ref, [this].concat(args)));

    _this._needsStyleFixes = true;
    _this._modifier = 'webcam';
    return _this;
  }

  /**
   * A method that is called whenever styles need to be fixed by the JavaScript.
   * This needs to be done thanks to older Internet Explorer browsers which have
   * a bunch of CSS bugs.
   */


  _createClass(WebcamComponent, [{
    key: 'fixStyles',
    value: function fixStyles() {
      if (_globals.Utils.Browser.isIElte(11)) {
        var _refs = this.refs,
            cell = _refs.cell,
            overlay = _refs.overlay;

        var cellHeight = cell.offsetHeight;
        overlay.style.height = cellHeight + 'px';
      }
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this row's content
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderContent',
    value: function _renderContent() {
      var style = {
        backgroundImage: 'url(' + this._getAssetPath('splash/webcam.png', true, true) + ')'
      };

      return _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:contentWrapper' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:contentRow' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:contentCell', onClick: this._onClick, style: style, ref: 'cell' },
            _globals.ReactBEM.createElement('div', { bem: 'e:overlay', ref: 'overlay' }),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:headline' },
              this._t('pesdk.splash.title.webcam')
            ),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:description' },
              this._t('pesdk.splash.text.webcam')
            )
          )
        )
      );
    }
  }]);

  return WebcamComponent;
}(_rowComponent2.default);

exports.default = WebcamComponent;


WebcamComponent.contextTypes = _rowComponent2.default.contextTypes;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _rowComponent = __webpack_require__(24);

var _rowComponent2 = _interopRequireDefault(_rowComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var PhotoRollComponent = function (_RowComponent) {
  _inherits(PhotoRollComponent, _RowComponent);

  function PhotoRollComponent() {
    var _ref;

    _classCallCheck(this, PhotoRollComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = PhotoRollComponent.__proto__ || Object.getPrototypeOf(PhotoRollComponent)).call.apply(_ref, [this].concat(args)));

    _this._needsStyleFixes = true;
    _this._modifier = 'photoRoll';
    return _this;
  }

  /**
   * A method that is called whenever styles need to be fixed by the JavaScript.
   * This needs to be done thanks to older Internet Explorer browsers which have
   * a bunch of CSS bugs.
   */


  _createClass(PhotoRollComponent, [{
    key: 'fixStyles',
    value: function fixStyles() {
      if (_globals.Utils.Browser.isIElte(11)) {
        var _refs = this.refs,
            cell = _refs.cell,
            overlay = _refs.overlay;

        var cellHeight = cell.offsetHeight;
        overlay.style.height = cellHeight + 'px';
      }
    }

    /**
     * Renders this row's content
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderContent',
    value: function _renderContent() {
      var style = {
        backgroundImage: 'url(' + this._getAssetPath('splash/photo-roll.png', true, true) + ')'
      };

      return _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:contentWrapper' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:contentRow' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:contentCell', onClick: this._onClick, style: style, ref: 'cell' },
            _globals.ReactBEM.createElement('div', { bem: 'e:overlay', ref: 'overlay' }),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:headline' },
              this._t('pesdk.splash.title.photoRoll')
            ),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:description' },
              this._t('pesdk.splash.text.photoRoll')
            )
          )
        )
      );
    }
  }]);

  return PhotoRollComponent;
}(_rowComponent2.default);

exports.default = PhotoRollComponent;


PhotoRollComponent.contextTypes = _rowComponent2.default.contextTypes;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _screenComponent = __webpack_require__(9);

var _screenComponent2 = _interopRequireDefault(_screenComponent);

var _topBarComponent = __webpack_require__(98);

var _topBarComponent2 = _interopRequireDefault(_topBarComponent);

var _overviewComponent = __webpack_require__(102);

var _overviewComponent2 = _interopRequireDefault(_overviewComponent);

var _photoListComponent = __webpack_require__(41);

var _photoListComponent2 = _interopRequireDefault(_photoListComponent);

var _searchResultsComponent = __webpack_require__(105);

var _searchResultsComponent2 = _interopRequireDefault(_searchResultsComponent);

var _modalManager = __webpack_require__(1);

var _modalManager2 = _interopRequireDefault(_modalManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var PhotoRollScreenComponent = function (_ScreenComponent) {
  _inherits(PhotoRollScreenComponent, _ScreenComponent);

  function PhotoRollScreenComponent() {
    var _ref;

    _classCallCheck(this, PhotoRollScreenComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = PhotoRollScreenComponent.__proto__ || Object.getPrototypeOf(PhotoRollScreenComponent)).call.apply(_ref, [this].concat(args)));

    _this.state = {
      section: 'overview',
      sectionsHistory: []
    };

    _this._bindAll('_onLibraryClicked', '_onSearchSuggestionClicked', '_onPhotoClicked', '_onFileUpload', '_onWebcamClick', '_onBackClicked', '_onSearch');
    return _this;
  }

  // -------------------------------------------------------------------------- SECTIONS

  /**
   * Checks if the photo roll screen has a previous section
   * @return {Boolean} [description]
   */


  _createClass(PhotoRollScreenComponent, [{
    key: 'hasPreviousSection',
    value: function hasPreviousSection() {
      return !!this.state.sectionsHistory.length;
    }

    /**
     * Switches to the given section
     * @param  {String} section
     * @param  {Boolean} allowScreenSwitch = true
     * @param  {Boolean} addToStack = true
     */

  }, {
    key: 'switchToSection',
    value: function switchToSection(section) {
      var allowScreenSwitch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var addToStack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (section === 'back') {
        if (!this.hasPreviousSection()) {
          if (allowScreenSwitch) {
            return this.props.app.switchToScreen('back');
          } else {
            return this.switchToSection('overview');
          }
        }
        section = this.state.sectionsHistory.pop();
      } else if (this.state.section !== section && addToStack) {
        this.state.sectionsHistory.push(this.state.section);
      }

      this.setState({ section: section });
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when a library has been clicked
     * @param  {PhotoEditorSDK.UI.ReactUI.PhotoRoll.Library} library
     * @param {Boolean} automatically = false
     * @private
     */

  }, {
    key: '_onLibraryClicked',
    value: function _onLibraryClicked(library) {
      var automatically = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      this.state.library = library;
      this.switchToSection('library', true, !automatically);
    }

    /**
     * Gets called when a search suggestion has been clicked
     * @param  {PhotoEditorSDK.UI.ReactUI.PhotoRoll.SearchSuggestion} searchSuggestion
     * @private
     */

  }, {
    key: '_onSearchSuggestionClicked',
    value: function _onSearchSuggestionClicked(searchSuggestion) {
      this.state.searchQuery = searchSuggestion.query;
      this.switchToSection('search');
    }

    /**
     * Gets called when the user has clicked and the PhotoRoll has loaded a photo
     * @param  {PhotoEditorSDK.UI.ReactUI.PhotoRoll.Photo} photo
     * @private
     */

  }, {
    key: '_onPhotoClicked',
    value: function _onPhotoClicked(photo) {
      var _this2 = this;

      var loadingModal = _modalManager2.default.instance.displayLoading(this._t('pesdk.common.text.loading'));

      var image = new window.Image();
      image.addEventListener('load', function () {
        loadingModal.close();
        _this2.props.app.setImage(image, true);
      });
      image.addEventListener('error', function () {
        loadingModal.close();
        _modalManager2.default.instance.displayError(_this2._t('pesdk.common.title.imageLoadFail'), _this2._t('pesdk.common.text.imageLoadFail', { path: image.src }));
      });
      image.crossOrigin = _globals.SDKUtils.getCrossOriginValue(this.context.options.crossOrigin);
      image.src = photo.urls.raw;
    }

    /**
     * Gets called when the user clicks the back button
     * @private
     */

  }, {
    key: '_onBackClicked',
    value: function _onBackClicked() {
      this.switchToSection('back');
    }

    /**
     * Gets called when a search is triggered
     * @param  {String} query
     * @private
     */

  }, {
    key: '_onSearch',
    value: function _onSearch(query) {
      if (!query.trim().length) {
        this.state.searchQuery = null;
        return this.switchToSection('back', false);
      }

      this.state.searchQuery = query;
      this.switchToSection('search');
    }

    /**
     * Gets called when the user clicks the webcam button. Switches to the
     * webcam screen
     * @private
     */

  }, {
    key: '_onWebcamClick',
    value: function _onWebcamClick() {
      this.props.app.switchToScreen('webcam');
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the user has selected a new file
     * @param {Image} image
     */

  }, {
    key: '_onFileUpload',
    value: function _onFileUpload(image) {
      this.props.app.setImage(image);
    }

    // -------------------------------------------------------------------------- BACK BUTTON

    /**
     * Checks if the back button should be visible
     * @return {Boolean}
     * @private
     */

  }, {
    key: '_isBackButtonVisible',
    value: function _isBackButtonVisible() {
      return this.state.sectionsHistory.length !== 0 || this.props.app.hasPreviousScreen();
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the content component for this screen
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderContent',
    value: function _renderContent() {
      switch (this.state.section) {
        case 'search':
          return _globals.ReactBEM.createElement(_searchResultsComponent2.default, {
            query: this.state.searchQuery,
            onPhotoClicked: this._onPhotoClicked,
            onSearchSuggestionClicked: this._onSearchSuggestionClicked });
        case 'library':
          return _globals.ReactBEM.createElement(_photoListComponent2.default, {
            crossOrigin: _globals.SDKUtils.getCrossOriginValue(this.context.options.crossOrigin),
            library: this.state.library,
            onPhotoClicked: this._onPhotoClicked });
        case 'overview':
          return _globals.ReactBEM.createElement(_overviewComponent2.default, {
            onLibraryClicked: this._onLibraryClicked,
            onSearchSuggestionClicked: this._onSearchSuggestionClicked
          });
      }
    }

    /**
     * Renders this screen
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderScreen',
    value: function _renderScreen() {
      var contentComponent = this._renderContent();

      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:photoRollScreen' },
        _globals.ReactBEM.createElement(_topBarComponent2.default, {
          onBackClicked: this._onBackClicked,
          onSearch: this._onSearch,
          searchQuery: this.state.searchQuery,
          onFileUpload: this._onFileUpload,
          onWebcamClick: this._onWebcamClick,
          backButton: this._isBackButtonVisible(),
          backButtonLabel: this._t('pesdk.common.button.back'),
          ref: 'topBarControls' }),
        contentComponent
      );
    }
  }]);

  return PhotoRollScreenComponent;
}(_screenComponent2.default);

// PhotoRollScreenComponent.childContextTypes = {
//   ui: PropTypes.object.isRequired,
//   editor: PropTypes.object.isRequired,
//   mediator: PropTypes.object.isRequired,
//   options: PropTypes.object.isRequired,
//   editorScreen: PropTypes.object.isRequired
// }

exports.default = PhotoRollScreenComponent;
PhotoRollScreenComponent.contextTypes = _screenComponent2.default.contextTypes;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _topBarComponent = __webpack_require__(12);

var _topBarComponent2 = _interopRequireDefault(_topBarComponent);

var _topBarButtonComponent = __webpack_require__(99);

var _topBarButtonComponent2 = _interopRequireDefault(_topBarButtonComponent);

var _invisibleUploadComponent = __webpack_require__(25);

var _invisibleUploadComponent2 = _interopRequireDefault(_invisibleUploadComponent);

var _topBarSearchComponent = __webpack_require__(100);

var _topBarSearchComponent2 = _interopRequireDefault(_topBarSearchComponent);

var _backButtonComponent = __webpack_require__(101);

var _backButtonComponent2 = _interopRequireDefault(_backButtonComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var PhotoRollTopBarComponent = function (_TopBarComponent) {
  _inherits(PhotoRollTopBarComponent, _TopBarComponent);

  function PhotoRollTopBarComponent() {
    var _ref;

    _classCallCheck(this, PhotoRollTopBarComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = PhotoRollTopBarComponent.__proto__ || Object.getPrototypeOf(PhotoRollTopBarComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onUploadButtonClicked', '_onWebcamButtonClicked', '_onBackClicked', '_onSearchValueChange', '_onNewFile');

    _this._onSearchValueChange = _globals.Utils.debounce(_this._onSearchValueChange, 250);
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user clicks the back button
   * @private
   */


  _createClass(PhotoRollTopBarComponent, [{
    key: '_onBackClicked',
    value: function _onBackClicked() {
      this.props.onBackClicked && this.props.onBackClicked();
    }

    /**
     * Gets called when the search value has changed (this method is debounced)
     * @param {String} value
     * @private
     */

  }, {
    key: '_onSearchValueChange',
    value: function _onSearchValueChange(value) {
      this.props.onSearch && this.props.onSearch(value);
    }

    /**
     * Gets called when the user clicks the upload button
     * @private
     */

  }, {
    key: '_onUploadButtonClicked',
    value: function _onUploadButtonClicked() {
      this.refs.upload.open();
    }

    /**
     * Gets called when the user clicks the webcam button
     * @private
     */

  }, {
    key: '_onWebcamButtonClicked',
    value: function _onWebcamButtonClicked() {
      this.props.onWebcamClick && this.props.onWebcamClick();
    }

    /**
     * Gets called when a new file has been selected
     * @param  {File} file
     * @private
     */

  }, {
    key: '_onNewFile',
    value: function _onNewFile(file) {
      this.props.onFileUpload && this.props.onFileUpload(file);
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Checks if the webcam is available
     * @return {Boolean}
     * @private
     */

  }, {
    key: '_isWebcamAvailable',
    value: function _isWebcamAvailable() {
      return !_globals.Utils.isMobile() && this.context.options.enableWebcam !== false;
    }

    /**
     * Renders the buttons on the right
     * @return {Array.<React.Component>}
     * @private
     */

  }, {
    key: '_renderRightButtons',
    value: function _renderRightButtons() {
      var options = this.context.options;

      var buttons = [];

      if (options.enableUpload) {
        buttons.push(_globals.ReactBEM.createElement(_topBarButtonComponent2.default, {
          icon: this._getAssetPath('photo-roll/upload.png', true),
          onClick: this._onUploadButtonClicked
        }));
      }

      if (this._isWebcamAvailable()) {
        buttons.push(_globals.ReactBEM.createElement(_topBarButtonComponent2.default, {
          icon: this._getAssetPath('photo-roll/webcam.png', true),
          onClick: this._onWebcamButtonClicked
        }));
      }

      return buttons;
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var backButton = void 0;
      if (this.props.backButton) {
        backButton = _globals.ReactBEM.createElement(_backButtonComponent2.default, {
          label: this.props.backButtonLabel,
          onClick: this._onBackClicked });
      }
      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:topBar e:row' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:cell' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:table' },
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:cell m:left' },
              backButton
            ),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:cell m:fullWidth' },
              _globals.ReactBEM.createElement(_topBarSearchComponent2.default, {
                searchQuery: this.props.searchQuery,
                onChange: this._onSearchValueChange }),
              _globals.ReactBEM.createElement(_invisibleUploadComponent2.default, { onNewFile: this._onNewFile, ref: 'upload' })
            ),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:cell m:right' },
              this._renderRightButtons()
            )
          )
        )
      );
    }
  }]);

  return PhotoRollTopBarComponent;
}(_topBarComponent2.default);

exports.default = PhotoRollTopBarComponent;


PhotoRollTopBarComponent.contextTypes = _topBarComponent2.default.contextTypes;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var TopBarButtonComponent = function (_BaseComponent) {
  _inherits(TopBarButtonComponent, _BaseComponent);

  function TopBarButtonComponent() {
    _classCallCheck(this, TopBarButtonComponent);

    return _possibleConstructorReturn(this, (TopBarButtonComponent.__proto__ || Object.getPrototypeOf(TopBarButtonComponent)).apply(this, arguments));
  }

  _createClass(TopBarButtonComponent, [{
    key: 'renderWithBEM',

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:topBar' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$e:iconButton', onClick: this.props.onClick },
          _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this.props.icon })
        )
      );
    }
  }]);

  return TopBarButtonComponent;
}(_globals.BaseComponent);

exports.default = TopBarButtonComponent;


TopBarButtonComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var TopBarSearchComponent = function (_BaseComponent) {
  _inherits(TopBarSearchComponent, _BaseComponent);

  function TopBarSearchComponent() {
    var _ref;

    _classCallCheck(this, TopBarSearchComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = TopBarSearchComponent.__proto__ || Object.getPrototypeOf(TopBarSearchComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onFocus', '_onBlur', '_onChange', '_onBarClick');

    _this.state = {
      active: false,
      placeholder: _this._t('pesdk.library.placeholder.search'),
      value: _this.props.searchQuery || ''
    };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component is about to receive new properties
   * @param  {Object} nextProps
   */


  _createClass(TopBarSearchComponent, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.searchQuery || this.state.value) {
        this.state.active = true;
      } else {
        this.state.active = false;
      }

      this.setState({
        value: nextProps.searchQuery || ''
      });
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      this.refs.input.value = this.state.value;
    }

    /**
     * Gets called when this component has been mounted
     */

  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      _get(TopBarSearchComponent.prototype.__proto__ || Object.getPrototypeOf(TopBarSearchComponent.prototype), 'componentDidMount', this).call(this);
      this._hiddenInputDummy = document.createElement('div');

      var styleObject = _globals.Utils.getStyleObject(this.refs.input);
      var overrideKeys = ['font', 'lineHeight', 'textAlign', 'textIndent', 'textTransform', 'textDecoration', 'textRendering', 'textShadow', 'textOverflow', 'wordSpacing', 'letterSpacing', 'whiteSpace'];
      overrideKeys.forEach(function (key) {
        _this2._hiddenInputDummy.style[key] = styleObject[key];
      });

      this._hiddenInputDummy.style.position = 'absolute';
      this._hiddenInputDummy.style.top = '-9999px';
      this._hiddenInputDummy.style.left = '-9999px';

      this.refs.root.appendChild(this._hiddenInputDummy);

      this._updateInputWidth();
    }

    // -------------------------------------------------------------------------- MISC

    /**
     * Updates the input width to fit the text width
     * @private
     */

  }, {
    key: '_updateInputWidth',
    value: function _updateInputWidth() {
      var _this3 = this;

      this._hiddenInputDummy.innerHTML = this.state.value || this.state.placeholder;
      setTimeout(function () {
        _this3.setState({
          inputWidth: _this3._hiddenInputDummy.offsetWidth + 5
        });
      }, 0);
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the search bar has been clicked
     * @private
     */

  }, {
    key: '_onBarClick',
    value: function _onBarClick() {
      this.refs.input.focus();
    }

    /**
     * Gets called when the input fields is focused
     * @private
     */

  }, {
    key: '_onFocus',
    value: function _onFocus() {
      this.setState({ active: true });
    }

    /**
     * Gets called when the input field loses focus
     * @private
     */

  }, {
    key: '_onBlur',
    value: function _onBlur() {
      if (this.state.value === '' && !this.props.searchQuery) {
        this.setState({ active: false });
      }
    }

    /**
     * Gets called when the input value has changed
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onChange',
    value: function _onChange(e) {
      this.state.value = e.target.value;
      this.forceUpdate();

      this.props.onChange && this.props.onChange(this.state.value);
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var searchBarBEM = '$e:searchBar';
      var iconPath = 'photo-roll/search-light.png';
      if (this.state.active) {
        searchBarBEM += ' m:active';
        iconPath = 'photo-roll/search-dark.png';
      }
      iconPath = this._getAssetPath(iconPath, true);

      var inputStyle = {
        width: this.state.inputWidth + 'px'
      };

      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:photoRollScreen' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: searchBarBEM, ref: 'root', onClick: this._onBarClick },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:content' },
            _globals.ReactBEM.createElement(
              'div',
              { bem: '$e:icon' },
              _globals.ReactBEM.createElement('img', { src: iconPath, bem: 'e:image' })
            ),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:inputContainer' },
              _globals.ReactBEM.createElement('input', {
                bem: 'e:input',
                ref: 'input',
                placeholder: this.state.placeholder,
                onBlur: this._onBlur,
                onFocus: this._onFocus,
                onChange: this._onChange,
                defaultValue: this.state.value,
                style: inputStyle })
            )
          )
        )
      );
    }
  }]);

  return TopBarSearchComponent;
}(_globals.BaseComponent);

exports.default = TopBarSearchComponent;


TopBarSearchComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var TopBarBackButtonComponent = function (_BaseComponent) {
  _inherits(TopBarBackButtonComponent, _BaseComponent);

  function TopBarBackButtonComponent() {
    _classCallCheck(this, TopBarBackButtonComponent);

    return _possibleConstructorReturn(this, (TopBarBackButtonComponent.__proto__ || Object.getPrototypeOf(TopBarBackButtonComponent)).apply(this, arguments));
  }

  _createClass(TopBarBackButtonComponent, [{
    key: 'renderWithBEM',

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:topBar' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$e:backButton', onClick: this.props.onClick },
          _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('top-bar/back.png', true) }),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:label' },
            this.props.label
          )
        )
      );
    }
  }]);

  return TopBarBackButtonComponent;
}(_globals.BaseComponent);

exports.default = TopBarBackButtonComponent;


TopBarBackButtonComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _modalManager = __webpack_require__(1);

var _modalManager2 = _interopRequireDefault(_modalManager);

var _libraryComponent = __webpack_require__(103);

var _libraryComponent2 = _interopRequireDefault(_libraryComponent);

var _searchSuggestionComponent = __webpack_require__(40);

var _searchSuggestionComponent2 = _interopRequireDefault(_searchSuggestionComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OverviewComponent = function (_BaseComponent) {
  _inherits(OverviewComponent, _BaseComponent);

  function OverviewComponent() {
    var _ref;

    _classCallCheck(this, OverviewComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = OverviewComponent.__proto__ || Object.getPrototypeOf(OverviewComponent)).call.apply(_ref, [this].concat(args)));

    _this._needsStyleFixes = true;
    _this.state = {
      loading: true,
      libraries: [],
      searchSuggestions: []
    };

    _this._bindAll('_onLibraryClick', '_onSearchSuggestionClick');

    var PhotoRollProvider = _this.context.options.photoRoll.provider;
    _this._provider = new PhotoRollProvider();
    return _this;
  }

  /**
   * A method that is called whenever styles need to be fixed by the JavaScript.
   * This needs to be done thanks to older Internet Explorer browsers which have
   * a bunch of CSS bugs.
   */


  _createClass(OverviewComponent, [{
    key: 'fixStyles',
    value: function fixStyles() {
      if (_globals.Utils.Browser.isIElte(11)) {
        var _refs = this.refs,
            cell = _refs.cell,
            container = _refs.container;

        if (!(cell && container)) {
          return;
        }
        var cellHeight = cell.offsetHeight;
        container.style.height = cellHeight + 'px';
      }
    }

    // -------------------------------------------------------------------------- LIFECYCLE

    /**
     * Gets called when this component has been mounted
     */

  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      _get(OverviewComponent.prototype.__proto__ || Object.getPrototypeOf(OverviewComponent.prototype), 'componentDidMount', this).call(this);

      var modal = _modalManager2.default.instance.displayLoading(this._t('pesdk.common.text.loading'));
      this._load().then(function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2),
            libraries = _ref3[0],
            searchSuggestions = _ref3[1];

        modal.close();
        if (libraries.length === 1) {
          _this2._onLibraryClick(libraries[0], true);
        } else {
          _this2.setState({
            loading: false,
            libraries: libraries,
            searchSuggestions: searchSuggestions
          });
        }
      });
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when a library was clicked
     * @param  {PhotoEditorSDK.UI.ReactUI.PhotoRoll.Library} library
     * @param  {Boolean} automatically = false
     * @private
     */

  }, {
    key: '_onLibraryClick',
    value: function _onLibraryClick(library) {
      var automatically = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      this.props.onLibraryClicked && this.props.onLibraryClicked(library, automatically);
    }

    /**
     * Gets called when a search suggestion was clicked
     * @param  {PhotoEditorSDK.UI.ReactUI.PhotoRoll.SearchSuggestion} searchSuggestion
     * @private
     */

  }, {
    key: '_onSearchSuggestionClick',
    value: function _onSearchSuggestionClick(searchSuggestion) {
      this.props.onSearchSuggestionClicked && this.props.onSearchSuggestionClicked(searchSuggestion);
    }

    // -------------------------------------------------------------------------- LOADING

    /**
     * Loads the libraries and search suggestions (if present)
     * @return {Promise}
     * @private
     */

  }, {
    key: '_load',
    value: function _load() {
      var promises = [this._provider.getLibraries(), this._provider.getSearchSuggestions()];
      return _globals.Promise.all(promises);
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the library items
     * @return {React.Component}
     * @private
     */

  }, {
    key: '_renderLibraries',
    value: function _renderLibraries() {
      var _this3 = this;

      var items = this.state.libraries.map(function (library) {
        return _globals.ReactBEM.createElement(_libraryComponent2.default, {
          onClick: _this3._onLibraryClick,
          library: library });
      });
      return _globals.ReactBEM.createElement(
        'li',
        { bem: 'e:item' },
        _globals.ReactBEM.createElement(
          'bem',
          { specifier: 'b:photoRoll' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:headline' },
            'Browse libraries'
          ),
          _globals.ReactBEM.createElement(
            'ul',
            { bem: '$e:libraryList' },
            items
          )
        )
      );
    }

    /**
     * Rnders the search suggestion items
     * @return {React.Component}
     * @private
     */

  }, {
    key: '_renderSearchSuggestions',
    value: function _renderSearchSuggestions() {
      var _this4 = this;

      if (!this.state.searchSuggestions.length) return null;

      var items = this.state.searchSuggestions.map(function (searchSuggestion) {
        return _globals.ReactBEM.createElement(_searchSuggestionComponent2.default, {
          onClick: _this4._onSearchSuggestionClick,
          searchSuggestion: searchSuggestion });
      });

      return _globals.ReactBEM.createElement(
        'li',
        { bem: 'e:item' },
        _globals.ReactBEM.createElement(
          'bem',
          { specifier: 'b:photoRoll' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:headline' },
            'Search suggestions'
          ),
          _globals.ReactBEM.createElement(
            'ul',
            { bem: '$e:libraryList' },
            items
          )
        )
      );
    }

    /**
     * Renders the content for this component
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderContent',
    value: function _renderContent() {
      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:photoRoll e:row m:fullHeight' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:cell', ref: 'cell' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:container', ref: 'container' },
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:innerContainer' },
              _globals.ReactBEM.createElement(
                'ul',
                { bem: '$e:groupList' },
                this._renderLibraries(),
                this._renderSearchSuggestions()
              )
            )
          )
        )
      );
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      if (!this.state.loading) {
        return this._renderContent();
      } else {
        return _globals.ReactBEM.createElement('div', null);
      }
    }
  }]);

  return OverviewComponent;
}(_globals.BaseComponent);

exports.default = OverviewComponent;


OverviewComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var LibraryComponent = function (_BaseComponent) {
  _inherits(LibraryComponent, _BaseComponent);

  function LibraryComponent() {
    var _ref;

    _classCallCheck(this, LibraryComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = LibraryComponent.__proto__ || Object.getPrototypeOf(LibraryComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onClick');
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user clicks the library
   * @private
   */


  _createClass(LibraryComponent, [{
    key: '_onClick',
    value: function _onClick() {
      this.props.onClick && this.props.onClick(this.props.library);
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var library = this.props.library;

      var style = {
        backgroundImage: 'url(' + library.coverImage + ')'
      };

      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: 'b:photoRoll e:libraryList' },
        _globals.ReactBEM.createElement(
          'li',
          { bem: 'e:item', style: style, onClick: this._onClick },
          _globals.ReactBEM.createElement('div', { bem: 'e:overlay' }),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:name' },
            library.name
          )
        )
      );
    }
  }]);

  return LibraryComponent;
}(_globals.BaseComponent);

exports.default = LibraryComponent;


LibraryComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var PhotoComponent = function (_BaseComponent) {
  _inherits(PhotoComponent, _BaseComponent);

  function PhotoComponent() {
    _classCallCheck(this, PhotoComponent);

    return _possibleConstructorReturn(this, (PhotoComponent.__proto__ || Object.getPrototypeOf(PhotoComponent)).apply(this, arguments));
  }

  _createClass(PhotoComponent, [{
    key: 'renderWithBEM',

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */
    value: function renderWithBEM() {
      var photo = this.props.photo;

      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: 'b:photoRoll e:photoList' },
        _globals.ReactBEM.createElement(
          'li',
          { bem: '$e:item', onClick: this.props.onClick },
          _globals.ReactBEM.createElement('div', { bem: 'e:overlay' }),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:title' },
            photo.title
          ),
          _globals.ReactBEM.createElement('img', { bem: 'e:image', src: photo.urls.thumb })
        )
      );
    }
  }]);

  return PhotoComponent;
}(_globals.BaseComponent);

exports.default = PhotoComponent;


PhotoComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _photoListComponent = __webpack_require__(41);

var _photoListComponent2 = _interopRequireDefault(_photoListComponent);

var _noSearchResultsComponent = __webpack_require__(106);

var _noSearchResultsComponent2 = _interopRequireDefault(_noSearchResultsComponent);

var _modalManager = __webpack_require__(1);

var _modalManager2 = _interopRequireDefault(_modalManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var SearchResultsComponent = function (_PhotoListComponent) {
  _inherits(SearchResultsComponent, _PhotoListComponent);

  function SearchResultsComponent() {
    _classCallCheck(this, SearchResultsComponent);

    return _possibleConstructorReturn(this, (SearchResultsComponent.__proto__ || Object.getPrototypeOf(SearchResultsComponent)).apply(this, arguments));
  }

  _createClass(SearchResultsComponent, [{
    key: 'componentWillReceiveProps',

    // -------------------------------------------------------------------------- LIFECYCLE

    /**
     * Gets called when this component receives new props
     * @param  {Object} props
     */
    value: function componentWillReceiveProps(props) {
      if (props.query !== this.props.query) {
        this._loadPhotos(props.query);
      }
    }

    // -------------------------------------------------------------------------- MISC

    /**
     * Returns the headline for this view
     * @return {String}
     * @private
     */

  }, {
    key: '_getHeadline',
    value: function _getHeadline() {
      return this._t('pesdk.library.title.searchResults', {
        query: this.props.query
      });
    }

    /**
     * Loads the photos
     * @param {String} query
     * @private
     */

  }, {
    key: '_loadPhotos',
    value: function _loadPhotos() {
      var _this2 = this;

      var query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.query;

      this._totalPhotosHeight = 0;
      var modal = _modalManager2.default.instance.displayProgress(this._t('pesdk.common.text.loading'));
      var PhotoRollProvider = this.context.options.photoRoll.provider;
      var provider = new PhotoRollProvider();

      provider.searchPhotos(query).then(function (photos) {
        return _this2._preloadPhotos(photos, modal);
      }).then(function (photos) {
        _this2.setState({ photos: photos, loading: false });
        modal.close();
      });
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the 'no results found' screen
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderNotFound',
    value: function _renderNotFound() {
      return _globals.ReactBEM.createElement(_noSearchResultsComponent2.default, {
        query: this.props.query,
        onSearchSuggestionClicked: this.props.onSearchSuggestionClicked });
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      if (!this.state.loading) {
        if (this.state.photos.length === 0) {
          return this._renderNotFound();
        } else {
          return this._renderPhotos();
        }
      } else {
        return _globals.ReactBEM.createElement('div', null);
      }
    }
  }]);

  return SearchResultsComponent;
}(_photoListComponent2.default);

exports.default = SearchResultsComponent;


SearchResultsComponent.contextTypes = _photoListComponent2.default.contextTypes;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _searchSuggestionComponent = __webpack_require__(40);

var _searchSuggestionComponent2 = _interopRequireDefault(_searchSuggestionComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var NoSearchResultsComponent = function (_BaseComponent) {
  _inherits(NoSearchResultsComponent, _BaseComponent);

  function NoSearchResultsComponent() {
    var _ref;

    _classCallCheck(this, NoSearchResultsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = NoSearchResultsComponent.__proto__ || Object.getPrototypeOf(NoSearchResultsComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onSearchSuggestionClick');

    var PhotoRollProvider = _this.context.options.photoRoll.provider;
    _this._provider = new PhotoRollProvider();

    _this.state = {
      searchSuggestions: []
    };
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when a search suggestion was clicked
   * @param  {PhotoEditorSDK.UI.ReactUI.PhotoRoll.SearchSuggestion} searchSuggestion
   * @private
   */


  _createClass(NoSearchResultsComponent, [{
    key: '_onSearchSuggestionClick',
    value: function _onSearchSuggestionClick(searchSuggestion) {
      this.props.onSearchSuggestionClicked && this.props.onSearchSuggestionClicked(searchSuggestion);
    }

    // -------------------------------------------------------------------------- LIFECYCLE

    /**
     * Gets called when this component has been mounted
     */

  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      _get(NoSearchResultsComponent.prototype.__proto__ || Object.getPrototypeOf(NoSearchResultsComponent.prototype), 'componentDidMount', this).call(this);

      this._provider.getSearchSuggestions().then(function (searchSuggestions) {
        _this2.setState({
          searchSuggestions: searchSuggestions
        });
      });
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the message (which can include html)
     * @return {Object}
     * @private
     */

  }, {
    key: '_renderMessage',
    value: function _renderMessage() {
      return { __html: this._t('pesdk.library.text.noSearchResults', {
          query: this.props.query
        }) };
    }

    /**
     * Renders the search suggestions
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderSearchSuggestions',
    value: function _renderSearchSuggestions() {
      var _this3 = this;

      if (!this.state.searchSuggestions.length) return null;

      var items = this.state.searchSuggestions.map(function (searchSuggestion) {
        return _globals.ReactBEM.createElement(_searchSuggestionComponent2.default, {
          onClick: _this3._onSearchSuggestionClick,
          searchSuggestion: searchSuggestion });
      });

      return _globals.ReactBEM.createElement(
        'div',
        null,
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:headline' },
          'Search suggestions'
        ),
        _globals.ReactBEM.createElement(
          'ul',
          { bem: '$e:libraryList' },
          items
        )
      );
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:photoRoll e:row m:fullHeight' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:cell' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:container' },
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:innerContainer' },
              _globals.ReactBEM.createElement('div', { bem: 'e:noSearchResults', dangerouslySetInnerHTML: this._renderMessage() }),
              this._renderSearchSuggestions()
            )
          )
        )
      );
    }
  }]);

  return NoSearchResultsComponent;
}(_globals.BaseComponent);

exports.default = NoSearchResultsComponent;


NoSearchResultsComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _screenComponent = __webpack_require__(9);

var _screenComponent2 = _interopRequireDefault(_screenComponent);

var _topBarComponent = __webpack_require__(12);

var _topBarComponent2 = _interopRequireDefault(_topBarComponent);

var _webcamComponent = __webpack_require__(108);

var _webcamComponent2 = _interopRequireDefault(_webcamComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */


var WebcamScreenComponent = function (_ScreenComponent) {
  _inherits(WebcamScreenComponent, _ScreenComponent);

  function WebcamScreenComponent() {
    _classCallCheck(this, WebcamScreenComponent);

    var _this = _possibleConstructorReturn(this, (WebcamScreenComponent.__proto__ || Object.getPrototypeOf(WebcamScreenComponent)).call(this));

    _this._bindAll('_onCancel', '_onWebcamReady', '_onShutterClicked');
    _this.state = { webcamReady: false };
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the webcam is ready
   * @private
   */


  _createClass(WebcamScreenComponent, [{
    key: '_onWebcamReady',
    value: function _onWebcamReady() {
      this.setState({ webcamReady: true });
    }

    /**
     * Gets called when the user clicks the cancel button in the top bar
     * @private
     */

  }, {
    key: '_onCancel',
    value: function _onCancel() {
      this.props.app.switchToScreen('back');
    }

    /**
     * Gets called when the shutter button has been clicked
     * @private
     */

  }, {
    key: '_onShutterClicked',
    value: function _onShutterClicked() {
      var _this2 = this;

      var webcam = this.refs.webcam;
      webcam.makePhoto().then(function (image) {
        _this2.props.app.setImage(image);
      }).catch(function (e) {
        _globals.Log.error(e);
      });
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this screen
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderScreen',
    value: function _renderScreen() {
      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:webcamScreen' },
        _globals.ReactBEM.createElement(
          _topBarComponent2.default,
          {
            label: this._t('pesdk.camera.title.headline') },
          _globals.ReactBEM.createElement(
            'bem',
            { specifier: '$b:topBar' },
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:cancelButton', onClick: this._onCancel },
              this._t('pesdk.common.button.cancel')
            ),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:label' },
              this._t('pesdk.camera.title.headline')
            )
          )
        ),
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$b:canvas e:container e:row' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:container e:cell' },
            _globals.ReactBEM.createElement(_webcamComponent2.default, {
              ref: 'webcam',
              onReady: this._onWebcamReady,
              onBack: this._onCancel })
          )
        ),
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$b:controls $e:container e:row' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:cell' },
            _globals.ReactBEM.createElement(
              'bem',
              { specifier: 'b:webcamScreen' },
              _globals.ReactBEM.createElement(
                'div',
                {
                  bem: '$e:shutterButton',
                  onClick: this._onShutterClicked,
                  className: this.state.webcamReady ? 'is-active' : false },
                _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/webcam/shutter.png', true) })
              )
            )
          )
        )
      );
    }
  }]);

  return WebcamScreenComponent;
}(_screenComponent2.default);

exports.default = WebcamScreenComponent;


WebcamScreenComponent.contextTypes = _screenComponent2.default.contextTypes;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _modalManager = __webpack_require__(1);

var _modalManager2 = _interopRequireDefault(_modalManager);

var _webcamVideoComponent = __webpack_require__(109);

var _webcamVideoComponent2 = _interopRequireDefault(_webcamVideoComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var WebcamComponent = function (_BaseComponent) {
  _inherits(WebcamComponent, _BaseComponent);

  function WebcamComponent() {
    _classCallCheck(this, WebcamComponent);

    var _this = _possibleConstructorReturn(this, (WebcamComponent.__proto__ || Object.getPrototypeOf(WebcamComponent)).call(this));

    _this._bindAll('_onWebcamReady', '_onWebcamError');

    _this.state = { webcamReady: false };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Checks whether this component needs an update
   * @param {Object} nextProps
   * @param {Object} nextState
   */


  _createClass(WebcamComponent, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      // This component never updates
      return false;
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the webcam is ready to serve a video
     * @private
     */

  }, {
    key: '_onWebcamReady',
    value: function _onWebcamReady() {
      this.props.onReady && this.props.onReady();
      this.setState({ webcamReady: true });
    }
  }, {
    key: '_onWebcamError',
    value: function _onWebcamError(msg) {
      var _this2 = this;

      var errorModal = _modalManager2.default.instance.displayError(this._t('pesdk.common.title.error'), this._t('pesdk.camera.text.webcamUnavailable', { error: msg }));
      errorModal.on('close', function () {
        return _this2.props.onBack();
      });
    }

    /**
     * Public method that makes a photo from the current video stream
     * @return {Promise}
     */

  }, {
    key: 'makePhoto',
    value: function makePhoto() {
      if (!this.state.webcamReady) {
        return;
      }

      return this._webcam.capture();
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var _this3 = this;

      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:webcam', ref: 'container' },
        _globals.ReactBEM.createElement(_webcamVideoComponent2.default, {
          flashURL: this._getAssetPath('fallback/webcam.swf'),
          ref: function ref(el) {
            _this3._webcam = el;
          },
          onWebcamError: this._onWebcamError,
          onWebcamAvailable: this._onWebcamReady })
      );
    }
  }]);

  return WebcamComponent;
}(_globals.BaseComponent);

exports.default = WebcamComponent;


WebcamComponent.propTypes = {
  onReady: _globals.PropTypes.func
};

WebcamComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx React.createElement */
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */
/* globals Image */

var WebcamVideoComponent = function (_BaseComponent) {
  _inherits(WebcamVideoComponent, _BaseComponent);

  function WebcamVideoComponent(props) {
    _classCallCheck(this, WebcamVideoComponent);

    var _this = _possibleConstructorReturn(this, (WebcamVideoComponent.__proto__ || Object.getPrototypeOf(WebcamVideoComponent)).call(this, props));

    _this._bindAll('_onLoadedMetadata');

    _this.state = {
      webcamAvailable: false,
      useFlashFallback: false,
      containerWidth: null,
      containerHeight: null
    };

    _this._getUserMedia = null;
    _this._webcamStream = null;
    return _this;
  }

  _createClass(WebcamVideoComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      this._initGetUserMedia();
      this._calculateFlashDimensions();

      if (this._getUserMedia) {
        this._getUserMedia({
          video: {
            optional: [{ minWidth: 320 }, { minWidth: 640 }, { minWidth: 1024 }, { minWidth: 1280 }, { minWidth: 1920 }, { minWidth: 2560 }]
          },
          audio: false
        }).then(function (stream) {
          _this2._webcamStream = stream;
          var video = _this2._videoElement;

          if ('srcObject' in video) {
            video.srcObject = stream;
          } else {
            video.src = window.URL.createObjectURL(stream);
          }
        }).catch(function (error) {
          if (_this2.props.onWebcamError) {
            _this2.props.onWebcamError(error);
          }
        });
      } else {
        var deleteWebcam = false;

        // Sadly we need to polute the global namespace for flash/js communication
        // keeping it at a minimum here
        if (!window.Webcam) {
          window.Webcam = {};
          deleteWebcam = true;
        }

        window.Webcam.flashNotify = function (type, msg) {
          switch (type) {
            case 'cameraLive':
              _this2.setState({ webcamAvailable: true }, function () {
                _this2.props.onWebcamAvailable && _this2.props.onWebcamAvailable();
              });
              delete window.Webcam.flashNotify;
              if (deleteWebcam) {
                delete window.Webcam;
              }
              break;
            case 'error':
              _this2.props.onWebcamError && _this2.props.onWebcamError(msg);
              delete window.Webcam.flashNotify;
              if (deleteWebcam) {
                delete window.Webcam;
              }
              break;
          }
        };
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this._disposeWebcam();
    }

    /**
     * Checks the current browser environment for mediaDevices.getUserMedia of for
     * legacy navitator.getUserMedia, and saves a shim into the _getUserMedia
     * property.
     *
     * @memberof WebcamVideoComponent
     * @private
     */

  }, {
    key: '_initGetUserMedia',
    value: function _initGetUserMedia() {
      // Check for mediaDevices#getUserMedia
      if (navigator.mediaDevices) {
        if (navigator.mediaDevices.getUserMedia) {
          this._getUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
        }
      }

      // Look for legacy navigator.getUserMedia implementations
      if (!this._getUserMedia) {
        var legacyGetUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

        if (legacyGetUserMedia) {
          this._getUserMedia = function (options) {
            return new Promise(function (resolve, reject) {
              return legacyGetUserMedia.call(navigator, options, resolve, reject);
            });
          };
        }
      }

      // If no getUserMedia is found, use flash fallbcak
      if (!this._getUserMedia) {
        this.setState({ useFlashFallback: true });
      }
    }

    /**
     * Disposes the current webcam stream, if available.
     *
     * @memberof WebcamVideoComponent
     * @private
     */

  }, {
    key: '_disposeWebcam',
    value: function _disposeWebcam() {
      if (this._webcamStream) {
        var stream = this._webcamStream;
        var track = stream.getTracks()[0];
        if (track) {
          track.stop();
        } else if (stream.stop) {
          stream.stop();
        }
      } else if (this._flashWebcam) {
        this._flashWebcam._releaseCamera();
      }
    }

    /**
     * Captures the current webcam image in the stream, if available.
     *
     * @returns {Promise<Image>}
     * @memberof WebcamVideoComponent
     */

  }, {
    key: 'capture',
    value: function capture() {
      var _this3 = this;

      if (!this.state.webcamAvailable) {
        return Promise.reject(new Error('Webcam video not available'));
      }

      if (this._videoElement && !this._flashWebcam) {
        return new Promise(function (resolve, reject) {
          var video = _this3._videoElement;
          if (video.readyState === 0) {
            reject(new Error('Webcam video not available'));
          } else {
            var canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            var context = canvas.getContext('2d');
            context.drawImage(video, 0, 0);

            var image = new window.Image();
            image.addEventListener('load', function () {
              resolve(image);
            });
            image.src = canvas.toDataURL('image/jpeg');
          }
        });
      } else if (this._flashWebcam) {
        return new Promise(function (resolve, reject) {
          var rawData = _this3._flashWebcam._snap();
          var image = new Image();
          image.onload = function () {
            resolve(image);
          };
          image.src = 'data:image/jpeg;base64,' + rawData;
        });
      }

      return Promise.reject(new Error('Webcam video not available'));
    }

    /**
     * Hack to get an estimate of the editor's screen height (only for IE where
     * height: 100% is broken). Just goes up the DOM tree until it finds an element
     * whose height is larger than a minimum value.
     *
     * @param {number} min
     * @returns {number|null}
     * @memberof WebcamVideoComponent
     * @private
     */

  }, {
    key: '_getIEHeight',
    value: function _getIEHeight() {
      var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;

      var current = this._container;

      for (var i = 0; i < 1000; i++) {
        if (current.clientHeight > min) {
          break;
        }

        if (current.parentNode) {
          current = current.parentNode;
        } else {
          break;
        }
      }
      return current.clientHeight > min ? current.clientHeight : null;
    }

    /**
     * Calculates the dimensions of the flash webcam viewport, and sets the state
     * accordingly.
     * @private
     * @memberof WebcamVideoComponent
     */

  }, {
    key: '_calculateFlashDimensions',
    value: function _calculateFlashDimensions() {
      var containerHeight = 0.9 * (this._getIEHeight() || window.innerHeight);
      var width = 4 / 3 * containerHeight || 640;
      var height = containerHeight || 480;

      this.setState({
        containerWidth: width,
        containerHeight: height
      });
    }

    /**
     * Creates a React Component wrapping the flash webcam object
     * @returns {React.Component}
     * @memberof WebcamVideoComponent
     */

  }, {
    key: '_getFlashFallbackComponent',
    value: function _getFlashFallbackComponent() {
      var _this4 = this;

      var width = this.state.containerWidth || 640;
      var height = this.state.containerHeight || 480;

      var flashvars = 'width=' + width + '&height=' + height + '&dest_width=1024&dest_height=768&jpeg_quality=100&fps=24';

      return React.createElement(
        'object',
        { classID: 'clsid:d27cdb6e-ae6d-11cf-96b8-444553540000', type: 'application/x-shockwave-flash', width: width, height: height, ref: function ref(e) {
            _this4._flashWebcam = e;
          }, align: 'middle' },
        React.createElement('param', { name: 'wmode', value: 'transparent' }),
        React.createElement('param', { name: 'allowScriptAccess', value: 'always' }),
        React.createElement('param', { name: 'allowFullScreen', value: 'false' }),
        React.createElement('param', { name: 'movie', value: this.props.flashURL }),
        React.createElement('param', { name: 'loop', value: 'false' }),
        React.createElement('param', { name: 'menu', value: 'false' }),
        React.createElement('param', { name: 'quality', value: 'best' }),
        React.createElement('param', { name: 'bgcolor', value: '#ffffff' }),
        React.createElement('param', { name: 'flashvars', value: flashvars })
      );
    }

    /**
     * Called when the webcam stream metadata is loaded into the video element.
     * @private
     * @memberof WebcamVideoComponent
     */

  }, {
    key: '_onLoadedMetadata',
    value: function _onLoadedMetadata() {
      var _this5 = this;

      this.setState({ webcamAvailable: true }, function () {
        _this5.props.onWebcamAvailable && _this5.props.onWebcamAvailable();
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this6 = this;

      var videoComponent = this.state.useFlashFallback ? this._getFlashFallbackComponent() : React.createElement('video', {
        style: { width: '100%' },
        autoPlay: true,
        ref: function ref(e) {
          _this6._videoElement = e;
        },
        onLoadedMetadata: this._onLoadedMetadata });

      return React.createElement(
        'div',
        {
          style: {
            width: this.state.useFlashFallback ? this.state.containerWidth : '100%',
            height: this.state.useFlashFallback ? this.state.containerHeight : '100%',
            display: 'block',
            margin: 'auto',
            overflow: 'hidden'
          },
          ref: function ref(el) {
            _this6._container = el;
          } },
        videoComponent
      );
    }
  }]);

  return WebcamVideoComponent;
}(_globals.BaseComponent);

exports.default = WebcamVideoComponent;


WebcamVideoComponent.propTypes = {
  flashURL: _globals.PropTypes.string,
  onWebcamAvailable: _globals.PropTypes.func,
  onWebcamError: _globals.PropTypes.func
};

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _overviewControlsComponent = __webpack_require__(42);

var _overviewControlsComponent2 = _interopRequireDefault(_overviewControlsComponent);

var _screenComponent = __webpack_require__(9);

var _screenComponent2 = _interopRequireDefault(_screenComponent);

var _canvasComponent = __webpack_require__(113);

var _canvasComponent2 = _interopRequireDefault(_canvasComponent);

var _modalManager = __webpack_require__(1);

var _modalManager2 = _interopRequireDefault(_modalManager);

var _overview = __webpack_require__(114);

var _overview2 = _interopRequireDefault(_overview);

var _editor3 = __webpack_require__(43);

var _editor4 = _interopRequireDefault(_editor3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var WINDOW_RESIZE_DELAY = 500;

var EditorScreenComponent = function (_ScreenComponent) {
  _inherits(EditorScreenComponent, _ScreenComponent);

  function EditorScreenComponent() {
    var _ref;

    _classCallCheck(this, EditorScreenComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = EditorScreenComponent.__proto__ || Object.getPrototypeOf(EditorScreenComponent)).call.apply(_ref, [this].concat(args)));

    _this._overviewControls = _overviewControlsComponent2.default;

    _this._bindAll('switchToControls', '_startEditor', '_onWindowResize', '_onWindowResizeDone', '_onImageResize', '_onNewImage', '_onRenderError');

    _this._previousControlsStack = [];
    _this.state = {
      zoom: null,
      controls: _overview2.default,
      dragEnabled: true,
      sharedState: new _globals.SharedState()
    };

    _this._editor = new _editor4.default(_this.context.ui, _this.context.options, _this.context.mediator);
    _this._editor.on('new-image', _this._onNewImage);
    _this._editor.on('ready', _this._startEditor);
    _this._editor.on('resize', _this._onImageResize);
    _this._editor.on('render-error', _this._onRenderError);

    _this._hasUsedForceCrop = false;

    _this._forceControls = _this.context.options.editor.forceControls;
    _this._forceControlIndex = 0;
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called after this component has been mounted
   */


  _createClass(EditorScreenComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      _get(EditorScreenComponent.prototype.__proto__ || Object.getPrototypeOf(EditorScreenComponent.prototype), 'componentDidMount', this).call(this);

      var options = this.context.options;
      var _context$options$edit = this.context.options.editor,
          image = _context$options$edit.image,
          forceCrop = _context$options$edit.forceCrop;


      this.setImage(image);
      this._editor.render();

      this._editor.on('ready', function () {
        if (forceCrop) {
          _this2._switchToFroceCropControl();
        } else {
          _this2._switchToNextForceControl();
        }
      });

      if (options.responsive) {
        window.addEventListener('resize', this._onWindowResize);
      }
    }

    /**
     * Gets called before this component is unmounted
     */

  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      _get(EditorScreenComponent.prototype.__proto__ || Object.getPrototypeOf(EditorScreenComponent.prototype), 'componentWillUnmount', this).call(this);

      this._editor.dispose();
      var options = this.context.options;

      if (options.responsive) {
        window.removeEventListener('resize', this._onWindowResize);
      }
    }

    /**
     * Sets the zoom level and starts the editor rendering
     * @private
     */

  }, {
    key: '_startEditor',
    value: function _startEditor() {
      this._editor.start();
    }

    // -------------------------------------------------------------------------- FORCE CONTROLS

  }, {
    key: '_switchToFroceCropControl',
    value: function _switchToFroceCropControl() {
      var availableControls = this._editor.controls.getAvailable();
      var controlObject = availableControls['transform'];

      if (!controlObject) {
        return;
      }

      this.switchToControls(controlObject, {}, null, { forceCrop: true, firstCrop: true });
      this._hasUsedForceCrop = true;
    }
    /**
     * Switches to the next forced control
     * @private
     */

  }, {
    key: '_switchToNextForceControl',
    value: function _switchToNextForceControl() {
      if (this._forceControlIndex < this._forceControls.length) {
        var _forceControls$_force = this._forceControls[this._forceControlIndex],
            control = _forceControls$_force.control,
            options = _forceControls$_force.options;

        var availableControls = this._editor.controls.getAvailable();
        var controlObject = availableControls[control];

        var fixedOptions = _globals.SDKUtils.defaults({
          forcedControl: true
        }, options);

        if (!controlObject) {
          throw new Error('Force controls: Could not find control with identifier `' + control + '`');
        }

        this.switchToControls(controlObject, {}, null, fixedOptions);
        this._forceControlIndex++;
      }
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when an error occurred while rendering
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onRenderError',
    value: function _onRenderError(e) {
      _modalManager2.default.instance.displayError(this._t('pesdk.editor.title.renderingError'), this._t('pesdk.editor.text.renderingError'), true);
      _globals.Log.error(this.constructor.name, 'An error occurred while rendering: ' + e.message);
    }

    /**
     * Gets called when the image has been changed
     * @private
     */

  }, {
    key: '_onNewImage',
    value: function _onNewImage() {
      this.switchToControls(_overview2.default);
    }

    /**
     * Gets called when the editor starts resizing an image
     * @private
     */

  }, {
    key: '_onImageResize',
    value: function _onImageResize() {
      var _this3 = this;

      var loadingModal = _modalManager2.default.instance.displayLoading(this._t('pesdk.editor.text.resizing'));
      this._editor.once('resized', function (_ref2) {
        var dimensions = _ref2.dimensions,
            reason = _ref2.reason;

        loadingModal.close();

        if (_this3.context.options.editor.displayResizeMessage) {
          _modalManager2.default.instance.displayWarning(_this3._t('pesdk.editor.title.imageResized_' + reason), _this3._t('pesdk.editor.text.imageResized_' + reason, {
            maxMegaPixels: _this3._editor.getMaxMegapixels(),
            width: dimensions.x,
            height: dimensions.y
          }));
        }
      });
    }

    /**
     * Gets called on window resize
     * @private
     */

  }, {
    key: '_onWindowResize',
    value: function _onWindowResize() {
      if (this._resizeTimeout) {
        window.clearTimeout(this._resizeTimeout);
        this._resizeTimeout = null;
      }
      this._resizeTimeout = window.setTimeout(this._onWindowResizeDone, WINDOW_RESIZE_DELAY);
    }

    /**
     * Gets called `WINDOW_RESIZE_DELAY` ms after the last resize event has been called
     * @private
     */

  }, {
    key: '_onWindowResizeDone',
    value: function _onWindowResizeDone() {
      this._emitEvent(_globals.Constants.EVENTS.WINDOW_RESIZE);
    }

    // -------------------------------------------------------------------------- MISC

    /**
     * Switches to the given controls
     * @param  {Component} controls
     * @param  {Object} [initialState] = {}
     * @param  {Function} [callback]
     * @param  {Object} [controlOptions]
     */

  }, {
    key: 'switchToControls',
    value: function switchToControls(controls) {
      var initialState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var controlOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      var newControls = null;
      if (controls === 'back') {
        newControls = this._previousControlsStack.pop();
      } else if (controls === 'home' || controls === _overview2.default) {
        if (this.context.options.editor.forceCrop && !this._hasUsedForceCrop) {
          return this._switchToFroceCropControl();
        }

        // When a control switches to `home`, override this action
        // with switching to the next force control (if present)
        if (this._forceControlIndex < this._forceControls.length) {
          return this._switchToNextForceControl();
        }

        newControls = _overview2.default;
        this._previousControlsStack = [];
      } else {
        newControls = controls;
        this._previousControlsStack.push(this.state.controls);
      }

      var controlsChanged = this.state.controls !== newControls;

      // If the previous controls have an `onExit` method, call it
      // with the controls as `this`
      if (this.state.controls.onExit) {
        this.state.controls.onExit.call(this.refs.controls);
      }

      this.state.sharedState.clear();
      this.state.sharedState.set(initialState, false);

      var controlsOptions = _globals.SDKUtils.defaults(_globals.SDKUtils.defaults(controlOptions, this.context.options.editor.controlsOptions[newControls.identifier]), newControls.defaultOptions);

      // If the new controls have an `onEnter` method, call it
      if (newControls.onEnter) {
        newControls.onEnter.call(this.refs.controls, this.state.sharedState, controlsOptions);
      }

      if (controlsChanged) {
        this.setState({
          controls: newControls,
          controlsOptions: controlsOptions
        }, callback);
      } else {
        return callback && callback();
      }
    }

    /**
     * Returns the zoom level
     * @return {Number}
     */

  }, {
    key: 'getZoom',
    value: function getZoom() {
      return this.state.zoom;
    }

    /**
     * Exports an image
     * @param {Boolean} download = false
     * @return {Promise}
     */

  }, {
    key: 'export',
    value: function _export() {
      var _this4 = this;

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return new Promise(function (resolve, reject) {
        _this4.switchToControls('home', {}, function () {
          var _editor;

          (_editor = _this4._editor).export.apply(_editor, args).then(resolve).catch(reject);
        });
      });
    }

    /**
     * Returns the editor
     * @return {PhotoEditorSDK.UI.ReactUI.Editor}
     */

  }, {
    key: 'getEditor',
    value: function getEditor() {
      return this._editor;
    }

    /**
     * Serializes the editor state
     * @return {Promise}
     */

  }, {
    key: 'serialize',
    value: function serialize() {
      var _editor2;

      return (_editor2 = this._editor).serialize.apply(_editor2, arguments);
    }

    /**
     * Deserializes the given data
     * @param  {Object} data
     * @return {Promise}
     */

  }, {
    key: 'deserialize',
    value: function deserialize(data) {
      return this._editor.deserialize(data);
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Decides whether the undo button should be displayed
     * @return {Boolean}
     * @private
     */

  }, {
    key: '_showUndoButton',
    value: function _showUndoButton() {
      return this._editor.history.isAvailable();
    }

    /**
     * Returns the context passed to all children
     * @return {Object}
     */

  }, {
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        editor: this._editor,
        ui: this.context.ui,
        options: this.context.options,
        editorScreen: this,
        mediator: this.context.mediator,
        globalState: this.context.globalState
      };
    }

    /**
     * Sets the image to the given one
     * @param {Image} image
     * @param {Boolean} resetEditor
     */

  }, {
    key: 'setImage',
    value: function setImage(image, resetEditor) {
      this._forceControlIndex = 0;
      this._editor.setImage(image, resetEditor);
    }

    /**
     * Renders this screen
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderScreen',
    value: function _renderScreen() {
      var ControlsComponent = this.state.controls.controlsComponent;
      var CanvasControlsComponent = this.state.controls.canvasControlsComponent;
      if (!CanvasControlsComponent) {
        CanvasControlsComponent = _overview2.default.canvasControlsComponent;
      }
      var TopBarControlsComponent = this.state.controls.topBarControlsComponent;
      if (!TopBarControlsComponent) {
        TopBarControlsComponent = _overview2.default.topBarControlsComponent;
      }

      var controls = void 0,
          canvasControls = void 0,
          topBarControls = void 0;

      if (TopBarControlsComponent && this.context.options.showTopBar) {
        topBarControls = _globals.ReactBEM.createElement(TopBarControlsComponent, {
          sharedState: this.state.sharedState,
          options: this.state.controlsOptions,
          app: this.props.app,
          ref: 'topBarControls' });
      }

      if (ControlsComponent) {
        controls = _globals.ReactBEM.createElement(ControlsComponent, {
          onSwitchControls: this.switchToControls,
          sharedState: this.state.sharedState,
          options: this.state.controlsOptions,
          app: this.props.app,
          key: this.state.controls.identifier + '-controls',
          ref: 'controls' });
      }

      if (CanvasControlsComponent) {
        canvasControls = _globals.ReactBEM.createElement(CanvasControlsComponent, {
          onSwitchControls: this.switchToControls,
          sharedState: this.state.sharedState,
          options: this.state.controlsOptions,
          app: this.props.app,
          key: this.state.controls.identifier + '-canvasControls',
          ref: 'canvasControls' });
      }

      var bemSpecifier = '$b:editorScreen';
      if (!this.context.options.showHeader) {
        bemSpecifier += ' m:noHeader';
      }

      return _globals.ReactBEM.createElement(
        'div',
        { bem: bemSpecifier },
        topBarControls,
        _globals.ReactBEM.createElement(
          _canvasComponent2.default,
          {
            ref: 'canvas',
            largeControls: this.state.controls.largeCanvasControls },
          canvasControls
        ),
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$b:controls $e:container e:row' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:cell' },
            controls
          )
        )
      );
    }
  }]);

  return EditorScreenComponent;
}(_screenComponent2.default);

exports.default = EditorScreenComponent;


EditorScreenComponent.childContextTypes = {
  ui: _globals.PropTypes.object.isRequired,
  editor: _globals.PropTypes.object.isRequired,
  mediator: _globals.PropTypes.object.isRequired,
  options: _globals.PropTypes.object.isRequired,
  editorScreen: _globals.PropTypes.object.isRequired,
  globalState: _globals.PropTypes.object.isRequired
};

EditorScreenComponent.contextTypes = _screenComponent2.default.contextTypes;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var BackButtonComponent = function (_BaseComponent) {
  _inherits(BackButtonComponent, _BaseComponent);

  function BackButtonComponent() {
    _classCallCheck(this, BackButtonComponent);

    return _possibleConstructorReturn(this, (BackButtonComponent.__proto__ || Object.getPrototypeOf(BackButtonComponent)).apply(this, arguments));
  }

  _createClass(BackButtonComponent, [{
    key: 'renderWithBEM',

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:controls' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:cell m:largeButton' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: '$e:largeButton', onClick: this.props.onClick },
            _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/back.png', true) })
          )
        )
      );
    }
  }]);

  return BackButtonComponent;
}(_globals.BaseComponent);

exports.default = BackButtonComponent;


BackButtonComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var DoneButtonComponent = function (_BaseComponent) {
  _inherits(DoneButtonComponent, _BaseComponent);

  function DoneButtonComponent() {
    _classCallCheck(this, DoneButtonComponent);

    return _possibleConstructorReturn(this, (DoneButtonComponent.__proto__ || Object.getPrototypeOf(DoneButtonComponent)).apply(this, arguments));
  }

  _createClass(DoneButtonComponent, [{
    key: 'renderWithBEM',

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:controls' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:cell m:largeButton' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: '$e:largeButton', onClick: this.props.onClick },
            _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/tick.png', true) })
          )
        )
      );
    }
  }]);

  return DoneButtonComponent;
}(_globals.BaseComponent);

exports.default = DoneButtonComponent;


DoneButtonComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var CanvasComponent = function (_BaseComponent) {
  _inherits(CanvasComponent, _BaseComponent);

  function CanvasComponent() {
    var _ref, _this$_events;

    _classCallCheck(this, CanvasComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = CanvasComponent.__proto__ || Object.getPrototypeOf(CanvasComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onDragStart', '_onDragMove', '_onDragEnd', '_onWindowResize', '_onFeaturesUpdated', '_onZoomChange');

    _this._events = (_this$_events = {}, _defineProperty(_this$_events, _globals.Constants.EVENTS.WINDOW_RESIZE, _this._onWindowResize), _defineProperty(_this$_events, _globals.Constants.EVENTS.FEATURES_UPDATED, _this._onFeaturesUpdated), _this$_events);

    _this._initialRenderDone = false;

    _this.state = {
      canvasPosition: new _globals.Vector2(),
      canvasOffset: new _globals.Vector2()
    };
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called after the window has been resized
   * @private
   */


  _createClass(CanvasComponent, [{
    key: '_onWindowResize',
    value: function _onWindowResize() {
      var editor = this.context.editor;

      var sdk = editor.getSDK();
      sdk.resizeTo(this._getContainerDimensions());
      editor.zoom.set('auto');
    }

    /**
     * Gets called when features (e.g. drag) are updated
     * @param {String[]} identifiers
     * @private
     */

  }, {
    key: '_onFeaturesUpdated',
    value: function _onFeaturesUpdated(identifiers) {
      if (identifiers.indexOf('drag') !== -1) {
        this.forceUpdate();
      }
    }

    // -------------------------------------------------------------------------- LIFECYCLE

    /**
     * Gets called after this component has been mounted
     */

  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      _get(CanvasComponent.prototype.__proto__ || Object.getPrototypeOf(CanvasComponent.prototype), 'componentDidMount', this).call(this);

      var editor = this.context.editor;

      var renderer = editor.getRenderer();

      var _refs = this.refs,
          canvasCell = _refs.canvasCell,
          canvas = _refs.canvas;

      var width = canvasCell.offsetWidth;
      var height = canvasCell.offsetHeight;
      renderer.setCanvas(canvas);
      renderer.resizeTo(new _globals.Vector2(width, height), true);

      editor.zoom.on('set', this._onZoomChange);
    }

    /**
     * Gets called when this component is about to be unmounted
     */

  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      var editor = this.context.editor;

      editor.zoom.off('set', this._onZoomChange);
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the zoom has changed
     * @private
     */

  }, {
    key: '_onZoomChange',
    value: function _onZoomChange() {
      this.forceUpdate();
    }

    // -------------------------------------------------------------------------- DRAGGING

    /**
     * Gets called when the user starts dragging the canvas
     * @param {React.SyntheticEvent} e
     * @private
     */

  }, {
    key: '_onDragStart',
    value: function _onDragStart(e) {
      var editor = this.context.editor;

      if (!editor.features.isEnabled('drag')) return;

      e.preventDefault();

      this._dragStartPosition = _globals.Utils.getEventPosition(e.nativeEvent);
      this._dragInitialOffset = editor.getOffset().clone();
      document.addEventListener('mousemove', this._onDragMove);
      document.addEventListener('touchmove', this._onDragMove);
      document.addEventListener('mouseup', this._onDragEnd);
      document.addEventListener('touchend', this._onDragEnd);
    }

    /**
     * Gets called while the user drags the canvas
     * @param {DOMEvent} e
     * @private
     */

  }, {
    key: '_onDragMove',
    value: function _onDragMove(e) {
      var eventPosition = _globals.Utils.getEventPosition(e);
      var diffFromStart = eventPosition.clone().subtract(this._dragStartPosition);

      var newOffset = this._dragInitialOffset.clone().add(diffFromStart);

      var editor = this.context.editor;

      var lastOffset = editor.getOffset().clone();
      editor.setOffset(newOffset);
      if (!editor.getOffset().equals(lastOffset)) {
        editor.render();
      }
    }

    /**
     * Gets called when the user stops dragging the canvas
     * @param {DOMEvent} e
     * @private
     */

  }, {
    key: '_onDragEnd',
    value: function _onDragEnd(e) {
      document.removeEventListener('mousemove', this._onDragMove);
      document.removeEventListener('touchmove', this._onDragMove);
      document.removeEventListener('mouseup', this._onDragEnd);
      document.removeEventListener('touchend', this._onDragEnd);
    }

    // -------------------------------------------------------------------------- MISC

    /**
     * Returns the container's dimensions
     * @return {Vector2}
     * @private
     */

  }, {
    key: '_getContainerDimensions',
    value: function _getContainerDimensions() {
      var canvasCell = this.refs.canvasCell;

      return new _globals.Vector2(canvasCell.offsetWidth, canvasCell.offsetHeight);
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Returns the style properties for the draggable canvas area
     * @private
     */

  }, {
    key: '_getDraggableStyle',
    value: function _getDraggableStyle() {
      return {
        top: this.state.canvasPosition.y + this.state.canvasOffset.y,
        left: this.state.canvasPosition.x + this.state.canvasOffset.x
      };
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var canvasContent = null;
      var containerContent = null;
      if (this.props.largeControls) {
        containerContent = this.props.children;
      } else {
        canvasContent = this.props.children;
      }

      var editor = this.context.editor;

      var zoomAllowsDrag = editor.isReady() && editor.zoom.get() > editor.zoom.getDefault();
      var dragEnabled = editor.features.isEnabled('drag') && zoomAllowsDrag;

      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:canvas e:container e:row' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:container e:cell', ref: 'canvasCell' },
          _globals.ReactBEM.createElement(
            'div',
            {
              bem: 'e:innerContainer',
              className: dragEnabled ? 'is-draggable' : null,
              onTouchStart: this._onDragStart,
              onMouseDown: this._onDragStart,
              style: this._getDraggableStyle() },
            _globals.ReactBEM.createElement('canvas', {
              bem: 'e:canvas',
              ref: 'canvas' }),
            canvasContent
          ),
          containerContent
        )
      );
    }
  }]);

  return CanvasComponent;
}(_globals.BaseComponent);

exports.default = CanvasComponent;


CanvasComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _controls = __webpack_require__(4);

var _controls2 = _interopRequireDefault(_controls);

var _topBarComponent = __webpack_require__(115);

var _topBarComponent2 = _interopRequireDefault(_topBarComponent);

var _overviewControlsComponent = __webpack_require__(42);

var _overviewControlsComponent2 = _interopRequireDefault(_overviewControlsComponent);

var _overviewCanvasControlsComponent = __webpack_require__(120);

var _overviewCanvasControlsComponent2 = _interopRequireDefault(_overviewCanvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OverviewControls = function (_Controls) {
  _inherits(OverviewControls, _Controls);

  function OverviewControls() {
    _classCallCheck(this, OverviewControls);

    return _possibleConstructorReturn(this, (OverviewControls.__proto__ || Object.getPrototypeOf(OverviewControls)).apply(this, arguments));
  }

  return OverviewControls;
}(_controls2.default);

/**
 * This control's top bar controls component. Used for the sub-header part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */


OverviewControls.topBarControlsComponent = _topBarComponent2.default;

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */
OverviewControls.controlsComponent = _overviewControlsComponent2.default;

/**
 * This control's canvas component. Used for the upper controls part of the editor (on
 * top of the canvas)
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */
OverviewControls.canvasControlsComponent = _overviewCanvasControlsComponent2.default;

exports.default = OverviewControls;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _topBarComponent = __webpack_require__(12);

var _topBarComponent2 = _interopRequireDefault(_topBarComponent);

var _newFileButtonComponent = __webpack_require__(116);

var _newFileButtonComponent2 = _interopRequireDefault(_newFileButtonComponent);

var _exportButtonComponent = __webpack_require__(117);

var _exportButtonComponent2 = _interopRequireDefault(_exportButtonComponent);

var _undoButtonComponent = __webpack_require__(118);

var _undoButtonComponent2 = _interopRequireDefault(_undoButtonComponent);

var _zoomComponent = __webpack_require__(119);

var _zoomComponent2 = _interopRequireDefault(_zoomComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OverviewTopBarComponent = function (_TopBarComponent) {
  _inherits(OverviewTopBarComponent, _TopBarComponent);

  function OverviewTopBarComponent() {
    _classCallCheck(this, OverviewTopBarComponent);

    return _possibleConstructorReturn(this, (OverviewTopBarComponent.__proto__ || Object.getPrototypeOf(OverviewTopBarComponent)).apply(this, arguments));
  }

  _createClass(OverviewTopBarComponent, [{
    key: 'renderContent',

    /**
     * Renders the content of this OverviewTopBarComponent
     * @return {ReactBEM.Element}
     */
    value: function renderContent() {
      var newFileButton = null;
      if (this.context.options.enableUpload) {
        newFileButton = _globals.ReactBEM.createElement(_newFileButtonComponent2.default, { app: this.props.app });
      }

      var zoomComponent = null;
      if (this.context.options.editor.enableZoom) {
        zoomComponent = _globals.ReactBEM.createElement(_zoomComponent2.default, null);
      }

      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:topBar' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:left' },
          newFileButton
        ),
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:right' },
          _globals.ReactBEM.createElement(_undoButtonComponent2.default, null),
          _globals.ReactBEM.createElement(_exportButtonComponent2.default, null)
        ),
        zoomComponent
      );
    }
  }]);

  return OverviewTopBarComponent;
}(_topBarComponent2.default);

exports.default = OverviewTopBarComponent;


OverviewTopBarComponent.contextTypes = _topBarComponent2.default.contextTypes;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _buttonComponent = __webpack_require__(26);

var _buttonComponent2 = _interopRequireDefault(_buttonComponent);

var _invisibleUploadComponent = __webpack_require__(25);

var _invisibleUploadComponent2 = _interopRequireDefault(_invisibleUploadComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var NewFileButtonComponent = function (_BaseComponent) {
  _inherits(NewFileButtonComponent, _BaseComponent);

  function NewFileButtonComponent() {
    var _ref;

    _classCallCheck(this, NewFileButtonComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = NewFileButtonComponent.__proto__ || Object.getPrototypeOf(NewFileButtonComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onNewFile', '_onButtonClick');
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user has selected a new file
   * @param {Image} image
   */


  _createClass(NewFileButtonComponent, [{
    key: '_onNewFile',
    value: function _onNewFile(image) {
      var editor = this.context.editor;

      editor.reset();
      editor.setImage(image);
      editor.zoom.set('auto');
    }

    /**
     * Gets called when the button has been clicked
     * @private
     */

  }, {
    key: '_onButtonClick',
    value: function _onButtonClick() {
      var options = this.context.options;

      var webcamEnabled = options.enableWebcam === false || _globals.Utils.isMobile();
      var photoRollEnabled = !!options.photoRoll.provider;
      if (webcamEnabled && !photoRollEnabled) {
        this.refs.upload.open();
      } else if (photoRollEnabled) {
        this.props.app.switchToScreen('photoRoll');
      } else {
        this.props.app.switchToScreen('splash');
      }
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var options = this.context.options;


      var buttonLabel = null;
      if (options.photoRoll.provider) {
        buttonLabel = this._t('pesdk.editor.button.backgroundImage');
      } else {
        buttonLabel = this._t('pesdk.editor.button.new');
      }

      return _globals.ReactBEM.createElement(
        'div',
        null,
        _globals.ReactBEM.createElement(_invisibleUploadComponent2.default, { onNewFile: this._onNewFile, ref: 'upload' }),
        _globals.ReactBEM.createElement(_buttonComponent2.default, {
          label: buttonLabel,
          icon: 'editor/new.png',
          onClick: this._onButtonClick })
      );
    }
  }]);

  return NewFileButtonComponent;
}(_globals.BaseComponent);

exports.default = NewFileButtonComponent;


NewFileButtonComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _modalManager = __webpack_require__(1);

var _modalManager2 = _interopRequireDefault(_modalManager);

var _buttonComponent = __webpack_require__(26);

var _buttonComponent2 = _interopRequireDefault(_buttonComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ExportButtonComponent = function (_BaseComponent) {
  _inherits(ExportButtonComponent, _BaseComponent);

  function ExportButtonComponent() {
    var _ref;

    _classCallCheck(this, ExportButtonComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = ExportButtonComponent.__proto__ || Object.getPrototypeOf(ExportButtonComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onButtonClick');
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the button has been clicked
   * @private
   */


  _createClass(ExportButtonComponent, [{
    key: '_onButtonClick',
    value: function _onButtonClick() {
      var _this2 = this;

      var _context = this.context,
          options = _context.options,
          editor = _context.editor,
          editorScreen = _context.editorScreen;

      var exportOptions = options.editor.export;

      editorScreen.switchToControls('home', null, function () {
        var loadingModal = _modalManager2.default.instance.displayLoading(_this2._t('pesdk.editor.text.exporting'));

        // Give it some time to display the loading modal
        setTimeout(function () {
          editor.export(exportOptions.download).then(function () {
            loadingModal.close();
          }).catch(function (e) {
            _modalManager2.default.instance.displayError(_this2._t('pesdk.common.title.error'), e.message);
            loadingModal.close();
          });
        }, 100);
      });
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var options = this.context.options;

      if (!options.editor.export.showButton) return null;

      return _globals.ReactBEM.createElement(_buttonComponent2.default, {
        style: 'blue',
        label: this._t('pesdk.editor.button.export'),
        icon: 'editor/export.png',
        onClick: this._onButtonClick });
    }
  }]);

  return ExportButtonComponent;
}(_globals.BaseComponent);

exports.default = ExportButtonComponent;


ExportButtonComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _buttonComponent = __webpack_require__(26);

var _buttonComponent2 = _interopRequireDefault(_buttonComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var UndoButtonComponent = function (_BaseComponent) {
  _inherits(UndoButtonComponent, _BaseComponent);

  function UndoButtonComponent() {
    var _ref, _this$_events;

    _classCallCheck(this, UndoButtonComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = UndoButtonComponent.__proto__ || Object.getPrototypeOf(UndoButtonComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onButtonClick', '_onHistoryUpdated', '_onFeaturesUpdated');

    _this._events = (_this$_events = {}, _defineProperty(_this$_events, _globals.Constants.EVENTS.HISTORY_UPDATED, _this._onHistoryUpdated), _defineProperty(_this$_events, _globals.Constants.EVENTS.FEATURES_UPDATED, _this._onFeaturesUpdated), _this$_events);
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the features have been enabled or disabled
   * @private
   */


  _createClass(UndoButtonComponent, [{
    key: '_onFeaturesUpdated',
    value: function _onFeaturesUpdated() {
      this.forceUpdate();
    }

    /**
     * Gets called when the history has been updated
     * @private
     */

  }, {
    key: '_onHistoryUpdated',
    value: function _onHistoryUpdated() {
      this.forceUpdate();
    }

    /**
     * Gets called when the button has been clicked
     * @private
     */

  }, {
    key: '_onButtonClick',
    value: function _onButtonClick() {
      var editor = this.context.editor;

      editor.history.undo();
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var editor = this.context.editor;

      if (!editor.history.isAvailable()) return null;

      return _globals.ReactBEM.createElement(_buttonComponent2.default, {
        label: this._t('pesdk.editor.button.undo'),
        icon: 'editor/undo.png',
        onClick: this._onButtonClick });
    }
  }]);

  return UndoButtonComponent;
}(_globals.BaseComponent);

exports.default = UndoButtonComponent;


UndoButtonComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ZoomComponent = function (_BaseComponent) {
  _inherits(ZoomComponent, _BaseComponent);

  function ZoomComponent() {
    var _ref, _this$_events;

    _classCallCheck(this, ZoomComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = ZoomComponent.__proto__ || Object.getPrototypeOf(ZoomComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onZoomOutClick', '_onZoomInClick', '_onZoomDone', '_onFeaturesUpdated');

    _this._events = (_this$_events = {}, _defineProperty(_this$_events, _globals.Constants.EVENTS.ZOOM_DONE, _this._onZoomDone), _defineProperty(_this$_events, _globals.Constants.EVENTS.FEATURES_UPDATED, _this._onFeaturesUpdated), _this$_events);
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the features have been updated
   * @private
   */


  _createClass(ZoomComponent, [{
    key: '_onFeaturesUpdated',
    value: function _onFeaturesUpdated() {
      this.forceUpdate();
    }

    /**
     * Gets called when the new zoom level has been applied
     * @private
     */

  }, {
    key: '_onZoomDone',
    value: function _onZoomDone() {
      this.forceUpdate();
    }

    /**
     * Gets called when the user clicks the "zoom out" button
     * @param {Event} e
     * @private
     */

  }, {
    key: '_onZoomOutClick',
    value: function _onZoomOutClick(e) {
      var editor = this.context.editor;

      if (!editor.features.isEnabled('zoom')) return;

      editor.zoom.out();
    }

    /**
     * Gets called when the user clicks the "zoom in" button
     * @param {Event} e
     * @private
     */

  }, {
    key: '_onZoomInClick',
    value: function _onZoomInClick(e) {
      var editor = this.context.editor;

      if (!editor.features.isEnabled('zoom')) return;

      editor.zoom.in();
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var editor = this.context.editor;

      var zoom = editor.zoom.get();
      var enabled = editor.features.isEnabled('zoom');

      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: 'b:editorScreen' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$e:zoom' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: '$e:button m:zoomOut',
              onClick: this._onZoomOutClick,
              className: enabled ? null : 'is-disabled' },
            _globals.ReactBEM.createElement('img', { bem: 'e:image', src: this._getAssetPath('controls/minus.png', true) })
          ),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:label' },
            this._t('pesdk.editor.title.zoom'),
            _globals.ReactBEM.createElement('br', null),
            Math.round(zoom * 100),
            '%'
          ),
          _globals.ReactBEM.createElement(
            'div',
            {
              bem: '$e:button m:zoomIn',
              onClick: this._onZoomInClick,
              className: enabled ? null : 'is-disabled' },
            _globals.ReactBEM.createElement('img', { bem: 'e:image', src: this._getAssetPath('controls/plus.png', true) })
          )
        )
      );
    }
  }]);

  return ZoomComponent;
}(_globals.BaseComponent);

exports.default = ZoomComponent;


ZoomComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _canvasControlsComponent = __webpack_require__(10);

var _canvasControlsComponent2 = _interopRequireDefault(_canvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OverviewCanvasControlsComponent = function (_CanvasControlsCompon) {
  _inherits(OverviewCanvasControlsComponent, _CanvasControlsCompon);

  function OverviewCanvasControlsComponent() {
    var _ref;

    _classCallCheck(this, OverviewCanvasControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = OverviewCanvasControlsComponent.__proto__ || Object.getPrototypeOf(OverviewCanvasControlsComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onClick');
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user clicks somewhere on the canvas
   * @param  {Event} e
   * @private
   */


  _createClass(OverviewCanvasControlsComponent, [{
    key: '_onClick',
    value: function _onClick(e) {
      this._performHitTest(_globals.Utils.getEventPosition(e));
    }

    // -------------------------------------------------------------------------- STYLING

    /**
     * Returns the container style
     * @return {Object}
     * @private
     */

  }, {
    key: '_getContainerStyle',
    value: function _getContainerStyle() {
      if (!this.context.editor.isReady()) {
        return { left: 0, top: 0, width: 1, height: 1 };
      }

      var _context$editor$getSD = this.context.editor.getSDK().getSprite().getBounds(),
          x = _context$editor$getSD.x,
          y = _context$editor$getSD.y,
          width = _context$editor$getSD.width,
          height = _context$editor$getSD.height;

      return {
        left: x,
        top: y,
        width: width,
        height: height
      };
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'div',
        {
          bem: '$b:canvasControls e:container m:full',
          ref: 'container' },
        _globals.ReactBEM.createElement('div', {
          bem: '$b:canvasControls e:innerContainer',
          ref: 'innerContainer',
          style: this._getContainerStyle(),
          onClick: this._onClick,
          onTouchStart: this._onClick })
      );
    }
  }]);

  return OverviewCanvasControlsComponent;
}(_canvasControlsComponent2.default);

exports.default = OverviewCanvasControlsComponent;


OverviewCanvasControlsComponent.contextTypes = _canvasControlsComponent2.default.contextTypes;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _globals = __webpack_require__(0);

var _fileDownloader = __webpack_require__(122);

var _fileDownloader2 = _interopRequireDefault(_fileDownloader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Exporter = function () {
  function Exporter(sdk, options, download) {
    _classCallCheck(this, Exporter);

    this._sdk = sdk;
    this._options = options;
    this._download = download;
  }

  /**
   * Exports the image / data url
   * @return {Promise}
   */


  _createClass(Exporter, [{
    key: 'export',
    value: function _export() {
      var _this = this;

      var renderType = this._getRenderType();

      return this._sdk.export(renderType, this._options.format, this._options.quality).then(function (data) {
        if (_this._download) {
          _this._downloadData(renderType, data);
        }
        return data;
      });
    }

    /**
     * Downloads the data using the given render type
     * @param  {RenderType} renderType
     * @param  {String} data
     * @private
     */

  }, {
    key: '_downloadData',
    value: function _downloadData(renderType, data) {
      switch (renderType) {
        case _globals.RenderType.DATAURL:
          _fileDownloader2.default.downloadDataURL(data, this._options.fileBasename);
          break;
        case _globals.RenderType.MSBLOB:
          _fileDownloader2.default.downloadMSBlob(data, this._options.fileBasename);
          break;
      }
    }

    /**
     * Returns the render type for this export
     * @return {RenderType}
     * @private
     */

  }, {
    key: '_getRenderType',
    value: function _getRenderType() {
      var options = this._options;
      if (options.type !== _globals.RenderType.IMAGE || !this._download) {
        return options.type;
      } else {
        if (_globals.Utils.supportsMSBlob()) {
          return _globals.RenderType.MSBLOB;
        } else {
          return _globals.RenderType.DATAURL;
        }
      }
    }
  }]);

  return Exporter;
}();

exports.default = Exporter;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FileDownloader = function () {
  function FileDownloader() {
    _classCallCheck(this, FileDownloader);
  }

  _createClass(FileDownloader, null, [{
    key: 'downloadDataURL',

    /**
     * Exports the given data url
     * @param  {String} data
     * @param  {String} baseName = 'photoeditorsdk-export'
     */
    value: function downloadDataURL(data) {
      var baseName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'photoeditorsdk-export';

      var url = this.createBlobURLFromDataURL(data);
      var extension = this.getExtensionFromDataURL(data);

      var link = document.createElement('a');
      link.download = baseName + '.' + extension;
      link.href = url;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    /**
     * Exports the given data url using msBlob
     * @param  {String} data
     * @param  {String} baseName = 'photoeditorsdk-export'
     */

  }, {
    key: 'downloadMSBlob',
    value: function downloadMSBlob(data) {
      var baseName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'photoeditorsdk-export';

      navigator.msSaveBlob(data, baseName + '.png');
    }

    /**
     * Returns the file extension by reading the given data url
     * @param  {String} data
     * @return {String}
     */

  }, {
    key: 'getExtensionFromDataURL',
    value: function getExtensionFromDataURL(data) {
      var mimeString = data.split(',')[0].split(':')[1].split(';')[0];
      return mimeString.split('/').pop();
    }

    /**
     * Creates a Blob URI from the given Data URI
     * @param {String} data
     */

  }, {
    key: 'createBlobURLFromDataURL',
    value: function createBlobURLFromDataURL(data) {
      if (!window.Blob || !window.URL || !ArrayBuffer || !Uint8Array) {
        return data;
      }

      var rawData = _globals.Base64.decode(data.split(',')[1]);
      var mimeString = data.split(',')[0].split(':')[1].split(';')[0];

      // write the bytes of the string to an ArrayBuffer
      var arrayBuffer = new ArrayBuffer(rawData.length);
      var intArray = new Uint8Array(arrayBuffer);
      for (var i = 0; i < rawData.length; i++) {
        intArray[i] = rawData[i];
      }

      // write the ArrayBuffer to a blob, and you're done
      var blob = new window.Blob([arrayBuffer], {
        type: mimeString
      });
      return window.URL.createObjectURL(blob);
    }
  }]);

  return FileDownloader;
}();

exports.default = FileDownloader;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ImageResizer = function () {
  function ImageResizer(image, maxPixels, maxDimensions) {
    _classCallCheck(this, ImageResizer);

    this._image = image;
    this._maxPixels = maxPixels;
    this._maxDimensions = maxDimensions;
  }

  /**
   * Checks if the image needs to be resized
   * @return {Boolean}
   */


  _createClass(ImageResizer, [{
    key: 'needsResize',
    value: function needsResize() {
      var dimensions = new _globals.Vector2(this._image.width, this._image.height);
      var pixels = dimensions.x * dimensions.y;
      var exceedsMaxPixels = pixels > this._maxPixels;
      var exceedsMaxDimensions = this._maxDimensions !== null && (dimensions.x > this._maxDimensions || dimensions.y > this._maxDimensions);

      return exceedsMaxPixels || exceedsMaxDimensions;
    }

    /**
     * Resizes the image to match the maximum amount of pixels
     * @return {Promise}
     */

  }, {
    key: 'resize',
    value: function resize() {
      var _this = this;

      var reason = null;
      var canvas = null;
      var maxDimensions = this._maxDimensions;

      return new _globals.Promise(function (resolve, reject) {
        window.setTimeout(function () {
          var initialDimensions = new _globals.Vector2(_this._image.width, _this._image.height);
          var dimensions = initialDimensions.clone();

          // If max pixels is exceeded, resize to fit the max pixels
          if (dimensions.x * dimensions.y > _this._maxPixels) {
            dimensions.copy(_this._getDimensionsByMaxPixels());
            reason = 'maxMegaPixels';
          }

          // If max dimensions (maximum texture size) is exceeded,
          // make sure the shorter side equals the maximum texture
          // size
          if (maxDimensions !== null && (dimensions.x > maxDimensions || dimensions.y > maxDimensions)) {
            var scale = Math.min(maxDimensions / dimensions.x, maxDimensions / dimensions.y);
            dimensions.multiply(scale);
            reason = 'maxDimensions';
          }

          dimensions.floor();
          canvas = _this._createResizedImageCanvas(dimensions);

          resolve({ canvas: canvas, dimensions: dimensions, reason: reason });
        }, 1000);
      });
    }

    /**
     * Creates a resized canvas with the given dimensions
     * @param  {PhotoEditorSDK.Math.Vector2} dimensions
     * @param  {PhotoEditorSDK.Math.Vector2} [imageDimensions] = dimensions
     * @return {Canvas}
     * @private
     */

  }, {
    key: '_createResizedImageCanvas',
    value: function _createResizedImageCanvas(dimensions) {
      var imageDimensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : dimensions;

      var image = this._image;

      var canvas = document.createElement('canvas');
      canvas.width = dimensions.x;
      canvas.height = dimensions.y;

      var offset = dimensions.clone().subtract(imageDimensions).divide(2);

      var context = canvas.getContext('2d');
      context.drawImage(image, 0, 0, image.width, image.height, offset.x, offset.y, imageDimensions.x, imageDimensions.y);
      return canvas;
    }

    /**
     * Returns the dimensions that match the max pixel count
     * @return {Vector2}
     * @private
     */

  }, {
    key: '_getDimensionsByMaxPixels',
    value: function _getDimensionsByMaxPixels() {
      var image = this._image;
      var maxPixels = this._maxPixels;

      var ratioHV = image.width / image.height;
      var ratioVH = image.height / image.width;

      return new _globals.Vector2(Math.sqrt(maxPixels * ratioHV), Math.sqrt(maxPixels * ratioVH)).floor();
    }
  }]);

  return ImageResizer;
}();

exports.default = ImageResizer;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _photoeditorsdk = __webpack_require__(7);

var _photoeditorsdk2 = _interopRequireDefault(_photoeditorsdk);

var _globals = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EditorOperations = function () {
  function EditorOperations(editor, sdk, mediator) {
    _classCallCheck(this, EditorOperations);

    this._editor = editor;
    this._sdk = sdk;
    this._mediator = mediator;

    this._map = {};

    // `editor` might be shallow (e.g. for preloading), so _sdk might not exist.
    this._stack = this._sdk && this._sdk.getOperationsStack();
    this._preferredOrder = this._editor.getOptions().editor.operationsOrder;

    this._available = {};

    var Operations = _photoeditorsdk2.default.Operations;

    for (var operationName in Operations) {
      var Operation = Operations[operationName];
      this._available[Operation.identifier] = Operation;
    }

    var options = editor.getOptions();
    var operations = options.extensions.operations;

    for (var key in operations) {
      var operation = operations[key];
      this._available[operation.identifier] = operation;
    }

    if (this._stack) {
      this._fixStack();
    }
  }

  /**
   * Checks whether an operation with the given identifier exists
   * @param {String} identifier
   * @return {Boolean}
   */


  _createClass(EditorOperations, [{
    key: 'exists',
    value: function exists(identifier) {
      return !!this._map[identifier];
    }

    /**
     * Adds the given operation to the stack
     * @param {PhotoEditorSDK.Operation} operation
     */

  }, {
    key: 'add',
    value: function add(operation) {
      var _this = this;

      var identifier = operation.constructor.identifier;
      operation.on('update', function () {
        _this._mediator.emit(_globals.Constants.EVENTS.OPERATION_UPDATED, operation);
      });
      var index = this._preferredOrder.indexOf(identifier);
      if (index === -1) {
        throw new Error('EditorOperations#add: `' + identifier + '` does not appear in `operationsOrder`');
      }
      this._stack.set(index, operation);
      this._map[identifier] = operation;

      this._mediator.emit(_globals.Constants.EVENTS.OPERATION_CREATED, operation);
    }

    /**
     * Removes the given operation from the stack
     * @param  {PhotoEditorSDK.Operation} operation
     */

  }, {
    key: 'remove',
    value: function remove(operation) {
      var identifier = operation.constructor.identifier;
      var stack = this._stack.getStack();

      // Remove operation from map
      delete this._map[identifier];

      // Remove operation from stack
      var index = stack.map(function (op) {
        return op.constructor.identifier;
      }).indexOf(operation.constructor.identifier);

      if (index !== -1) {
        this._stack.removeAt(index);

        // Set all following operations to dirty, since they might
        // have cached stuff drawn by the removed operation
        for (var i = index + 1; i < stack.length; i++) {
          var _operation = stack[i];
          if (!_operation) continue;
          _operation.setDirty(true);
        }

        this._mediator.emit(_globals.Constants.EVENTS.OPERATION_REMOVED, operation);
      }
    }

    /**
     * Returns the operation with the given identifier
     * @param  {String} identifier
     * @return {PhotoEditorSDK.Operation}
     */

  }, {
    key: 'get',
    value: function get(identifier) {
      return this._map[identifier];
    }

    /**
     * If the operation with the given identifier already exists, it returns
     * the existing operation. Otherwise, it creates and returns a new one.
     * @param  {String} identifier
     * @param  {Object} options
     * @return {PhotoEditorSDK.Operation}
     */

  }, {
    key: 'getOrCreate',
    value: function getOrCreate(identifier) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this._map[identifier]) {
        var operation = this._map[identifier];
        operation.set(options, false);
        return operation;
      } else {
        var Operation = this._available[identifier];
        var _operation2 = new Operation(this._sdk, options);
        this.add(_operation2);
        return _operation2;
      }
    }

    /**
     * Returns the operations stack
     * @return {PhotoEditorSDK.OperationsStack}
     */

  }, {
    key: 'getStack',
    value: function getStack() {
      return this._stack;
    }

    /**
     * Checks if the given operation is available
     * @param {String}
     * @return {Boolean}
     */

  }, {
    key: 'isAvailable',
    value: function isAvailable(identifier) {
      return !!this._available[identifier];
    }

    /**
     * Returns the available operations
     * @return {Object}
     */

  }, {
    key: 'getAvailable',
    value: function getAvailable() {
      return this._available;
    }

    /**
     * Resets the operations
     */

  }, {
    key: 'reset',
    value: function reset() {
      this._map = {};
    }

    /**
     * Since the SDK might create some operations upfront (e.g. to fix the EXIF orientation),
     * we might have operations at array positions where they should not be. This method
     * moves them to their appropriate position
     * @private
     */

  }, {
    key: '_fixStack',
    value: function _fixStack() {
      var _this2 = this;

      var stack = this._stack.getStack().slice();
      this._stack.clear();

      stack.forEach(function (s) {
        _this2.add(s);
      });
    }
  }]);

  return EditorOperations;
}();

exports.default = EditorOperations;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _controls = __webpack_require__(44);

var Controls = _interopRequireWildcard(_controls);

var _globals = __webpack_require__(0);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EditorControls = function () {
  function EditorControls(editor, sdk, mediator) {
    _classCallCheck(this, EditorControls);

    this._editor = editor;
    this._sdk = sdk;
    this._mediator = mediator;

    this._invalidOperationsSeen = [];
    this._options = this._editor.getOptions();
    this._available = _globals.SDKUtils.extend({}, Controls, this._options.extensions.controls);
  }

  /**
   * Checks if the control with the given identifier is selectable
   * @param  {String}  identifier
   * @return {Boolean}
   */


  _createClass(EditorControls, [{
    key: 'isEnabled',
    value: function isEnabled(identifier) {
      var _this = this;

      var control = this.get(identifier);

      if (!control) {
        _globals.Log.info('EditorControls#isEnabled: Unknown control: ' + identifier);
        return false;
      }

      var requiredOperations = control.requiredOperations || [];
      var missingOperations = [];
      requiredOperations.forEach(function (operationIdentifier) {
        if (!_this._editor.operations.isAvailable(operationIdentifier)) {
          missingOperations.push(operationIdentifier);
        }
      });

      if (missingOperations.length) {
        // Making sure we only show one error per control
        if (this._invalidOperationsSeen.indexOf(identifier) === -1) {
          this._invalidOperationsSeen.push(identifier);
          _globals.Log.error('Control `' + identifier + '` can not be used because ' + (missingOperations.length === 1 ? 'operation is' : 'operations are') + ' missing: ' + missingOperations.map(function (o) {
            return '`' + o + '`';
          }).join(', '));
        }
        return false;
      }

      return control.isAvailable && control.isAvailable(this._editor);
    }

    /**
     * Returns the control with the given identifier
     * @param  {String} identifier
     * @return {Control}
     */

  }, {
    key: 'get',
    value: function get(identifier) {
      return this._available[identifier];
    }

    /**
     * Returns the available controls
     * @return {Object}
     */

  }, {
    key: 'getAvailable',
    value: function getAvailable() {
      return this._available;
    }
  }]);

  return EditorControls;
}();

exports.default = EditorControls;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _controls = __webpack_require__(4);

var _controls2 = _interopRequireDefault(_controls);

var _adjustmentsControlsComponent = __webpack_require__(127);

var _adjustmentsControlsComponent2 = _interopRequireDefault(_adjustmentsControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var TOOLS = ['brightness', 'clarity', 'contrast', 'exposure', 'highlights', 'saturation', 'shadows', 'gamma', 'whites', 'blacks', 'temperature'];

/**
 * The adjustments controls
 * @class
 * @extends PhotoEditorSDK.UI.ReactUI.Control
 * @memberof PhotoEditorSDK.UI.ReactUI.Controls
 */

var AdjustmentsControls = function (_Controls) {
  _inherits(AdjustmentsControls, _Controls);

  function AdjustmentsControls() {
    _classCallCheck(this, AdjustmentsControls);

    return _possibleConstructorReturn(this, (AdjustmentsControls.__proto__ || Object.getPrototypeOf(AdjustmentsControls)).apply(this, arguments));
  }

  _createClass(AdjustmentsControls, null, [{
    key: 'onEnter',

    /**
     * Gets called when the user enters these controls
     * @this {AdjustmentsControlsComponent}
     * @param {SharedState} sharedState
     * @override
     * @ignore
     */
    value: function onEnter(sharedState) {
      var editor = this.context.editor;

      var operationExistedBefore = editor.operations.exists('adjustments');
      var operation = editor.operations.getOrCreate('adjustments');
      var initialOptions = operation.serializeOptions();

      this.setSharedState({ operation: operation, operationExistedBefore: operationExistedBefore, initialOptions: initialOptions });
    }

    /**
     * Checks if this control is available to the user
     * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
     * @return {Boolean}
     * @override
     * @ignore
     */

  }, {
    key: 'isAvailable',
    value: function isAvailable(editor) {
      return editor.isToolAllowed('adjustment') && TOOLS.filter(function (tool) {
        return editor.isToolEnabled(tool);
      }).length > 0;
    }

    /**
     * Returns the assets that should be preloaded for this control
     * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
     * @return {String[]}
     */

  }, {
    key: 'getPreloadAssets',
    value: function getPreloadAssets(editor) {
      return TOOLS.filter(function (tool) {
        return editor.isToolEnabled(tool);
      }).map(function (tool) {
        return 'controls/adjustments/' + tool + '.png';
      });
    }
  }]);

  return AdjustmentsControls;
}(_controls2.default);

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */


AdjustmentsControls.controlsComponent = _adjustmentsControlsComponent2.default;

/**
 * This control's identifier
 * @type {String}
 * @default
 */
AdjustmentsControls.identifier = 'adjustments';

/**
 * This control's icon path
 * @type {String}
 * @ignore
 */
AdjustmentsControls.iconPath = 'controls/overview/adjustments.png';

/**
 * The language key that should be used when displaying this filter
 * @type {String}
 * @ignore
 */
AdjustmentsControls.languageKey = 'pesdk.adjustments.title.name';

/**
 * The default options for this control
 * @type {Object}
 */
AdjustmentsControls.defaultOptions = {};

/**
 * The operations required for this control to work properly
 * @type {Array}
 */
AdjustmentsControls.requiredOperations = ['adjustments'];

exports.default = AdjustmentsControls;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _controlsComponent = __webpack_require__(3);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _scrollbarComponent = __webpack_require__(2);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

var _sliderOverlayComponent = __webpack_require__(6);

var _sliderOverlayComponent2 = _interopRequireDefault(_sliderOverlayComponent);

var _miniSliderComponent = __webpack_require__(128);

var _miniSliderComponent2 = _interopRequireDefault(_miniSliderComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var AdjustmentsOperation = _globals.SDK.Operations.AdjustmentsOperation;


var ITEMS = ['brightness', 'saturation', 'contrast', 'gamma', 'clarity', 'exposure', 'shadows', 'highlights', 'whites', 'blacks', 'temperature'];

var AdjustmentsControlsComponent = function (_ControlsComponent) {
  _inherits(AdjustmentsControlsComponent, _ControlsComponent);

  function AdjustmentsControlsComponent() {
    var _ref;

    _classCallCheck(this, AdjustmentsControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = AdjustmentsControlsComponent.__proto__ || Object.getPrototypeOf(AdjustmentsControlsComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onSliderValueChange');

    var editor = _this.context.editor;

    _this._operation = editor.operations.getOrCreate('adjustments');

    _this.state = { selectedControls: null };
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user clicks the back button
   * @param {Event} e
   * @private
   */


  _createClass(AdjustmentsControlsComponent, [{
    key: '_onBackClick',
    value: function _onBackClick(e) {
      var editor = this.context.editor;

      var operationExistedBefore = this.getSharedState('operationExistedBefore');
      var initialOptions = this.getSharedState('initialOptions');

      if (!this._operation.optionsEqual(initialOptions)) {
        editor.history.add(this._operation, initialOptions, operationExistedBefore);
      }

      var defaultOptions = this._operation.getDefaultOptions();
      if (this._operation.optionsEqual(defaultOptions)) {
        editor.operations.remove(this._operation);
      }

      _get(AdjustmentsControlsComponent.prototype.__proto__ || Object.getPrototypeOf(AdjustmentsControlsComponent.prototype), '_onBackClick', this).call(this, e);
    }

    /**
     * Gets called when the user changes the slider value
     * @param  {Number} value
     * @private
     */

  }, {
    key: '_onSliderValueChange',
    value: function _onSliderValueChange(value) {
      var selectedControls = this.state.selectedControls;

      var option = AdjustmentsOperation.prototype.availableOptions[selectedControls];
      var minValue = option.minValue,
          midValue = option.midValue,
          maxValue = option.maxValue;


      value = value < 0 ? midValue + (midValue - minValue) * value / 100 : midValue + (maxValue - midValue) * value / 100;

      this._operation.setOption(selectedControls, value);

      var editor = this.context.editor;

      editor.render();
    }

    /**
     * Gets called when the user clicks one of the three buttons
     * @param {Object} controlsItem
     * @param {Event} e
     * @private
     */

  }, {
    key: '_onButtonClick',
    value: function _onButtonClick(controlsItem, e) {
      this.setState({ selectedControls: controlsItem });
    }

    // -------------------------------------------------------------------------- MISC

    /**
     * Builds the props hash passed to the sliders
     * @param {String} identifier
     * @return {Object}
     */

  }, {
    key: '_buildSliderProps',
    value: function _buildSliderProps(identifier) {
      var option = AdjustmentsOperation.prototype.availableOptions[identifier];
      var minValue = option.minValue,
          midValue = option.midValue,
          maxValue = option.maxValue;


      var value = this._operation ? this._operation.getOption(identifier) : midValue;

      var sliderValue = (value <= midValue ? (value - minValue) / (midValue - minValue) - 1 : (value - midValue) / (maxValue - midValue)) * 100;

      return {
        minValue: -100,
        maxValue: 100,
        value: sliderValue,
        valueUnit: '%',
        positiveValuePrefix: '+',
        label: this._t('pesdk.adjustments.text.' + identifier),
        middleDot: true,
        onChange: this._onSliderValueChange
      };
    }

    // -------------------------------------------------------------------------- RENDERING

  }, {
    key: 'renderOverlayControls',
    value: function renderOverlayControls() {
      var selectedControls = this.state.selectedControls;

      if (!selectedControls) return;

      var sliderProps = this._buildSliderProps(selectedControls);
      return _globals.ReactBEM.createElement(_sliderOverlayComponent2.default, sliderProps);
    }

    /**
     * Renders the list items
     * @return {ReactBEM.Element[]}
     * @private
     */

  }, {
    key: '_renderListItems',
    value: function _renderListItems() {
      var _this2 = this;

      return ITEMS.filter(function (item) {
        return _this2.context.editor.isToolEnabled(item);
      }).map(function (item) {
        var isSelected = _this2.state.selectedControls === item;
        var className = isSelected ? 'is-active' : null;

        var miniSlider = void 0;
        /* eslint-disable no-constant-condition */
        if (!isSelected && false) {
          // Mini sliders temporarily disabled
          var sliderProps = _this2._buildSliderProps(item);
          miniSlider = _globals.ReactBEM.createElement(
            'bem',
            { specifier: 'b:adjustmentsControls' },
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:miniSlider' },
              _globals.ReactBEM.createElement(_miniSliderComponent2.default, sliderProps)
            )
          );
        }
        /* eslint-enable no-constant-condition */

        return _globals.ReactBEM.createElement(
          'li',
          {
            bem: 'e:item',
            key: item,
            'data-identifier': item },
          _globals.ReactBEM.createElement(
            'bem',
            { specifier: '$b:controls' },
            _globals.ReactBEM.createElement(
              'div',
              { bem: '$e:button m:withLabel', onClick: _this2._onButtonClick.bind(_this2, item), className: className },
              _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: _this2._getAssetPath('controls/adjustments/' + item + '.png', true) }),
              _globals.ReactBEM.createElement(
                'div',
                { bem: 'e:label' },
                _this2._t('pesdk.adjustments.text.' + item)
              ),
              miniSlider
            )
          )
        );
      });
    }

    /**
     * Renders the controls of this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderControls',
    value: function renderControls() {
      var listItems = this._renderListItems();

      return _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell m:list' },
        _globals.ReactBEM.createElement(
          _scrollbarComponent2.default,
          null,
          _globals.ReactBEM.createElement(
            'ul',
            { bem: '$e:list' },
            listItems
          )
        )
      );
    }
  }]);

  return AdjustmentsControlsComponent;
}(_controlsComponent2.default);

exports.default = AdjustmentsControlsComponent;


AdjustmentsControlsComponent.contextTypes = _controlsComponent2.default.contextTypes;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */


var MiniSliderComponent = function (_BaseComponent) {
  _inherits(MiniSliderComponent, _BaseComponent);

  function MiniSliderComponent() {
    var _ref;

    _classCallCheck(this, MiniSliderComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = MiniSliderComponent.__proto__ || Object.getPrototypeOf(MiniSliderComponent)).call.apply(_ref, [this].concat(args)));

    _this.state = {
      value: _this.props.value || 0,
      sliderPosition: 0,
      foregroundLeft: 0,
      foregroundWidth: 0
    };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called after the component has been mounted
   */


  _createClass(MiniSliderComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      // Trigger a re-render to position the knob
      this._setValue(this.state.value, false);
    }

    /**
     * Gets called when this component receives new props
     * @param  {Object} props
     */

  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(props) {
      if (props.value !== this.state.value) {
        this._setValue(props.value, false);
      }
    }

    /**
     * Returns the style for the knob (position)
     * @return {Object}
     * @private
     */

  }, {
    key: '_getKnobStyle',
    value: function _getKnobStyle() {
      return { left: this.state.sliderPosition };
    }

    /**
     * Returns the style for the foreground bar
     * @return {Object}
     * @private
     */

  }, {
    key: '_getForegroundStyle',
    value: function _getForegroundStyle() {
      return {
        left: this.state.foregroundLeft,
        width: this.state.foregroundWidth
      };
    }

    // -------------------------------------------------------------------------- MISC

    /**
     * Decides whether or not this slider should have a middle dot on the bar
     * @private
     */

  }, {
    key: '_displayMiddleDot',
    value: function _displayMiddleDot() {
      return this.props.middleDot !== false;
    }

    /**
     * Sets the value to the given value, updates the slider position
     * @param {Number} value
     * @param {Boolean} emitChange = true
     * @private
     */

  }, {
    key: '_setValue',
    value: function _setValue(value) {
      var emitChange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      value = Math.round(value);
      var _props = this.props,
          minValue = _props.minValue,
          maxValue = _props.maxValue;

      var progress = (value - minValue) / (maxValue - minValue);

      // Calculate slider position
      var bar = this.refs.bar;

      var barWidth = bar.offsetWidth;
      var sliderPosition = barWidth * progress;

      // Calculate foreground position and width
      var foregroundWidth = progress * barWidth;
      var foregroundLeft = 0;
      if (this._displayMiddleDot()) {
        foregroundWidth = Math.abs(progress - 0.5) * barWidth;
        foregroundLeft = progress < 0.5 ? barWidth * 0.5 - foregroundWidth : '50%';
      }

      this.setState({ value: value, sliderPosition: sliderPosition, foregroundWidth: foregroundWidth, foregroundLeft: foregroundLeft });
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var foregroundProps = {
        style: this._getForegroundStyle()
      };

      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:miniSlider' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$e:bar', ref: 'bar' },
          _globals.ReactBEM.createElement('div', { bem: '$e:background' }),
          _globals.ReactBEM.createElement('div', _extends({ bem: '$e:foreground' }, foregroundProps)),
          _globals.ReactBEM.createElement('div', { bem: 'e:knob', style: this._getKnobStyle() })
        )
      );
    }
  }]);

  return MiniSliderComponent;
}(_globals.BaseComponent);

exports.default = MiniSliderComponent;


MiniSliderComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _controls = __webpack_require__(4);

var _controls2 = _interopRequireDefault(_controls);

var _transformControlsComponent = __webpack_require__(130);

var _transformControlsComponent2 = _interopRequireDefault(_transformControlsComponent);

var _transformCanvasControlsComponent = __webpack_require__(131);

var _transformCanvasControlsComponent2 = _interopRequireDefault(_transformCanvasControlsComponent);

var _transformTopBarComponent = __webpack_require__(132);

var _transformTopBarComponent2 = _interopRequireDefault(_transformTopBarComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

/**
 * The transform controls
 * @class
 * @extends PhotoEditorSDK.UI.ReactUI.Control
 * @memberof PhotoEditorSDK.UI.ReactUI.Controls
 */
var TransformControls = function (_Controls) {
  _inherits(TransformControls, _Controls);

  function TransformControls() {
    _classCallCheck(this, TransformControls);

    return _possibleConstructorReturn(this, (TransformControls.__proto__ || Object.getPrototypeOf(TransformControls)).apply(this, arguments));
  }

  _createClass(TransformControls, null, [{
    key: 'onEnter',

    /**
     * Gets called when the user enters these controls
     * @this {TransformControlsComponent}
     * @param {SharedState} sharedState
     * @override
     * @ignore
     */
    value: function onEnter(sharedState) {
      var editor = this.context.editor;


      var transformOperationExistedBefore = editor.operations.exists('transform');
      var transformOperation = editor.operations.getOrCreate('transform');
      transformOperation.setEnabled(false, false);

      var orientationOperationExistedBefore = editor.operations.exists('orientation');
      var orientationOperation = editor.operations.getOrCreate('orientation');

      var defaultOptions = {
        end: new _globals.Vector2(1, 1),
        rotation: 0,
        start: new _globals.Vector2(0, 0),
        textureScale: 1
      };

      var inputDimensions = transformOperation.getInputDimensions(false);
      var initialDimensions = transformOperation.getNewDimensions(inputDimensions);

      var initialTransformOptions = defaultOptions;
      if (transformOperationExistedBefore) {
        initialTransformOptions = transformOperation.serializeOptions();
        delete initialTransformOptions.enabled;

        // Convert operation options to our UI options
        var _initialTransformOpti = initialTransformOptions,
            start = _initialTransformOpti.start,
            end = _initialTransformOpti.end,
            rotation = _initialTransformOpti.rotation;

        var finalScale = transformOperation.calculateScale(rotation);
        var _inputDimensions = transformOperation.getInputDimensions(false);
        var cos = Math.cos(rotation);
        var sin = Math.sin(rotation);

        var halfRelativeSize = end.clone().subtract(start).divide(2);
        var middleInPixels = start.clone().add(halfRelativeSize).multiply(_inputDimensions);

        var middleDistanceFromCenter = middleInPixels.subtract(_inputDimensions.clone().multiply(0.5));

        // Rotate and scale the middle back
        var newMiddleDistanceFromCenter = new _globals.Vector2(middleDistanceFromCenter.x * cos - middleDistanceFromCenter.y * sin, middleDistanceFromCenter.x * sin + middleDistanceFromCenter.y * cos).multiply(finalScale);

        var newMiddleInPixels = _inputDimensions.clone().multiply(0.5).add(newMiddleDistanceFromCenter);

        var newRelativeMiddle = newMiddleInPixels.clone().divide(_inputDimensions);

        var newStart = newRelativeMiddle.clone().subtract(halfRelativeSize.clone().multiply(finalScale));
        var newEnd = newRelativeMiddle.clone().add(halfRelativeSize.clone().multiply(finalScale));

        initialTransformOptions.start = newStart;
        initialTransformOptions.end = newEnd;
      }

      editor.broadcastTransform(transformOperation, defaultOptions);

      var initialOrientationOptions = orientationOperation.serializeOptions();
      var activePadding = [10, 0, 58 + 10, 0];
      editor.setSpriteScale(transformOperation.calculateScale());
      editor.setRotation(initialTransformOptions.rotation);
      editor.setPadding(activePadding);

      // Reset start and end so that SpriteOperation gets an update and repositions
      // the stickers
      transformOperation.set(defaultOptions, transformOperationExistedBefore);

      editor.zoom.set('auto', function () {
        // Disable zoom and drag while we're transformping
        editor.features.disable('zoom', 'drag');
      }, false);

      this.setSharedState({
        initialTransformOptions: initialTransformOptions,
        initialOrientationOptions: initialOrientationOptions,
        operation: transformOperation,
        orientationOperation: orientationOperation,
        activePadding: activePadding,
        orientationOperationExistedBefore: orientationOperationExistedBefore,
        transformOperationExistedBefore: transformOperationExistedBefore,
        start: _globals.Vector2.fromObject(initialTransformOptions.start),
        end: _globals.Vector2.fromObject(initialTransformOptions.end),
        rotation: initialTransformOptions.rotation,
        orientationRotation: orientationOperation.getRotation(),
        flipVertically: orientationOperation.getFlipVertically(),
        flipHorizontally: orientationOperation.getFlipHorizontally(),
        initialDimensions: initialDimensions,
        inputDimensions: inputDimensions
      });
    }

    /**
     * Checks if this control is available to the user
     * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
     * @return {Boolean}
     * @ignore
     */

  }, {
    key: 'isAvailable',
    value: function isAvailable(editor) {
      return editor.isToolAllowed('transform') && editor.isToolEnabled('transform');
    }

    /**
     * Returns the assets that should be preloaded for this control
     * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
     * @return {String[]}
     */

  }, {
    key: 'getPreloadAssets',
    value: function getPreloadAssets(editor) {
      var options = editor.getOptions();
      var transformOptions = _globals.SDKUtils.defaults(options.editor.controlsOptions.transform, this.defaultOptions);

      var assets = ['controls/transform/rotate-ccw.png', 'controls/transform/rotate-cw.png', 'controls/transform/flip-h.png', 'controls/transform/flip-v.png'];

      // Add ratios
      var ratios = _transformControlsComponent2.default.getRatios(transformOptions);
      ratios.forEach(function (itemOrGroup) {
        if (Array.isArray(itemOrGroup)) {
          itemOrGroup.forEach(function (_ref) {
            var identifier = _ref.identifier;

            assets.push('controls/transform/' + identifier + '.png');
          });
        } else {
          assets.push('controls/transform/' + itemOrGroup.identifier + '.png');
        }
      });

      return assets;
    }
  }]);

  return TransformControls;
}(_controls2.default);

/**
 * This control's top bar component. Used for the upper part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.TopBarControlsComponent}
 */


TransformControls.topBarControlsComponent = _transformTopBarComponent2.default;

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */
TransformControls.controlsComponent = _transformControlsComponent2.default;

/**
 * This control's canvas component. Used for the upper controls part of the editor (on
 * top of the canvas)
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */
TransformControls.canvasControlsComponent = _transformCanvasControlsComponent2.default;

/**
 * This control's identifier
 * @type {String}
 * @default
 */
TransformControls.identifier = 'transform';

/**
 * This control's icon path
 * @type {String}
 * @ignore
 */
TransformControls.iconPath = 'controls/overview/transform.png';

/**
 * The language key that should be used when displaying this filter
 * @type {String}
 * @ignore
 */
TransformControls.languageKey = 'pesdk.transform.title.name';

/**
 * The default options for this control
 * @type {Object}
 * @property {Object[]} [ratios = []]
 * @property {Boolean} [replaceRatios = false]
 * @property {String[]} [availableRatios = null]
 */
TransformControls.defaultOptions = {};

/**
 * The operations required for this control to work properly
 * @type {Array}
 */
TransformControls.requiredOperations = ['transform'];

exports.default = TransformControls;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _controlsComponent = __webpack_require__(3);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _scrollbarComponent = __webpack_require__(2);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

var _sliderOverlayComponent = __webpack_require__(6);

var _sliderOverlayComponent2 = _interopRequireDefault(_sliderOverlayComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var TransformControlsComponent = function (_ControlsComponent) {
  _inherits(TransformControlsComponent, _ControlsComponent);

  function TransformControlsComponent() {
    var _ref;

    _classCallCheck(this, TransformControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = TransformControlsComponent.__proto__ || Object.getPrototypeOf(TransformControlsComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_selectRatio', '_onRotationChange', '_reapplyRatio');

    _this.state = { ratio: null };
    _this._ratios = _this.constructor.getRatios(_this.props.options);

    _this._events = _defineProperty({}, _globals.Constants.EVENTS.TRANSFORM_REAPPLY_RATIO, _this._reapplyRatio);

    _this._selectInitialRatio(!_this.getSharedState('transformOperationExistedBefore'));
    return _this;
  }

  // -------------------------------------------------------------------------- INITIALIZATION

  /**
   * Initializes the available ratios
   * @param {Object} options
   * @return {Object[]}
   */


  _createClass(TransformControlsComponent, [{
    key: 'shouldSharedComponentUpdate',


    // -------------------------------------------------------------------------- LIFECYCLE

    /**
     * Checks if the component should change from the given state
     * @param  {Object} oldState
     * @param  {Object} newState
     * @return {Boolean}
     */
    value: function shouldSharedComponentUpdate(oldState, newState) {
      return oldState.ratio !== newState.ratio;
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the rotation has been chagned (by using the slider)
     * @param  {Number} rotation
     * @private
     */

  }, {
    key: '_onRotationChange',
    value: function _onRotationChange(rotation) {
      var transformOperation = this.getSharedState('operation');
      var editor = this.context.editor;

      rotation = rotation * Math.PI / 180;
      editor.setRotation(rotation);
      editor.setSpriteScale(transformOperation.calculateScale(rotation));

      editor.render();
      this.setSharedState({ rotation: rotation });
    }

    /**
     * Gets the outer bounding dimensions of the rotated sprite
     * @return {PhotoEditorSDK.Math.Vector2}
     * @private
     */

  }, {
    key: '_getRotatedSpriteDimensions',
    value: function _getRotatedSpriteDimensions() {
      var editor = this.context.editor;

      var rotation = editor.getRotation();

      var outputDimensions = editor.getOutputDimensions(false);

      return new _globals.Vector2(Math.abs(outputDimensions.x * Math.cos(rotation)) + Math.abs(outputDimensions.y * Math.sin(rotation)), Math.abs(outputDimensions.x * Math.sin(rotation)) + Math.abs(outputDimensions.y * Math.cos(rotation)));
    }

    /**
     * Calculates the texture scale using the current settings
     * @return {Number}
     * @private
     */

  }, {
    key: '_calculateTextureScale',
    value: function _calculateTextureScale() {
      var transformOperation = this.getSharedState('operation');
      var ratio = this.getSharedState('ratio');
      if (!ratio || !ratio.dimensions) {
        return 1;
      }

      var start = this.getSharedState('start');
      var end = this.getSharedState('end');

      var size = end.clone().subtract(start);
      var transformDimensions = transformOperation.getInputDimensions(false).multiply(size);
      return ratio.dimensions.x / transformDimensions.x;
    }

    /**
     * Returns all the history items for all operations
     * @private
     */

  }, {
    key: '_getHistoryItems',
    value: function _getHistoryItems() {
      var historyItems = [];

      var transformHistoryItem = this._getTransformHistoryItem();
      if (transformHistoryItem) {
        historyItems.push(transformHistoryItem);
      }

      var orientationHistoryItem = this._getOrientationHistoryItem();
      if (orientationHistoryItem) {
        historyItems.push(orientationHistoryItem);
      }

      return historyItems;
    }

    /**
     * Returns the history item for the transform operation
     * @private
     */

  }, {
    key: '_getTransformHistoryItem',
    value: function _getTransformHistoryItem() {
      var editor = this.context.editor;

      var transformOperation = this.getSharedState('operation');
      var initialTransformOptions = this.getSharedState('initialTransformOptions');
      var transformOperationExistedBefore = this.getSharedState('transformOperationExistedBefore');
      if (!transformOperation.optionsEqual(initialTransformOptions)) {
        return {
          operation: transformOperation,
          options: initialTransformOptions,
          existent: transformOperationExistedBefore,
          undo: function undo(operation, newOptions) {
            editor.broadcastTransform(operation, newOptions);
          }
        };
      }
    }

    /**
     * Returns the history item for the orientation operation
     * @private
     */

  }, {
    key: '_getOrientationHistoryItem',
    value: function _getOrientationHistoryItem() {
      var editor = this.context.editor;

      var orientationOperation = this.getSharedState('orientationOperation');
      var initialOrientationOptions = this.getSharedState('initialOrientationOptions');
      var orientationOperationExistedBefore = this.getSharedState('orientationOperationExistedBefore');
      if (!orientationOperation.optionsEqual(initialOrientationOptions)) {
        return {
          operation: orientationOperation,
          options: initialOrientationOptions,
          existent: orientationOperationExistedBefore,
          undo: function undo(operation, newOptions) {
            if (operation.getRotation() !== newOptions.rotation) {
              editor.broadcastRotate(newOptions.rotation - operation.getRotation());
            }

            var rotation = newOptions.rotation;
            var inverseFlip = rotation === 90 || rotation === 270;
            if (operation.getFlipVertically() !== newOptions.flipVertically) {
              editor.broadcastFlip(inverseFlip ? 'horizontal' : 'vertical');
            } else if (operation.getFlipHorizontally() !== newOptions.flipHorizontally) {
              editor.broadcastFlip(inverseFlip ? 'vertical' : 'horizontal');
            }
          }
        };
      }
    }

    /**
     * Re-applies the current ratio
     * @private
     */

  }, {
    key: '_reapplyRatio',
    value: function _reapplyRatio() {
      var ratio = this.getSharedState('ratio');
      this._selectRatio(ratio);
    }

    /**
     * Gets called when the user clicks the back button
     * @param {Event} e
     * @private
     */

  }, {
    key: '_onBackClick',
    value: function _onBackClick(e) {
      var editor = this.context.editor;


      var ratio = this.getSharedState('ratio');
      var transformOperation = this.getSharedState('operation');
      var orientationOperation = this.getSharedState('orientationOperation');

      var rotation = editor.getRotation();
      var start = this.getSharedState('start').clone();
      var end = this.getSharedState('end').clone();
      if ((ratio === null || start.equals(0, 0) && end.equals(1, 1)) && rotation === 0) {
        editor.operations.remove(transformOperation);
      } else {
        // Calculate texture scale
        var textureScale = this._calculateTextureScale();

        var options = {
          rotation: rotation,
          start: start,
          end: end,
          textureScale: textureScale,
          enabled: true
        };

        var finalScale = transformOperation.calculateScale(rotation);
        var inputDimensions = transformOperation.getInputDimensions(false);
        var cos = Math.cos(-rotation);
        var sin = Math.sin(-rotation);

        var halfRelativeSize = end.clone().subtract(start).divide(2);
        var middleInPixels = start.clone().add(halfRelativeSize).multiply(inputDimensions);

        var middleDistanceFromCenter = middleInPixels.subtract(inputDimensions.clone().multiply(0.5));

        // Rotate and scale the middle back
        var newMiddleDistanceFromCenter = new _globals.Vector2(middleDistanceFromCenter.x * cos - middleDistanceFromCenter.y * sin, middleDistanceFromCenter.x * sin + middleDistanceFromCenter.y * cos).divide(finalScale);

        var newMiddleInPixels = inputDimensions.clone().multiply(0.5).add(newMiddleDistanceFromCenter);

        var newRelativeMiddle = newMiddleInPixels.clone().divide(inputDimensions);

        options.start = newRelativeMiddle.clone().subtract(halfRelativeSize.clone().divide(finalScale));
        options.end = newRelativeMiddle.clone().add(halfRelativeSize.clone().divide(finalScale));

        editor.broadcastTransform(transformOperation, options);
        transformOperation.set(options);
      }

      if (orientationOperation.getRotation() === 0 && !orientationOperation.getFlipVertically() && !orientationOperation.getFlipHorizontally()) {
        editor.operations.remove(orientationOperation);
      }

      // Reset editor transforms
      editor.setPadding(false);
      editor.setRotation(0);
      editor.setSpriteScale(1);

      // Handle history
      var historyItems = this._getHistoryItems();
      if (historyItems.length) {
        var _props$options = this.props.options,
            forceCrop = _props$options.forceCrop,
            firstCrop = _props$options.firstCrop;


        if (!forceCrop && !firstCrop) {
          editor.history.add(historyItems);
        }
      }

      // Enable zoom and drag again, reset zoom
      editor.features.enable('zoom', 'drag');
      editor.zoom.set('auto');

      _get(TransformControlsComponent.prototype.__proto__ || Object.getPrototypeOf(TransformControlsComponent.prototype), '_onBackClick', this).call(this, e);
    }

    // -------------------------------------------------------------------------- RATIO HANDLING

    /**
     * Selects the initial ratio
     * @param {Boolean} setDefaultOptions = true
     * @private
     */

  }, {
    key: '_selectInitialRatio',
    value: function _selectInitialRatio() {
      var setDefaultOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      var operation = this.getSharedState('operation');
      var selectedRatio = null;
      var ratios = _globals.SDKUtils.Array.flatten(this._ratios);

      // 1. Selected ratio stored in operation
      var operationRatio = operation._ratio;
      if (operationRatio) {
        var matchingRatios = ratios.filter(function (ratio) {
          return ratio === operationRatio;
        });
        selectedRatio = matchingRatios[0];
      }

      // 2. First ratio with `selected` flag
      if (!selectedRatio) {
        var selectedRatios = ratios.filter(function (ratio) {
          return ratio.selected;
        });
        selectedRatio = selectedRatios.pop();
      }

      // 3. First ratio
      if (!selectedRatio) {
        selectedRatio = ratios[0];
      }

      return this._selectRatio(selectedRatio, setDefaultOptions, false);
    }

    /**
     * Selects the given ratio
     * @param {String} ratio
     * @param {Boolean} setDefaultOptions = true
     * @param {Boolean} update = true
     * @private
     */

  }, {
    key: '_selectRatio',
    value: function _selectRatio(ratio) {
      var setDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var operation = this.getSharedState('operation');
      if (setDefaultOptions && ratio) {
        this._setDefaultOptionsForRatio(ratio, update);
      }
      operation._ratio = ratio;

      var newSharedState = {
        ratio: ratio
      };
      var editor = this.context.editor;

      if (!ratio) {
        editor.setPadding(false);
        editor.setRotation(0);
        editor.setSpriteScale(1);

        newSharedState.rotation = 0;
        newSharedState.start = new _globals.Vector2(0, 0);
        newSharedState.end = new _globals.Vector2(1, 1);
      } else {
        editor.setPadding(this.getSharedState('activePadding'));
      }
      editor.render();
      this.setSharedState(newSharedState, update);
    }

    /**
     * Sets the default options (start / end) for the given ratio
     * @param {Object} ratio
     * @param {Boolean} update = false
     * @private
     */

  }, {
    key: '_setDefaultOptionsForRatio',
    value: function _setDefaultOptionsForRatio(_ref2) {
      var ratio = _ref2.ratio,
          name = _ref2.name,
          dimensions = _ref2.dimensions;
      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var editor = this.context.editor;

      var start = new _globals.Vector2();
      var end = new _globals.Vector2();

      if (dimensions && !ratio) {
        ratio = dimensions.x / dimensions.y;
      }

      if (ratio === '*') {
        start = new _globals.Vector2(0, 0);
        end = new _globals.Vector2(1, 1);
      } else {
        var outputDimensions = editor.getOutputDimensions();
        var canvasRatio = outputDimensions.x / outputDimensions.y;
        if (canvasRatio <= ratio) {
          var height = 1 / outputDimensions.y * (outputDimensions.x / ratio);
          start.set(0, (1.0 - height) / 2);
          end.set(1.0, 1 - start.y);
        } else {
          var width = 1 / outputDimensions.x * (ratio * outputDimensions.y);
          start.set((1 - width) / 2, 0);
          end.set(1 - start.x, 1.0);
        }
      }

      this.setSharedState({ start: start, end: end }, update);
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the overlay controls of this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderOverlayControls',
    value: function renderOverlayControls() {
      var rotation = this.getSharedState('rotation') * 180 / Math.PI;
      if (!this.getSharedState('ratio')) return null;
      return _globals.ReactBEM.createElement(_sliderOverlayComponent2.default, {
        value: rotation,
        minValue: -45,
        middleDot: true,
        maxValue: 45,
        valueUnit: '\xB0',
        label: this._t('pesdk.transform.text.rotation'),
        onChange: this._onRotationChange });
    }

    /**
     * Renders the list items for this controls
     * @return {ReactBEM.Element[]}
     * @private
     */

  }, {
    key: '_renderListItems',
    value: function _renderListItems() {
      var _this2 = this;

      var items = [];
      var makeItem = function makeItem(ratio) {
        return _globals.ReactBEM.createElement(
          'li',
          {
            bem: 'e:item',
            key: ratio.identifier,
            'data-identifier': ratio.identifier },
          _globals.ReactBEM.createElement(
            'bem',
            { specifier: '$b:controls' },
            _globals.ReactBEM.createElement(
              'div',
              { bem: '$e:button m:withLabel',
                className: _this2.getSharedState('ratio') === ratio ? 'is-active' : null,
                onClick: _this2._selectRatio.bind(_this2, ratio) },
              _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: _this2._getAssetPath('controls/transform/' + ratio.identifier + '.png', true) }),
              _globals.ReactBEM.createElement(
                'div',
                { bem: 'e:label' },
                _this2._t('pesdk.transform.asset.' + ratio.identifier) || ratio.defaultName
              )
            )
          )
        );
      };

      this._ratios.forEach(function (groupOrRatio) {
        if (Array.isArray(groupOrRatio)) {
          var group = groupOrRatio;

          var groupItems = [];
          group.forEach(function (ratio) {
            groupItems.push(makeItem(ratio));
          });

          if (groupItems.length) {
            items.push(groupItems);
          }
        } else {
          var ratio = groupOrRatio;
          items.push(makeItem(ratio));
        }
      });

      var finalItems = [];
      items.forEach(function (itemOrGroup) {
        finalItems = finalItems.concat(itemOrGroup);
        if (Array.isArray(itemOrGroup) && itemOrGroup !== items[items.length - 1]) {
          finalItems.push(_globals.ReactBEM.createElement('li', { bem: 'e:separator' }));
        }
      });

      var noTransformItem = _globals.ReactBEM.createElement(
        'li',
        {
          bem: 'e:item',
          'data-identifier': 'none',
          key: 'noTransform' },
        _globals.ReactBEM.createElement(
          'bem',
          { specifier: '$b:controls' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: '$e:button m:withLabel',
              className: !this.getSharedState('ratio') ? 'is-active' : null,
              onClick: this._selectRatio.bind(this, null) },
            _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/transform/no-transform.png', true) }),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:label' },
              this._t('pesdk.transform.button.none')
            )
          )
        )
      );

      var options = this.context.options;


      return options.editor.forceCrop ? finalItems : [noTransformItem, _globals.ReactBEM.createElement('li', { bem: 'e:separator' })].concat(finalItems);
    }

    /**
     * Renders the controls of this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderControls',
    value: function renderControls() {
      var listItems = this._renderListItems();

      return _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell m:list' },
        _globals.ReactBEM.createElement(
          _scrollbarComponent2.default,
          null,
          _globals.ReactBEM.createElement(
            'ul',
            { bem: '$e:list' },
            listItems
          )
        )
      );
    }
  }], [{
    key: 'getRatios',
    value: function getRatios(options) {
      var ratios = options.ratios,
          replaceRatios = options.replaceRatios,
          availableRatios = options.availableRatios;

      ratios = ratios || [];

      var selectableRatios = void 0;
      selectableRatios = _globals.Constants.DEFAULTS.TRANSFORM_RATIOS;
      if (replaceRatios) {
        selectableRatios = ratios;
      } else {
        selectableRatios = selectableRatios.concat(ratios);
      }

      if (availableRatios && availableRatios.length) {
        var pickRatios = function pickRatios(item) {
          if (Array.isArray(item)) {
            return item.map(pickRatios).filter(function (r) {
              return r;
            });
          } else {
            if (availableRatios.indexOf(item.identifier) === -1) {
              return null;
            } else {
              return item;
            }
          }
        };
        selectableRatios = selectableRatios.map(pickRatios).filter(function (r) {
          return r;
        });
      }

      return selectableRatios;
    }
  }]);

  return TransformControlsComponent;
}(_controlsComponent2.default);

exports.default = TransformControlsComponent;


TransformControlsComponent.contextTypes = _controlsComponent2.default.contextTypes;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _draggableComponent = __webpack_require__(5);

var _draggableComponent2 = _interopRequireDefault(_draggableComponent);

var _canvasControlsComponent = __webpack_require__(10);

var _canvasControlsComponent2 = _interopRequireDefault(_canvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var MIN_DIMENSIONS = new _globals.Vector2(50, 50);

var TransformCanvasControlsComponent = function (_CanvasControlsCompon) {
  _inherits(TransformCanvasControlsComponent, _CanvasControlsCompon);

  function TransformCanvasControlsComponent() {
    var _ref;

    _classCallCheck(this, TransformCanvasControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = TransformCanvasControlsComponent.__proto__ || Object.getPrototypeOf(TransformCanvasControlsComponent)).call.apply(_ref, [this].concat(args)));

    _this._needsStyleFixes = true;
    _this._bindAll('_onCenterDragStart', '_onCenterDrag');

    _this.state = {
      dimensions: _this.getSharedState('initialDimensions')
    };
    return _this;
  }

  /**
   * Fixes styles in IE
   */


  _createClass(TransformCanvasControlsComponent, [{
    key: 'fixStyles',
    value: function fixStyles() {
      if (_globals.Utils.Browser.isIElte(11)) {
        var editor = this.context.editor;
        var container = this.refs.container;


        var canvasDimensions = editor.getCanvasDimensions(false);
        var cellHeight = canvasDimensions.y;
        container.style.height = cellHeight + 'px';
      }
    }

    /**
     * Gets called when the shared state did change
     * @param {Object} newState
     */

  }, {
    key: 'sharedStateDidChange',
    value: function sharedStateDidChange(newState) {
      if (newState !== this.getSharedState('ratio')) {
        this._updateDimensions();
      }
    }

    /**
     * Updates the dimensions display
     * @private
     */

  }, {
    key: '_updateDimensions',
    value: function _updateDimensions() {
      var operation = this.getSharedState('operation');
      var ratio = this.getSharedState('ratio') || { ratio: '*' };

      var dimensions = void 0;
      if (ratio.dimensions) {
        dimensions = ratio.dimensions.clone();
      } else {
        var inputDimensions = operation.getInputDimensions(false);
        var start = this.getSharedState('start');
        var end = this.getSharedState('end');
        var transformSize = end.clone().subtract(start);
        dimensions = transformSize.multiply(inputDimensions).floor();
      }

      this.setState({ dimensions: dimensions });
    }

    // -------------------------------------------------------------------------- CENTER DRAGGING

    /**
     * Gets called when the user stars dragging the center
     * @private
     */

  }, {
    key: '_onCenterDragStart',
    value: function _onCenterDragStart() {
      var start = this.getSharedState('start');
      var end = this.getSharedState('end');

      this._initialValues = {
        start: start.clone(),
        end: end.clone(),
        size: end.clone().subtract(start)
      };
    }

    /**
     * Gets called while the user drags the center
     * @param {Vector2} offset
     * @private
     */

  }, {
    key: '_onCenterDrag',
    value: function _onCenterDrag(offset) {
      var editor = this.context.editor;
      var _initialValues = this._initialValues,
          start = _initialValues.start,
          size = _initialValues.size;

      var outputDimensions = editor.getOutputDimensions();
      var transformDifference = offset.clone().divide(outputDimensions);

      var minStart = new _globals.Vector2(0, 0);
      var maxStart = new _globals.Vector2(1, 1).subtract(size);

      var newStart = start.clone().add(transformDifference).clamp(minStart, maxStart);
      var newEnd = newStart.clone().add(size);

      this.setSharedState({ start: newStart, end: newEnd });
    }

    // -------------------------------------------------------------------------- KNOB DRAGGING

    /**
     * Gets called when the user starts dragging a knob
     * @param {String} optionName
     * @private
     */

  }, {
    key: '_onKnobDragStart',
    value: function _onKnobDragStart(optionName) {
      this._currentDragOption = optionName;

      this._initialValues = {
        start: this.getSharedState('start').clone(),
        end: this.getSharedState('end').clone()
      };
    }

    /**
     * Gets called while the user drags a knob
     * @param {String} optionName
     * @param {Vector2} offset
     * @private
     */

  }, {
    key: '_onKnobDrag',
    value: function _onKnobDrag(optionName, offset) {
      var editor = this.context.editor;

      var outputDimensions = editor.getOutputDimensions();

      var _ref2 = this.getSharedState('ratio') || { ratio: '*' },
          ratio = _ref2.ratio,
          dimensions = _ref2.dimensions;

      if (dimensions && !ratio) {
        ratio = dimensions.x / dimensions.y;
      }

      var newSize = this._initialValues.end.clone().subtract(this._initialValues.start).multiply(outputDimensions);

      // Calculate max size and new size
      var maxSize = void 0;
      if (optionName === 'start') {
        newSize.subtract(offset);
        maxSize = this._initialValues.end.clone().multiply(outputDimensions);
      } else if (optionName === 'end') {
        newSize.add(offset);
        maxSize = new _globals.Vector2(1, 1).subtract(this._initialValues.start).multiply(outputDimensions);
      }

      var biggestPossibleCrop = outputDimensions;
      if (typeof ratio !== 'undefined' && ratio !== '*') {
        if (ratio > outputDimensions.x / outputDimensions.y) {
          biggestPossibleCrop = new _globals.Vector2(outputDimensions.x, outputDimensions.x / ratio);
        } else {
          biggestPossibleCrop = new _globals.Vector2(outputDimensions.y * ratio, outputDimensions.y);
        }
      }

      newSize.x = Math.min(Math.max(Math.min(MIN_DIMENSIONS.x, biggestPossibleCrop.x), newSize.x), maxSize.x);
      if (ratio !== '*') {
        newSize.y = newSize.x / ratio;
      }
      newSize.y = Math.min(Math.max(Math.min(MIN_DIMENSIONS.y, biggestPossibleCrop.y), newSize.y), maxSize.y);
      if (ratio !== '*') {
        newSize.x = newSize.y * ratio;
      }

      if (optionName === 'start') {
        var newStart = this._initialValues.end.clone().subtract(newSize.clone().divide(outputDimensions));
        this.setSharedState({ start: newStart }, false);
        this._updateDimensions();
      } else if (optionName === 'end') {
        var newEnd = this._initialValues.start.clone().add(newSize.clone().divide(outputDimensions));
        this.setSharedState({ end: newEnd }, false);
        this._updateDimensions();
      }
    }

    // -------------------------------------------------------------------------- MISC

    /**
     * Returns the dimensions according to the current transform dimensions
     * @private
     */

  }, {
    key: '_calculateDimensions',
    value: function _calculateDimensions() {
      var editor = this.context.editor;

      var start = this.getSharedState('start');
      var end = this.getSharedState('end');

      return end.clone().subtract(start).multiply(editor.getInputDimensions(false)).round();
    }

    // -------------------------------------------------------------------------- RESIZING / STYLING

    /**
     * Returns the styles (width / height) for the transform areas that define the
     * transform size
     * @return {Object}
     * @private
     */

  }, {
    key: '_getAreaStyles',
    value: function _getAreaStyles() {
      var editor = this.context.editor;

      var outputDimensions = editor.getOutputDimensions();
      var canvasDimensions = editor.getCanvasDimensions();

      var start = this.getSharedState('start').clone().multiply(outputDimensions).floor();
      var end = this.getSharedState('end').clone().multiply(outputDimensions).ceil();
      var size = end.clone().subtract(start);

      var offset = canvasDimensions.clone().subtract(outputDimensions).divide(2).floor();

      var padding = editor.getPadding();
      start.add(offset).add(0, padding[0]);

      return {
        topLeft: this._getDimensionsStyles(start.x, start.y),
        topCenter: this._getDimensionsStyles(size.x, start.y),
        centerLeft: this._getDimensionsStyles(start.x, size.y),
        center: this._getDimensionsStyles(size.x, size.y)
      };
    }

    /**
     * Returns the dimensions style (width / height) for the given dimensions
     * @param {Number} x
     * @param {Number} y
     * @return {Object}
     * @private
     */

  }, {
    key: '_getDimensionsStyles',
    value: function _getDimensionsStyles(x, y) {
      // Table cells and rows can't have a width / height of 0
      return {
        width: Math.max(1, x),
        height: Math.max(1, y)
      };
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var ratio = this.getSharedState('ratio');
      var dimensions = this.state.dimensions;


      var canvasContent = void 0;
      if (ratio) {
        var areaStyles = this._getAreaStyles();
        canvasContent = _globals.ReactBEM.createElement(
          'div',
          { bem: '$b:transformCanvasControls' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:row' },
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:cell m:dark', style: areaStyles.topLeft },
              '\xA0'
            ),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:cell m:dark', style: areaStyles.topCenter },
              '\xA0'
            ),
            _globals.ReactBEM.createElement('div', { bem: 'e:cell m:dark' })
          ),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:row' },
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:cell m:dark', style: areaStyles.centerLeft },
              '\xA0'
            ),
            _globals.ReactBEM.createElement(
              _draggableComponent2.default,
              {
                onStart: this._onCenterDragStart,
                onDrag: this._onCenterDrag },
              _globals.ReactBEM.createElement(
                'div',
                { bem: 'e:cell m:bordered', style: areaStyles.center },
                _globals.ReactBEM.createElement(
                  _draggableComponent2.default,
                  {
                    onStart: this._onKnobDragStart.bind(this, 'start'),
                    onDrag: this._onKnobDrag.bind(this, 'start') },
                  _globals.ReactBEM.createElement(
                    'div',
                    { bem: 'e:knob m:topLeft $b:knob' },
                    _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/knobs/resize-diagonal-down.png', true) })
                  )
                ),
                _globals.ReactBEM.createElement(
                  'div',
                  { bem: 'e:dimensions' },
                  dimensions.x + 'x' + dimensions.y
                ),
                _globals.ReactBEM.createElement(
                  _draggableComponent2.default,
                  {
                    onStart: this._onKnobDragStart.bind(this, 'end'),
                    onDrag: this._onKnobDrag.bind(this, 'end') },
                  _globals.ReactBEM.createElement(
                    'div',
                    { bem: 'e:knob m:bottomRight $b:knob' },
                    _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/knobs/resize-diagonal-down.png', true) })
                  )
                )
              )
            ),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:cell m:dark' },
              '\xA0'
            )
          ),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:row' },
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:cell m:dark' },
              '\xA0'
            ),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:cell m:dark' },
              '\xA0'
            ),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:cell m:dark' },
              '\xA0'
            )
          )
        );
      } else {
        canvasContent = _globals.ReactBEM.createElement(
          'div',
          { bem: '$b:transformCanvasControls' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:dimensions' },
            dimensions.x + 'x' + dimensions.y
          )
        );
      }

      return _globals.ReactBEM.createElement(
        'div',
        { bem: 'b:canvasControls e:container m:full', ref: 'container' },
        canvasContent
      );
    }
  }]);

  return TransformCanvasControlsComponent;
}(_canvasControlsComponent2.default);

exports.default = TransformCanvasControlsComponent;


TransformCanvasControlsComponent.contextTypes = _canvasControlsComponent2.default.contextTypes;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _topBarComponent = __webpack_require__(12);

var _topBarComponent2 = _interopRequireDefault(_topBarComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var TransformTopBarComponent = function (_TopBarComponent) {
  _inherits(TransformTopBarComponent, _TopBarComponent);

  function TransformTopBarComponent() {
    _classCallCheck(this, TransformTopBarComponent);

    return _possibleConstructorReturn(this, (TransformTopBarComponent.__proto__ || Object.getPrototypeOf(TransformTopBarComponent)).apply(this, arguments));
  }

  _createClass(TransformTopBarComponent, [{
    key: '_onRotateClick',

    /**
     * Gets called when the user clicks one of the rotate buttons
     * @param  {String} direction
     * @private
     */
    value: function _onRotateClick(direction) {
      var degrees = void 0;
      if (direction === 'cw') {
        degrees = 90;
      } else if (direction === 'ccw') {
        degrees = -90;
      }

      var editor = this.context.editor;

      var operation = this.getSharedState('orientationOperation');
      var newRotation = (operation.getRotation() + degrees) % 360;

      operation.set({ rotation: newRotation });

      var newState = {
        orientationRotation: newRotation
      };

      var ratio = this.getSharedState('ratio');
      if (ratio && !ratio.dimensions) {
        var start = this.getSharedState('start');
        var end = this.getSharedState('end');
        var tempStart = start.clone();
        if (direction === 'cw') {
          start.set(1.0 - end.y, tempStart.x);
          end.set(1.0 - tempStart.y, end.x);
        } else if (direction === 'ccw') {
          start.set(tempStart.y, 1.0 - end.x);
          end.set(end.y, 1.0 - tempStart.x);
        }
        newState.start = start;
        newState.end = end;
      }

      if (ratio && ratio.dimensions) {
        this._emitEvent(_globals.Constants.EVENTS.TRANSFORM_REAPPLY_RATIO);
      }

      this.setSharedState(newState);

      editor.broadcastRotate(degrees);
      editor.zoom.set('auto');
    }

    /**
     * Gets called when the user clicks one of the flip buttons
     * @private
     */

  }, {
    key: '_onFlipClick',
    value: function _onFlipClick(direction) {
      var _setSharedState;

      var editor = this.context.editor;

      var operation = this.getSharedState('orientationOperation');

      var newFlip = !this.getSharedState('flip' + direction);
      var newRotation = this.getSharedState('rotation') * -1;
      this.setSharedState((_setSharedState = {}, _defineProperty(_setSharedState, 'flip' + direction, newFlip), _defineProperty(_setSharedState, 'rotation', newRotation), _setSharedState));
      editor.setRotation(newRotation);
      operation.flip(direction);

      var start = this.getSharedState('start');
      var end = this.getSharedState('end');
      var tmpStart = start.clone();
      if (direction === 'horizontal') {
        start.set(1.0 - end.x, start.y);
        end.set(1.0 - tmpStart.x, end.y);
      } else if (direction === 'vertical') {
        start.set(start.x, 1.0 - end.y);
        end.set(end.x, 1.0 - tmpStart.y);
      }

      this.setSharedState({ start: start, end: end });

      editor.broadcastFlip(direction);
      editor.render();
    }

    /**
     * Checks if the component should change from the given state
     * @param  {Object} oldState
     * @param  {Object} newState
     * @return {Boolean}
     */

  }, {
    key: 'shouldSharedComponentUpdate',
    value: function shouldSharedComponentUpdate(oldState, newState) {
      return false;
    }

    /**
     * Renders the content of this OverviewTopBarComponent
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderContent',
    value: function renderContent() {
      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:topBar' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$e:iconButton', onClick: this._onFlipClick.bind(this, 'vertical') },
          _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/transform/flip-v.png', true) })
        ),
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$e:iconButton', onClick: this._onFlipClick.bind(this, 'horizontal') },
          _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/transform/flip-h.png', true) })
        ),
        _globals.ReactBEM.createElement('div', { bem: 'e:space' }),
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$e:iconButton', onClick: this._onRotateClick.bind(this, 'ccw') },
          _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/transform/rotate-ccw.png', true) })
        ),
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$e:iconButton', onClick: this._onRotateClick.bind(this, 'cw') },
          _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/transform/rotate-cw.png', true) })
        )
      );
    }
  }]);

  return TransformTopBarComponent;
}(_topBarComponent2.default);

exports.default = TransformTopBarComponent;


TransformTopBarComponent.contextTypes = _topBarComponent2.default.contextTypes;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _controls = __webpack_require__(4);

var _controls2 = _interopRequireDefault(_controls);

var _filterControlsComponent = __webpack_require__(134);

var _filterControlsComponent2 = _interopRequireDefault(_filterControlsComponent);

var _filterManager = __webpack_require__(27);

var _filterManager2 = _interopRequireDefault(_filterManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

/**
 * The filters controls
 * @class
 * @extends PhotoEditorSDK.UI.ReactUI.Control
 * @memberof PhotoEditorSDK.UI.ReactUI.Controls
 */
var FiltersControls = function (_Controls) {
  _inherits(FiltersControls, _Controls);

  function FiltersControls() {
    _classCallCheck(this, FiltersControls);

    return _possibleConstructorReturn(this, (FiltersControls.__proto__ || Object.getPrototypeOf(FiltersControls)).apply(this, arguments));
  }

  _createClass(FiltersControls, null, [{
    key: 'onEnter',

    /**
     * Gets called when the user enters these controls
     * @this {FiltersControlsComponent}
     * @param {SharedState} sharedState
     * @override
     * @ignore
     */
    value: function onEnter(sharedState) {
      var editor = this.context.editor;

      var operationExistedBefore = editor.operations.exists('filter');
      var operation = editor.operations.getOrCreate('filter');
      var initialOptions = operation.serializeOptions(['identifier', 'filter', 'intensity']);

      this.setSharedState({ operation: operation, operationExistedBefore: operationExistedBefore, initialOptions: initialOptions });
    }

    /**
     * Gets called when the user leaves these controls
     * @this {StickersControlsComponent}
     * @override
     * @ignore
     */

  }, {
    key: 'onExit',
    value: function onExit() {
      var initialOptions = this.getSharedState('initialOptions');
      var FilterConstructor = this._operation.getFilter().constructor;
      var InitialFilterConstructor = initialOptions.filter.constructor;

      var lutImage = void 0;
      if (InitialFilterConstructor.identifier === '3d-lut') {
        lutImage = initialOptions.filter.getImage();
      }
      var intensity = this._operation.getIntensity();
      if (this._operation.getIdentifier() !== initialOptions.identifier || intensity !== initialOptions.intensity) {
        var editor = this.context.editor;

        editor.history.add(this._operation, {
          identifier: initialOptions.identifier,
          intensity: intensity
        }, this.getSharedState('operationExistedBefore'), function () {
          var operation = editor.operations.getOrCreate('filter');
          if (InitialFilterConstructor.identifier === '3d-lut') {
            operation.setFilter(new InitialFilterConstructor({ image: lutImage }));
          } else {
            operation.setFilter(new InitialFilterConstructor());
          }
        });
      }

      if (FilterConstructor.isIdentity) {
        var _editor = this.context.editor;

        _editor.operations.remove(this._operation);
      }
    }

    /**
     * Checks if this control is available to the user
     * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
     * @return {Boolean}
     * @override
     */

  }, {
    key: 'isAvailable',
    value: function isAvailable(editor) {
      return editor.isToolAllowed('filter') && editor.isToolEnabled(this.identifier);
    }

    /**
     * Returns the assets that should be preloaded for this control
     * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
     * @return {String[]}
     */

  }, {
    key: 'getPreloadAssets',
    value: function getPreloadAssets(editor) {
      var options = editor.getOptions();
      var filterOptions = _globals.SDKUtils.defaults(options.editor.controlsOptions.filter, this.defaultOptions);
      var filterManager = new _filterManager2.default(editor.getUI(), filterOptions);

      var assets = [];
      var categories = filterManager.getCategories();
      categories.forEach(function (category) {
        assets.push('controls/filters/categories/' + category.identifier + '.png');
        var filters = filterManager.getFiltersForCategory(category.identifier);
        filters.forEach(function (filter) {
          assets.push('controls/filters/' + filter.identifier + '.png');
          if (filter.lutImage) {
            assets.push([filter.lutImage, false, false]);
          }
        });
      });

      return assets;
    }
  }]);

  return FiltersControls;
}(_controls2.default);

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */


FiltersControls.controlsComponent = _filterControlsComponent2.default;

/**
 * This control's identifier
 * @type {String}
 * @default
 */
FiltersControls.identifier = 'filter';

/**
 * This control's icon path
 * @type {String}
 * @ignore
 */
FiltersControls.iconPath = 'controls/overview/filters.png';

/**
 * The language key that should be used when displaying this filter
 * @type {String}
 * @ignore
 */
FiltersControls.languageKey = 'pesdk.filter.title.name';

/**
 * The default options for this control
 * @type {Object}
 * @property {PhotoEditorSDK.Filter[]} [categories = []]
 * @property {Boolean} [replaceCategories = false]
 * @property {String[]} [availableFilters = null]
 */
FiltersControls.defaultOptions = {
  categories: [],
  replaceCategories: false,
  availableFilters: null,
  hideCategories: false

  /**
   * The operations required for this control to work properly
   * @type {Array}
   */
};FiltersControls.requiredOperations = ['filter'];

exports.default = FiltersControls;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _controlsComponent = __webpack_require__(3);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _scrollbarComponent = __webpack_require__(2);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

var _categoryDropdownComponent = __webpack_require__(45);

var _categoryDropdownComponent2 = _interopRequireDefault(_categoryDropdownComponent);

var _sliderOverlayComponent = __webpack_require__(6);

var _sliderOverlayComponent2 = _interopRequireDefault(_sliderOverlayComponent);

var _filterManager = __webpack_require__(27);

var _filterManager2 = _interopRequireDefault(_filterManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var Filters = _globals.SDK.Operations.FilterOperation.Filters;

var FilterControlsComponent = function (_ControlsComponent) {
  _inherits(FilterControlsComponent, _ControlsComponent);

  function FilterControlsComponent() {
    var _ref;

    _classCallCheck(this, FilterControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = FilterControlsComponent.__proto__ || Object.getPrototypeOf(FilterControlsComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onItemClick', '_onOperationUpdated', '_onSliderValueChange', '_onCategoryChange');
    _this._operation = _this.getSharedState('operation');

    _this._events = _defineProperty({}, _globals.Constants.EVENTS.OPERATION_UPDATED, _this._onOperationUpdated);

    _this._initFilterManager();

    _this.state = {
      category: _this._filterManager.getCategoryByIdentifier('all')
    };
    return _this;
  }

  // -------------------------------------------------------------------------- INITIALIZATION

  /**
   * Initializes the filter manager
   * @private
   */


  _createClass(FilterControlsComponent, [{
    key: '_initFilterManager',
    value: function _initFilterManager() {
      this._filterManager = new _filterManager2.default(this.context.ui, this.props.options);
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the slider value has been changed
     * @param {Number} value
     * @private
     */

  }, {
    key: '_onSliderValueChange',
    value: function _onSliderValueChange(value) {
      this._operation.setIntensity(value / 100);

      var editor = this.context.editor;

      editor.render();
    }

    /**
     * Gets called when the user switches the category
     * @param  {Object} category
     * @private
     */

  }, {
    key: '_onCategoryChange',
    value: function _onCategoryChange(category) {
      var _this2 = this;

      this.setState({ category: category }, function () {
        _this2.refs.scrollbar.update();
      });
    }

    /**
     * Gets called when an operation has been updated
     * @param  {Operation} operation
     * @private
     */

  }, {
    key: '_onOperationUpdated',
    value: function _onOperationUpdated(operation) {
      // The undo button might change this operation's selected filter or intensity.
      // Update the component to reflect the change
      if (operation === this._operation) {
        this.forceUpdate();
      }
    }

    /**
     * Gets called when the user clicks an item
     * @param {String} identifier
     * @param {Event} e
     * @private
     */

  }, {
    key: '_onItemClick',
    value: function _onItemClick(identifier, e) {
      var _this3 = this;

      this._filterManager.instantiateFilterWithIdentifier(identifier).then(function (filter) {
        _this3._operation.set({
          filter: filter,
          identifier: identifier,
          intensity: 1
        });

        var editor = _this3.context.editor;

        editor.render();
        _this3.forceUpdate();
      });
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the overlay controls of this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderOverlayControls',
    value: function renderOverlayControls() {
      var currentFilter = this._operation.getFilter();
      if (currentFilter.isIdentity) return null;

      var intensity = this._operation.getIntensity();
      return _globals.ReactBEM.createElement(_sliderOverlayComponent2.default, {
        minValue: 0,
        maxValue: 100,
        value: intensity * 100,
        valueUnit: '%',
        positiveValuePrefix: '+',
        label: this._t('pesdk.filter.text.intensity'),
        onChange: this._onSliderValueChange });
    }

    /**
     * Renders the list items for this control
     * @return {Array.<ReactBEM.Element>}
     * @private
     */

  }, {
    key: '_renderListItems',
    value: function _renderListItems() {
      var _this4 = this;

      var currentFilterIdentifier = this._operation.getIdentifier();
      var filters = this._filterManager.getFiltersForCategory(this.state.category.identifier);

      return [Filters.IdentityFilter].concat(filters).map(function (filter) {
        var identifier = filter.identifier;

        return _globals.ReactBEM.createElement(
          'li',
          {
            bem: 'e:item',
            key: identifier,
            onClick: _this4._onItemClick.bind(_this4, identifier) },
          _globals.ReactBEM.createElement(
            'bem',
            { specifier: '$b:controls' },
            _globals.ReactBEM.createElement(
              'div',
              {
                bem: '$e:button m:withInlineLabel' },
              _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: _this4._getAssetPath('controls/filters/' + identifier + '.png', true) }),
              _globals.ReactBEM.createElement(
                'div',
                { bem: '$e:inlineLabel', className: identifier === currentFilterIdentifier ? 'is-active' : null },
                _globals.ReactBEM.createElement(
                  'div',
                  { bem: 'e:label' },
                  _this4._t('pesdk.filter.asset.' + filter.identifier) || filter.defaultName
                )
              )
            )
          )
        );
      });
    }

    /**
     * Renders the category dropdown (if present)
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderCategoryDropdown',
    value: function _renderCategoryDropdown() {
      var _this5 = this;

      var categories = this._filterManager.getCategories();
      var categoryDropdownVisible = !this.props.options.hideCategories && categories.length > 1;
      if (!categoryDropdownVisible) {
        return null;
      }

      var categoryItems = categories.map(function (c) {
        return {
          identifier: c.identifier,
          item: c,
          label: _this5._t('pesdk.filter.asset.' + c.identifier) || c.defaultName,
          icon: _this5._getAssetPath('controls/filters/categories/' + c.identifier + '.png', true)
        };
      });

      var selectedCategory = {
        identifier: this.state.category.identifier,
        item: this.state.category,
        label: this._t('pesdk.filter.asset.' + this.state.category.identifier) || this.state.category.defaultName,
        icon: this._getAssetPath('controls/filters/categories/' + this.state.category.identifier + '.png', true)
      };

      return _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell m:categoryDropdown' },
        _globals.ReactBEM.createElement(_categoryDropdownComponent2.default, {
          items: categoryItems,
          selectedItem: selectedCategory,
          onChange: this._onCategoryChange })
      );
    }

    /**
     * Renders the controls of this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderControls',
    value: function renderControls() {
      var listItems = this._renderListItems();
      var categoryDropdown = this._renderCategoryDropdown();

      return [categoryDropdown, _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell m:list' },
        _globals.ReactBEM.createElement(
          _scrollbarComponent2.default,
          { ref: 'scrollbar' },
          _globals.ReactBEM.createElement(
            'ul',
            { bem: '$e:list' },
            listItems
          )
        )
      )];
    }
  }]);

  return FilterControlsComponent;
}(_controlsComponent2.default);

exports.default = FilterControlsComponent;


FilterControlsComponent.contextTypes = _controlsComponent2.default.contextTypes;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var CategoryDropdownOverlayComponent = function (_BaseComponent) {
  _inherits(CategoryDropdownOverlayComponent, _BaseComponent);

  function CategoryDropdownOverlayComponent() {
    _classCallCheck(this, CategoryDropdownOverlayComponent);

    return _possibleConstructorReturn(this, (CategoryDropdownOverlayComponent.__proto__ || Object.getPrototypeOf(CategoryDropdownOverlayComponent)).apply(this, arguments));
  }

  _createClass(CategoryDropdownOverlayComponent, [{
    key: '_onItemClick',

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the user clicks on an item
     * @param  {Object} item
     * @private
     */
    value: function _onItemClick(item) {
      this.props.onChange && this.props.onChange(item.item);
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the list items
     * @return {Array.<React.Element>}
     * @private
     */

  }, {
    key: '_renderListItems',
    value: function _renderListItems() {
      var _this2 = this;

      return this.props.items.map(function (item) {
        var active = item.identifier === _this2.props.selectedItem.identifier;
        return _globals.ReactBEM.createElement(
          'li',
          {
            bem: '$e:item',
            className: active ? ' is-active' : '',
            onClick: _this2._onItemClick.bind(_this2, item) },
          _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: item.icon }),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:label' },
            item.label
          )
        );
      });
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:categoryDropdown $e:overlay' },
        _globals.ReactBEM.createElement(
          'ul',
          { bem: '$e:list' },
          this._renderListItems()
        )
      );
    }
  }]);

  return CategoryDropdownOverlayComponent;
}(_globals.BaseComponent);

exports.default = CategoryDropdownOverlayComponent;


CategoryDropdownOverlayComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _controls = __webpack_require__(4);

var _controls2 = _interopRequireDefault(_controls);

var _focusControlsComponent = __webpack_require__(137);

var _focusControlsComponent2 = _interopRequireDefault(_focusControlsComponent);

var _focusCanvasControlsComponent = __webpack_require__(138);

var _focusCanvasControlsComponent2 = _interopRequireDefault(_focusCanvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

/**
 * The focus controls
 * @class
 * @extends PhotoEditorSDK.UI.ReactUI.Control
 * @memberof PhotoEditorSDK.UI.ReactUI.Controls
 */
var FocusControls = function (_Controls) {
  _inherits(FocusControls, _Controls);

  function FocusControls() {
    _classCallCheck(this, FocusControls);

    return _possibleConstructorReturn(this, (FocusControls.__proto__ || Object.getPrototypeOf(FocusControls)).apply(this, arguments));
  }

  _createClass(FocusControls, null, [{
    key: 'isAvailable',

    /**
     * Checks if this control is available to the user
     * @param  {Editor} editor
     * @return {Boolean}
     * @ignore
     */
    value: function isAvailable(editor) {
      return editor.isToolAllowed('focus') && (editor.isToolEnabled('radial-focus') || editor.isToolEnabled('mirrored-focus'));
    }

    /**
     * Gets called when the user leaves these controls
     * @this {FocusControlsComponent}
     * @override
     * @ignore
     */

  }, {
    key: 'onExit',
    value: function onExit() {
      var editor = this.context.editor;

      editor.features.enable('zoom', 'drag');

      var initialOptions = this.getSharedState('initialOptions');
      var initialOperation = this.getSharedState('initialOperation');
      var operation = this.getSharedState('operation');

      if (!operation && initialOperation || operation && initialOperation && operation.constructor === initialOperation.constructor) {
        editor.history.add(initialOperation, initialOptions, true);
      }

      if (operation && !initialOperation) {
        editor.history.add(operation, {}, false);
      }

      if (operation && initialOperation && operation.constructor !== initialOperation.constructor) {
        editor.history.add([{
          operation: initialOperation,
          options: initialOptions,
          existent: true
        }, {
          operation: operation,
          options: {},
          existent: false
        }]);
      }
    }

    /**
     * Gets called when the user enters these controls
     * @this {FocusControlsComponent}
     * @param {SharedState} sharedState
     * @override
     * @ignore
     */

  }, {
    key: 'onEnter',
    value: function onEnter(sharedState) {
      var editor = this.context.editor;

      var operation = editor.operations.get('mirrored-focus') || editor.operations.get('radial-focus');

      var initialOptions = {};
      if (operation) {
        initialOptions = operation.serializeOptions();
        delete initialOptions.enabled;
      }

      this.setSharedState({
        operation: operation,
        initialOperation: operation,
        operationExistedBefore: !!operation,
        initialOptions: initialOptions,
        inputDimensions: editor.getOutputDimensions()
      });
    }

    /**
     * Returns the assets that should be preloaded for this control
     * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
     * @return {String[]}
     */

  }, {
    key: 'getPreloadAssets',
    value: function getPreloadAssets(editor) {
      var assets = [];
      if (editor.isToolEnabled('radial-focus')) {
        assets.push('controls/focus/radial.png');
      }
      if (editor.isToolEnabled('mirrored-focus')) {
        assets.push('controls/focus/mirrored.png');
      }

      return assets;
    }
  }]);

  return FocusControls;
}(_controls2.default);

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */


FocusControls.controlsComponent = _focusControlsComponent2.default;

/**
 * This control's canvas component. Used for the upper controls part of the editor (on
 * top of the canvas)
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */
FocusControls.canvasControlsComponent = _focusCanvasControlsComponent2.default;

/**
 * This control's identifier
 * @type {String}
 * @default
 */
FocusControls.identifier = 'focus';

/**
 * This control's icon path
 * @type {String}
 * @ignore
 */
FocusControls.iconPath = 'controls/overview/focus.png';

/**
 * The language key that should be used when displaying this filter
 * @type {String}
 * @ignore
 */
FocusControls.languageKey = 'pesdk.focus.title.name';

/**
 * The default options for this control
 * @type {Object}
 */
FocusControls.defaultOptions = {};

/**
 * The operations required for this control to work properly
 * @type {Array}
 */
FocusControls.requiredOperations = ['radial-focus', 'mirrored-focus', 'linear-focus', 'blur'];

exports.default = FocusControls;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _controlsComponent = __webpack_require__(3);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _scrollbarComponent = __webpack_require__(2);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

var _sliderOverlayComponent = __webpack_require__(6);

var _sliderOverlayComponent2 = _interopRequireDefault(_sliderOverlayComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ITEMS = [{ toolName: 'radial-focus', iconName: 'radial', languageKey: 'pesdk.focus.button.radial' }, { toolName: 'mirrored-focus', iconName: 'mirrored', languageKey: 'pesdk.focus.button.mirrored' }];

var FocusControlsComponent = function (_ControlsComponent) {
  _inherits(FocusControlsComponent, _ControlsComponent);

  function FocusControlsComponent() {
    var _ref;

    _classCallCheck(this, FocusControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = FocusControlsComponent.__proto__ || Object.getPrototypeOf(FocusControlsComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onBlurRadiusChange', '_onOperationRemoved');
    _this._removedOperation = null;

    _this._events = _defineProperty({}, _globals.Constants.EVENTS.OPERATION_REMOVED, _this._onOperationRemoved);
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the slider value has changed
   * @param {Number} value
   * @private
   */


  _createClass(FocusControlsComponent, [{
    key: '_onBlurRadiusChange',
    value: function _onBlurRadiusChange(value) {
      var operation = this.getSharedState('operation');
      var inputDimensions = this.getSharedState('inputDimensions');
      operation.setBlurRadius(value / inputDimensions.min());

      var editor = this.context.editor;

      editor.render();
    }

    /**
     * Gets called when the user clicks one of the buttons
     * @param {Object} toolName
     * @param {Event} e
     * @private
     */

  }, {
    key: '_onButtonClick',
    value: function _onButtonClick(toolName, e) {
      var editor = this.context.editor;

      var previousOperation = this.getSharedState('operation');
      if (previousOperation) {
        this._removedOperation = previousOperation;
        editor.operations.remove(previousOperation);
      }

      var newOperation = null;
      if (toolName) {
        newOperation = editor.operations.getOrCreate(toolName);
      }

      this.setSharedState({ operation: newOperation });
      editor.render();
    }

    /**
     * Gets called when an operation has been removed
     * @param  {Operation} operation
     * @private
     */

  }, {
    key: '_onOperationRemoved',
    value: function _onOperationRemoved(operation) {
      var currentOperation = this.getSharedState('operation');
      if (!currentOperation || operation !== currentOperation || operation === this._removedOperation) return;
      if (this._backButtonClicked) return;

      var editor = this.context.editor;

      var identifier = currentOperation.constructor.identifier;
      var newOperation = editor.operations.getOrCreate(identifier);

      this.setSharedState({
        operation: newOperation,
        operationExistedBefore: false,
        initialOptions: {}
      });
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the overlay controls of this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderOverlayControls',
    value: function renderOverlayControls() {
      var focusOperation = this.getSharedState('operation');
      if (!focusOperation) return null;

      var inputDimensions = this.getSharedState('inputDimensions');
      var shortestSide = inputDimensions.min();
      var value = focusOperation.getBlurRadius() * shortestSide;
      return _globals.ReactBEM.createElement(_sliderOverlayComponent2.default, {
        minValue: 0,
        maxValue: Math.min(180, Math.round(shortestSide * 0.1)),
        valueUnit: 'px',
        middleDot: false,
        label: this._t('pesdk.focus.text.blurRadius'),
        onChange: this._onBlurRadiusChange,
        value: value });
    }

    /**
     * Renders the list items for this control
     * @return {Array.<ReactBEM.Element>}
     * @private
     */

  }, {
    key: '_renderListItems',
    value: function _renderListItems() {
      var _this2 = this;

      var focusOperation = this.getSharedState('operation');

      var editor = this.context.editor;

      var noFocusItem = _globals.ReactBEM.createElement(
        'li',
        {
          bem: 'e:item',
          key: 'none' },
        _globals.ReactBEM.createElement(
          'bem',
          { specifier: '$b:controls' },
          _globals.ReactBEM.createElement(
            'div',
            {
              bem: '$e:button m:withLabel',
              className: !focusOperation ? 'is-active' : null,
              onClick: this._onButtonClick.bind(this, null) },
            _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/focus/none.png', true) }),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:label' },
              this._t('pesdk.focus.button.none')
            )
          )
        )
      );

      return [noFocusItem].concat(ITEMS.filter(function (_ref2) {
        var toolName = _ref2.toolName;
        return editor.isToolEnabled(toolName);
      }).map(function (_ref3) {
        var toolName = _ref3.toolName,
            iconName = _ref3.iconName,
            languageKey = _ref3.languageKey;

        var isActive = focusOperation && focusOperation.constructor.identifier === toolName;
        return _globals.ReactBEM.createElement(
          'li',
          {
            bem: 'e:item',
            'data-identifier': toolName,
            key: toolName },
          _globals.ReactBEM.createElement(
            'bem',
            { specifier: '$b:controls' },
            _globals.ReactBEM.createElement(
              'div',
              {
                bem: '$e:button m:withLabel',
                className: isActive ? 'is-active' : null,
                onClick: _this2._onButtonClick.bind(_this2, toolName) },
              _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: _this2._getAssetPath('controls/focus/' + iconName + '.png', true) }),
              _globals.ReactBEM.createElement(
                'div',
                { bem: 'e:label' },
                _this2._t(languageKey)
              )
            )
          )
        );
      }));
    }

    /**
     * Renders the controls of this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderControls',
    value: function renderControls() {
      var listItems = this._renderListItems();

      return _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell m:list' },
        _globals.ReactBEM.createElement(
          _scrollbarComponent2.default,
          null,
          _globals.ReactBEM.createElement(
            'ul',
            { bem: '$e:list' },
            listItems
          )
        )
      );
    }
  }]);

  return FocusControlsComponent;
}(_controlsComponent2.default);

exports.default = FocusControlsComponent;


FocusControlsComponent.contextTypes = _controlsComponent2.default.contextTypes;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _canvasControlsComponent = __webpack_require__(10);

var _canvasControlsComponent2 = _interopRequireDefault(_canvasControlsComponent);

var _linearFocusCanvasControlsComponent = __webpack_require__(139);

var _linearFocusCanvasControlsComponent2 = _interopRequireDefault(_linearFocusCanvasControlsComponent);

var _radialFocusCanvasControlsComponent = __webpack_require__(140);

var _radialFocusCanvasControlsComponent2 = _interopRequireDefault(_radialFocusCanvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FocusCanvasControlsComponent = function (_CanvasControlsCompon) {
  _inherits(FocusCanvasControlsComponent, _CanvasControlsCompon);

  function FocusCanvasControlsComponent() {
    _classCallCheck(this, FocusCanvasControlsComponent);

    return _possibleConstructorReturn(this, (FocusCanvasControlsComponent.__proto__ || Object.getPrototypeOf(FocusCanvasControlsComponent)).apply(this, arguments));
  }

  _createClass(FocusCanvasControlsComponent, [{
    key: '_getControlsForOperation',

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Returns the appropriate canvas controls for the given operation
     * @param  {PhotoEditorSDK.Operation} operation
     * @return {ReactBEM.Element}
     * @private
     */
    value: function _getControlsForOperation(operation) {
      if (!operation) return null;

      switch (operation.constructor.identifier) {
        case 'mirrored-focus':
          return _linearFocusCanvasControlsComponent2.default;
        case 'radial-focus':
          return _radialFocusCanvasControlsComponent2.default;
      }
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var operation = this.getSharedState('operation');
      var Controls = this._getControlsForOperation(operation);
      if (!Controls) return _globals.ReactBEM.createElement('div', null);
      return _globals.ReactBEM.createElement(Controls, this.props);
    }
  }]);

  return FocusCanvasControlsComponent;
}(_canvasControlsComponent2.default);

exports.default = FocusCanvasControlsComponent;


FocusCanvasControlsComponent.contextTypes = _canvasControlsComponent2.default.contextTypes;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _draggableComponent = __webpack_require__(5);

var _draggableComponent2 = _interopRequireDefault(_draggableComponent);

var _canvasControlsComponent = __webpack_require__(10);

var _canvasControlsComponent2 = _interopRequireDefault(_canvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var LinearFocusCanvasControlsComponent = function (_CanvasControlsCompon) {
  _inherits(LinearFocusCanvasControlsComponent, _CanvasControlsCompon);

  function LinearFocusCanvasControlsComponent() {
    var _ref;

    _classCallCheck(this, LinearFocusCanvasControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = LinearFocusCanvasControlsComponent.__proto__ || Object.getPrototypeOf(LinearFocusCanvasControlsComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onCenterDragStart', '_onCenterDrag', '_onKnobDragStart', '_onKnobDrag', '_onOperationUpdated');

    _this.state = {
      areaPosition: new _globals.Vector2(),
      areaDimensions: new _globals.Vector2(),
      knobPosition: new _globals.Vector2()
    };
    _this._operation = _this.getSharedState('operation');

    _this._events = _defineProperty({}, _globals.Constants.EVENTS.OPERATION_UPDATED, _this._onOperationUpdated);
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called after the canvas has been zoomed in or out
   * @private
   */


  _createClass(LinearFocusCanvasControlsComponent, [{
    key: '_onCanvasZoomDone',
    value: function _onCanvasZoomDone() {
      this._setStylesFromOptions();
    }

    /**
     * Gets called when an operation has been updated
     * @param  {Operation} operation
     * @private
     */

  }, {
    key: '_onOperationUpdated',
    value: function _onOperationUpdated(operation) {
      if (operation !== this.getSharedState('operation')) return;
      this._setStylesFromOptions();
    }

    // -------------------------------------------------------------------------- LIFECYCLE

    /**
     * Gets called when the shared state did change
     * @param {Object} newState
     */

  }, {
    key: 'sharedStateDidChange',
    value: function sharedStateDidChange(newState) {
      if (newState.operation) {
        this._operation = newState.operation;
        if (this._operation.constructor.identifier === 'mirrored-focus') this._setStylesFromOptions();
      }
    }

    /**
     * Gets called when this component has been mounted
     */

  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      _get(LinearFocusCanvasControlsComponent.prototype.__proto__ || Object.getPrototypeOf(LinearFocusCanvasControlsComponent.prototype), 'componentDidMount', this).call(this);

      var editor = this.context.editor;

      editor.zoom.set('auto', function () {
        editor.features.disable('zoom', 'drag');
        _this2._setStylesFromOptions();
      });
    }

    // -------------------------------------------------------------------------- CENTER DRAGGING

    /**
     * Gets called when the user stars dragging the center
     * @private
     */

  }, {
    key: '_onCenterDragStart',
    value: function _onCenterDragStart() {
      this._initialStart = this._operation.getStart();
      this._initialEnd = this._operation.getEnd();
      this._initialDist = this._initialEnd.clone().subtract(this._initialStart);
    }

    /**
     * Gets called while the user drags the center
     * @param {Vector2} offset
     * @private
     */

  }, {
    key: '_onCenterDrag',
    value: function _onCenterDrag(offset) {
      var editor = this.context.editor;


      var outputDimensions = editor.getOutputDimensions();
      var relativeOffset = offset.clone().divide(outputDimensions);

      var newStart = this._initialStart.clone().add(relativeOffset).clamp(new _globals.Vector2(0, 0), new _globals.Vector2(1, 1).subtract(this._initialDist));
      var newEnd = newStart.clone().add(this._initialDist);

      this._operation.set({
        start: newStart,
        end: newEnd
      });

      editor.render();
      this._setStylesFromOptions();
      this.forceUpdate();
    }

    // -------------------------------------------------------------------------- GRADIENT KNOB DRAG

    /**
     * Gets called when the user stars dragging the gradient knob
     * @private
     */

  }, {
    key: '_onKnobDragStart',
    value: function _onKnobDragStart(e) {
      this._initialKnobPosition = this.state.knobPosition.clone();
    }

    /**
     * Gets called while the user drags the gradient knob
     * @param {Vector2} offset
     * @private
     */

  }, {
    key: '_onKnobDrag',
    value: function _onKnobDrag(offset) {
      var editor = this.context.editor;

      var outputDimensions = editor.getOutputDimensions();

      var newKnobPosition = this._initialKnobPosition.clone().add(offset).clamp(new _globals.Vector2(0, 0), outputDimensions);

      var distanceFromCenter = newKnobPosition.clone().subtract(this.state.areaPosition);

      var start = this.state.areaPosition.clone().add(-distanceFromCenter.y, distanceFromCenter.x).divide(outputDimensions);
      var end = this.state.areaPosition.clone().add(distanceFromCenter.y, -distanceFromCenter.x).divide(outputDimensions);
      var size = distanceFromCenter.len() * 2;

      this._operation.set({
        start: start,
        end: end,
        size: size / outputDimensions.min(),
        gradientSize: size / outputDimensions.min()
      });
      this.setState({
        knobPosition: newKnobPosition,
        areaDimensions: new _globals.Vector2(this.state.areaDimensions.x, size)
      });
      editor.render();
    }

    // -------------------------------------------------------------------------- STYLING

    /**
     * Returns the CSS styles for the area div
     * @return {Object}
     * @private
     */

  }, {
    key: '_getAreaStyle',
    value: function _getAreaStyle() {
      var dist = this.state.knobPosition.clone().subtract(this.state.areaPosition);
      var degrees = Math.atan2(dist.x, dist.y) * (180 / Math.PI);
      var transform = 'rotate(' + (-degrees).toFixed(2) + 'deg)';

      return {
        width: this.state.areaDimensions.x,
        height: this.state.areaDimensions.y,
        left: this.state.areaPosition.x,
        top: this.state.areaPosition.y,
        marginLeft: this.state.areaDimensions.x * -0.5,
        marginTop: this.state.areaDimensions.y * -0.5,
        transform: transform,
        MozTransform: transform,
        msTransform: transform,
        WebkitTransform: transform
      };
    }

    /**
     * Returns the CSS styles for the knob
     * @return {Object}
     * @private
     */

  }, {
    key: '_getKnobStyle',
    value: function _getKnobStyle() {
      return {
        left: this.state.knobPosition.x,
        top: this.state.knobPosition.y
      };
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Sets the dimensions and position values from the current operation options
     * @private
     */

  }, {
    key: '_setStylesFromOptions',
    value: function _setStylesFromOptions() {
      var editor = this.context.editor;

      var outputDimensions = editor.getOutputDimensions();

      var start = this._operation.getStart().clone().multiply(outputDimensions);
      var end = this._operation.getEnd().clone().multiply(outputDimensions);
      var size = this._operation.getSize() * outputDimensions.min();

      var dist = end.clone().subtract(start);
      var middle = start.clone().add(dist.clone().divide(2));

      var areaSize = new _globals.Vector2(outputDimensions.len() * 2, size);

      var totalDist = dist.len();
      var factor = dist.clone().divide(totalDist).divide(2);

      this.setState({
        areaDimensions: areaSize,
        areaPosition: middle.clone(),
        knobPosition: middle.clone().add(-size * factor.y, size * factor.x)
      });
    }

    /**
     * Returns the container style
     * @return {Object}
     * @private
     */

  }, {
    key: '_getContainerStyle',
    value: function _getContainerStyle() {
      var _context$editor$getSD = this.context.editor.getSDK().getSprite().getBounds(),
          x = _context$editor$getSD.x,
          y = _context$editor$getSD.y,
          width = _context$editor$getSD.width,
          height = _context$editor$getSD.height;

      return {
        left: x,
        top: y,
        width: width,
        height: height
      };
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'div',
        { bem: 'b:canvasControls e:container m:full', ref: 'container', style: this._getContainerStyle() },
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$b:linearFocusCanvasControls' },
          _globals.ReactBEM.createElement(
            _draggableComponent2.default,
            {
              onStart: this._onCenterDragStart,
              onDrag: this._onCenterDrag },
            _globals.ReactBEM.createElement('div', { bem: 'e:area', style: this._getAreaStyle() })
          ),
          _globals.ReactBEM.createElement(
            _draggableComponent2.default,
            {
              onStart: this._onKnobDragStart,
              onDrag: this._onKnobDrag },
            _globals.ReactBEM.createElement('div', { bem: 'e:knob $b:knob', style: this._getKnobStyle() })
          )
        )
      );
    }
  }]);

  return LinearFocusCanvasControlsComponent;
}(_canvasControlsComponent2.default);

exports.default = LinearFocusCanvasControlsComponent;


LinearFocusCanvasControlsComponent.contextTypes = _canvasControlsComponent2.default.contextTypes;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _draggableComponent = __webpack_require__(5);

var _draggableComponent2 = _interopRequireDefault(_draggableComponent);

var _canvasControlsComponent = __webpack_require__(10);

var _canvasControlsComponent2 = _interopRequireDefault(_canvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var RadialFocusCanvasControlsComponent = function (_CanvasControlsCompon) {
  _inherits(RadialFocusCanvasControlsComponent, _CanvasControlsCompon);

  function RadialFocusCanvasControlsComponent() {
    var _ref;

    _classCallCheck(this, RadialFocusCanvasControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = RadialFocusCanvasControlsComponent.__proto__ || Object.getPrototypeOf(RadialFocusCanvasControlsComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onCenterDragStart', '_onCenterDrag', '_onKnobDragStart', '_onKnobDrag', '_onOperationUpdated');

    _this.state = {
      areaPosition: new _globals.Vector2(),
      areaDimensions: new _globals.Vector2(),
      knobPosition: new _globals.Vector2()
    };
    _this._knobChangedManually = false;
    _this._operation = _this.getSharedState('operation');

    _this._events = _defineProperty({}, _globals.Constants.EVENTS.OPERATION_UPDATED, _this._onOperationUpdated);
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called after the canvas has been zoomed in or out
   * @private
   */


  _createClass(RadialFocusCanvasControlsComponent, [{
    key: '_onCanvasZoomDone',
    value: function _onCanvasZoomDone() {
      this._setStylesFromOptions();
    }

    /**
     * Gets called when an operation has been updated
     * @param  {Operation} operation
     * @private
     */

  }, {
    key: '_onOperationUpdated',
    value: function _onOperationUpdated(operation) {
      if (operation !== this.getSharedState('operation')) return;
      this._knobChangedManually = false;
      this._setStylesFromOptions();
    }

    // -------------------------------------------------------------------------- LIFECYCLE

    /**
     * Gets called when the shared state did change
     * @param {Object} newState
     */

  }, {
    key: 'sharedStateDidChange',
    value: function sharedStateDidChange(newState) {
      if (newState.operation) {
        this._operation = newState.operation;
        if (this._operation.constructor.identifier === 'radial-focus') this._setStylesFromOptions();
      }
    }

    /**
     * Gets called when this component has been mounted
     */

  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      _get(RadialFocusCanvasControlsComponent.prototype.__proto__ || Object.getPrototypeOf(RadialFocusCanvasControlsComponent.prototype), 'componentDidMount', this).call(this);
      var editor = this.context.editor;

      editor.zoom.set('auto', function () {
        editor.features.disable('zoom', 'drag');
        _this2._setStylesFromOptions();
      });
    }

    // -------------------------------------------------------------------------- CENTER DRAGGING

    /**
     * Gets called when the user stars dragging the center
     * @private
     */

  }, {
    key: '_onCenterDragStart',
    value: function _onCenterDragStart() {
      this._initialPosition = this._operation.getPosition();
      this._initialKnobPosition = this.state.knobPosition.clone();
    }

    /**
     * Gets called while the user drags the center
     * @param {Vector2} offset
     * @private
     */

  }, {
    key: '_onCenterDrag',
    value: function _onCenterDrag(offset) {
      var editor = this.context.editor;


      var outputDimensions = editor.getOutputDimensions();
      var relativeOffset = offset.clone().divide(outputDimensions);
      var newPosition = this._initialPosition.clone().add(relativeOffset);

      var newKnobPosition = this._initialKnobPosition.clone().add(offset);

      this._operation.set({
        position: newPosition
      });

      this.state.knobPosition = newKnobPosition;

      editor.render();
      this._setStylesFromOptions();
    }

    // -------------------------------------------------------------------------- GRADIENT KNOB DRAG

    /**
     * Gets called when the user stars dragging the gradient knob
     * @private
     */

  }, {
    key: '_onKnobDragStart',
    value: function _onKnobDragStart(e) {
      this._knobChangedManually = true;
      this._initialKnobPosition = this.state.knobPosition.clone();
    }

    /**
     * Gets called while the user drags the gradient knob
     * @param {Vector2} offset
     * @private
     */

  }, {
    key: '_onKnobDrag',
    value: function _onKnobDrag(offset) {
      var editor = this.context.editor;

      var outputDimensions = editor.getOutputDimensions();

      var newKnobPosition = this._initialKnobPosition.clone().add(offset).clamp(new _globals.Vector2(0, 0), outputDimensions);

      var position = this._operation.getPosition().clone().multiply(outputDimensions);

      var radius = newKnobPosition.clone().subtract(position).abs().len();
      var gradientRadius = radius / 2;

      this.setState({
        knobPosition: newKnobPosition,
        areaDimensions: new _globals.Vector2(radius * 2, radius * 2)
      });
      this._operation.set({
        radius: radius / outputDimensions.min(),
        gradientRadius: gradientRadius / outputDimensions.min()
      });

      editor.render();
    }

    // -------------------------------------------------------------------------- STYLING

    /**
     * Returns the CSS styles for the area div
     * @return {Object}
     * @private
     */

  }, {
    key: '_getAreaStyle',
    value: function _getAreaStyle() {
      return {
        width: this.state.areaDimensions.x,
        height: this.state.areaDimensions.y,
        left: this.state.areaPosition.x,
        top: this.state.areaPosition.y,
        marginLeft: this.state.areaDimensions.x * -0.5,
        marginTop: this.state.areaDimensions.y * -0.5
      };
    }

    /**
     * Returns the CSS styles for the knob
     * @return {Object}
     * @private
     */

  }, {
    key: '_getKnobStyle',
    value: function _getKnobStyle() {
      return {
        left: this.state.knobPosition.x,
        top: this.state.knobPosition.y
      };
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Sets the dimensions and position values from the current operation options
     * @private
     */

  }, {
    key: '_setStylesFromOptions',
    value: function _setStylesFromOptions() {
      var editor = this.context.editor;


      var outputDimensions = editor.getOutputDimensions();
      var position = this._operation.getPosition().clone().multiply(outputDimensions);

      var radius = this._operation.getRadius() * outputDimensions.min();
      var diameter = radius * 2;
      var areaSize = new _globals.Vector2(diameter, diameter);

      var newState = {
        areaDimensions: areaSize,
        areaPosition: position
      };

      if (!this._knobChangedManually) {
        newState.knobPosition = position.clone().add(radius, 0);
      }

      this.setState(newState);
    }

    /**
     * Returns the container style
     * @return {Object}
     * @private
     */

  }, {
    key: '_getContainerStyle',
    value: function _getContainerStyle() {
      var editor = this.context.editor;

      var _editor$getSDK$getSpr = editor.getSDK().getSprite().getBounds(),
          x = _editor$getSDK$getSpr.x,
          y = _editor$getSDK$getSpr.y,
          width = _editor$getSDK$getSpr.width,
          height = _editor$getSDK$getSpr.height;

      return {
        left: x,
        top: y,
        width: width,
        height: height
      };
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'div',
        { bem: 'b:canvasControls e:container m:full', ref: 'container', style: this._getContainerStyle() },
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$b:radialFocusCanvasControls' },
          _globals.ReactBEM.createElement(
            _draggableComponent2.default,
            {
              onStart: this._onCenterDragStart,
              onDrag: this._onCenterDrag },
            _globals.ReactBEM.createElement('div', { bem: 'e:area', style: this._getAreaStyle() })
          ),
          _globals.ReactBEM.createElement(
            _draggableComponent2.default,
            {
              onStart: this._onKnobDragStart,
              onDrag: this._onKnobDrag },
            _globals.ReactBEM.createElement('div', { bem: 'e:knob $b:knob', style: this._getKnobStyle() })
          )
        )
      );
    }
  }]);

  return RadialFocusCanvasControlsComponent;
}(_canvasControlsComponent2.default);

exports.default = RadialFocusCanvasControlsComponent;


RadialFocusCanvasControlsComponent.contextTypes = _canvasControlsComponent2.default.contextTypes;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _controls = __webpack_require__(4);

var _controls2 = _interopRequireDefault(_controls);

var _stickerControlsComponent = __webpack_require__(142);

var _stickerControlsComponent2 = _interopRequireDefault(_stickerControlsComponent);

var _stickerCanvasControlsComponent = __webpack_require__(144);

var _stickerCanvasControlsComponent2 = _interopRequireDefault(_stickerCanvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _SDK$Operations$Sprit = _globals.SDK.Operations.SpriteOperation,
    StickerSprite = _SDK$Operations$Sprit.StickerSprite,
    BrushSprite = _SDK$Operations$Sprit.BrushSprite;

/**
 * The sticker controls
 * @class
 * @extends PhotoEditorSDK.UI.ReactUI.Control
 * @memberof PhotoEditorSDK.UI.ReactUI.Controls
 */

var StickerControls = function (_Controls) {
  _inherits(StickerControls, _Controls);

  function StickerControls() {
    _classCallCheck(this, StickerControls);

    return _possibleConstructorReturn(this, (StickerControls.__proto__ || Object.getPrototypeOf(StickerControls)).apply(this, arguments));
  }

  _createClass(StickerControls, null, [{
    key: 'onExit',

    /**
     * Gets called when the user leaves these controls
     * @this {StickerControlsComponent}
     * @override
     * @ignore
     */
    value: function onExit() {
      var editor = this.context.editor;

      var operation = this.getSharedState('operation');

      if (!this.getSharedState('skipHistory')) {
        editor.history.add(operation, this.getSharedState('initialOptions'), this.getSharedState('operationExistedBefore'));
      }

      editor.zoom.restore();
      editor.features.enable('zoom', 'drag');
      editor.render();
    }

    /**
     * Gets called when the user enters these controls
     * @this {StickerControlsComponent}
     * @param {SharedState} sharedState
     * @override
     * @ignore
     */

  }, {
    key: 'onEnter',
    value: function onEnter(sharedState) {
      var editor = this.context.editor;

      var operationExistedBefore = editor.operations.exists('sprite');
      var operation = editor.operations.getOrCreate('sprite');
      var sprites = operation.getSprites();
      var stickers = operation.getSpritesOfType(StickerSprite);
      var initialOptions = operation.serializeOptions();

      editor.zoom.save();
      editor.zoom.set('auto');
      editor.features.disable('zoom', 'drag');

      this.setSharedState({
        operationExistedBefore: operationExistedBefore, operation: operation, sprites: sprites, stickers: stickers, initialOptions: initialOptions
      });
    }

    /**
     * Checks if there is something at the given position that
     * would cause the UI to switch to this control on click
     * @param  {PhotoEditorSDK.Math.Vector2} position
     * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
     * @return {*}
     * @override
     * @ignore
     */

  }, {
    key: 'clickAtPosition',
    value: function clickAtPosition(position, editor) {
      if (!editor.operations.exists('sprite')) return false;

      var operation = editor.operations.getOrCreate('sprite');
      var sprites = operation.getSpritesAtPosition(position, editor.getOutputTextureDimensions()).filter(function (s) {
        return !(s instanceof BrushSprite);
      });

      if (sprites.length && sprites[0] instanceof StickerSprite) {
        return { selectedSprite: sprites[0] };
      } else {
        return false;
      }
    }

    /**
     * Checks if this control is available to the user
     * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
     * @return {Boolean}
     * @override
     * @ignore
     */

  }, {
    key: 'isAvailable',
    value: function isAvailable(editor) {
      return editor.isToolAllowed('sticker') && editor.isToolEnabled('sticker');
    }
  }]);

  return StickerControls;
}(_controls2.default);

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */


StickerControls.controlsComponent = _stickerControlsComponent2.default;

/**
 * This control's canvas component. Used for the upper controls part of the editor (on
 * top of the canvas)
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */
StickerControls.canvasControlsComponent = _stickerCanvasControlsComponent2.default;

/**
 * This control's identifier
 * @type {String}
 * @default
 */
StickerControls.identifier = 'sticker';

/**
 * This control's icon path
 * @type {String}
 * @ignore
 */
StickerControls.iconPath = 'controls/overview/sticker.png';

/**
 * The language key that should be used when displaying this filter
 * @type {String}
 * @ignore
 */
StickerControls.languageKey = 'pesdk.sticker.title.name';

/**
 * The default options for this control
 * @type {Object}
 * @property {Object[]} [categories = []]
 * @property {Boolean} [replaceCategories = false]
 * @property {String[]} [availableStickers = null]
 * @property {Boolean} [tooltips = false]
 */
StickerControls.defaultOptions = {
  categories: null,
  replaceCategories: false,
  availableStickers: null,
  tooltips: false,
  hideCategories: false,
  fixedRatio: true,
  snapRotation: 90,
  snapRotationTolerance: 5,
  smoothDownscaling: false

  /**
   * The operations required for this control to work properly
   * @type {Array}
   */
};StickerControls.requiredOperations = ['sprite'];

StickerControls.getPreloadAssets = _controls2.default.getPreloadAssets;

exports.default = StickerControls;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _controlsComponent = __webpack_require__(3);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _scrollbarComponent = __webpack_require__(2);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

var _categoryDropdownComponent = __webpack_require__(45);

var _categoryDropdownComponent2 = _interopRequireDefault(_categoryDropdownComponent);

var _modalManager = __webpack_require__(1);

var _modalManager2 = _interopRequireDefault(_modalManager);

var _stickerManager = __webpack_require__(11);

var _stickerManager2 = _interopRequireDefault(_stickerManager);

var _stickerItemComponent = __webpack_require__(143);

var _stickerItemComponent2 = _interopRequireDefault(_stickerItemComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var StickerOverviewControlsComponent = function (_ControlsComponent) {
  _inherits(StickerOverviewControlsComponent, _ControlsComponent);

  function StickerOverviewControlsComponent() {
    var _ref;

    _classCallCheck(this, StickerOverviewControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = StickerOverviewControlsComponent.__proto__ || Object.getPrototypeOf(StickerOverviewControlsComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onStickerMouseLeave', '_renderTooltipCanvas', '_onCategoryChange', '_onBeforeHistoryUndo');
    _this._events = _defineProperty({}, _globals.Constants.EVENTS.HISTORY_BEFORE_UNDO, _this._onBeforeHistoryUndo);

    _this._operation = _this.getSharedState('operation');
    _this._sprites = _this.getSharedState('sprites');
    _this._stickers = _this.getSharedState('stickers');

    _this._initStickerManager();

    _this.state = {
      category: _this._stickerManager.getCategory('all')
    };
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called before a history item is being undone
   * @param  {Object} historyObject
   * @private
   */


  _createClass(StickerOverviewControlsComponent, [{
    key: '_onBeforeHistoryUndo',
    value: function _onBeforeHistoryUndo(historyObject) {
      var operation = historyObject.operation,
          options = historyObject.options;

      if (operation !== this.getSharedState('operation')) return;

      var sprites = options.sprites;

      if (sprites.indexOf(this.getSharedState('selectedSprite')) === -1) {
        // Currently selected sprite is being removed. Leave control without adding history item.
        this.setSharedState({ skipHistory: true }, false);
        this.props.onSwitchControls('home');
      }
    }

    /**
     * Gets called when the user switches the category
     * @param  {Object} category
     * @private
     */

  }, {
    key: '_onCategoryChange',
    value: function _onCategoryChange(category) {
      var _this2 = this;

      this.setState({ category: category }, function () {
        _this2.refs.scrollbar.update();
      });
    }

    // -------------------------------------------------------------------------- LIFECYCLE

    /**
     * Gets called when this component is mounted
     */

  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      _get(StickerOverviewControlsComponent.prototype.__proto__ || Object.getPrototypeOf(StickerOverviewControlsComponent.prototype), 'componentDidMount', this).call(this);

      if (this.props.options.stickersJSONPath) {
        this._loadExternalStickers();
      }

      var editor = this.context.editor;

      editor.zoom.set('auto', function () {
        editor.features.disable('zoom', 'drag');
      });
    }

    // -------------------------------------------------------------------------- EXTERNAL STICKER LOADING

    /**
     * Loads the stickers from an external JSON source
     * @private
     */

  }, {
    key: '_loadExternalStickers',
    value: function _loadExternalStickers() {
      var _this3 = this;

      // Display loading modal after 100ms
      var loadingModal = null;
      var loadTimeout = setTimeout(function () {
        loadingModal = _modalManager2.default.instance.displayLoading(_this3._t('pesdk.common.text.loading'));
      }, 100);

      // Called when loading is done. Cancels the loading timeout
      // or closes the loadingModal in case it has been opened
      var doneLoading = function doneLoading() {
        if (loadTimeout) {
          clearTimeout(loadTimeout);
          loadTimeout = null;
        }
        if (loadingModal) loadingModal.close();
        _this3._jsonLoaded = true;
      };

      this._stickerManager.loadExternal(this.props.options.stickersJSONPath).then(function (result) {
        doneLoading();
        _this3.forceUpdate(function () {
          _this3.refs.scrollbar.update();
        });
      }).catch(function (e) {
        doneLoading();
        var errorModal = _modalManager2.default.instance.displayError(_this3._t('pesdk.sticker.title.loadingStickersFailed'), e.message);
        errorModal.on('close', function () {
          _this3.props.onBack();
        });
      });
    }

    // -------------------------------------------------------------------------- STICKER RENDERING

    /**
     * Renders the sticker on the tooltip canvas
     * @private
     */

  }, {
    key: '_renderTooltipCanvas',
    value: function _renderTooltipCanvas() {
      var _this4 = this;

      var hoveredSticker = this.state.hoveredSticker;

      var image = new window.Image();
      var mediaBase = hoveredSticker.images.mediaBase;

      image.addEventListener('load', function () {
        if (!_this4.state.tooltipVisible || _this4.state.hoveredSticker !== hoveredSticker) {
          return;
        }

        if (typeof mediaBase.width !== 'undefined' && typeof mediaBase.height !== 'undefined') {
          image.width = mediaBase.width;
          image.height = mediaBase.height;
        }

        var canvas = _this4.refs.tooltipCanvas;
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;

        var context = canvas.getContext('2d');
        var scale = Math.min(canvas.width / image.width, canvas.height / image.height);
        var drawSize = new _globals.Vector2(image.width, image.height).multiply(scale);
        var drawPosition = new _globals.Vector2(canvas.width, canvas.height).divide(2).subtract(drawSize.clone().divide(2));

        context.drawImage(image, 0, 0, image.width, image.height, drawPosition.x, drawPosition.y, drawSize.x, drawSize.y);
      });

      var resolvedStickerPath = this._getAssetPath(_stickerManager2.default.getURLForSticker(hoveredSticker, 'base'));
      image.crossOrigin = this.context.editor.getCrossOrigin();
      image.src = resolvedStickerPath;
    }

    // -------------------------------------------------------------------------- STICKERS

    /**
     * Initializes the sticker manager
     * @private
     */

  }, {
    key: '_initStickerManager',
    value: function _initStickerManager() {
      this._stickerManager = new _stickerManager2.default(this.context.ui, this.props.options);
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the user clicks the back button
     * @param {Event} e
     * @private
     */

  }, {
    key: '_onBackClick',
    value: function _onBackClick(e) {
      this._backButtonClicked = true;
      this.props.onSwitchControls('home');
    }

    /**
     * Gets called when a sticker has been clicked
     * @param  {Object} sticker
     * @private
     */

  }, {
    key: '_onStickerClick',
    value: function _onStickerClick(sticker) {
      var _this5 = this;

      var mediaBase = sticker.images.mediaBase;

      var url = _stickerManager2.default.getURLForSticker(sticker, 'base');
      var resolvedStickerPath = this._getAssetPath(url);
      var image = new window.Image();

      var loadingModal = void 0;
      var loadTimeout = setTimeout(function () {
        loadingModal = _modalManager2.default.instance.displayLoading(_this5._t('pesdk.common.text.loading'));
      }, 100);

      image.addEventListener('load', function () {
        if (loadingModal) loadingModal.close();
        if (loadTimeout) {
          clearTimeout(loadTimeout);
          loadTimeout = null;
        }

        if (typeof mediaBase.width !== 'undefined' && typeof mediaBase.height !== 'undefined') {
          image.width = mediaBase.width;
          image.height = mediaBase.height;
        }

        var editor = _this5.context.editor;


        var scale = _this5._calculateInitialStickerScale(sticker, image);
        var sprite = _this5._operation.createSticker({
          identifier: sticker.identifier,
          image: image,
          position: new _globals.Vector2(0.5, 0.5),
          dimensions: new _globals.Vector2(image.width, image.height).multiply(scale),
          rotation: 0,
          smoothDownscaling: _this5.props.options.smoothDownscaling
        });
        _this5._operation.addSprite(sprite);
        _this5._stickers.push(sprite);

        editor.render(function () {
          // Broadcast new state
          _this5.setSharedState({
            selectedSprite: sprite,
            sprites: _this5._sprites,
            stickers: _this5._stickers
          });
        });
      });

      image.addEventListener('error', function () {
        if (loadingModal) loadingModal.close();
        if (loadTimeout) {
          clearTimeout(loadTimeout);
          loadTimeout = null;
        }

        _modalManager2.default.instance.displayError(_this5._t('pesdk.common.title.imageLoadFail'), _this5._t('pesdk.common.text.imageLoadFail', { path: image.src }));
      });

      image.crossOrigin = this.context.editor.getCrossOrigin();
      image.src = resolvedStickerPath;
    }

    /**
     * Calculates the initial sticker scale
     * @param  {Object} sticker
     * @param  {Image} image
     * @return {Number}
     * @private
     */

  }, {
    key: '_calculateInitialStickerScale',
    value: function _calculateInitialStickerScale(sticker, image) {
      var operation = this.getSharedState('operation');
      var inputDimensions = operation.getInputDimensions(false);
      var imageDimensions = new _globals.Vector2(image.width, image.height);

      var stickerDimensions = _globals.SDKUtils.resizeVectorToFit(imageDimensions, inputDimensions.clone().multiply(0.5));
      return stickerDimensions.x / imageDimensions.x;
    }

    /**
     * Gets called when the user starts hovering a sticker
     * @param  {String} stickerPath
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onStickerMouseEnter',
    value: function _onStickerMouseEnter(stickerPath, e) {
      var _this6 = this;

      this.setState({
        tooltipVisible: true,
        hoveredSticker: stickerPath,
        hoveredStickerElement: e.currentTarget
      }, function () {
        _this6._renderTooltipCanvas();
        _this6._updateTooltipPosition();
      });
    }

    /**
     * Updates the tooltip position to match the currently hovered
     * sticker's position
     * @private
     */

  }, {
    key: '_updateTooltipPosition',
    value: function _updateTooltipPosition() {
      var el = this.state.hoveredStickerElement;
      var parent = this.refs.root;
      var boundingRect = el.getBoundingClientRect();
      var parentBoundingRect = parent.getBoundingClientRect();

      this.setState({
        tooltipPosition: boundingRect.left - parentBoundingRect.left
      });
    }

    /**
     * Gets called when the user does no longer hover a sticker
     * @private
     */

  }, {
    key: '_onStickerMouseLeave',
    value: function _onStickerMouseLeave() {
      this.setState({
        tooltipVisible: false,
        hoveredSticker: null
      });
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the list items for this control
     * @return {Array.<ReactBEM.Element>}
     * @private
     */

  }, {
    key: '_renderListItems',
    value: function _renderListItems() {
      var _this7 = this;

      var _props$options = this.props.options,
          stickersJSONPath = _props$options.stickersJSONPath,
          replaceCategories = _props$options.replaceCategories;

      if (stickersJSONPath && replaceCategories && !this._jsonLoaded) {
        // If all categories are replaced by the JSON anyways, we don't need to render
        // anything before receiving the JSON data
        return;
      }

      var stickers = this._stickerManager.getStickersForCategory(this.state.category.identifier);
      return stickers.map(function (sticker, i) {
        var options = _this7.props.options;


        var itemEvents = options.tooltips ? {
          onMouseEnter: _this7._onStickerMouseEnter.bind(_this7, sticker),
          onMouseLeave: _this7._onStickerMouseLeave
        } : null;

        return _globals.ReactBEM.createElement(_stickerItemComponent2.default, _extends({
          sticker: sticker,
          onClick: _this7._onStickerClick.bind(_this7, sticker)
        }, itemEvents));
      });
    }

    /**
     * Renders the tooltip (if present)
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderTooltip',
    value: function _renderTooltip() {
      var tooltipVisible = this.props.options.tooltips && this.state.tooltipVisible;

      var style = {
        left: this.state.tooltipPosition
      };

      return tooltipVisible ? _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell m:empty' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$b:stickersControls $e:tooltip',
            style: style },
          _globals.ReactBEM.createElement('canvas', { bem: 'e:canvas', ref: 'tooltipCanvas' })
        )
      ) : null;
    }

    /**
     * Renders the category dropdown (if present)
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderCategoryDropdown',
    value: function _renderCategoryDropdown() {
      var _this8 = this;

      var _props$options2 = this.props.options,
          stickersJSONPath = _props$options2.stickersJSONPath,
          replaceCategories = _props$options2.replaceCategories;

      if (stickersJSONPath && replaceCategories && !this._jsonLoaded) {
        // If all categories are replaced by the JSON anyways, we don't need to render
        // anything before receiving the JSON data
        return;
      }

      var categories = this._stickerManager.getCategories(true);
      var categoryDropdownVisible = !this.props.options.hideCategories && categories.length > 1;
      if (!categoryDropdownVisible) {
        return null;
      }

      var categoryItems = categories.map(function (c) {
        return {
          identifier: c.identifier,
          item: c,
          label: _this8._t('pesdk.sticker.asset.' + c.identifier) || c.defaultName,
          icon: _this8._getAssetPath('controls/stickers/categories/' + c.identifier + '.png', true)
        };
      });
      var currentCategory = this.state.category;

      var selectedCategoryItem = {
        identifier: currentCategory.identifier,
        item: currentCategory,
        label: this._t('pesdk.sticker.asset.' + currentCategory.identifier) || currentCategory.defaultName,
        icon: this._getAssetPath('controls/stickers/categories/' + currentCategory.identifier + '.png', true)
      };

      return _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell m:categoryDropdown' },
        _globals.ReactBEM.createElement(_categoryDropdownComponent2.default, {
          items: categoryItems,
          selectedItem: selectedCategoryItem,
          onChange: this._onCategoryChange })
      );
    }

    /**
     * Renders the controls of this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderControls',
    value: function renderControls() {
      var listItems = this._renderListItems();
      var tooltip = this._renderTooltip();
      var categoryDropdown = this._renderCategoryDropdown();

      return [tooltip, categoryDropdown, _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell m:list' },
        _globals.ReactBEM.createElement(
          _scrollbarComponent2.default,
          { ref: 'scrollbar' },
          _globals.ReactBEM.createElement(
            'ul',
            { bem: '$e:list' },
            listItems
          )
        )
      )];
    }
  }]);

  return StickerOverviewControlsComponent;
}(_controlsComponent2.default);

exports.default = StickerOverviewControlsComponent;


StickerOverviewControlsComponent.contextTypes = _controlsComponent2.default.contextTypes;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _stickerManager = __webpack_require__(11);

var _stickerManager2 = _interopRequireDefault(_stickerManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var StickerOverviewControlsComponent = function (_BaseComponent) {
  _inherits(StickerOverviewControlsComponent, _BaseComponent);

  function StickerOverviewControlsComponent() {
    var _ref;

    _classCallCheck(this, StickerOverviewControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = StickerOverviewControlsComponent.__proto__ || Object.getPrototypeOf(StickerOverviewControlsComponent)).call.apply(_ref, [this].concat(args)));

    _this.state = {
      sticker: _this.props.sticker
    };
    return _this;
  }

  /**
   * Gets called when this component has been mounted
   */


  _createClass(StickerOverviewControlsComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this._renderSticker();
    }

    /**
     * Gets called when this component is about to receive new properties
     * @param  {Object} nextProps
     */

  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      if (this.props.sticker !== nextProps.sticker) {
        this.setState({ sticker: nextProps.sticker }, function () {
          _this2._renderSticker();
        });
      }
    }

    /**
     * Renders the sticker onto the canvas
     * @private
     */

  }, {
    key: '_renderSticker',
    value: function _renderSticker() {
      var editor = this.context.editor;

      var sdk = editor.getSDK();

      var sticker = this.props.sticker;
      var mediaThumb = sticker.images.mediaThumb;

      var url = _stickerManager2.default.getURLForSticker(sticker, 'thumb');
      var resolvedStickerPath = this._getAssetPath(url);
      var canvas = this.refs['canvas-' + sticker.name];

      var pixelRatio = sdk.getPixelRatio();
      canvas.width = canvas.offsetWidth * pixelRatio;
      canvas.height = canvas.offsetHeight * pixelRatio;

      canvas.style.width = canvas.offsetWidth + 'px';
      canvas.style.height = canvas.offsetHeight + 'px';

      var context = canvas.getContext('2d');
      var image = new window.Image();
      image.addEventListener('load', function () {
        if (typeof mediaThumb.width !== 'undefined' && typeof mediaThumb.height !== 'undefined' && !_globals.Utils.Browser.getIEVersion()) {
          image.width = mediaThumb.width;
          image.height = mediaThumb.height;
        }

        var scale = Math.min(canvas.width / image.width, canvas.height / image.height);
        var drawSize = new _globals.Vector2(image.width, image.height).multiply(scale);
        var drawPosition = new _globals.Vector2(canvas.width, canvas.height).divide(2).subtract(drawSize.clone().divide(2));

        context.drawImage(image, 0, 0, image.width, image.height, drawPosition.x, drawPosition.y, drawSize.x, drawSize.y);
      });
      image.crossOrigin = this.context.editor.getCrossOrigin();
      image.src = resolvedStickerPath;
    }

    /**
     * Renders this element
     * @return {ReactBEM.element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'li',
        {
          bem: '$b:stickersControls $e:item',
          key: this.props.sticker.name,
          onClick: this.props.onClick,
          onMouseEnter: this.props.onMouseEnter,
          onMouseLeave: this.props.onMouseLeave },
        _globals.ReactBEM.createElement('canvas', { bem: 'e:canvas', ref: 'canvas-' + this.props.sticker.name })
      );
    }
  }]);

  return StickerOverviewControlsComponent;
}(_globals.BaseComponent);

exports.default = StickerOverviewControlsComponent;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _spritesCanvasControlsComponent = __webpack_require__(14);

var _spritesCanvasControlsComponent2 = _interopRequireDefault(_spritesCanvasControlsComponent);

var _stickerControlsOverlayComponent = __webpack_require__(148);

var _stickerControlsOverlayComponent2 = _interopRequireDefault(_stickerControlsOverlayComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */


var StickerCanvasControlsComponent = function (_SpritesCanvasControl) {
  _inherits(StickerCanvasControlsComponent, _SpritesCanvasControl);

  function StickerCanvasControlsComponent() {
    _classCallCheck(this, StickerCanvasControlsComponent);

    return _possibleConstructorReturn(this, (StickerCanvasControlsComponent.__proto__ || Object.getPrototypeOf(StickerCanvasControlsComponent)).apply(this, arguments));
  }

  _createClass(StickerCanvasControlsComponent, [{
    key: '_renderOverlayControls',

    /**
     * This renders controls on top of the sprites
     * @return {ReactBEM.Element}
     * @private
     */
    value: function _renderOverlayControls() {
      if (!this.getSharedState('selectedSprite')) return;

      return _globals.ReactBEM.createElement(_stickerControlsOverlayComponent2.default, {
        onFlip: this._onSpriteFlip,
        onTakeToFront: this._onSpriteTakeToFront,
        onRemove: this._onSpriteRemove });
    }
  }]);

  return StickerCanvasControlsComponent;
}(_spritesCanvasControlsComponent2.default);

exports.default = StickerCanvasControlsComponent;


StickerCanvasControlsComponent.contextTypes = _spritesCanvasControlsComponent2.default.contextTypes;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _draggableComponent = __webpack_require__(5);

var _draggableComponent2 = _interopRequireDefault(_draggableComponent);

var _itemComponent = __webpack_require__(28);

var _itemComponent2 = _interopRequireDefault(_itemComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var TextItemComponent = function (_ItemComponent) {
  _inherits(TextItemComponent, _ItemComponent);

  function TextItemComponent() {
    var _ref;

    _classCallCheck(this, TextItemComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = TextItemComponent.__proto__ || Object.getPrototypeOf(TextItemComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onTextChange', '_onItemDoubleClick', '_onItemTouchStart', '_onItemTouchEnd', '_onResizeKnobDragStart', '_onResizeKnobDrag', '_onResizeKnobDragStop', '_onRotationKnobDragStart', '_onRotationKnobDrag', '_onRotationKnobDragStop', '_onBlur');

    _this.state = {
      editMode: false,
      text: _this.props.sprite.getText()
    };
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when this component will receive new props
   * @param  {Object} nextProps
   */


  _createClass(TextItemComponent, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      _get(TextItemComponent.prototype.__proto__ || Object.getPrototypeOf(TextItemComponent.prototype), 'componentWillReceiveProps', this).call(this, nextProps);
      if (nextProps.sprite !== this.props.sprite) {
        this.refs.textarea.blur();
        this.setState({
          text: nextProps.sprite.getText(),
          editMode: false
        });
      }
    }

    /**
     * Gets called when the user has changed the text
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onTextChange',
    value: function _onTextChange(e) {
      var sprite = this.props.sprite;

      sprite.setText(e.target.value);
      this.setState({ text: e.target.value });
    }

    /**
     * Gets called when the user double clicks the text. Turns the sprite into
     * editing mode.
     * @private
     */

  }, {
    key: '_onItemDoubleClick',
    value: function _onItemDoubleClick() {
      this.enterEditMode();
    }

    /**
     * Enters the edit mode
     */

  }, {
    key: 'enterEditMode',
    value: function enterEditMode() {
      var _this2 = this;

      var sprite = this.props.sprite;
      var editor = this.context.editor;


      sprite.setVisible(false);

      if (!sprite._edited) {
        sprite.setText('');
        this.refs.textarea.value = '';
        sprite._edited = true;
        this.setState({ text: '' });
      }
      this.setState({ editMode: true }, function () {
        _this2.refs.textarea.focus();
        _this2.refs.textarea.select();
      });

      editor.render();
    }

    /**
     *  Leaves edit mode
     */

  }, {
    key: 'leaveEditMode',
    value: function leaveEditMode() {
      var sprite = this.props.sprite;
      var editor = this.context.editor;


      sprite.setVisible(true);
      editor.render();
      this.setState({ editMode: false });
    }

    /**
     * Gets called when the user starts touching the item
     * @param {Event} e
     * @private
     */

  }, {
    key: '_onItemTouchStart',
    value: function _onItemTouchStart(e) {
      this._initialTouchPosition = _globals.Utils.getEventPosition(e);
      this._tapStartAt = (0, _globals.now)();
    }

    /**
     * Gets called when the user stops touching the item
     * @private
     */

  }, {
    key: '_onItemTouchEnd',
    value: function _onItemTouchEnd() {
      // Recognize double tap
      if ((0, _globals.now)() - this._tapStartAt <= 100) {
        // Touch didn't last longer than 100ms => recognized as tap
        if (typeof this._lastTapAt !== 'undefined' && (0, _globals.now)() - this._lastTapAt <= 300) {
          // Last tap was no longer than 300ms ago => recognized as double tap
          this._onItemDoubleClick();
        }
        this._lastTapAt = (0, _globals.now)();
      }
    }

    // -------------------------------------------------------------------------- ROTATION DRAGGING

    /**
     * Gets called when the user starts dragging the resize knob
     * @param  {Vector2} position
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onRotationKnobDragStart',
    value: function _onRotationKnobDragStart(position, e) {
      this._dragging = true;
      this._initialPosition = this._getRotationKnobPosition();

      this.props.onDragStart && this.props.onDragStart();
    }

    /**
     * Gets called while the user rotates the text
     * @param  {Vector2} offset
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onRotationKnobDrag',
    value: function _onRotationKnobDrag(offset, e) {
      var sprite = this.props.sprite;
      var editor = this.context.editor;


      var spritePosition = this._getAbsoluteSpritePosition();
      var newKnobPosition = this._initialPosition.clone().add(offset);

      // Calculate new rotation and scale from new knob position
      var knobDistanceFromCenter = newKnobPosition.clone().subtract(spritePosition);

      var boundingBox = sprite.getDimensions(editor.getSDK(), editor.getOutputDimensions());
      var radians = Math.atan2(knobDistanceFromCenter.y / 2, knobDistanceFromCenter.x / 2) - Math.atan2(boundingBox.y / 2, boundingBox.x / 2);

      sprite.setRotation(radians);
      editor.render();
      this.forceUpdate();
    }

    /**
     * Gets called when the user stops rotating the text
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onRotationKnobDragStop',
    value: function _onRotationKnobDragStop(e) {
      this.props.onDragStop && this.props.onDragStop();
    }

    // -------------------------------------------------------------------------- RESIZE DRAGGING

    /**
     * Gets called when the user starts resizing the text
     * @param  {Vector2} position
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onResizeKnobDragStart',
    value: function _onResizeKnobDragStart(position, e) {
      this._initialPosition = this._getResizeKnobPosition();

      this.props.onDragStart && this.props.onDragStart();
    }

    /**
     * Gets called while the user resizes the text
     * @param  {Vector2} offset
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onResizeKnobDrag',
    value: function _onResizeKnobDrag(offset, e) {
      var sprite = this.props.sprite;

      var textRotation = sprite.getRotation();

      var editor = this.context.editor;

      var outputDimensions = editor.getOutputDimensions();

      var cos = Math.cos(textRotation);
      var sin = Math.sin(textRotation);

      var newKnobPosition = this._initialPosition.clone().add(offset);
      var position = this._getAbsoluteSpritePosition();
      var distanceToPosition = newKnobPosition.clone().subtract(position);

      var newMaxWidth = Math.max((distanceToPosition.x * cos + distanceToPosition.y * sin) / outputDimensions.x * 2, 0.1);
      sprite.setMaxWidth(newMaxWidth);
      editor.render();
    }

    /**
     * Gets called when the user stops resizing the text
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onResizeKnobDragStop',
    value: function _onResizeKnobDragStop(e) {
      this.props.onDragStop && this.props.onDragStop();
    }

    /**
     * Get called when the textarea loses focus
     * @private
     */

  }, {
    key: '_onBlur',
    value: function _onBlur() {
      this.leaveEditMode();
    }

    // -------------------------------------------------------------------------- STYLING

    /**
     * Returns the style object for the rotation knob
     * @return {Object}
     * @private
     */

  }, {
    key: '_getRotationKnobStyle',
    value: function _getRotationKnobStyle() {
      var position = this._getRotationKnobPosition();
      return {
        left: position.x,
        top: position.y
      };
    }

    /**
     * Returns the style object for the resize knob
     * @return {Object}
     * @private
     */

  }, {
    key: '_getResizeKnobStyle',
    value: function _getResizeKnobStyle() {
      var position = this._getResizeKnobPosition();
      return {
        left: position.x,
        top: position.y
      };
    }

    /**
     * Returns the style object for the given text object
     * @return {Object}
     * @private
     */

  }, {
    key: '_getTextStyle',
    value: function _getTextStyle() {
      var editor = this.context.editor;
      var sprite = this.props.sprite;

      var sdk = editor.getSDK();
      var outputDimensions = editor.getOutputDimensions();
      var style = sprite.getDOMStyle(sdk, outputDimensions);

      var spritePosition = this._getAbsoluteSpritePosition();
      var boundingBox = sprite.getDimensions(sdk, outputDimensions);
      style.height = Math.min(boundingBox.y, outputDimensions.y - spritePosition.y);
      if (!this.state.editMode) {
        style.display = 'none';
      }
      return style;
    }

    /**
     * Returns the style object for the item container
     * @return {Object}
     * @private
     */

  }, {
    key: '_getItemContainerStyle',
    value: function _getItemContainerStyle() {
      var editor = this.context.editor;
      var sprite = this.props.sprite;


      var outputDimensions = editor.getOutputDimensions();
      var boundingBox = sprite.getDimensions(editor.getSDK(), outputDimensions);

      var position = sprite.getPosition().clone().multiply(outputDimensions);

      var degrees = sprite.getRotation() * 180 / Math.PI;
      var transform = 'rotateZ(' + degrees.toFixed(2) + 'deg)';
      var transformOrigin = '50% 50%';

      var width = boundingBox.x;
      var height = boundingBox.y;

      return {
        width: width,
        height: height,
        left: position.x - width * 0.5,
        top: position.y - height * 0.5,
        marginLeft: 0,
        marginTop: 0,
        transform: transform,
        MozTransform: transform,
        msTransform: transform,
        WebkitTransform: transform,
        transformOrigin: transformOrigin,
        MozTransformOrigin: transformOrigin,
        msTransformOrigin: transformOrigin,
        WebkitTransformOrigin: transformOrigin
      };
    }

    // -------------------------------------------------------------------------- CALCULATIONS

    /**
     * Returns the position of the rotation knob
     * @return {Vector2}
     * @private
     */

  }, {
    key: '_getRotationKnobPosition',
    value: function _getRotationKnobPosition() {
      var sprite = this.props.sprite;
      var editor = this.context.editor;


      var sin = Math.sin(sprite.getRotation());
      var cos = Math.cos(sprite.getRotation());

      var outputDimensions = editor.getOutputDimensions();
      var boundingBox = sprite.getDimensions(editor.getSDK(), outputDimensions);
      var halfDimensions = boundingBox.clone().divide(2);

      var position = sprite.getPosition().clone().multiply(outputDimensions).add(halfDimensions.x * cos - halfDimensions.y * sin, halfDimensions.x * sin + halfDimensions.y * cos);
      return position;
    }

    /**
     * Returns the position of the resize knob
     * @return {Vector2}
     * @private
     */

  }, {
    key: '_getResizeKnobPosition',
    value: function _getResizeKnobPosition() {
      var sprite = this.props.sprite;
      var editor = this.context.editor;


      var sin = Math.sin(sprite.getRotation());
      var cos = Math.cos(sprite.getRotation());

      var outputDimensions = editor.getOutputDimensions();
      var boundingBox = sprite.getDimensions(editor.getSDK(), outputDimensions);
      var halfDimensions = boundingBox.clone().divide(2);
      var position = sprite.getPosition().clone().multiply(outputDimensions).add(halfDimensions.x * cos + halfDimensions.y * sin, halfDimensions.x * sin - halfDimensions.y * cos);
      return position;
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the knobs for this item
     * @return {Array.<ReactBEM.Element>}
     * @private
     */

  }, {
    key: '_renderKnobs',
    value: function _renderKnobs() {
      var knobs = [];
      if (this.props.selected && !this.state.editMode) {
        knobs = [_globals.ReactBEM.createElement(
          _draggableComponent2.default,
          {
            onStart: this._onRotationKnobDragStart,
            onDrag: this._onRotationKnobDrag,
            onStop: this._onRotationKnobDragStop },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:knob m:rotate $b:knob', style: this._getRotationKnobStyle() },
            _globals.ReactBEM.createElement('img', { bem: 'e:icon m:larger', src: this._getAssetPath('controls/knobs/rotate.png', true) })
          )
        ), _globals.ReactBEM.createElement(
          _draggableComponent2.default,
          {
            onStart: this._onResizeKnobDragStart,
            onDrag: this._onResizeKnobDrag,
            onStop: this._onResizeKnobDragStop },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:knob m:resize $b:knob', style: this._getResizeKnobStyle() },
            _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/knobs/resize-diagonal-up.png', true) })
          )
        )];
      }
      return knobs;
    }

    /**
     * Renders the draggable item
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderItem',
    value: function _renderItem() {
      var itemContainerStyle = this._getItemContainerStyle();
      var textArea = _globals.ReactBEM.createElement('textarea', {
        bem: 'e:content',
        ref: 'textarea',
        style: this._getTextStyle(),
        value: this.state.text,
        disabled: !this.state.editMode,
        onBlur: this._onBlur,
        onChange: this._onTextChange });

      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: 'e:text' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:container', style: itemContainerStyle },
          textArea
        )
      );
    }

    /**
     * Renders the overlay that appears when the sprite is selected
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderSelectedOverlay',
    value: function _renderSelectedOverlay() {
      var selectedOverlayClassNames = [];
      if (this.props.selected) {
        selectedOverlayClassNames.push('is-selected');
      }
      if (this.state.editMode) {
        selectedOverlayClassNames.push('is-disabled');
      }
      selectedOverlayClassNames = selectedOverlayClassNames.join(' ');
      var overlayStyle = this._getItemContainerStyle();

      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: 'e:text' },
        _globals.ReactBEM.createElement(
          _draggableComponent2.default,
          {
            onStart: this._onItemDragStart,
            onStop: this._onItemDragStop,
            onDrag: this._onItemDrag,
            disabled: !this.props.selected || this.props.selected && this.state.editMode },
          _globals.ReactBEM.createElement('div', { bem: 'e:selectedOverlay',
            onDoubleClick: this._onItemDoubleClick,
            onTouchStart: this._onItemTouchStart,
            onTouchEnd: this._onItemTouchEnd,
            style: overlayStyle,
            className: selectedOverlayClassNames })
        )
      );
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: 'b:spritesCanvasControls' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$e:item e:container' },
          this._renderItem(),
          this._renderSelectedOverlay(),
          this._renderKnobs()
        )
      );
    }
  }]);

  return TextItemComponent;
}(_itemComponent2.default);

exports.default = TextItemComponent;


TextItemComponent.contextTypes = _itemComponent2.default.contextTypes;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _draggableComponent = __webpack_require__(5);

var _draggableComponent2 = _interopRequireDefault(_draggableComponent);

var _itemComponent = __webpack_require__(28);

var _itemComponent2 = _interopRequireDefault(_itemComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var StickerItemComponent = function (_ItemComponent) {
  _inherits(StickerItemComponent, _ItemComponent);

  function StickerItemComponent() {
    var _ref;

    _classCallCheck(this, StickerItemComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = StickerItemComponent.__proto__ || Object.getPrototypeOf(StickerItemComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onRotateKnobDragStart', '_onRotateKnobDrag', '_onRotateKnobDragStop');
    _this._id = _globals.SDKUtils.getUUID();
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user starts dragging a knob
   * @param  {String} side
   * @param  {Vector2} position
   * @param  {Event} e
   * @private
   */


  _createClass(StickerItemComponent, [{
    key: '_onKnobDragStart',
    value: function _onKnobDragStart(side, position, e) {
      var sprite = this.props.sprite;

      switch (side) {
        case 'bottom':
          this._initialPosition = this._getBottomDragKnobPosition();
          break;
        case 'top':
          this._initialPosition = this._getTopDragKnobPosition();
          break;
      }

      this._initialDimensions = sprite.getDimensions().clone();

      this.props.onDragStart && this.props.onDragStart();
    }

    /**
     * Gets called while the user drags a sticker
     * @param  {String} side
     * @param  {Vector2} offset
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onKnobDrag',
    value: function _onKnobDrag(side, offset, e) {
      var sprite = this.props.sprite;
      var editor = this.context.editor;


      var stickerPosition = this._getAbsoluteSpritePosition();
      var newKnobPosition = this._initialPosition.clone().add(offset);

      // Calculate new rotation and dimensions from new knob position
      var knobDistanceFromCenter = newKnobPosition.clone().subtract(stickerPosition);

      var initialKnobDistanceFromCenter = this._initialPosition.clone().subtract(stickerPosition);

      if (this.props.options.fixedRatio) {
        var halfDimensions = this._getStickerDimensions().divide(2).abs();

        var initialDistanceFromCenter = this._initialPosition.clone().subtract(stickerPosition);

        var radians = void 0;

        switch (side) {
          case 'bottom':
            radians = Math.atan2(knobDistanceFromCenter.y, knobDistanceFromCenter.x) - Math.atan2(halfDimensions.y, halfDimensions.x);
            break;
          case 'top':
            radians = Math.atan2(knobDistanceFromCenter.y, knobDistanceFromCenter.x) - Math.atan2(-halfDimensions.y, -halfDimensions.x);
            break;
        }

        var newDimensions = this._initialDimensions.clone().multiply(knobDistanceFromCenter.len() / initialDistanceFromCenter.len());

        var _props$options = this.props.options,
            snapRotation = _props$options.snapRotation,
            snapRotationTolerance = _props$options.snapRotationTolerance;

        var degrees = Math.round(radians * 180 / Math.PI);
        var nextSnap = Math.round(degrees / snapRotation) * snapRotation;
        var remainder = degrees - nextSnap;
        if (Math.abs(remainder) < snapRotationTolerance) {
          radians = nextSnap * Math.PI / 180;
        }

        sprite.set({
          dimensions: newDimensions,
          rotation: radians
        });
      } else {
        var zoom = this.context.editor.zoom.get();
        var rotation = sprite.getRotation();
        var cos = Math.cos(rotation * -1);
        var sin = Math.sin(rotation * -1);

        var localDistanceToCenter = new _globals.Vector2(knobDistanceFromCenter.x * cos - knobDistanceFromCenter.y * sin, knobDistanceFromCenter.x * sin + knobDistanceFromCenter.y * cos);

        var previousLocalDistanceToCenter = new _globals.Vector2(initialKnobDistanceFromCenter.x * cos - initialKnobDistanceFromCenter.y * sin, initialKnobDistanceFromCenter.x * sin + initialKnobDistanceFromCenter.y * cos);

        var distanceToCenterDiff = void 0;

        switch (side) {
          case 'bottom':
            distanceToCenterDiff = localDistanceToCenter.clone().subtract(previousLocalDistanceToCenter);
            break;
          case 'top':
            distanceToCenterDiff = previousLocalDistanceToCenter.clone().subtract(localDistanceToCenter);
            break;
        }

        var _newDimensions = this._initialDimensions.clone().add(distanceToCenterDiff.clone().divide(zoom).multiply(2));

        sprite.set({
          dimensions: _newDimensions
        });
      }
      editor.render();
    }

    /**
     * Gets called when the user stops dragging a knob
     * @private
     */

  }, {
    key: '_onKnobDragStop',
    value: function _onKnobDragStop() {
      this.props.onDragStop && this.props.onDragStop();
    }

    /**
     * Gets called when the user starts dragging the rotate knob
     * @param  {Vector2} position
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onRotateKnobDragStart',
    value: function _onRotateKnobDragStart(position, e) {
      this._initialPosition = this._getRotateKnobPosition();
      this.props.onDragStart && this.props.onDragStart();
    }

    /**
     * Gets called when the user stops dragging the rotate knob
     * @private
     */

  }, {
    key: '_onRotateKnobDragStop',
    value: function _onRotateKnobDragStop() {
      this.props.onDragStop && this.props.onDragStop();
    }

    /**
     * Gets called while the user drags a sticker
     * @param  {Vector2} offset
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onRotateKnobDrag',
    value: function _onRotateKnobDrag(offset, e) {
      var sprite = this.props.sprite;
      var editor = this.context.editor;

      var stickerPosition = this._getAbsoluteSpritePosition();
      var newKnobPosition = this._initialPosition.clone().add(offset);

      var halfDimensions = this._getStickerDimensions().divide(2);

      // Calculate new rotation and dimensions from new knob position
      var knobDistanceFromCenter = newKnobPosition.clone().subtract(stickerPosition);

      var radians = void 0;
      radians = Math.atan2(knobDistanceFromCenter.y, knobDistanceFromCenter.x) - Math.atan2(-halfDimensions.y, halfDimensions.x);

      sprite.set({
        rotation: radians
      });

      editor.render();
    }

    // -------------------------------------------------------------------------- STYLING

    /**
     * Returns the style object for the bottom right drag knob
     * @return {Object}
     * @private
     */

  }, {
    key: '_getBottomDragKnobStyle',
    value: function _getBottomDragKnobStyle() {
      var knobPosition = this._getBottomDragKnobPosition();

      return {
        left: knobPosition.x,
        top: knobPosition.y
      };
    }

    /**
     * Returns the style object for the top right drag knob
     * @return {Object}
     * @private
     */

  }, {
    key: '_getTopDragKnobStyle',
    value: function _getTopDragKnobStyle() {
      var knobPosition = this._getTopDragKnobPosition();

      return {
        left: knobPosition.x,
        top: knobPosition.y
      };
    }

    /**
     * Returns the style object for the rotate knob
     * @return {Object}
     * @private
     */

  }, {
    key: '_getRotateKnobStyle',
    value: function _getRotateKnobStyle() {
      var knobPosition = this._getRotateKnobPosition();

      return {
        left: knobPosition.x,
        top: knobPosition.y
      };
    }

    /**
     * Builds the style object for this sticker
     * @return {Object}
     * @private
     */

  }, {
    key: '_getStickerStyle',
    value: function _getStickerStyle() {
      var sprite = this.props.sprite;


      var processedDimensions = this._getStickerDimensions().abs();
      var spritePosition = this._getAbsoluteSpritePosition().subtract(processedDimensions.clone().divide(2));

      var degrees = sprite.getRotation() * 180 / Math.PI;
      var transform = 'rotate(' + degrees.toFixed(2) + 'deg)';

      var spriteDimensions = sprite.getDimensions();

      var flipVertically = sprite.getFlipVertically();
      if (spriteDimensions.y < 0) flipVertically = !flipVertically;
      if (flipVertically) {
        transform += ' scaleY(-1)';
      }

      var flipHorizontally = sprite.getFlipHorizontally();
      if (spriteDimensions.x < 0) flipHorizontally = !flipHorizontally;
      if (flipHorizontally) {
        transform += ' scaleX(-1)';
      }

      return {
        top: spritePosition.y,
        left: spritePosition.x,
        width: processedDimensions.x,
        height: processedDimensions.y,
        WebkitTransform: transform,
        msTransform: transform,
        MozTransform: transform,
        OTransform: transform
      };
    }

    // -------------------------------------------------------------------------- CALCULATIONS

    /**
     * Calculates the sticker dimensions
     * @param  {Object} sticker
     * @return {Vector2}
     * @private
     */

  }, {
    key: '_getStickerDimensions',
    value: function _getStickerDimensions() {
      var sprite = this.props.sprite;
      var editor = this.context.editor;


      return sprite.getDimensions().clone().multiply(editor.zoom.get());
    }

    /**
     * Calculates the rotate button knob's position
     * @return {PhotoEditorSDK.Math.Vector2}
     * @private
     */

  }, {
    key: '_getRotateKnobPosition',
    value: function _getRotateKnobPosition() {
      var sprite = this.props.sprite;

      var stickerPosition = this._getAbsoluteSpritePosition();
      var stickerRotation = sprite.getRotation();

      // Calculate sin and cos for rotation
      var sin = Math.sin(stickerRotation || 0);
      var cos = Math.cos(stickerRotation || 0);

      // Calculate sticker dimensions
      var halfDimensions = this._getStickerDimensions().divide(2);

      // Calculate knob position
      return stickerPosition.clone().add(halfDimensions.x * cos + halfDimensions.y * sin, halfDimensions.x * sin - halfDimensions.y * cos);
    }

    /**
     * Calculates the drag bottom right knob's position
     * @return {Vector2}
     * @private
     */

  }, {
    key: '_getBottomDragKnobPosition',
    value: function _getBottomDragKnobPosition() {
      var sprite = this.props.sprite;

      var stickerPosition = this._getAbsoluteSpritePosition();
      var stickerRotation = sprite.getRotation();

      // Calculate sin and cos for rotation
      var sin = Math.sin(stickerRotation || 0);
      var cos = Math.cos(stickerRotation || 0);

      // Calculate sticker dimensions
      var halfDimensions = this._getStickerDimensions().divide(2);

      // Calculate knob position
      return stickerPosition.clone().add(halfDimensions.x * cos - halfDimensions.y * sin, halfDimensions.x * sin + halfDimensions.y * cos);
    }

    /**
     * Calculates the drag top right knob's position
     * @return {Vector2}
     * @private
     */

  }, {
    key: '_getTopDragKnobPosition',
    value: function _getTopDragKnobPosition() {
      var sprite = this.props.sprite;

      var stickerPosition = this._getAbsoluteSpritePosition();
      var stickerRotation = sprite.getRotation();

      // Calculate sin and cos for rotation
      var sin = Math.sin(stickerRotation || 0);
      var cos = Math.cos(stickerRotation || 0);

      // Calculate sticker dimensions
      var halfDimensions = this._getStickerDimensions(sprite).divide(2);

      // Calculate knob position
      return stickerPosition.clone().subtract(halfDimensions.x * cos - halfDimensions.y * sin, halfDimensions.x * sin + halfDimensions.y * cos);
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the knobs for this item
     * @return {Array.<ReactBEM.Element>}
     * @private
     */

  }, {
    key: '_renderKnobs',
    value: function _renderKnobs() {
      var knobs = [];
      if (this.props.selected) {
        knobs = [_globals.ReactBEM.createElement(
          _draggableComponent2.default,
          {
            onStart: this._onKnobDragStart.bind(this, 'bottom'),
            onStop: this._onKnobDragStop.bind(this, 'bottom'),
            onDrag: this._onKnobDrag.bind(this, 'bottom') },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:knob $b:knob', style: this._getBottomDragKnobStyle() },
            _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/knobs/resize-diagonal-down.png', true) })
          )
        ), _globals.ReactBEM.createElement(
          _draggableComponent2.default,
          {
            onStart: this._onKnobDragStart.bind(this, 'top'),
            onStop: this._onKnobDragStop.bind(this, 'top'),
            onDrag: this._onKnobDrag.bind(this, 'top') },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:knob $b:knob', style: this._getTopDragKnobStyle() },
            _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/knobs/resize-diagonal-down.png', true) })
          )
        )];

        if (!this.props.options.fixedRatio) {
          knobs.push(_globals.ReactBEM.createElement(
            _draggableComponent2.default,
            {
              onStart: this._onRotateKnobDragStart,
              onStop: this._onRotateKnobDragStop,
              onDrag: this._onRotateKnobDrag },
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:knob $b:knob', style: this._getRotateKnobStyle() },
              _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/knobs/rotate.png', true) })
            )
          ));
        }
      }
      return knobs;
    }

    /**
     * Renders the SVG filters
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderSVGFilter',
    value: function _renderSVGFilter() {
      if (this.props.hideContent) return null;
      var sprite = this.props.sprite;

      var adjustments = sprite.getAdjustments();
      var brightness = adjustments.getBrightness();
      var saturation = adjustments.getSaturation();
      var contrast = adjustments.getContrast();

      var filtersSVG = '<filter id=\'pesdk-sticker-' + this._id + '-filter\'>\n        <feComponentTransfer>\n          <feFuncR type=\'linear\' intercept=\'' + brightness + '\' />\n          <feFuncG type=\'linear\' intercept=\'' + brightness + '\' />\n          <feFuncB type=\'linear\' intercept=\'' + brightness + '\' />\n        </feComponentTransfer>\n        <feColorMatrix type=\'saturate\' values=\'' + saturation + '\' />\n        <feComponentTransfer>\n          <feFuncR type=\'linear\' slope=\'' + contrast + '\' intercept=\'' + (-(0.5 * contrast) + 0.5) + '\' />\n          <feFuncG type=\'linear\' slope=\'' + contrast + '\' intercept=\'' + (-(0.5 * contrast) + 0.5) + '\' />\n          <feFuncB type=\'linear\' slope=\'' + contrast + '\' intercept=\'' + (-(0.5 * contrast) + 0.5) + '\' />\n        </feComponentTransfer>\n      </filter>';

      // We added `key: Math.random()` because in Safari, dangerouslySetInnerHTML
      // would not update without that...
      // https://github.com/facebook/react/issues/2863
      return _globals.ReactBEM.createElement(
        'svg',
        { width: '0', height: '0', 'color-interpolation-filters': 'sRGB', is: 'svg' },
        _globals.ReactBEM.createElement('defs', {
          key: Math.random(),
          dangerouslySetInnerHTML: {
            __html: filtersSVG
          }
        })
      );
    }

    /**
     * Renders the overlay that appears when the sprite is selected
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderSelectedOverlay',
    value: function _renderSelectedOverlay() {
      var selectedOverlayClassNames = [];
      if (this.props.selected) {
        selectedOverlayClassNames.push('is-selected');
      }
      selectedOverlayClassNames = selectedOverlayClassNames.join(' ');

      var overlayStyle = this._getStickerStyle();
      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: 'e:text' },
        _globals.ReactBEM.createElement(
          _draggableComponent2.default,
          {
            onStart: this._onItemDragStart,
            onStop: this._onItemDragStop,
            onDrag: this._onItemDrag,
            disabled: !this.props.selected },
          _globals.ReactBEM.createElement('div', { bem: 'e:selectedOverlay',
            onDoubleClick: this._onItemDoubleClick,
            onTouchStart: this._onItemTouchStart,
            onTouchEnd: this._onItemTouchEnd,
            style: overlayStyle,
            className: selectedOverlayClassNames })
        )
      );
    }

    /**
     * Renders the draggable item
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderItem',
    value: function _renderItem() {
      if (this.props.hideContent) return null;

      var sprite = this.props.sprite;

      var stickerStyle = this._getStickerStyle();

      var baseURL = window.location.href.replace(window.location.hash, '');
      var stickerImageStyle = { filter: 'url("' + baseURL + '#pesdk-sticker-' + this._id + '-filter")' };

      var svgStyle = { width: stickerStyle.width, height: stickerStyle.height };
      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: 'e:sticker' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:container', style: stickerStyle },
          _globals.ReactBEM.createElement(
            'svg',
            { width: parseInt(stickerStyle.width), height: parseInt(stickerStyle.height), 'color-interpolation-filters': 'sRGB', is: 'svg', style: svgStyle, preserveAspectRatio: 'none' },
            _globals.ReactBEM.createElement('image', {
              xlinkHref: sprite.getImage().src,
              width: stickerStyle.width,
              height: stickerStyle.height,
              style: stickerImageStyle,
              preserveAspectRatio: 'none'
            })
          )
        )
      );
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: 'b:spritesCanvasControls' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$e:item e:container' },
          this._renderSVGFilter(),
          this._renderItem(),
          this._renderSelectedOverlay(),
          this._renderKnobs()
        )
      );
    }
  }]);

  return StickerItemComponent;
}(_itemComponent2.default);

exports.default = StickerItemComponent;


StickerItemComponent.contextTypes = _itemComponent2.default.contextTypes;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _itemComponent = __webpack_require__(28);

var _itemComponent2 = _interopRequireDefault(_itemComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var BrushItemComponent = function (_ItemComponent) {
  _inherits(BrushItemComponent, _ItemComponent);

  function BrushItemComponent() {
    _classCallCheck(this, BrushItemComponent);

    return _possibleConstructorReturn(this, (BrushItemComponent.__proto__ || Object.getPrototypeOf(BrushItemComponent)).apply(this, arguments));
  }

  _createClass(BrushItemComponent, [{
    key: 'componentDidMount',

    // -------------------------------------------------------------------------- LIFECYCLE

    /**
     * Gets called when this component has been mounted
     */
    value: function componentDidMount() {
      _get(BrushItemComponent.prototype.__proto__ || Object.getPrototypeOf(BrushItemComponent.prototype), 'componentDidMount', this).call(this);
      if (this.props.hideContent) return;
      var canvas = this.props.sprite.getCanvas();
      this._appendCanvas(canvas);
    }

    /**
     * Gets called when this component is about to receive new properties
     * @param  {Object} nextProps
     */

  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.hideContent) return;
      if (nextProps.sprite !== this.props.sprite) {
        var canvas = this.props.sprite.getCanvas();
        canvas.parentNode.removeChild(canvas);
        var newCanvas = nextProps.sprite.getCanvas();
        this._appendCanvas(newCanvas);
      }
    }

    // -------------------------------------------------------------------------- MISC

    /**
     * Checks if this item is currently selected
     * @return {Boolean}
     */

  }, {
    key: '_isSelected',
    value: function _isSelected() {
      return this.getSharedState('brush') === this.props.sprite;
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Appends and styles the given canvas
     * @param  {HTMLCanvasElement} canvas
     * @private
     */

  }, {
    key: '_appendCanvas',
    value: function _appendCanvas(canvas) {
      var editor = this.context.editor;

      var outputDimensions = editor.getOutputDimensions();
      canvas.style.width = outputDimensions.x + 'px';
      canvas.style.height = outputDimensions.y + 'px';
      this.refs.brush.appendChild(canvas);
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      if (this.props.hideContent) return null;

      var brushClassName = this._isSelected() ? 'is-selected' : null;
      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: 'b:spritesCanvasControls' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$e:item e:container m:full', ref: 'container' },
          _globals.ReactBEM.createElement('div', {
            bem: '$e:brush',
            className: brushClassName,
            ref: 'brush' })
        )
      );
    }
  }]);

  return BrushItemComponent;
}(_itemComponent2.default);

exports.default = BrushItemComponent;


BrushItemComponent.contextTypes = _itemComponent2.default.contextTypes;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var StickerControlsOverlayComponent = function (_BaseComponent) {
  _inherits(StickerControlsOverlayComponent, _BaseComponent);

  function StickerControlsOverlayComponent() {
    _classCallCheck(this, StickerControlsOverlayComponent);

    return _possibleConstructorReturn(this, (StickerControlsOverlayComponent.__proto__ || Object.getPrototypeOf(StickerControlsOverlayComponent)).apply(this, arguments));
  }

  _createClass(StickerControlsOverlayComponent, [{
    key: '_onFlipClick',

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the user clicks one of the flip items
     * @param  {String} direction
     * @param  {Event} e
     * @private
     */
    value: function _onFlipClick(direction, e) {
      e.preventDefault();
      e.stopPropagation();

      this.props.onFlip && this.props.onFlip(direction);
    }

    /**
     * Gets called when the user clicks the `take to front` item
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onTakeToFrontClick',
    value: function _onTakeToFrontClick(e) {
      e.preventDefault();
      e.stopPropagation();

      this.props.onTakeToFront && this.props.onTakeToFront();
    }

    /**
     * Gets called when the user clicks the `remove` item
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onRemoveClick',
    value: function _onRemoveClick(e) {
      e.preventDefault();
      e.stopPropagation();

      this.props.onRemove && this.props.onRemove();
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the items of this component
     * @return {Array.<ReactBEM.Element>}
     */

  }, {
    key: '_renderItems',
    value: function _renderItems() {
      return [_globals.ReactBEM.createElement(
        'div',
        { bem: '$e:item', onClick: this._onFlipClick.bind(this, 'h') },
        _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/sprites/flip-h.png', true) })
      ), _globals.ReactBEM.createElement(
        'div',
        { bem: '$e:item', onClick: this._onFlipClick.bind(this, 'v') },
        _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/sprites/flip-v.png', true) })
      ), _globals.ReactBEM.createElement(
        'div',
        { bem: '$e:item', onClick: this._onTakeToFrontClick.bind(this) },
        _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/sprites/take-to-front.png', true) })
      ), _globals.ReactBEM.createElement('div', { bem: '$e:separator' }), _globals.ReactBEM.createElement(
        'div',
        { bem: '$e:item', onClick: this._onRemoveClick.bind(this) },
        _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/sprites/remove.png', true) })
      )];
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'div',
        {
          bem: '$b:spritesControlsOverlay' },
        this._renderItems()
      );
    }
  }]);

  return StickerControlsOverlayComponent;
}(_globals.BaseComponent);

exports.default = StickerControlsOverlayComponent;


StickerControlsOverlayComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _controls = __webpack_require__(4);

var _controls2 = _interopRequireDefault(_controls);

var _textCanvasControlsComponent = __webpack_require__(150);

var _textCanvasControlsComponent2 = _interopRequireDefault(_textCanvasControlsComponent);

var _textControlsComponent = __webpack_require__(152);

var _textControlsComponent2 = _interopRequireDefault(_textControlsComponent);

var _fontManager = __webpack_require__(15);

var _fontManager2 = _interopRequireDefault(_fontManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _SDK$Operations$Sprit = _globals.SDK.Operations.SpriteOperation,
    TextSprite = _SDK$Operations$Sprit.TextSprite,
    BrushSprite = _SDK$Operations$Sprit.BrushSprite;
/**
 * The text controls
 * @class
 * @extends PhotoEditorSDK.UI.ReactUI.Control
 * @memberof PhotoEditorSDK.UI.ReactUI.Controls
 */

var TextControls = function (_Controls) {
  _inherits(TextControls, _Controls);

  function TextControls() {
    _classCallCheck(this, TextControls);

    return _possibleConstructorReturn(this, (TextControls.__proto__ || Object.getPrototypeOf(TextControls)).apply(this, arguments));
  }

  _createClass(TextControls, [{
    key: 'saveTextSettings',

    /**
     * Saves the current text settings to the global state
     */
    value: function saveTextSettings() {
      var selectedSprite = this.getSharedState('selectedSprite');

      if (!selectedSprite) {
        return;
      }

      this.setGlobalToolState('text', selectedSprite.serializeOptions(['color', 'backgroundColor', 'characterSpacing', 'lineHeight', 'alignment', 'fontIdentifier', 'fontFamily', 'fontWeight', 'fontStyle']));
    }

    /**
     * Gets called when the user leaves these controls
     * @this {TextControlsComponent}
     * @ignore
     */

  }], [{
    key: 'onExit',
    value: function onExit() {
      var editor = this.context.editor;

      var operation = this.getSharedState('operation');

      this.saveTextSettings();

      if (!this.getSharedState('skipHistory')) {
        editor.history.add(operation, this.getSharedState('initialOptions'), this.getSharedState('operationExistedBefore'));
      }
      editor.zoom.restore();
      editor.features.enable('zoom', 'drag');
      editor.render();
    }

    /**
     * Gets called when the user enters these controls
     * @this {StickerControlsComponent}
     * @param {SharedState} sharedState
     * @override
     * @ignore
     */

  }, {
    key: 'onEnter',
    value: function onEnter(sharedState, options) {
      var _context = this.context,
          editor = _context.editor,
          ui = _context.ui;

      var operationExistedBefore = editor.operations.exists('sprite');
      var operation = editor.operations.getOrCreate('sprite');
      var sprites = operation.getSprites();
      var initialOptions = operation.serializeOptions();

      var fontManager = new _fontManager2.default(ui, options);
      var defaultFontVariation = fontManager.getDefaultVariation();

      this.setSharedState({
        operationExistedBefore: operationExistedBefore,
        operation: operation,
        sprites: sprites,
        initialOptions: initialOptions,
        fontManager: fontManager,
        defaultFontVariation: defaultFontVariation,
        fonts: fontManager.getFonts()
      });

      editor.zoom.save();
      editor.render();
    }

    /**
     * Checks if there is something at the given position that
     * would cause the UI to switch to this control on click
     * @param  {PhotoEditorSDK.Math.Vector2} position
     * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
     * @return {*}
     * @ignore
     */

  }, {
    key: 'clickAtPosition',
    value: function clickAtPosition(position, editor) {
      if (!editor.operations.exists('sprite')) return false;

      var operation = editor.operations.getOrCreate('sprite');
      var sprites = operation.getSpritesAtPosition(position, editor.getOutputTextureDimensions()).filter(function (s) {
        return !(s instanceof BrushSprite);
      });

      if (sprites.length && sprites[0] instanceof TextSprite) {
        return { selectedSprite: sprites[0] };
      } else {
        return false;
      }
    }

    /**
     * Checks if this control is available to the user
     * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
     * @return {Boolean}
     * @ignore
     */

  }, {
    key: 'isAvailable',
    value: function isAvailable(editor) {
      return editor.isToolAllowed('text') && editor.isToolEnabled('text');
    }

    /**
     * Returns the assets that should be preloaded for this control
     * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
     * @return {String[]}
     */

  }, {
    key: 'getPreloadAssets',
    value: function getPreloadAssets(editor) {
      return ['controls/text/align_left.png', 'controls/text/align_right.png', 'controls/text/align_center.png', 'controls/text/minus.png', 'controls/text/plus.png'];
    }
  }]);

  return TextControls;
}(_controls2.default);

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */


TextControls.controlsComponent = _textControlsComponent2.default;

/**
 * This control's canvas component. Used for the upper controls part of the editor (on
 * top of the canvas)
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */
TextControls.canvasControlsComponent = _textCanvasControlsComponent2.default;

/**
 * This control's identifier
 * @type {String}
 * @default
 */
TextControls.identifier = 'text';

/**
 * This control's icon path
 * @type {String}
 * @ignore
 */
TextControls.iconPath = 'controls/overview/text.png';

/**
 * The language key that should be used when displaying this filter
 * @type {String}
 * @ignore
 */
TextControls.languageKey = 'pesdk.text.title.name';

/**
 * The default options for this control
 * @type {Object}
 * @property {Object[]} [fonts = []]
 * @property {Boolean} [replaceFonts = false]
 * @property {String[]} [availableVariations = null]
 */
TextControls.defaultOptions = {
  fonts: [],
  replaceFonts: false,
  availableVariations: null

  /**
   * The operations required for this control to work properly
   * @type {Array}
   */
};TextControls.requiredOperations = ['sprite'];

exports.default = TextControls;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _spritesCanvasControlsComponent = __webpack_require__(14);

var _spritesCanvasControlsComponent2 = _interopRequireDefault(_spritesCanvasControlsComponent);

var _textControlsOverlayComponent = __webpack_require__(151);

var _textControlsOverlayComponent2 = _interopRequireDefault(_textControlsOverlayComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */


var TextCanvasControlsComponent = function (_SpritesCanvasControl) {
  _inherits(TextCanvasControlsComponent, _SpritesCanvasControl);

  function TextCanvasControlsComponent() {
    var _ref;

    _classCallCheck(this, TextCanvasControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = TextCanvasControlsComponent.__proto__ || Object.getPrototypeOf(TextCanvasControlsComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onTextEdit');
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the selected item is deselected
   * @private
   */


  _createClass(TextCanvasControlsComponent, [{
    key: '_onItemBlur',
    value: function _onItemBlur() {
      var sprite = this.getSharedState('selectedSprite');
      if (sprite && sprite.getText() === '') {
        sprite.setText(this._t('pesdk.text.placeholder.defaultText'));
        sprite._edited = false;
      }
    }

    /**
     * Gets called when the user removes the selected sprite
     * @private
     */

  }, {
    key: '_onSpriteRemove',
    value: function _onSpriteRemove() {
      _get(TextCanvasControlsComponent.prototype.__proto__ || Object.getPrototypeOf(TextCanvasControlsComponent.prototype), '_onSpriteRemove', this).call(this);
      this.props.onSwitchControls('home');
    }

    /**
     * Gets called when the clicks the edit button
     * @private
     */

  }, {
    key: '_onTextEdit',
    value: function _onTextEdit() {
      var sprite = this.getSharedState('selectedSprite');
      this.refs['sprite-' + sprite.getId()].enterEditMode();
    }

    /**
     * This renders controls on top of the sprites
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderOverlayControls',
    value: function _renderOverlayControls() {
      if (!this.getSharedState('selectedSprite')) return;

      return _globals.ReactBEM.createElement(_textControlsOverlayComponent2.default, {
        onTakeToFront: this._onSpriteTakeToFront,
        onRemove: this._onSpriteRemove,
        onEdit: this._onTextEdit });
    }
  }]);

  return TextCanvasControlsComponent;
}(_spritesCanvasControlsComponent2.default);

exports.default = TextCanvasControlsComponent;


TextCanvasControlsComponent.contextTypes = _spritesCanvasControlsComponent2.default.contextTypes;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var TextControlsOverlayComponent = function (_BaseComponent) {
  _inherits(TextControlsOverlayComponent, _BaseComponent);

  function TextControlsOverlayComponent() {
    _classCallCheck(this, TextControlsOverlayComponent);

    return _possibleConstructorReturn(this, (TextControlsOverlayComponent.__proto__ || Object.getPrototypeOf(TextControlsOverlayComponent)).apply(this, arguments));
  }

  _createClass(TextControlsOverlayComponent, [{
    key: '_onEditClick',

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the user clicks the `edit` item
     * @param  {Event} e
     * @private
     */
    value: function _onEditClick(e) {
      e.preventDefault();
      e.stopPropagation();

      this.props.onEdit && this.props.onEdit();
    }

    /**
     * Gets called when the user clicks the `take to front` item
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onTakeToFrontClick',
    value: function _onTakeToFrontClick(e) {
      e.preventDefault();
      e.stopPropagation();

      this.props.onTakeToFront && this.props.onTakeToFront();
    }

    /**
     * Gets called when the user clicks the `remove` item
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onRemoveClick',
    value: function _onRemoveClick(e) {
      e.preventDefault();
      e.stopPropagation();

      this.props.onRemove && this.props.onRemove();
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the items of this component
     * @return {Array.<ReactBEM.Element>}
     */

  }, {
    key: '_renderItems',
    value: function _renderItems() {
      var items = [_globals.ReactBEM.createElement(
        'div',
        { bem: '$e:item', onClick: this._onTakeToFrontClick.bind(this) },
        _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/sprites/take-to-front.png', true) })
      )];

      if (_globals.Utils.isTouchDevice()) {
        items = items.concat([_globals.ReactBEM.createElement('div', { bem: '$e:separator' }), _globals.ReactBEM.createElement(
          'div',
          { bem: '$e:item', onClick: this._onEditClick.bind(this) },
          _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/sprites/edit.png', true) })
        )]);
      }

      items = items.concat([_globals.ReactBEM.createElement('div', { bem: '$e:separator' }), _globals.ReactBEM.createElement(
        'div',
        { bem: '$e:item', onClick: this._onRemoveClick.bind(this) },
        _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/sprites/remove.png', true) })
      )]);

      return items;
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'div',
        {
          bem: '$b:spritesControlsOverlay' },
        this._renderItems()
      );
    }
  }]);

  return TextControlsOverlayComponent;
}(_globals.BaseComponent);

exports.default = TextControlsOverlayComponent;


TextControlsOverlayComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _controlsComponent = __webpack_require__(3);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _scrollbarComponent = __webpack_require__(2);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

var _colorPickerComponent = __webpack_require__(29);

var _colorPickerComponent2 = _interopRequireDefault(_colorPickerComponent);

var _sliderOverlayComponent = __webpack_require__(6);

var _sliderOverlayComponent2 = _interopRequireDefault(_sliderOverlayComponent);

var _fontPreviewComponent = __webpack_require__(46);

var _fontPreviewComponent2 = _interopRequireDefault(_fontPreviewComponent);

var _fontComponent = __webpack_require__(157);

var _fontComponent2 = _interopRequireDefault(_fontComponent);

var _modalManager = __webpack_require__(1);

var _modalManager2 = _interopRequireDefault(_modalManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ALIGNMENTS = ['left', 'center', 'right'];

var TextControlsComponent = function (_ControlsComponent) {
  _inherits(TextControlsComponent, _ControlsComponent);

  function TextControlsComponent() {
    var _ref;

    _classCallCheck(this, TextControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = TextControlsComponent.__proto__ || Object.getPrototypeOf(TextControlsComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onFontSizeChange', '_onFontChange', '_onAlignmentClick', '_onTakeToFrontClick', '_onForegroundColorChange', '_onBackgroundColorChange', '_onBeforeHistoryUndo');
    _this._events = _defineProperty({}, _globals.Constants.EVENTS.HISTORY_BEFORE_UNDO, _this._onBeforeHistoryUndo);
    _this._operation = _this.getSharedState('operation');
    _this._fontLoader = _this.context.ui.getFontLoader();
    _this._fontLoader.setFonts(_this.getSharedState('fonts'));

    _this.state = { mode: null, loading: true };

    var editor = _this.context.editor;

    editor.render();

    _this._fonts = _this.getSharedState('fonts');
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  _createClass(TextControlsComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      _get(TextControlsComponent.prototype.__proto__ || Object.getPrototypeOf(TextControlsComponent.prototype), 'componentDidMount', this).call(this);

      var editor = this.context.editor;

      editor.zoom.set('auto', function () {
        editor.features.disable('zoom', 'drag');
      });

      var fontsLoaded = function fontsLoaded() {
        _this2._createText();
        _this2.setState({ loading: false });
      };

      if (this._fontLoader.needsToLoad()) {
        this._loadFonts().then(fontsLoaded.bind(this));
      } else {
        fontsLoaded();
      }
    }

    /**
     * Loads the fonts
     * @return {Promise}
     * @private
     */

  }, {
    key: '_loadFonts',
    value: function _loadFonts() {
      var _this3 = this;

      var loadingModal = _modalManager2.default.instance.displayLoading(this._t('pesdk.common.text.loading'));
      return this._fontLoader.load().then(function () {
        loadingModal.close();
      }).catch(function (e) {
        loadingModal.close();
        _modalManager2.default.instance.displayWarning(_this3._t('pesdk.text.title.loadingFontsFailed'), _this3._t('pesdk.text.text.loadingFontsFailed'));
      });
    }

    /**
     * Creates a new text object
     * @private
     */

  }, {
    key: '_createText',
    value: function _createText() {
      var editor = this.context.editor;

      var selectedSprite = this.getSharedState('selectedSprite');
      var operation = this.getSharedState('operation');
      var fontManager = this.getSharedState('fontManager');

      // Check for previously saved text settings in the global state
      var defaultOptions = this.getGlobalToolState('text');

      var defaultFontVariation = defaultOptions ? this.getSharedState('defaultFontVariation') : fontManager.getDefaultVariation();

      var outputDimensions = editor.getOutputDimensions();
      if (!selectedSprite) {
        var sdk = editor.getSDK();
        var renderer = sdk.getRenderer();

        var maxTextureSize = renderer.getMaxTextureSize();
        var text = operation.createText(_extends({
          fontIdentifier: defaultFontVariation.getIdentifier(),
          text: this._t('pesdk.text.placeholder.defaultText'),
          position: new _globals.Vector2(0.5, 0.5),
          pivot: new _globals.Vector2(0.5, 0.5),
          maxWidth: 0.5,
          maxHeight: maxTextureSize ? maxTextureSize / outputDimensions.y : 3,
          fontSize: 0.08,
          fontFamily: defaultFontVariation.getFont().getFontFamily(),
          fontWeight: defaultFontVariation.getFontWeight(),
          fontStyle: defaultFontVariation.getFontStyle(),
          alignment: 'center'
        }, defaultOptions || {}));
        operation.addSprite(text);
        this.setSharedState({ selectedSprite: text });
        editor.render();
      }
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called before a history item is being undone
     * @param  {Object} historyObject
     * @private
     */

  }, {
    key: '_onBeforeHistoryUndo',
    value: function _onBeforeHistoryUndo(historyObject) {
      var operation = historyObject.operation,
          options = historyObject.options;

      if (operation !== this.getSharedState('operation')) return;

      var sprites = options.sprites;

      if (sprites.indexOf(this.getSharedState('selectedSprite')) === -1) {
        // Currently selected sprite is being removed. Leave control without adding history item.
        this.setSharedState({ skipHistory: true }, false);
        this.props.onSwitchControls('home');
      }
    }

    /**
     * Gets called when the user clicks the back button
     * @param {Event} e
     * @private
     */

  }, {
    key: '_onBackClick',
    value: function _onBackClick(e) {
      var editor = this.context.editor;

      this.saveTextSettings();
      editor.render();
      this._backButtonClicked = true;
      this.props.onSwitchControls('home');
    }

    /**
     * Saves the current text settings to the global state
     */

  }, {
    key: 'saveTextSettings',
    value: function saveTextSettings() {
      var selectedSprite = this.getSharedState('selectedSprite');

      if (!selectedSprite) {
        return;
      }

      this.setGlobalToolState('text', selectedSprite.serializeOptions(['color', 'backgroundColor', 'characterSpacing', 'lineHeight', 'alignment', 'fontIdentifier', 'fontFamily', 'fontWeight', 'fontStyle']));
    }

    /**
     * Gets called when the shared state has changed
     * @param  {Object} newState
     */

  }, {
    key: 'sharedStateDidChange',
    value: function sharedStateDidChange(newState) {
      if ('selectedSprite' in newState) {
        this.forceUpdate();
      }
    }

    /**
     * Gets called when the font size has been changed
     * @param  {Number} fontSize
     * @private
     */

  }, {
    key: '_onFontSizeChange',
    value: function _onFontSizeChange(fontSize) {
      var editor = this.context.editor;

      var outputDimensions = this.context.editor.getOutputDimensions();
      var selectedText = this.getSharedState('selectedSprite');
      selectedText.setFontSize(fontSize / outputDimensions.y);
      this.forceUpdate();
      editor.render();
    }

    /**
     * Gets called when the font family or weight has been changed
     * @param  {Object} variation
     * @private
     */

  }, {
    key: '_onFontChange',
    value: function _onFontChange(variation) {
      var editor = this.context.editor;

      var selectedText = this.getSharedState('selectedSprite');
      selectedText.setFontFamily(variation.getFont().getFontFamily());
      selectedText.setFontWeight(variation.getFontWeight());
      selectedText.setFontStyle(variation.getFontStyle());
      selectedText.setFontIdentifier(variation.getIdentifier());
      this.forceUpdate();
      editor.render();
    }

    /**
     * Gets called when the user clicks the alignment button
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onAlignmentClick',
    value: function _onAlignmentClick(e) {
      var editor = this.context.editor;

      var selectedText = this.getSharedState('selectedSprite');
      var alignment = selectedText.getAlignment();

      var currentIndex = ALIGNMENTS.indexOf(alignment);
      var nextIndex = (currentIndex + 1) % ALIGNMENTS.length;
      var newAlignment = ALIGNMENTS[nextIndex];

      selectedText.setAlignment(newAlignment);
      this.forceSharedUpdate();
      editor.render();
    }

    /**
     * Gets called when the user clicks the "take to front" button
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onTakeToFrontClick',
    value: function _onTakeToFrontClick(e) {
      var editor = this.context.editor;

      var operation = this.getSharedState('operation');
      operation.takeSpriteToFront(this.getSharedState('selectedSprite'));
      this.forceSharedUpdate();
      editor.render();
    }

    /**
     * Gets called when the user changes the foreground color
     * @param  {Color} color
     * @private
     */

  }, {
    key: '_onForegroundColorChange',
    value: function _onForegroundColorChange(color) {
      var editor = this.context.editor;

      var selectedText = this.getSharedState('selectedSprite');
      selectedText.setColor(color);
      editor.render();
    }

    /**
     * Gets called when the user changes the background color
     * @param  {Color} color
     * @private
     */

  }, {
    key: '_onBackgroundColorChange',
    value: function _onBackgroundColorChange(color) {
      var editor = this.context.editor;

      var selectedText = this.getSharedState('selectedSprite');
      selectedText.setBackgroundColor(color);
      editor.render();
    }

    // -------------------------------------------------------------------------- MODES

    /**
     * Switches to the given mode
     * @param  {String} mode
     * @private
     */

  }, {
    key: '_switchToMode',
    value: function _switchToMode(mode) {
      if (mode === this.state.mode) mode = null;

      this.setState({ mode: mode });
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the overlay controls of this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderOverlayControls',
    value: function renderOverlayControls() {
      switch (this.state.mode) {
        case 'size':
          return this._renderFontSizeOverlayControl();
        case 'font':
          return this._renderFontFamilyOverlayControl();
        default:
          return null;
      }
    }

    // -------------------------------------------------------------------------- FONT SIZE

    /**
     * Renders the font size overlay control (slider)
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderFontSizeOverlayControl',
    value: function _renderFontSizeOverlayControl() {
      var selectedText = this.getSharedState('selectedSprite');
      if (!selectedText) return;

      var editor = this.context.editor;

      var outputDimensions = editor.getOutputDimensions();

      var maxFontSize = Math.round(outputDimensions.y);
      var fontSize = Math.round(selectedText.getFontSize() * outputDimensions.y);
      return _globals.ReactBEM.createElement(_sliderOverlayComponent2.default, {
        value: fontSize,
        minValue: outputDimensions.y * 0.05,
        maxValue: maxFontSize,
        label: this._t('pesdk.text.button.size'),
        onChange: this._onFontSizeChange });
    }

    /**
     * Renders the font size list item
     * @return {Component}
     * @private
     */

  }, {
    key: '_renderSizeItem',
    value: function _renderSizeItem() {
      var selectedText = this.getSharedState('selectedSprite');
      if (!selectedText) return;

      var outputDimensions = this.context.editor.getOutputDimensions();

      var fontSize = selectedText.getFontSize();
      var className = this.state.mode === 'size' ? 'is-active' : null;

      return _globals.ReactBEM.createElement(
        'li',
        {
          bem: 'e:item',
          key: 'size' },
        _globals.ReactBEM.createElement(
          'bem',
          { specifier: '$b:controls' },
          _globals.ReactBEM.createElement(
            'div',
            {
              bem: '$e:button m:withLabel',
              className: className,
              'data-identifier': 'fontSize',
              onClick: this._switchToMode.bind(this, 'size') },
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'b:fontSize e:text' },
              Math.round(fontSize * outputDimensions.y)
            ),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:label' },
              this._t('pesdk.text.button.size')
            )
          )
        )
      );
    }

    // -------------------------------------------------------------------------- FONT FAMILY

    /**
     * Renders the font family overlay control
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderFontFamilyOverlayControl',
    value: function _renderFontFamilyOverlayControl() {
      var selectedText = this.getSharedState('selectedSprite');
      if (!selectedText) return;

      return _globals.ReactBEM.createElement(_fontComponent2.default, {
        fontFamily: selectedText.getFontFamily(),
        fontWeight: selectedText.getFontWeight(),
        fontStyle: selectedText.getFontStyle(),
        fonts: this._fonts,
        onChange: this._onFontChange });
    }

    /**
     * Renders the font list item
     * @return {Component}
     * @private
     */

  }, {
    key: '_renderFontItem',
    value: function _renderFontItem() {
      var selectedText = this.getSharedState('selectedSprite');
      if (!selectedText) return;

      var className = this.state.mode === 'font' ? 'is-active' : null;
      return _globals.ReactBEM.createElement(
        'li',
        {
          bem: 'e:item',
          key: 'font' },
        _globals.ReactBEM.createElement(
          'bem',
          { specifier: '$b:controls' },
          _globals.ReactBEM.createElement(
            'div',
            {
              bem: '$e:button m:withLabel',
              className: className,
              'data-identifier': 'font',
              onClick: this._switchToMode.bind(this, 'font') },
            _globals.ReactBEM.createElement(_fontPreviewComponent2.default, {
              fontFamily: selectedText.getFontFamily(),
              fontWeight: selectedText.getFontWeight(),
              fontStyle: selectedText.getFontStyle() }),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:label' },
              this._t('pesdk.text.button.font')
            )
          )
        )
      );
    }

    // -------------------------------------------------------------------------- ALIGNMENT

    /**
     * Renders the text alignment list item
     * @return {Component}
     * @private
     */

  }, {
    key: '_renderAlignmentItem',
    value: function _renderAlignmentItem() {
      var selectedText = this.getSharedState('selectedSprite');
      if (!selectedText) return;

      var alignment = selectedText.getAlignment();

      return _globals.ReactBEM.createElement(
        'li',
        {
          bem: 'e:item',
          key: 'alignment' },
        _globals.ReactBEM.createElement(
          'bem',
          { specifier: '$b:controls' },
          _globals.ReactBEM.createElement(
            'div',
            {
              bem: '$e:button m:withLabel',
              onClick: this._onAlignmentClick,
              'data-identifier': 'alignment' },
            _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/text/align_' + alignment + '.png', true) }),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:label' },
              this._t('pesdk.text.button.alignment')
            )
          )
        )
      );
    }

    /**
     * Renders the "take to front" list item
     * @return {Component}
     * @private
     */

  }, {
    key: '_renderTakeToFrontItem',
    value: function _renderTakeToFrontItem() {
      return _globals.ReactBEM.createElement(
        'li',
        {
          bem: 'e:item',
          key: 'takeToFront' },
        _globals.ReactBEM.createElement(
          'bem',
          { specifier: '$b:controls' },
          _globals.ReactBEM.createElement(
            'div',
            {
              bem: '$e:button m:withLabel',
              onClick: this._onTakeToFrontClick },
            _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/sprites/take_to_front.png', true) }),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:label' },
              this._t('pesdk.text.button.takeToFront')
            )
          )
        )
      );
    }

    /**
     * Renders this component
     * @return {Array.<ReactBEM.Element>}
     */

  }, {
    key: 'renderControls',
    value: function renderControls() {
      if (this.state.loading) return _globals.ReactBEM.createElement('div', null);

      var listItems = [this._renderSizeItem(), this._renderFontItem(), this._renderAlignmentItem()];

      var selectedText = this.getSharedState('selectedSprite');

      var foregroundColor = selectedText.getColor().clone();
      var backgroundColor = selectedText.getBackgroundColor().clone();

      return [_globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell m:list' },
        _globals.ReactBEM.createElement(
          _scrollbarComponent2.default,
          { ref: 'scrollbar' },
          _globals.ReactBEM.createElement(
            'ul',
            { bem: '$e:list' },
            listItems
          )
        )
      ), _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell m:colorPicker' },
        _globals.ReactBEM.createElement(_colorPickerComponent2.default, {
          initialValue: foregroundColor,
          label: this._t('pesdk.text.button.foreground'),
          onChange: this._onForegroundColorChange })
      ), _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell m:colorPicker' },
        _globals.ReactBEM.createElement(_colorPickerComponent2.default, {
          initialValue: backgroundColor,
          label: this._t('pesdk.text.button.background'),
          onChange: this._onBackgroundColorChange })
      )];
    }
  }]);

  return TextControlsComponent;
}(_controlsComponent2.default);

exports.default = TextControlsComponent;


TextControlsComponent.contextTypes = _controlsComponent2.default.contextTypes;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _alphaComponent = __webpack_require__(154);

var _alphaComponent2 = _interopRequireDefault(_alphaComponent);

var _saturationComponent = __webpack_require__(155);

var _saturationComponent2 = _interopRequireDefault(_saturationComponent);

var _hueComponent = __webpack_require__(156);

var _hueComponent2 = _interopRequireDefault(_hueComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ColorPickerOverlayComponent = function (_BaseComponent) {
  _inherits(ColorPickerOverlayComponent, _BaseComponent);

  function ColorPickerOverlayComponent() {
    var _ref;

    _classCallCheck(this, ColorPickerOverlayComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = ColorPickerOverlayComponent.__proto__ || Object.getPrototypeOf(ColorPickerOverlayComponent)).call.apply(_ref, [this].concat(args)));

    _this._value = _this.props.initialValue.clone();
    var hsvArr = _this._value.toHSV();
    var h = hsvArr[0];
    var s = hsvArr[1];
    var v = hsvArr[2];
    _this._hsv = { h: h, s: s, v: v };

    _this._bindAll('_onElementClick', '_onColorChange', '_onDocumentClick');
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  _createClass(ColorPickerOverlayComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      _get(ColorPickerOverlayComponent.prototype.__proto__ || Object.getPrototypeOf(ColorPickerOverlayComponent.prototype), 'componentDidMount', this).call(this);

      document.addEventListener('click', this._onDocumentClick);
    }

    /**
     * Gets called when this component is about to be unmounted
     */

  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      _get(ColorPickerOverlayComponent.prototype.__proto__ || Object.getPrototypeOf(ColorPickerOverlayComponent.prototype), 'componentWillUnmount', this).call(this);

      document.removeEventListener('click', this._onDocumentClick);
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the user clicks anywhere on the screen. If the click is outside
     * of the color picker and the color picker is visible, we hide this color picker.
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onDocumentClick',
    value: function _onDocumentClick(e) {
      for (var element = e.target; element; element = element.parentNode) {
        if (element === this.refs.root) {
          return;
        }
      }
      this.props.onClose && this.props.onClose();
    }

    /**
     * Catches clicks on the element and makes sure that no click event is triggered
     * on the parent element
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onElementClick',
    value: function _onElementClick(e) {
      e.stopPropagation();
    }

    /**
     * Gets called when the color changes
     * @param  {Color} color
     * @private
     */

  }, {
    key: '_onColorChange',
    value: function _onColorChange(color) {
      this._value = color;
      this.props.onChange && this.props.onChange(color);
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var alphaComponent = void 0;
      if (this.props.alpha !== false) {
        alphaComponent = _globals.ReactBEM.createElement(_alphaComponent2.default, {
          initialValue: this._value,
          onChange: this._onColorChange
        });
      }

      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:colorPicker $e:overlay', onClick: this._onElementClick, ref: 'root' },
        alphaComponent,
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:bottom' },
          _globals.ReactBEM.createElement(_saturationComponent2.default, {
            initialValue: this._value,
            onChange: this._onColorChange
          }),
          _globals.ReactBEM.createElement(_hueComponent2.default, {
            initialValue: this._value,
            onChange: this._onColorChange
          })
        )
      );
    }
  }]);

  return ColorPickerOverlayComponent;
}(_globals.BaseComponent);

exports.default = ColorPickerOverlayComponent;


ColorPickerOverlayComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _draggableComponent = __webpack_require__(5);

var _draggableComponent2 = _interopRequireDefault(_draggableComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var AlphaComponent = function (_BaseComponent) {
  _inherits(AlphaComponent, _BaseComponent);

  function AlphaComponent() {
    var _ref;

    _classCallCheck(this, AlphaComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = AlphaComponent.__proto__ || Object.getPrototypeOf(AlphaComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onKnobDrag', '_onKnobDragStart');

    _this._value = _this.props.initialValue.clone();
    _this._transparentPatternCanvas = _globals.Utils.createTransparentPatternCanvas();
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called after this component has been mounted
   */


  _createClass(AlphaComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      _get(AlphaComponent.prototype.__proto__ || Object.getPrototypeOf(AlphaComponent.prototype), 'componentDidMount', this).call(this);
      this._renderCanvas();
    }

    /**
     * Gets called when this component receives new props or state
     * @param  {Object} newProps
     * @return {Boolean}
     */

  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(newProps) {
      var initialValue = newProps.initialValue;

      if (initialValue !== this._value) {
        this._value = initialValue.clone();
        this._renderCanvas();
        return true;
      }
      return false;
    }

    // -------------------------------------------------------------------------- DRAG EVENTS

    /**
     * Gets called when the user starts dragging the knob
     * @param  {Vector2} position
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onKnobDragStart',
    value: function _onKnobDragStart(position, e) {
      if (e.target === this.refs.knob) {
        this._initialAlpha = this._value.a;
      } else {
        this._setAlphaFromPosition(position);
      }
    }

    /**
     * Gets called while the user drags the knob
     * @param  {Vector2} offset
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onKnobDrag',
    value: function _onKnobDrag(offset, e) {
      var canvas = this.refs.canvas;
      var canvasWidth = canvas.offsetWidth;

      var alphaChange = offset.x / canvasWidth;
      this._setAlpha(this._initialAlpha + alphaChange);
    }

    // -------------------------------------------------------------------------- STYLING

    /**
     * Returns the style object for the knob
     * @return {Object}
     * @private
     */

  }, {
    key: '_getKnobStyle',
    value: function _getKnobStyle() {
      return {
        left: (this._value.a * 100).toFixed(2) + '%',
        top: '50%'
      };
    }

    // -------------------------------------------------------------------------- MISC

    /**
     * Sets the alpha value of the color to the given one
     * @param {Number} a
     * @private
     */

  }, {
    key: '_setAlpha',
    value: function _setAlpha(a) {
      this._value.a = a;
      this._value.a = Math.min(1, Math.max(0, this._value.a));
      this.forceUpdate();
      this.props.onChange && this.props.onChange(this._value);
    }

    /**
     * Sets the alpha from the given cursor position
     * @param {Vector2} position
     * @private
     */

  }, {
    key: '_setAlphaFromPosition',
    value: function _setAlphaFromPosition(position) {
      var canvas = this.refs.canvas;
      this._initialAlpha = position.x / canvas.offsetWidth;
      this._setAlpha(this._initialAlpha);
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the canvas with the current color
     * @private
     */

  }, {
    key: '_renderCanvas',
    value: function _renderCanvas() {
      var canvas = this.refs.canvas;
      var context = canvas.getContext('2d');

      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;

      // Fill with pattern
      var pattern = context.createPattern(this._transparentPatternCanvas, 'repeat');
      context.fillStyle = pattern;
      context.fillRect(0, 0, canvas.width, canvas.height);

      // Create gradient
      var gradient = context.createLinearGradient(0, 0, canvas.width, canvas.height);
      var color = this._value.clone();
      color.a = 0;
      gradient.addColorStop(0, color.toRGBA());
      gradient.addColorStop(1, this._value.toHex());

      // Draw gradient
      context.fillStyle = gradient;
      context.fillRect(0, 0, canvas.width, canvas.height);
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:colorPicker $e:alpha' },
        _globals.ReactBEM.createElement(
          _draggableComponent2.default,
          {
            onStart: this._onKnobDragStart,
            onDrag: this._onKnobDrag },
          _globals.ReactBEM.createElement(
            'div',
            null,
            _globals.ReactBEM.createElement('canvas', { bem: 'e:canvas', ref: 'canvas' }),
            _globals.ReactBEM.createElement('div', {
              bem: 'e:knob $b:knob m:transparent',
              ref: 'knob',
              style: this._getKnobStyle() })
          )
        )
      );
    }
  }]);

  return AlphaComponent;
}(_globals.BaseComponent);

exports.default = AlphaComponent;


AlphaComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _draggableComponent = __webpack_require__(5);

var _draggableComponent2 = _interopRequireDefault(_draggableComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var SaturationComponent = function (_BaseComponent) {
  _inherits(SaturationComponent, _BaseComponent);

  function SaturationComponent() {
    var _ref;

    _classCallCheck(this, SaturationComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = SaturationComponent.__proto__ || Object.getPrototypeOf(SaturationComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onKnobDrag', '_onKnobDragStart');

    _this._value = _this.props.initialValue.clone();
    var hsvArr = _this._value.toHSV();
    var h = hsvArr[0];
    var s = hsvArr[1];
    var v = hsvArr[2];
    _this._hsvColor = { h: h, s: s, v: v };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called after this component has been mounted
   */


  _createClass(SaturationComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      _get(SaturationComponent.prototype.__proto__ || Object.getPrototypeOf(SaturationComponent.prototype), 'componentDidMount', this).call(this);
      this._renderCanvas();
    }

    /**
     * Gets called when this component receives new props or state
     * @param  {Object} newProps
     * @return {Boolean}
     */

  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(newProps) {
      var initialValue = newProps.initialValue;

      if (initialValue !== this._value) {
        this._value = initialValue.clone();
        var hsvArr = this._value.toHSV();
        var h = hsvArr[0];
        var s = hsvArr[1];
        var v = hsvArr[2];
        this._hsvColor = { h: h, s: s, v: v };
        this._renderCanvas();
        return true;
      }
      return false;
    }

    // -------------------------------------------------------------------------- DRAG EVENTS

    /**
     * Gets called when the user starts dragging the knob
     * @param  {Vector} position
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onKnobDragStart',
    value: function _onKnobDragStart(position, e) {
      if (e.target === this.refs.knob) {
        this._initialValue = this._hsvColor.v;
        this._initialSaturation = this._hsvColor.s;
      } else {
        this._setValuesFromPosition(position);
      }
    }

    /**
     * Gets called while the user drags the knob
     * @param  {Vector2} offset
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onKnobDrag',
    value: function _onKnobDrag(offset, e) {
      var canvas = this.refs.canvas;

      var canvasWidth = canvas.offsetWidth;
      var canvasHeight = canvas.offsetHeight;

      var saturationChange = offset.x / canvasWidth;
      var valueChange = offset.y / canvasHeight * -1;

      var h = this._hsvColor.h;

      this._setHSV(h, this._initialSaturation + saturationChange, this._initialValue + valueChange);
    }

    // -------------------------------------------------------------------------- STYLING

    /**
     * Returns the style object for the knob
     * @return {Object}
     * @private
     */

  }, {
    key: '_getKnobStyle',
    value: function _getKnobStyle() {
      var _hsvColor = this._hsvColor,
          s = _hsvColor.s,
          v = _hsvColor.v;


      return {
        left: (s * 100).toFixed(2) + '%',
        top: ((1 - v) * 100).toFixed(2) + '%'
      };
    }

    // -------------------------------------------------------------------------- MISC

    /**
     * Sets the HSV values of the color to the given values
     * @param {Number} h
     * @param {Number} s
     * @param {Number} v
     * @private
     */

  }, {
    key: '_setHSV',
    value: function _setHSV(h, s, v) {
      s = Math.max(0.01, Math.min(s, 0.99));
      v = Math.max(0.01, Math.min(v, 0.99));
      this._value = _globals.Color.fromHSV(h, s, v, this._value.a);
      this._hsvColor = { h: h, s: s, v: v };

      this.forceUpdate();
      this.props.onChange && this.props.onChange(this._value);
    }

    /**
     * Sets the values from the given cursor position
     * @param {Vector2} position
     * @private
     */

  }, {
    key: '_setValuesFromPosition',
    value: function _setValuesFromPosition(position) {
      var canvas = this.refs.canvas;

      this._initialSaturation = position.x / canvas.offsetWidth;
      this._initialValue = 1 - position.y / canvas.offsetHeight;

      var h = this._hsvColor.h;

      this._setHSV(h, this._initialSaturation, this._initialValue);
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the current color to the canvas
     * @private
     */

  }, {
    key: '_renderCanvas',
    value: function _renderCanvas() {
      var canvas = this.refs.canvas;

      var context = canvas.getContext('2d');

      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;

      var imageData = context.getImageData(0, 0, canvas.width, canvas.height);

      for (var y = 0; y < canvas.height; y++) {
        var value = (canvas.height - y) / canvas.height;
        for (var x = 0; x < canvas.width; x++) {
          var saturation = x / canvas.width;
          var color = _globals.Color.fromHSV(this._hsvColor.h, saturation, value);
          var r = color.r,
              g = color.g,
              b = color.b,
              a = color.a;


          var index = (y * canvas.width + x) * 4;

          imageData.data[index] = r * 255;
          imageData.data[index + 1] = g * 255;
          imageData.data[index + 2] = b * 255;
          imageData.data[index + 3] = a * 255;
        }
      }

      context.putImageData(imageData, 0, 0);
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:colorPicker $e:saturation' },
        _globals.ReactBEM.createElement(
          _draggableComponent2.default,
          {
            onStart: this._onKnobDragStart,
            onDrag: this._onKnobDrag },
          _globals.ReactBEM.createElement(
            'div',
            null,
            _globals.ReactBEM.createElement('canvas', { bem: 'e:canvas', ref: 'canvas' }),
            _globals.ReactBEM.createElement('div', {
              bem: 'e:knob $b:knob m:transparent',
              ref: 'knob',
              style: this._getKnobStyle() })
          )
        )
      );
    }
  }]);

  return SaturationComponent;
}(_globals.BaseComponent);

exports.default = SaturationComponent;


SaturationComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _draggableComponent = __webpack_require__(5);

var _draggableComponent2 = _interopRequireDefault(_draggableComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var HueComponent = function (_BaseComponent) {
  _inherits(HueComponent, _BaseComponent);

  function HueComponent() {
    var _ref;

    _classCallCheck(this, HueComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = HueComponent.__proto__ || Object.getPrototypeOf(HueComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onKnobDrag', '_onKnobDragStart');

    _this._value = _this.props.initialValue.clone();
    var hsvArr = _this._value.toHSV();
    var h = hsvArr[0];
    var s = hsvArr[1];
    var v = hsvArr[2];
    _this._hsvColor = { h: h, s: s, v: v };

    _this.state = {
      value: _this.props.initialValue
    };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called after this component has been mounted
   */


  _createClass(HueComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      _get(HueComponent.prototype.__proto__ || Object.getPrototypeOf(HueComponent.prototype), 'componentDidMount', this).call(this);
      this._renderCanvas();
    }

    /**
     * Gets called when this component receives new props or state
     * @param  {Object} newProps
     * @return {Boolean}
     */

  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(newProps) {
      var initialValue = newProps.initialValue;

      if (initialValue !== this._value) {
        this._value = initialValue.clone();
        var hsvArr = this._value.toHSV();
        var h = hsvArr[0];
        var s = hsvArr[1];
        var v = hsvArr[2];
        this._hsvColor = { h: h, s: s, v: v };
        this._renderCanvas();
        return true;
      }
      return false;
    }

    // -------------------------------------------------------------------------- DRAG EVENTS

    /**
     * Gets called when the user starts dragging the knob
     * @param  {Vector2} position
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onKnobDragStart',
    value: function _onKnobDragStart(position, e) {
      if (e.target === this.refs.knob) {
        this._initialHue = this._hsvColor.h;
      } else {
        this._setValueFromPosition(position);
      }
    }

    /**
     * Gets called while the user drags the knob
     * @param  {Vector2} offset
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onKnobDrag',
    value: function _onKnobDrag(offset, e) {
      var canvas = this.refs.canvas;

      var canvasHeight = canvas.offsetHeight;

      var hueChange = offset.y / canvasHeight;
      this._setHue(this._initialHue + hueChange);
    }

    // -------------------------------------------------------------------------- STYLING

    /**
     * Returns the style object for the knob
     * @return {Object}
     * @private
     */

  }, {
    key: '_getKnobStyle',
    value: function _getKnobStyle() {
      return {
        left: '50%',
        top: (this._hsvColor.h * 100).toFixed(2) + '%'
      };
    }

    // -------------------------------------------------------------------------- MISC

    /**
     * Sets the hue value of the color to the given one
     * @param {Number} h
     * @private
     */

  }, {
    key: '_setHue',
    value: function _setHue(h) {
      var _hsvColor = this._hsvColor,
          s = _hsvColor.s,
          v = _hsvColor.v;

      h = Math.min(1, Math.max(0, h));
      s = Math.max(0.01, Math.min(s, 0.99));
      v = Math.max(0.01, Math.min(v, 0.99));

      this._value = _globals.Color.fromHSV(h, s, v, this._value.a);
      this._hsvColor = { h: h, s: s, v: v };
      this.forceUpdate();
      this.props.onChange && this.props.onChange(this._value);
    }

    /**
     * Sets the value from the given cursor position
     * @param {Vector2} position
     * @private
     */

  }, {
    key: '_setValueFromPosition',
    value: function _setValueFromPosition(position) {
      var canvas = this.refs.canvas;

      this._initialHue = position.y / canvas.offsetHeight;
      this._setHue(this._initialHue);
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the hue colors to the canvas
     * @private
     */

  }, {
    key: '_renderCanvas',
    value: function _renderCanvas() {
      var canvas = this.refs.canvas;

      var context = canvas.getContext('2d');

      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;

      for (var y = 0; y < canvas.height; y++) {
        var ratio = y / canvas.height;
        var color = _globals.Color.fromHSV(ratio, 1, 1);

        context.strokeStyle = color.toRGBA();
        context.beginPath();
        context.moveTo(0, y);
        context.lineTo(canvas.width, y);
        context.stroke();
      }
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:colorPicker $e:hue' },
        _globals.ReactBEM.createElement(
          _draggableComponent2.default,
          {
            onStart: this._onKnobDragStart,
            onDrag: this._onKnobDrag },
          _globals.ReactBEM.createElement(
            'div',
            null,
            _globals.ReactBEM.createElement('canvas', { bem: 'e:canvas', ref: 'canvas' }),
            _globals.ReactBEM.createElement('div', {
              bem: 'e:knob $b:knob m:transparent',
              ref: 'knob',
              style: this._getKnobStyle() })
          )
        )
      );
    }
  }]);

  return HueComponent;
}(_globals.BaseComponent);

exports.default = HueComponent;


HueComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _scrollbarComponent = __webpack_require__(2);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

var _fontPreviewComponent = __webpack_require__(46);

var _fontPreviewComponent2 = _interopRequireDefault(_fontPreviewComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FontComponent = function (_BaseComponent) {
  _inherits(FontComponent, _BaseComponent);

  function FontComponent() {
    _classCallCheck(this, FontComponent);

    return _possibleConstructorReturn(this, (FontComponent.__proto__ || Object.getPrototypeOf(FontComponent)).apply(this, arguments));
  }

  _createClass(FontComponent, [{
    key: '_onListItemClick',

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the user clicks one one of the list items
     * @param  {FontVariation} variation
     * @param  {Event} e
     * @private
     */
    value: function _onListItemClick(variation, e) {
      this.props.onChange && this.props.onChange(variation);
    }

    // -------------------------------------------------------------------------- LIST ITEMS

    /**
     * Renders the list items
     * @return {Array.<ReactBEM.Element>}
     * @private
     */

  }, {
    key: '_renderListItems',
    value: function _renderListItems() {
      var _this2 = this;

      var fonts = this.props.fonts;


      return fonts.map(function (font) {
        var selectedIdentifier = _this2.props.selectedIdentifier;


        return font.getVariations().map(function (variation) {
          var isSelected = selectedIdentifier === variation.getIdentifier();
          var className = isSelected ? 'is-active' : null;

          return _globals.ReactBEM.createElement(
            'li',
            {
              bem: 'e:item',
              key: variation.getIdentifier(),
              className: className,
              onClick: _this2._onListItemClick.bind(_this2, variation) },
            _globals.ReactBEM.createElement(_fontPreviewComponent2.default, {
              fontFamily: variation.getFontFamily(),
              fontWeight: variation.getFontWeight(),
              fontStyle: variation.getFontStyle() }),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:label' },
              font.getFontFamily()
            )
          );
        });
      });
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var listItems = this._renderListItems();

      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:controls e:overlay m:dark m:large' },
        _globals.ReactBEM.createElement(
          _scrollbarComponent2.default,
          null,
          _globals.ReactBEM.createElement(
            'ul',
            { bem: '$b:fontFamily e:list' },
            listItems
          )
        )
      );
    }
  }]);

  return FontComponent;
}(_globals.BaseComponent);

exports.default = FontComponent;


FontComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _photoeditorsdk = __webpack_require__(7);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var Font = function (_Configurable) {
  _inherits(Font, _Configurable);

  function Font() {
    _classCallCheck(this, Font);

    return _possibleConstructorReturn(this, (Font.__proto__ || Object.getPrototypeOf(Font)).apply(this, arguments));
  }

  return Font;
}(_photoeditorsdk.Configurable);

/**
 * Specifies the available options for the Font class
 * @type {Object}
 * @ignore
 */


exports.default = Font;
Font.prototype.availableOptions = {
  fontFamily: { type: _photoeditorsdk.OptionType.STRING, required: true },
  variations: { type: _photoeditorsdk.OptionType.ARRAY, required: true }
};

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _controls = __webpack_require__(4);

var _controls2 = _interopRequireDefault(_controls);

var _brushControlsComponent = __webpack_require__(160);

var _brushControlsComponent2 = _interopRequireDefault(_brushControlsComponent);

var _brushCanvasControlsComponent = __webpack_require__(162);

var _brushCanvasControlsComponent2 = _interopRequireDefault(_brushCanvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

/**
 * The brush controls
 * @class
 * @extends PhotoEditorSDK.UI.ReactUI.Control
 * @memberof PhotoEditorSDK.UI.ReactUI.Controls
 */
var BrushControls = function (_Controls) {
  _inherits(BrushControls, _Controls);

  function BrushControls() {
    _classCallCheck(this, BrushControls);

    return _possibleConstructorReturn(this, (BrushControls.__proto__ || Object.getPrototypeOf(BrushControls)).apply(this, arguments));
  }

  _createClass(BrushControls, null, [{
    key: 'onExit',

    /**
     * Gets called when the user leaves these controls
     * @this {StickersControlsComponent}
     * @override
     * @ignore
     */
    value: function onExit() {
      var editor = this.context.editor;


      editor.zoom.restore();
      editor.features.enable('zoom', 'drag');
      editor.render();
    }

    /**
     * Gets called when the user enters these controls
     * @this {BrushControlsComponent}
     * @param {SharedState} sharedState
     * @param {Object} options
     * @override
     * @ignore
     */

  }, {
    key: 'onEnter',
    value: function onEnter(sharedState, options) {
      var editor = this.context.editor;


      editor.zoom.save();
      editor.zoom.set('auto', function () {
        // operation.setEnabled(false)
        editor.render();
      });

      var outputDimensions = editor.getOutputDimensions();
      var operationExistedBefore = editor.operations.exists('sprite');
      var operation = editor.operations.getOrCreate('sprite');
      var brush = operation.createBrush();
      var initialOptions = operation.serializeOptions(undefined, true);
      operation.addSprite(brush);

      var size = Math.max(outputDimensions.min() * 0.05, 1);
      if (options.sizePresets && options.sizePresets.length > 0) {
        size = options.sizePresets[0];
      }

      var color = new _globals.Color(1, 0, 0, 1);
      var hardness = 1;

      this.setSharedState({
        operationExistedBefore: operationExistedBefore, operation: operation, brush: brush, initialOptions: initialOptions, size: size, color: color, hardness: hardness
      });
    }

    /**
     * Checks if this control is available to the user
     * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
     * @return {Boolean}
     * @override
     * @ignore
     */

  }, {
    key: 'isAvailable',
    value: function isAvailable(editor) {
      return editor.isToolAllowed('brush') && editor.isToolEnabled('brush');
    }

    /**
     * Returns the assets that should be preloaded for this control
     * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
     * @return {String[]}
     */

  }, {
    key: 'getPreloadAssets',
    value: function getPreloadAssets() {
      return [];
    }
  }]);

  return BrushControls;
}(_controls2.default);

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */


BrushControls.controlsComponent = _brushControlsComponent2.default;

/**
 * This control's canvas component. Used for the upper controls part of the editor (on
 * top of the canvas)
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */
BrushControls.canvasControlsComponent = _brushCanvasControlsComponent2.default;

/**
 * This control's identifier
 * @type {String}
 * @default
 */
BrushControls.identifier = 'brush';

/**
 * This control's icon path
 * @type {String}
 * @ignore
 */
BrushControls.iconPath = 'controls/overview/brush.png';

/**
 * The language key that should be used when displaying this filter
 * @type {String}
 * @ignore
 */
BrushControls.languageKey = 'pesdk.brush.title.name';

/**
 * The default options for this control
 * @type {Object}
 */
BrushControls.defaultOptions = {
  sizePresets: []

  /**
   * The operations required for this control to work properly
   * @type {Array}
   */
};BrushControls.requiredOperations = ['sprite'];

exports.default = BrushControls;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _controlsComponent = __webpack_require__(3);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _sliderComponent = __webpack_require__(13);

var _sliderComponent2 = _interopRequireDefault(_sliderComponent);

var _scrollbarComponent = __webpack_require__(2);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

var _colorPickerComponent = __webpack_require__(29);

var _colorPickerComponent2 = _interopRequireDefault(_colorPickerComponent);

var _presetPreviewItemComponent = __webpack_require__(161);

var _presetPreviewItemComponent2 = _interopRequireDefault(_presetPreviewItemComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var BrushControlsComponent = function (_ControlsComponent) {
  _inherits(BrushControlsComponent, _ControlsComponent);

  function BrushControlsComponent() {
    var _ref, _this$_events;

    _classCallCheck(this, BrushControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = BrushControlsComponent.__proto__ || Object.getPrototypeOf(BrushControlsComponent)).call.apply(_ref, [this].concat(args)));

    _this._hasDoneButton = false;
    _this._brushOptions = {
      size: _this.getSharedState('size'),
      color: _this.getSharedState('color').clone()
    };

    _this._hasPresets = _this.props.options.sizePresets && _this.props.options.sizePresets.length > 0;
    _this._hasSlider = !_this._hasPresets;

    _this._bindAll('_onSizeUpdated', '_onColorUpdated', '_onOperationUpdated', '_onOperationRemoved');

    _this.state = {
      sizeControlsEnabled: false
    };

    _this._events = (_this$_events = {}, _defineProperty(_this$_events, _globals.Constants.EVENTS.OPERATION_UPDATED, _this._onOperationUpdated), _defineProperty(_this$_events, _globals.Constants.EVENTS.OPERATION_REMOVED, _this._onOperationRemoved), _this$_events);
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  _createClass(BrushControlsComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      _get(BrushControlsComponent.prototype.__proto__ || Object.getPrototypeOf(BrushControlsComponent.prototype), 'componentDidMount', this).call(this);

      var editor = this.context.editor;

      editor.zoom.set('auto');
      editor.features.disable('zoom', 'drag');
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the user clicks a size preset
     * @param  {Number} size
     * @private
     */

  }, {
    key: '_onSizeClick',
    value: function _onSizeClick(size) {
      this._onSizeUpdated(size);
      this.forceUpdate();
    }

    /**
     * Gets called when an operation has been removed
     * @param  {Operation} operation
     * @private
     */

  }, {
    key: '_onOperationRemoved',
    value: function _onOperationRemoved(operation) {
      if (operation !== this.getSharedState('operation')) return;
      if (this._backButtonClicked) return;

      // Operation can be removed by the undo button. We need
      // to make sure we re-create the operation for the lifetime
      // of this control
      var editor = this.context.editor;

      var newOperation = editor.operations.getOrCreate('sprite');

      var brush = newOperation.createBrush();
      newOperation.addSprite(brush);

      this.setSharedState({
        operation: newOperation,
        brush: brush,
        operationExistedBefore: false,
        initialOptions: {}
      });

      editor.render();
    }

    /**
     * Gets called when an operation has been updated
     * @param  {Operation} operation
     * @private
     */

  }, {
    key: '_onOperationUpdated',
    value: function _onOperationUpdated(operation) {
      if (operation === this.getSharedState('operation')) {
        // SpriteOperation re-creates all sprites when they're mass-assigned,
        // so we need to find the new instance by matching against the previous ID
        var previousBrush = this.getSharedState('brush');
        if (previousBrush) {
          var brush = operation.getSprites().filter(function (s) {
            return s.getId() === previousBrush.getId();
          })[0];
          this.setSharedState({ brush: brush });
        }

        // Trigger brush canvas rendering
        // operation.setEnabled(true)
        this.context.editor.render();
        // this.context.editor.render(() => {
        //   operation.setEnabled(false)
        //   this.context.editor.render()
        // })
      }
    }

    /**
     * Gets called when the size has been updated
     * @param {Number} size
     * @private
     */

  }, {
    key: '_onSizeUpdated',
    value: function _onSizeUpdated(size) {
      this.setSharedState({ size: size });
      this._brushOptions.size = size;
    }

    /**
     * Gets called when the color has been updated
     * @param  {Color} color
     * @private
     */

  }, {
    key: '_onColorUpdated',
    value: function _onColorUpdated(color) {
      this.setSharedState({ color: color });
      this._brushOptions.color = color.clone();
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the size list items
     * @return {Array.<ReactBEM.Element>}
     * @private
     */

  }, {
    key: '_renderSizeItems',
    value: function _renderSizeItems() {
      var _this2 = this;

      var sizePresets = this.props.options.sizePresets;

      var maxSize = Math.max.apply(null, sizePresets);
      return sizePresets.map(function (size) {
        var isActive = _this2.getSharedState('size') === size;
        return _globals.ReactBEM.createElement(_presetPreviewItemComponent2.default, {
          size: size,
          maxSize: maxSize,
          active: isActive,
          key: size,
          onClick: _this2._onSizeClick.bind(_this2, size) });
      });
    }

    /**
     * Renders the controls of this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderControls',
    value: function renderControls() {
      var editor = this.context.editor;

      var zoom = editor.zoom.get();
      var items = [];

      if (this._hasSlider) {
        var finalDimensions = editor.getFinalDimensions();
        var minSize = 1;
        var maxSize = Math.round(finalDimensions.clone().multiply(zoom).min() / 2);
        var currentWidth = this._brushOptions.size;

        items.push(_globals.ReactBEM.createElement(
          'div',
          { bem: 'e:cell m:slider' },
          _globals.ReactBEM.createElement(_sliderComponent2.default, {
            style: 'large',
            minValue: minSize,
            maxValue: maxSize,
            valueUnit: 'px',
            middleDot: false,
            label: this._t('pesdk.brush.text.size'),
            onChange: this._onSizeUpdated,
            value: currentWidth })
        ));
      } else if (this._hasPresets) {
        items.push(_globals.ReactBEM.createElement(
          'div',
          { bem: 'e:cell m:list' },
          _globals.ReactBEM.createElement(
            _scrollbarComponent2.default,
            null,
            _globals.ReactBEM.createElement(
              'ul',
              { bem: '$e:list' },
              this._renderSizeItems()
            )
          )
        ));
      }

      items.push(_globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell m:colorPicker' },
        _globals.ReactBEM.createElement(_colorPickerComponent2.default, {
          initialValue: this._brushOptions.color.clone(),
          onChange: this._onColorUpdated })
      ));

      return items;
    }
  }]);

  return BrushControlsComponent;
}(_controlsComponent2.default);

exports.default = BrushControlsComponent;


BrushControlsComponent.contextTypes = _controlsComponent2.default.contextTypes;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var PresetPreviewItemComponent = function (_BaseComponent) {
  _inherits(PresetPreviewItemComponent, _BaseComponent);

  function PresetPreviewItemComponent() {
    _classCallCheck(this, PresetPreviewItemComponent);

    return _possibleConstructorReturn(this, (PresetPreviewItemComponent.__proto__ || Object.getPrototypeOf(PresetPreviewItemComponent)).apply(this, arguments));
  }

  _createClass(PresetPreviewItemComponent, [{
    key: 'componentDidMount',

    // -------------------------------------------------------------------------- LIFECYCLE

    /**
     * Gets called after the component has been mounted
     */
    value: function componentDidMount() {
      _get(PresetPreviewItemComponent.prototype.__proto__ || Object.getPrototypeOf(PresetPreviewItemComponent.prototype), 'componentDidMount', this).call(this);
      this._renderCanvas();
    }

    /**
     * Gets called after this component has been updated
     */

  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      this._renderCanvas();
    }

    // -------------------------------------------------------------------------- CANVAS RENDERING

    /**
     * Renders the current font family onto the canvas
     * @private
     */

  }, {
    key: '_renderCanvas',
    value: function _renderCanvas() {
      var canvas = this.refs.canvas;

      var context = canvas.getContext('2d');

      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;

      var _props = this.props,
          maxSize = _props.maxSize,
          size = _props.size;

      var diameter = canvas.width * (size / maxSize);
      var radius = diameter / 2;

      context.fillStyle = 'white';
      context.beginPath();
      context.arc(canvas.width / 2, canvas.height / 2, radius, 0, 2 * Math.PI);
      context.fill();
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:controls $e:list' },
        _globals.ReactBEM.createElement(
          'li',
          {
            bem: 'e:item',
            onClick: this.props.onClick },
          _globals.ReactBEM.createElement(
            'bem',
            { specifier: '$b:controls' },
            _globals.ReactBEM.createElement(
              'div',
              { bem: '$e:button m:withLabel', className: this.props.active ? 'is-active' : null },
              _globals.ReactBEM.createElement('canvas', { bem: 'e:canvas', ref: 'canvas' }),
              _globals.ReactBEM.createElement(
                'div',
                { bem: 'e:label' },
                this.props.size
              )
            )
          )
        )
      );
    }
  }]);

  return PresetPreviewItemComponent;
}(_globals.BaseComponent);

exports.default = PresetPreviewItemComponent;


PresetPreviewItemComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _spritesCanvasControlsComponent = __webpack_require__(14);

var _spritesCanvasControlsComponent2 = _interopRequireDefault(_spritesCanvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var BrushSprite = _globals.SDK.Operations.SpriteOperation.BrushSprite;
var RadialBrush = _globals.SDK.Operations.SpriteOperation.BrushSprite.Brushes.RadialBrush;

var BrushCanvasControlsComponent = function (_SpritesCanvasControl) {
  _inherits(BrushCanvasControlsComponent, _SpritesCanvasControl);

  function BrushCanvasControlsComponent() {
    var _ref;

    _classCallCheck(this, BrushCanvasControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = BrushCanvasControlsComponent.__proto__ || Object.getPrototypeOf(BrushCanvasControlsComponent)).call.apply(_ref, [this].concat(args)));

    _this._windowResized = false;
    _this._drawing = false;
    _this._bindAll('_onMouseEnter', '_onMouseLeave', '_onMouseDown', '_onMouseMove', '_onMouseUp', '_onMouseMoveOnCanvas', '_onWindowResize');

    _this._lastDrawPosition = null;

    _this._events = _globals.SDKUtils.extend(_this._events, _defineProperty({}, _globals.Constants.EVENTS.WINDOW_RESIZE, _this._onWindowResize));

    _this.state = {
      cursorVisible: false,
      cursorPosition: new _globals.Vector2()
    };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  _createClass(BrushCanvasControlsComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      _get(BrushCanvasControlsComponent.prototype.__proto__ || Object.getPrototypeOf(BrushCanvasControlsComponent.prototype), 'componentDidMount', this).call(this);
      this._updateContainerRect();
    }

    /**
     * Gets called when this component has been updated
     */

  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      if (this._windowResized) {
        this._updateContainerRect();
        this._windowResized = false;
      }
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the window has been resized
     * @private
     */

  }, {
    key: '_onWindowResize',
    value: function _onWindowResize() {
      this._windowResized = true;
    }

    /**
     * Gets called when an operation has been removed
     * @param  {Operation} operation
     * @private
     */

  }, {
    key: '_onOperationRemoved',
    value: function _onOperationRemoved(operation) {
      void 0;
    }

    /**
     * Gets called when an operation has been updated
     * @param  {Operation} operation
     * @private
     */

  }, {
    key: '_onOperationUpdated',
    value: function _onOperationUpdated(operation) {
      if (operation === this.getSharedState('operation')) {
        this.forceUpdate();
      }
    }

    /**
     * Gets called when the user presses a mouse button
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onMouseDown',
    value: function _onMouseDown(e) {
      e.preventDefault();

      this._optionsBeforeDraw = this.getSharedState('operation').serializeOptions();
      this._operationExistedBeforeDraw = this.getSharedState('operationExistedBefore');
      this.setSharedState({ operationExistedBefore: true }, false);

      var outputDimensions = this.context.editor.getOutputDimensions();
      var cursorPosition = this._getCursorPosition(e);

      var brush = this.getSharedState('brush');
      var size = this.getSharedState('size') / outputDimensions.min();
      var color = this.getSharedState('color');
      var hardness = this.getSharedState('hardness');
      this._drawing = true;
      var _brush = new RadialBrush({ size: size, hardness: hardness, color: color });
      this._currentPath = brush.createPath(_brush);
      this._currentPath.addControlPoint(cursorPosition.clone().divide(outputDimensions));

      document.addEventListener('mousemove', this._onMouseMove);
      document.addEventListener('touchmove', this._onMouseMove);
      document.addEventListener('mouseup', this._onMouseUp);
      document.addEventListener('touchend', this._onMouseUp);
    }

    /**
     * Gets called when the user releases a mouse button
     * @private
     */

  }, {
    key: '_onMouseUp',
    value: function _onMouseUp() {
      this._currentPath.setClosed(true);

      var editor = this.context.editor;

      var outputTextureDimensions = editor.getOutputTextureDimensions();
      this.getSharedState('brush').render(outputTextureDimensions);

      this._currentPath = null;
      this._drawing = false;

      editor.history.add(this.getSharedState('operation'), this._optionsBeforeDraw, this._operationExistedBeforeDraw);

      document.removeEventListener('mousemove', this._onMouseMove);
      document.removeEventListener('touchmove', this._onMouseMove);
      document.removeEventListener('mouseup', this._onMouseUp);
      document.removeEventListener('touchend', this._onMouseUp);
    }

    /**
     * Gets called when the user enters the canvas
     * @param {Event} event
     * @private
     */

  }, {
    key: '_onMouseEnter',
    value: function _onMouseEnter(e) {
      var cursorPosition = this._getCursorPosition(e);
      this.setState({
        cursorVisible: true,
        cursorPosition: cursorPosition
      });
      this._onMouseMove(e);
    }

    /**
     * Gets called when the user leaves the canvas
     * @private
     */

  }, {
    key: '_onMouseLeave',
    value: function _onMouseLeave() {
      this.setState({
        cursorVisible: false
      });
    }

    /**
     * Gets called while the user moves the mouse
     * @param {Event} e
     * @private
     */

  }, {
    key: '_onMouseMove',
    value: function _onMouseMove(e) {
      var editor = this.context.editor;

      var outputDimensions = editor.getOutputDimensions();
      var outputTextureDimensions = editor.getOutputTextureDimensions();

      var zoom = editor.zoom.get();
      var cursorPosition = this._getCursorPosition(e);
      this.setState({ cursorPosition: cursorPosition });

      var shouldDraw = void 0;
      if (!this._lastDrawPosition) {
        shouldDraw = true;
      } else {
        var brushSize = this.getSharedState('size');
        var distance = this._lastDrawPosition.clone().subtract(cursorPosition).abs().len() / zoom;
        shouldDraw = distance >= brushSize / 10;
      }

      if (this._drawing && shouldDraw) {
        this._currentPath.addControlPoint(cursorPosition.clone().divide(outputDimensions));

        this.getSharedState('brush').render(outputTextureDimensions);

        this._lastDrawPosition = cursorPosition.clone();
      }
    }

    /**
     * Gets called while the user moves the mouse on top of the canvas. Updates
     * the cursor cursor position
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onMouseMoveOnCanvas',
    value: function _onMouseMoveOnCanvas(e) {
      var cursorPosition = this._getCursorPosition(e);
      this.setState({ cursorPosition: cursorPosition });
    }

    /**
     * Returns the props that are passed to the item component of the given sprite
     * @param  {Sprite} sprite
     * @return {Object}
     * @private
     */

  }, {
    key: '_getPropsForSprite',
    value: function _getPropsForSprite(sprite) {
      var props = _get(BrushCanvasControlsComponent.prototype.__proto__ || Object.getPrototypeOf(BrushCanvasControlsComponent.prototype), '_getPropsForSprite', this).call(this, sprite);
      if (sprite instanceof BrushSprite) {
        props.hideContent = false;
      }
      return props;
    }
    // -------------------------------------------------------------------------- STYLING

    /**
     * Returns the cursor's style object
     * @return {Object}
     * @private
     */

  }, {
    key: '_getCursorStyle',
    value: function _getCursorStyle() {
      var size = this.getSharedState('size');
      var color = this.getSharedState('color');

      var cursorPosition = this.state.cursorPosition;

      return {
        left: cursorPosition.x,
        top: cursorPosition.y,
        width: size,
        height: size,
        background: color.toRGBA(),
        marginLeft: size * -0.5,
        marginTop: size * -0.5
      };
    }

    // -------------------------------------------------------------------------- MISC

    /**
     * Updates the container bounding rect
     * @private
     */

  }, {
    key: '_updateContainerRect',
    value: function _updateContainerRect() {
      this._containerBoundingRect = this.refs.innerContainer.getBoundingClientRect();
    }

    /**
     * Returns the cursor position for the given event
     * @param  {Event} event
     * @private
     */

  }, {
    key: '_getCursorPosition',
    value: function _getCursorPosition(event) {
      var position = _globals.Utils.getEventPosition(event);
      var boundingRect = this._containerBoundingRect;
      return position.subtract(boundingRect.left, boundingRect.top);
    }

    /**
     * Returns the properties for the outer container
     * @return {Object}
     * @private
     */

  }, {
    key: '_getContainerProps',
    value: function _getContainerProps() {
      var props = _get(BrushCanvasControlsComponent.prototype.__proto__ || Object.getPrototypeOf(BrushCanvasControlsComponent.prototype), '_getContainerProps', this).call(this);

      props.onMouseDown = props.onTouchStart = this._onMouseDown;
      return props;
    }

    /**
     * Returns the properties for the canvas container
     * @return {Object}
     * @private
     */

  }, {
    key: '_getInnerContainerProps',
    value: function _getInnerContainerProps() {
      var props = _get(BrushCanvasControlsComponent.prototype.__proto__ || Object.getPrototypeOf(BrushCanvasControlsComponent.prototype), '_getInnerContainerProps', this).call(this);

      // This disables the hit testing for this sub control
      delete props.onClick;

      props.onMouseEnter = this._onMouseEnter;
      props.onMouseLeave = this._onMouseLeave;
      props.onMouseMove = this._onMouseMoveOnCanvas;
      return props;
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * This renders controls on top of the sprites
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderOverlayControls',
    value: function _renderOverlayControls() {
      var cursorClass = this.state.cursorVisible ? 'is-visible' : null;
      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:brushCanvasControls' },
        _globals.ReactBEM.createElement('div', { bem: 'e:cursor', className: cursorClass, style: this._getCursorStyle() })
      );
    }
  }]);

  return BrushCanvasControlsComponent;
}(_spritesCanvasControlsComponent2.default);

exports.default = BrushCanvasControlsComponent;


BrushCanvasControlsComponent.contextTypes = _spritesCanvasControlsComponent2.default.contextTypes;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _controls = __webpack_require__(4);

var _controls2 = _interopRequireDefault(_controls);

var _selectiveBlurControlsComponent = __webpack_require__(164);

var _selectiveBlurControlsComponent2 = _interopRequireDefault(_selectiveBlurControlsComponent);

var _selectiveBlurCanvasControlsComponent = __webpack_require__(165);

var _selectiveBlurCanvasControlsComponent2 = _interopRequireDefault(_selectiveBlurCanvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

/**
 * The selective blur controls
 * @class
 * @extends PhotoEditorSDK.UI.ReactUI.Control
 * @memberof PhotoEditorSDK.UI.ReactUI.Controls
 */
var SelectiveBlurControls = function (_Controls) {
  _inherits(SelectiveBlurControls, _Controls);

  function SelectiveBlurControls() {
    _classCallCheck(this, SelectiveBlurControls);

    return _possibleConstructorReturn(this, (SelectiveBlurControls.__proto__ || Object.getPrototypeOf(SelectiveBlurControls)).apply(this, arguments));
  }

  _createClass(SelectiveBlurControls, null, [{
    key: 'onExit',

    /**
     * Gets called when the user leaves these controls
     * @this {SelectiveBlurControlsComponent}
     * @override
     * @ignore
     */
    value: function onExit() {
      var editor = this.context.editor;

      var operation = this.getSharedState('operation');

      if (operation.getPaths().length === 0) {
        editor.operations.remove(operation);
      }

      editor.zoom.restore();
      editor.features.enable('zoom', 'drag');
      editor.render();
    }

    /**
     * Gets called when the user enters these controls
     * @this {SelectiveBlurControlsComponent}
     * @param {SharedState} sharedState
     * @param {Object} options
     * @override
     * @ignore
     */

  }, {
    key: 'onEnter',
    value: function onEnter(sharedState, options) {
      var editor = this.context.editor;


      editor.zoom.save();
      editor.zoom.set('auto', function () {
        editor.render();
      });

      var outputDimensions = editor.getOutputDimensions();
      var operationExistedBefore = editor.operations.exists('selective-blur');
      var operation = editor.operations.getOrCreate('selective-blur');
      var initialOptions = operation.serializeOptions();
      var brush = operation.getBrush();

      var size = outputDimensions.min() * 0.1;
      var hardness = 1;

      var inputDimensions = operation.getInputDimensions();

      this.setSharedState({
        operationExistedBefore: operationExistedBefore, operation: operation, brush: brush, initialOptions: initialOptions, size: size, hardness: hardness, inputDimensions: inputDimensions
      });
    }

    /**
     * Checks if this control is available to the user
     * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
     * @return {Boolean}
     * @override
     * @ignore
     */

  }, {
    key: 'isAvailable',
    value: function isAvailable(editor) {
      return editor.isToolEnabled('selective-blur');
    }
  }]);

  return SelectiveBlurControls;
}(_controls2.default);

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */


SelectiveBlurControls.controlsComponent = _selectiveBlurControlsComponent2.default;

/**
 * This control's canvas component. Used for the upper controls part of the editor (on
 * top of the canvas)
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */
SelectiveBlurControls.canvasControlsComponent = _selectiveBlurCanvasControlsComponent2.default;

/**
 * This control's identifier
 * @type {String}
 * @default
 */
SelectiveBlurControls.identifier = 'selective-blur';

/**
 * This control's icon path
 * @type {String}
 * @ignore
 */
SelectiveBlurControls.iconPath = 'controls/overview/selective-blur.png';

/**
 * The language key that should be used when displaying this filter
 * @type {String}
 * @ignore
 */
SelectiveBlurControls.languageKey = 'controls.overview.selective-blur';

/**
 * The default options for this control
 * @type {Object}
 */
SelectiveBlurControls.defaultOptions = {};

/**
 * The operations required for this control to work properly
 * @type {Array}
 */
SelectiveBlurControls.requiredOperations = ['selective-blur'];

exports.default = SelectiveBlurControls;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _controlsComponent = __webpack_require__(3);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _sliderComponent = __webpack_require__(13);

var _sliderComponent2 = _interopRequireDefault(_sliderComponent);

var _sliderOverlayComponent = __webpack_require__(6);

var _sliderOverlayComponent2 = _interopRequireDefault(_sliderOverlayComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var BrushControlsComponent = function (_ControlsComponent) {
  _inherits(BrushControlsComponent, _ControlsComponent);

  function BrushControlsComponent() {
    var _ref, _this$_events;

    _classCallCheck(this, BrushControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = BrushControlsComponent.__proto__ || Object.getPrototypeOf(BrushControlsComponent)).call.apply(_ref, [this].concat(args)));

    _this._hasDoneButton = false;
    _this._brushSize = _this.getSharedState('size');

    _this._bindAll('_onOperationUpdated', '_onOperationRemoved', '_onSizeUpdated', '_onBlurRadiusChange');

    _this.state = {
      sizeControlsEnabled: false
    };

    _this._events = (_this$_events = {}, _defineProperty(_this$_events, _globals.Constants.EVENTS.OPERATION_UPDATED, _this._onOperationUpdated), _defineProperty(_this$_events, _globals.Constants.EVENTS.OPERATION_REMOVED, _this._onOperationRemoved), _this$_events);
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  _createClass(BrushControlsComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      _get(BrushControlsComponent.prototype.__proto__ || Object.getPrototypeOf(BrushControlsComponent.prototype), 'componentDidMount', this).call(this);

      var editor = this.context.editor;

      editor.zoom.set('auto');
      editor.features.disable('zoom', 'drag');
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when an operation has been removed
     * @param  {Operation} operation
     * @private
     */

  }, {
    key: '_onOperationRemoved',
    value: function _onOperationRemoved(operation) {
      if (operation !== this.getSharedState('operation')) return;
      if (this._backButtonClicked) return;

      // Operation can be removed by the undo button. We need
      // to make sure we re-create the operation for the lifetime
      // of this control
      var editor = this.context.editor;

      var newOperation = editor.operations.getOrCreate('selective-blur');
      var brush = newOperation.getBrush();

      this.setSharedState({
        operation: newOperation,
        brush: brush,
        operationExistedBefore: false,
        initialOptions: {}
      });

      editor.render();
    }

    /**
     * Gets called when an operation has been updated
     * @param  {Operation} operation
     * @private
     */

  }, {
    key: '_onOperationUpdated',
    value: function _onOperationUpdated(operation) {
      if (operation === this.getSharedState('operation')) {
        var editor = this.context.editor;

        editor.render();
        this.forceUpdate();
      }
    }

    /**
     * Gets called when the size has been updated
     * @param {Number} size
     * @private
     */

  }, {
    key: '_onSizeUpdated',
    value: function _onSizeUpdated(size) {
      this.setSharedState({ size: size });
      this._brushSize = size;
    }

    /**
     * Gets called when the slider value has changed
     * @param {Number} value
     * @param {Number} previousValue
     * @param {Boolean} released
     * @private
     */

  }, {
    key: '_onBlurRadiusChange',
    value: function _onBlurRadiusChange(value, previousValue) {
      var released = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var inputDimensions = this.getSharedState('inputDimensions');
      this.getSharedState('operation').setBlurRadius(value / inputDimensions.min());

      var editor = this.context.editor;

      editor.render();

      if (released) {
        editor.history.add(this.getSharedState('operation'), { blurRadius: previousValue / inputDimensions.min() }, true);
      }
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the overlay controls of this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderOverlayControls',
    value: function renderOverlayControls() {
      var inputDimensions = this.getSharedState('inputDimensions');
      var shortestSide = inputDimensions.min();
      var value = this.getSharedState('operation').getBlurRadius() * shortestSide;

      return _globals.ReactBEM.createElement(_sliderOverlayComponent2.default, {
        minValue: 0,
        maxValue: Math.min(180, Math.round(shortestSide * 0.1)),
        value: value,
        valueUnit: 'px',
        label: this._t('controls.selectiveBlur.blurRadius'),
        onChange: this._onBlurRadiusChange });
    }

    /**
     * Renders the controls of this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderControls',
    value: function renderControls() {
      var editor = this.context.editor;

      var zoom = editor.zoom.get();
      var items = [];

      var finalDimensions = editor.getFinalDimensions();
      var minSize = 1;
      var maxSize = Math.round(finalDimensions.clone().multiply(zoom).min() / 2);
      var currentWidth = this._brushSize;

      items.push(_globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell m:slider' },
        _globals.ReactBEM.createElement(_sliderComponent2.default, {
          style: 'large',
          minValue: minSize,
          maxValue: maxSize,
          valueUnit: 'px',
          middleDot: false,
          label: this._t('controls.brush.size'),
          onChange: this._onSizeUpdated,
          value: currentWidth })
      ));

      return items;
    }
  }]);

  return BrushControlsComponent;
}(_controlsComponent2.default);

exports.default = BrushControlsComponent;


BrushControlsComponent.contextTypes = _controlsComponent2.default.contextTypes;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _spritesCanvasControlsComponent = __webpack_require__(14);

var _spritesCanvasControlsComponent2 = _interopRequireDefault(_spritesCanvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var BrushCanvasControlsComponent = function (_SpritesCanvasControl) {
  _inherits(BrushCanvasControlsComponent, _SpritesCanvasControl);

  function BrushCanvasControlsComponent() {
    var _ref;

    _classCallCheck(this, BrushCanvasControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = BrushCanvasControlsComponent.__proto__ || Object.getPrototypeOf(BrushCanvasControlsComponent)).call.apply(_ref, [this].concat(args)));

    _this._windowResized = false;
    _this._drawing = false;
    _this._bindAll('_onMouseEnter', '_onMouseLeave', '_onMouseDown', '_onMouseMove', '_onMouseUp', '_onMouseMoveOnCanvas', '_onWindowResize');

    _this._lastDrawPosition = null;

    _this._events = _globals.SDKUtils.extend(_this._events, _defineProperty({}, _globals.Constants.EVENTS.WINDOW_RESIZE, _this._onWindowResize));

    _this.state = {
      cursorVisible: false,
      cursorPosition: new _globals.Vector2()
    };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  _createClass(BrushCanvasControlsComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      _get(BrushCanvasControlsComponent.prototype.__proto__ || Object.getPrototypeOf(BrushCanvasControlsComponent.prototype), 'componentDidMount', this).call(this);
      this._updateContainerRect();
    }

    /**
     * Gets called when this component has been updated
     */

  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      if (this._windowResized) {
        this._updateContainerRect();
        this._windowResized = false;
      }
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the window has been resized
     * @private
     */

  }, {
    key: '_onWindowResize',
    value: function _onWindowResize() {
      this._windowResized = true;
    }

    /**
     * Gets called when an operation has been removed
     * @param  {Operation} operation
     * @private
     */

  }, {
    key: '_onOperationRemoved',
    value: function _onOperationRemoved(operation) {}

    /**
     * Gets called when an operation has been updated
     * @param  {Operation} operation
     * @private
     */

  }, {
    key: '_onOperationUpdated',
    value: function _onOperationUpdated(operation) {
      if (operation === this.getSharedState('operation')) {
        this.forceUpdate();
      }
    }

    /**
     * Gets called when the user presses a mouse button
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onMouseDown',
    value: function _onMouseDown(e) {
      e.preventDefault();

      var operation = this.getSharedState('operation');
      this._optionsBeforeDraw = operation.serializeOptions();
      this._operationExistedBeforeDraw = this.getSharedState('operationExistedBefore');
      this.setSharedState({ operationExistedBefore: true }, false);

      var outputDimensions = this.context.editor.getOutputDimensions();
      var cursorPosition = this._getCursorPosition(e);

      var size = this.getSharedState('size') / outputDimensions.min();
      var hardness = this.getSharedState('hardness');
      this._drawing = true;

      this._currentPath = operation.createPath(size, hardness);
      this._currentPath.addControlPoint(cursorPosition.clone().divide(outputDimensions));

      document.addEventListener('mousemove', this._onMouseMove);
      document.addEventListener('touchmove', this._onMouseMove);
      document.addEventListener('mouseup', this._onMouseUp);
      document.addEventListener('touchend', this._onMouseUp);
    }

    /**
     * Gets called when the user releases a mouse button
     * @private
     */

  }, {
    key: '_onMouseUp',
    value: function _onMouseUp() {
      this._currentPath.setClosed(true);

      var editor = this.context.editor;

      editor.render();

      this._currentPath = null;
      this._drawing = false;

      editor.history.add(this.getSharedState('operation'), this._optionsBeforeDraw, this._operationExistedBeforeDraw);

      document.removeEventListener('mousemove', this._onMouseMove);
      document.removeEventListener('touchmove', this._onMouseMove);
      document.removeEventListener('mouseup', this._onMouseUp);
      document.removeEventListener('touchend', this._onMouseUp);
    }

    /**
     * Gets called when the user enters the canvas
     * @param {Event} event
     * @private
     */

  }, {
    key: '_onMouseEnter',
    value: function _onMouseEnter(e) {
      var cursorPosition = this._getCursorPosition(e);
      this.setState({
        cursorVisible: true,
        cursorPosition: cursorPosition
      });
      this._onMouseMove(e);
    }

    /**
     * Gets called when the user leaves the canvas
     * @private
     */

  }, {
    key: '_onMouseLeave',
    value: function _onMouseLeave() {
      this.setState({
        cursorVisible: false
      });
    }

    /**
     * Gets called while the user moves the mouse
     * @param {Event} e
     * @private
     */

  }, {
    key: '_onMouseMove',
    value: function _onMouseMove(e) {
      var editor = this.context.editor;

      var outputDimensions = editor.getOutputDimensions();

      var zoom = editor.zoom.get();
      var cursorPosition = this._getCursorPosition(e);
      this.setState({ cursorPosition: cursorPosition });

      var shouldDraw = void 0;
      if (!this._lastDrawPosition) {
        shouldDraw = true;
      } else {
        var brushSize = this.getSharedState('size');
        var distance = this._lastDrawPosition.clone().subtract(cursorPosition).abs().len() / zoom;
        shouldDraw = distance >= brushSize / 10;
      }

      if (this._drawing && shouldDraw) {
        this._currentPath.addControlPoint(cursorPosition.clone().divide(outputDimensions));
        this._lastDrawPosition = cursorPosition.clone();

        editor.render();
      }
    }

    /**
     * Gets called while the user moves the mouse on top of the canvas. Updates
     * the cursor cursor position
     * @param  {Event} e
     * @private
     */

  }, {
    key: '_onMouseMoveOnCanvas',
    value: function _onMouseMoveOnCanvas(e) {
      var cursorPosition = this._getCursorPosition(e);
      this.setState({ cursorPosition: cursorPosition });
    }

    // -------------------------------------------------------------------------- STYLING

    /**
     * Returns the cursor's style object
     * @return {Object}
     * @private
     */

  }, {
    key: '_getCursorStyle',
    value: function _getCursorStyle() {
      var size = this.getSharedState('size');

      var cursorPosition = this.state.cursorPosition;

      return {
        left: cursorPosition.x,
        top: cursorPosition.y,
        width: size,
        height: size,
        marginLeft: size * -0.5,
        marginTop: size * -0.5
      };
    }

    // -------------------------------------------------------------------------- MISC

    /**
     * Updates the container bounding rect
     * @private
     */

  }, {
    key: '_updateContainerRect',
    value: function _updateContainerRect() {
      this._containerBoundingRect = this.refs.innerContainer.getBoundingClientRect();
    }

    /**
     * Returns the cursor position for the given event
     * @param  {Event} event
     * @private
     */

  }, {
    key: '_getCursorPosition',
    value: function _getCursorPosition(event) {
      var position = _globals.Utils.getEventPosition(event);
      var boundingRect = this._containerBoundingRect;
      return position.subtract(boundingRect.left, boundingRect.top);
    }

    /**
     * Returns the properties for the outer container
     * @return {Object}
     * @private
     */

  }, {
    key: '_getContainerProps',
    value: function _getContainerProps() {
      var props = _get(BrushCanvasControlsComponent.prototype.__proto__ || Object.getPrototypeOf(BrushCanvasControlsComponent.prototype), '_getContainerProps', this).call(this);

      props.onMouseDown = props.onTouchStart = this._onMouseDown;
      return props;
    }

    /**
     * Returns the properties for the canvas container
     * @return {Object}
     * @private
     */

  }, {
    key: '_getInnerContainerProps',
    value: function _getInnerContainerProps() {
      var props = _get(BrushCanvasControlsComponent.prototype.__proto__ || Object.getPrototypeOf(BrushCanvasControlsComponent.prototype), '_getInnerContainerProps', this).call(this);

      // This disables the hit testing for this sub control
      delete props.onClick;

      props.onMouseEnter = this._onMouseEnter;
      props.onMouseLeave = this._onMouseLeave;
      props.onMouseMove = this._onMouseMoveOnCanvas;
      return props;
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the sprite items
     * @return {Array.<SpriteItemComponent>}
     * @private
     */

  }, {
    key: '_renderSpriteItems',
    value: function _renderSpriteItems() {
      return null;
    }

    /**
     * This renders controls on top of the sprites
     * @return {ReactBEM.Element}
     * @private
     */

  }, {
    key: '_renderOverlayControls',
    value: function _renderOverlayControls() {
      var cursorClass = this.state.cursorVisible ? 'is-visible' : null;
      return _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:selectiveBlurCanvasControls' },
        _globals.ReactBEM.createElement('div', { bem: 'e:cursor', className: cursorClass, style: this._getCursorStyle() })
      );
    }
  }]);

  return BrushCanvasControlsComponent;
}(_spritesCanvasControlsComponent2.default);

exports.default = BrushCanvasControlsComponent;


BrushCanvasControlsComponent.contextTypes = _spritesCanvasControlsComponent2.default.contextTypes;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _controls = __webpack_require__(4);

var _controls2 = _interopRequireDefault(_controls);

var _frameControlsComponent = __webpack_require__(167);

var _frameControlsComponent2 = _interopRequireDefault(_frameControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

/**
 * The frame controls
 * @class
 * @extends PhotoEditorSDK.UI.ReactUI.Control
 * @memberof PhotoEditorSDK.UI.ReactUI.Controls
 */
var FrameControls = function (_Controls) {
  _inherits(FrameControls, _Controls);

  function FrameControls() {
    _classCallCheck(this, FrameControls);

    return _possibleConstructorReturn(this, (FrameControls.__proto__ || Object.getPrototypeOf(FrameControls)).apply(this, arguments));
  }

  _createClass(FrameControls, null, [{
    key: 'onExit',

    /**
     * Gets called when the user leaves these controls
     * @this {FrameControlsComponent}
     * @override
     * @ignore
     */
    value: function onExit() {
      var editor = this.context.editor;

      var operation = this.getSharedState('operation');
      var initialOptions = this.getSharedState('initialOptions');

      var frame = operation.getFrame();
      var scale = operation.getScale();

      if ((frame && frame.identifier) !== (initialOptions.frame && initialOptions.frame.identifier) || scale !== initialOptions.scale) {
        editor.history.add(operation, this.getSharedState('initialOptions'), this.getSharedState('operationExistedBefore'));
      }

      if (!operation.getFrame()) {
        editor.operations.remove(operation);
      }

      editor.render();
    }

    /**
     * Gets called when the user enters these controls
     * @this {FrameControlsComponent}
     * @param {SharedState} sharedState
     * @override
     * @ignore
     */

  }, {
    key: 'onEnter',
    value: function onEnter(sharedState) {
      var editor = this.context.editor;

      var operationExistedBefore = editor.operations.exists('frame');
      var operation = editor.operations.getOrCreate('frame');
      var initialOptions = operation.serializeOptions();

      this.setSharedState({
        operation: operation,
        operationExistedBefore: operationExistedBefore,
        initialOptions: initialOptions,
        inputDimensions: operation.getInputDimensions(),
        frame: operation.getFrame()
      });
    }

    /**
     * Checks if this control is available to the user
     * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
     * @return {Boolean}
     * @override
     * @ignore
     */

  }, {
    key: 'isAvailable',
    value: function isAvailable(editor) {
      return editor.isToolAllowed('frame') && editor.isToolEnabled('frame');
    }
  }]);

  return FrameControls;
}(_controls2.default);

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */


FrameControls.controlsComponent = _frameControlsComponent2.default;

/**
 * This control's identifier
 * @type {String}
 * @default
 */
FrameControls.identifier = 'frame';

/**
 * This control's icon path
 * @type {String}
 * @ignore
 */
FrameControls.iconPath = 'controls/overview/frame.png';

/**
 * The language key that should be used when displaying this filter
 * @type {String}
 * @ignore
 */
FrameControls.languageKey = 'pesdk.frame.title.name';

/**
 * The default options for this control
 * @type {Object}
 * @property {Object[]} [frames = []]
 */
FrameControls.defaultOptions = {
  frames: []

  /**
   * The operations required for this control to work properly
   * @type {Array}
   */
};FrameControls.requiredOperations = ['sprite'];

FrameControls.getPreloadAssets = _controls2.default.getPreloadAssets;

exports.default = FrameControls;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _controlsComponent = __webpack_require__(3);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _scrollbarComponent = __webpack_require__(2);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

var _modalManager = __webpack_require__(1);

var _modalManager2 = _interopRequireDefault(_modalManager);

var _frameManager = __webpack_require__(48);

var _frameManager2 = _interopRequireDefault(_frameManager);

var _frameItemComponent = __webpack_require__(168);

var _frameItemComponent2 = _interopRequireDefault(_frameItemComponent);

var _colorPickerComponent = __webpack_require__(29);

var _colorPickerComponent2 = _interopRequireDefault(_colorPickerComponent);

var _sliderOverlayComponent = __webpack_require__(6);

var _sliderOverlayComponent2 = _interopRequireDefault(_sliderOverlayComponent);

var _frame = __webpack_require__(49);

var _frame2 = _interopRequireDefault(_frame);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FrameOverviewControlsComponent = function (_ControlsComponent) {
  _inherits(FrameOverviewControlsComponent, _ControlsComponent);

  function FrameOverviewControlsComponent() {
    var _ref, _this$_events;

    _classCallCheck(this, FrameOverviewControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = FrameOverviewControlsComponent.__proto__ || Object.getPrototypeOf(FrameOverviewControlsComponent)).call.apply(_ref, [this].concat(args)));

    _this._operation = _this.getSharedState('operation');
    _this._bindAll('_onScaleChange', '_onColorChange', '_onOperationUpdated', '_onOperationRemoved');

    _this._events = (_this$_events = {}, _defineProperty(_this$_events, _globals.Constants.EVENTS.OPERATION_UPDATED, _this._onOperationUpdated), _defineProperty(_this$_events, _globals.Constants.EVENTS.OPERATION_REMOVED, _this._onOperationRemoved), _this$_events);

    _this._initFrameManager();
    return _this;
  }

  // -------------------------------------------------------------------------- FRAMES

  /**
   * Initializes the frame manager
   * @private
   */


  _createClass(FrameOverviewControlsComponent, [{
    key: '_initFrameManager',
    value: function _initFrameManager() {
      this._frameManager = new _frameManager2.default(this.context.ui, this.props.options);
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when an operation has been updated
     * @param  {Operation} operation
     * @private
     */

  }, {
    key: '_onOperationUpdated',
    value: function _onOperationUpdated(operation) {
      if (operation === this.getSharedState('operation')) {
        this.forceSharedUpdate();
      }
    }

    /**
     * Gets called when an operation has been removed
     * @param  {Operation} operation
     * @private
     */

  }, {
    key: '_onOperationRemoved',
    value: function _onOperationRemoved(operation) {
      if (operation !== this.getSharedState('operation')) return;
      if (this._backButtonClicked) return;

      // Operation can be removed by the undo button. We need
      // to make sure we re-create the operation for the lifetime
      // of this control
      var editor = this.context.editor;

      var newOperation = editor.operations.getOrCreate('frame');

      this.setSharedState({
        operation: newOperation,
        frame: null,
        operationExistedBefore: false,
        initialOptions: {}
      });

      editor.render();
    }

    /**
     * Gets called when the scale has been changed
     * @param  {Number} scale
     * @private
     */

  }, {
    key: '_onScaleChange',
    value: function _onScaleChange(scale) {
      var editor = this.context.editor;


      var inputDimensions = this.getSharedState('inputDimensions');
      this._operation.setScale(scale / inputDimensions.min());

      editor.render();
    }

    /**
     * Gets called when the tint color has been changed
     * @param  {PhotoEditorSDK.Color} color
     * @private
     */

  }, {
    key: '_onColorChange',
    value: function _onColorChange(color) {
      var operation = this.getSharedState('operation');
      operation.setTintColor(color.clone());

      var editor = this.context.editor;

      editor.render();
    }

    /**
     * Gets called when the user clicks the back button
     * @param {Event} e
     * @private
     */

  }, {
    key: '_onBackClick',
    value: function _onBackClick(e) {
      this._backButtonClicked = true;
      this.props.onSwitchControls('home');
    }

    /**
     * Gets called when a frame has been clicked
     * @param  {Object} frameData
     * @private
     */

  }, {
    key: '_onFrameClick',
    value: function _onFrameClick(frameData) {
      var _this2 = this;

      var editor = this.context.editor;

      var operation = this.getSharedState('operation');
      if (frameData === null) {
        operation.setFrame(null);
        editor.render();
        return this.setSharedState({ frame: null });
      }

      var loadingModal = void 0;
      var loadTimeout = setTimeout(function () {
        loadingModal = _modalManager2.default.instance.displayLoading(_this2._t('pesdk.common.text.loading'));
      }, 100);

      var frame = new _frame2.default(this.context.ui, frameData);

      frame.load().then(function () {
        if (loadingModal) loadingModal.close();
        if (loadTimeout) {
          clearTimeout(loadTimeout);
          loadTimeout = null;
        }

        var frameObject = frame.getFrame();
        operation.setFrame(frameObject);

        var editor = _this2.context.editor;

        editor.render();

        _this2.setSharedState({ frame: frame });
      });
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the overlay controls of this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderOverlayControls',
    value: function renderOverlayControls() {
      var frame = this.getSharedState('frame');

      if (!frame) return null;

      var inputDimensions = this.getSharedState('inputDimensions');

      var minSize = 5;
      var maxSize = Math.round(0.3 * inputDimensions.min());
      var currentScale = this._operation.getScale() * inputDimensions.min();

      return _globals.ReactBEM.createElement(_sliderOverlayComponent2.default, {
        minValue: minSize,
        maxValue: maxSize,
        value: currentScale,
        valueUnit: 'px',
        middleDot: false,
        label: this._t('pesdk.frame.text.scale'),
        onChange: this._onScaleChange });
    }

    /**
     * Renders the list items for this control
     * @return {Array.<ReactBEM.Element>}
     * @private
     */

  }, {
    key: '_renderListItems',
    value: function _renderListItems() {
      var _this3 = this;

      var frames = this._frameManager.getFramesForCategory('all');
      var currentFrame = this.getSharedState('operation').getFrame();

      var noFrameItem = _globals.ReactBEM.createElement(
        'li',
        {
          bem: 'e:item',
          key: 'no-frame',
          onClick: this._onFrameClick.bind(this, null) },
        _globals.ReactBEM.createElement(
          'bem',
          { specifier: '$b:controls' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: '$e:button m:withLabel',
              className: !currentFrame ? 'is-active' : null },
            _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/frame/no-frame.png', true) }),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:label' },
              this._t('pesdk.frame.button.none')
            )
          )
        )
      );

      return [noFrameItem].concat(frames.map(function (frame, i) {
        return _globals.ReactBEM.createElement(_frameItemComponent2.default, {
          frame: frame,
          active: currentFrame && currentFrame.identifier === frame.identifier,
          onClick: _this3._onFrameClick.bind(_this3, frame) });
      }));
    }

    /**
     * Renders the controls of this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderControls',
    value: function renderControls() {
      var frame = this.getSharedState('operation').getFrame();
      var listItems = this._renderListItems();

      var items = [_globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell m:list' },
        _globals.ReactBEM.createElement(
          _scrollbarComponent2.default,
          { ref: 'scrollbar' },
          _globals.ReactBEM.createElement(
            'ul',
            { bem: '$e:list' },
            listItems
          )
        )
      )];

      if (frame && frame.tintable) {
        var operation = this.getSharedState('operation');
        items.push(_globals.ReactBEM.createElement(
          'div',
          { bem: 'e:cell m:colorPicker' },
          _globals.ReactBEM.createElement(_colorPickerComponent2.default, {
            initialValue: operation.getTintColor().clone(),
            onChange: this._onColorChange })
        ));
      }

      return items;
    }
  }]);

  return FrameOverviewControlsComponent;
}(_controlsComponent2.default);

exports.default = FrameOverviewControlsComponent;


FrameOverviewControlsComponent.contextTypes = _controlsComponent2.default.contextTypes;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FrameItemComponent = function (_BaseComponent) {
  _inherits(FrameItemComponent, _BaseComponent);

  function FrameItemComponent() {
    var _ref;

    _classCallCheck(this, FrameItemComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = FrameItemComponent.__proto__ || Object.getPrototypeOf(FrameItemComponent)).call.apply(_ref, [this].concat(args)));

    _this.state = {
      frame: _this.props.frame
    };
    return _this;
  }

  /**
   * Gets called when this component has been mounted
   */


  _createClass(FrameItemComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this._renderFrame();
    }

    /**
     * Gets called when this component is about to receive new properties
     * @param  {Object} nextProps
     */

  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      if (this.props.frame !== nextProps.frame) {
        this.setState({ frame: nextProps.frame }, function () {
          _this2._renderFrame();
        });
      }
    }

    /**
     * Renders the frame onto the canvas
     * @private
     */

  }, {
    key: '_renderFrame',
    value: function _renderFrame() {
      var editor = this.context.editor;

      var sdk = editor.getSDK();

      var frame = this.props.frame;


      var resolvedFramePath = this._getAssetPath(frame.thumbnail);
      var canvas = this.refs['canvas-' + frame.identifier];

      var pixelRatio = sdk.getPixelRatio();
      canvas.width = canvas.offsetWidth * pixelRatio;
      canvas.height = canvas.offsetHeight * pixelRatio;

      canvas.style.width = canvas.offsetWidth + 'px';
      canvas.style.height = canvas.offsetHeight + 'px';

      var context = canvas.getContext('2d');

      var image = new window.Image();
      image.addEventListener('load', function () {
        var scale = Math.min(canvas.width / image.width, canvas.height / image.height);
        var drawSize = new _globals.Vector2(image.width, image.height).multiply(scale);
        var drawPosition = new _globals.Vector2(canvas.width, canvas.height).divide(2).subtract(drawSize.clone().divide(2));

        context.drawImage(image, 0, 0, image.width, image.height, drawPosition.x, drawPosition.y, drawSize.x, drawSize.y);
      });
      image.crossOrigin = this.context.editor.getCrossOrigin();
      image.src = resolvedFramePath;
    }

    /**
     * Renders this element
     * @return {ReactBEM.element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: 'b:controls e:list' },
        _globals.ReactBEM.createElement(
          'li',
          {
            bem: 'e:item',
            key: this.props.frame.identifier,
            onClick: this.props.onClick },
          _globals.ReactBEM.createElement(
            'bem',
            { specifier: '$b:controls' },
            _globals.ReactBEM.createElement(
              'div',
              { bem: '$e:button m:withInlineLabel' },
              _globals.ReactBEM.createElement('canvas', { bem: 'e:canvas m:large', ref: 'canvas-' + this.props.frame.identifier }),
              _globals.ReactBEM.createElement(
                'div',
                { bem: '$e:inlineLabel', className: this.props.active ? 'is-active' : null },
                _globals.ReactBEM.createElement(
                  'div',
                  { bem: 'e:label' },
                  this._t('pesdk.frame.asset.' + this.props.frame.identifier) || this.props.frame.defaultName
                )
              )
            )
          )
        )
      );
    }
  }]);

  return FrameItemComponent;
}(_globals.BaseComponent);

exports.default = FrameItemComponent;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EditorFeatures = function () {
  function EditorFeatures(editor, sdk, mediator) {
    _classCallCheck(this, EditorFeatures);

    this._editor = editor;
    this._sdk = sdk;
    this._mediator = mediator;

    this._options = this._editor.getOptions();

    this._features = {
      drag: this._options.editor.enableDrag,
      zoom: this._options.editor.enableZoom
    };
  }

  /**
   * Checks if the feature with the given identifier is enabled
   * @param  {String}  identifier
   * @return {Boolean}
   */


  _createClass(EditorFeatures, [{
    key: 'isEnabled',
    value: function isEnabled(identifier) {
      var capitalizedIdentifier = identifier.charAt(0).toUpperCase() + identifier.slice(1);
      var optionEnabled = this._options.editor['enable' + capitalizedIdentifier];
      return this._features[identifier] && optionEnabled;
    }

    /**
     * Enables the features with the given identifiers
     * @param  {String[]} identifiers
     */

  }, {
    key: 'enable',
    value: function enable() {
      var _this = this;

      for (var _len = arguments.length, identifiers = Array(_len), _key = 0; _key < _len; _key++) {
        identifiers[_key] = arguments[_key];
      }

      identifiers.forEach(function (identifier) {
        _this._features[identifier] = true;
      });
      this._mediator.emit(_globals.Constants.EVENTS.FEATURES_ENABLED, identifiers);
      this._mediator.emit(_globals.Constants.EVENTS.FEATURES_UPDATED, identifiers);
    }

    /**
     * Disables the features with the given identifiers
     * @param  {String[]} identifiers
     */

  }, {
    key: 'disable',
    value: function disable() {
      var _this2 = this;

      for (var _len2 = arguments.length, identifiers = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        identifiers[_key2] = arguments[_key2];
      }

      identifiers.forEach(function (identifier) {
        _this2._features[identifier] = false;
      });
      this._mediator.emit(_globals.Constants.EVENTS.FEATURES_DISABLED, identifiers);
      this._mediator.emit(_globals.Constants.EVENTS.FEATURES_UPDATED, identifiers);
    }
  }]);

  return EditorFeatures;
}();

exports.default = EditorFeatures;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var MIN_ZOOM_DIMENSIONS = 300;

var EditorZoom = function (_EventEmitter) {
  _inherits(EditorZoom, _EventEmitter);

  function EditorZoom(editor, sdk, mediator) {
    _classCallCheck(this, EditorZoom);

    var _this = _possibleConstructorReturn(this, (EditorZoom.__proto__ || Object.getPrototypeOf(EditorZoom)).call(this));

    _this._editor = editor;
    _this._sdk = sdk;
    _this._mediator = mediator;

    _this._isDefaultZoom = false;
    _this._zoom = _this._sdk.getZoom();
    _this._options = _this._editor.getOptions();

    _this._zoomLevels = [1, 2, 3, 4, 5, 6.25, 8.33, 12.5, 16.66, 25, 33.33, 50, 66.66, 100, 200, 300, 400, 500, 600, 700, 800, 1200, 1600, 3200].map(function (z) {
      return z / 100;
    });
    return _this;
  }

  /**
   * Zooms in the editor
   */


  _createClass(EditorZoom, [{
    key: 'in',
    value: function _in() {
      var newZoom = this._getClosestZoomLevel(this._zoom + 0.001, +1);
      if (!newZoom) return this._zoomLevels[this._zoomLevels.length - 1];
      this.set(newZoom);
    }

    /**
     * Zooms out the editor
     */

  }, {
    key: 'out',
    value: function out() {
      var newZoom = this._getClosestZoomLevel(this._zoom - 0.001, -1);
      if (!newZoom) return this._zoomLevels[0];
      this.set(newZoom);
    }

    /**
     * Returns the closest zoom level to the given one
     * @param  {Number} zoomLevel
     * @param  {Number} direction
     * @return {Number}
     * @private
     */

  }, {
    key: '_getClosestZoomLevel',
    value: function _getClosestZoomLevel(zoomLevel, direction) {
      if (direction === -1) {
        return this._zoomLevels.filter(function (l) {
          return l < zoomLevel;
        }).pop();
      } else if (direction === 1) {
        return this._zoomLevels.filter(function (l) {
          return l > zoomLevel;
        })[0];
      }
    }

    /**
     * Switches to the previous zoom
     */

  }, {
    key: 'restore',
    value: function restore() {
      if (!this._previousZoom) return;
      this.set(this._previousZoom);
      this._previousZoom = null;
    }

    /**
     * Stores the current zoom level, can be restored with .restore()
     */

  }, {
    key: 'save',
    value: function save() {
      this._previousZoom = this._zoom;
    }

    /**
     * Sets the zoom to the given one
     * @param {Number} zoom
     * @param {Function} [callback]
     * @param {Boolean} [considerMinimum = true]
     */

  }, {
    key: 'set',
    value: function set(zoom, callback) {
      var considerMinimum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (!this._editor.isReady()) {
        return;
      }

      var newZoom = zoom;
      var defaultZoom = this.getDefault();
      if (zoom === 'auto' || newZoom === defaultZoom) {
        newZoom = defaultZoom;
        zoom = 'auto';

        this._isDefaultZoom = true;
      } else {
        this._isDefaultZoom = false;
      }

      var maxZoom = Math.max(1, defaultZoom * 2);
      var minZoom = considerMinimum ? this.getMinimum() : 0;
      newZoom = Math.max(minZoom, Math.min(maxZoom, newZoom));

      this._zoom = newZoom;
      this._sdk.setZoom(this._zoom);
      this._sdk.setTextureQuality(Math.min(this._zoom, 1));
      this.emit('set', this._zoom, callback);
    }

    /**
     * Returns the default zoom level
     * @return {Number}
     */

  }, {
    key: 'getDefault',
    value: function getDefault() {
      var finalDimensions = this._editor.getFinalDimensions(false);
      var canvasDimensions = this._editor.getCanvasDimensions();
      var defaultDimensions = _globals.SDKUtils.resizeVectorToFit(finalDimensions, canvasDimensions);

      return defaultDimensions.divide(finalDimensions).x;
    }

    /**
     * Returns the minimum zoom level
     * @return {Number}
     */

  }, {
    key: 'getMinimum',
    value: function getMinimum() {
      var finalDimensions = this._editor.getFinalDimensions();
      var minimumDimensions = _globals.SDKUtils.resizeVectorToFit(finalDimensions, new _globals.Vector2(MIN_ZOOM_DIMENSIONS, MIN_ZOOM_DIMENSIONS));

      return minimumDimensions.divide(finalDimensions).x;
    }

    /**
     * Checks if the editor is at the default zoom level
     * @return {Boolean}
     */

  }, {
    key: 'isDefault',
    value: function isDefault() {
      return this._isDefaultZoom;
    }

    /**
     * Returns the current zoom level
     * @return {Number}
     */

  }, {
    key: 'get',
    value: function get() {
      return this._zoom;
    }
  }]);

  return EditorZoom;
}(_globals.EventEmitter);

exports.default = EditorZoom;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var EditorHistory = function (_EventEmitter) {
  _inherits(EditorHistory, _EventEmitter);

  function EditorHistory(editor, sdk, mediator) {
    _classCallCheck(this, EditorHistory);

    var _this = _possibleConstructorReturn(this, (EditorHistory.__proto__ || Object.getPrototypeOf(EditorHistory)).call(this));

    _this._editor = editor;
    _this._sdk = sdk;
    _this._mediator = mediator;

    _this._history = [];
    return _this;
  }

  /**
   * Checks if there are any history items available
   * @return {Boolean}
   */


  _createClass(EditorHistory, [{
    key: 'isAvailable',
    value: function isAvailable() {
      return this._history.length !== 0;
    }

    /**
     * Adds the given data to the history
     * @param {PhotoEditorSDK.Operation} operation
     * @param {Object} options
     * @param {Boolean} existent
     * @param {Function} [undo]
     * @return {Object}
     */

  }, {
    key: 'add',
    value: function add(operation, options, existent) {
      var _this2 = this;

      var undo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var historyItem = void 0;
      if (operation instanceof Array) {
        var items = operation;
        this._history.push(items);
        items.forEach(function (item) {
          _this2._mediator.emit(_globals.Constants.EVENTS.HISTORY_UPDATED, item.operation);
        });

        historyItem = items;
      } else {
        historyItem = {
          operation: operation, options: options, existent: existent, undo: undo
        };
        this._history.push(historyItem);
        this._mediator.emit(_globals.Constants.EVENTS.HISTORY_UPDATED, operation);
      }
      return historyItem;
    }

    /**
     * Reverts the last change
     */

  }, {
    key: 'undo',
    value: function undo() {
      var _this3 = this;

      var operations = this._editor.operations;

      var lastItem = this._history.pop();
      if (lastItem) {
        var items = [].concat(lastItem);

        items.forEach(function (historyObject) {
          var operation = historyObject.operation,
              existent = historyObject.existent,
              options = historyObject.options,
              undo = historyObject.undo;

          _this3._mediator.emit(_globals.Constants.EVENTS.HISTORY_BEFORE_UNDO, historyObject);

          if (!existent) {
            operations.remove(operation);
          } else {
            operation = operations.getOrCreate(operation.constructor.identifier);
            operation.set(options);
            _this3._mediator.emit(_globals.Constants.EVENTS.OPERATION_UPDATED, operation);
          }

          if (typeof undo === 'function') {
            undo(operation, options);
          }

          _this3._mediator.emit(_globals.Constants.EVENTS.HISTORY_UPDATED, operation);
          _this3._mediator.emit(_globals.Constants.EVENTS.HISTORY_UNDO, operation);
        });

        this.emit('undo');
      }
    }

    /**
     * Resets the history
     */

  }, {
    key: 'reset',
    value: function reset() {
      this._history = [];
    }
  }]);

  return EditorHistory;
}(_globals.EventEmitter);

exports.default = EditorHistory;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _serializer = __webpack_require__(50);

var _serializer2 = _interopRequireDefault(_serializer);

var _deserializer = __webpack_require__(51);

var _deserializer2 = _interopRequireDefault(_deserializer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Serialization = function () {
  function Serialization(editor) {
    _classCallCheck(this, Serialization);

    this._editor = editor;
  }

  /**
   * Serializes the editor state
   * @return {Promise}
   */


  _createClass(Serialization, [{
    key: 'serialize',
    value: function serialize() {
      var serializer = new _serializer2.default(this._editor);
      return serializer.serialize.apply(serializer, arguments);
    }

    /**
     * Deserializes the given data
     * @param  {Object} data
     * @return {Promise}
     */

  }, {
    key: 'deserialize',
    value: function deserialize(data) {
      var deserializer = new _deserializer2.default(this._editor, data);
      return deserializer.deserialize();
    }
  }]);

  return Serialization;
}();

exports.default = Serialization;


Serialization.version = '1.0.0';

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(174);


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(175);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),
/* 175 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BrushManager = function () {
  function BrushManager(ui, options) {
    _classCallCheck(this, BrushManager);

    this._ui = ui;
    this._options = options;
    this._brushes = [];
    this._brushesById = {};

    this._addBrushes(_globals.Constants.DEFAULTS.BRUSHES);

    var _options = this._options,
        brushes = _options.brushes,
        replaceBrushes = _options.replaceBrushes,
        availableBrushes = _options.availableBrushes;

    if (this._options.brushes) {
      this._addBrushes(brushes, replaceBrushes);
    }

    if (availableBrushes) {
      this._brushes = this._brushes.filter(function (brush) {
        return availableBrushes.indexOf(brush.identifier) !== -1;
      });
    }
  }

  _createClass(BrushManager, [{
    key: '_addBrushes',
    value: function _addBrushes(brushes, replaceBrushes) {
      var _this = this;

      if (replaceBrushes) {
        this._brushes = [];
        this._brushesById = {};
      }

      brushes.forEach(function (brush) {
        _this._brushes.push(brush);
        _this._brushesById[brush.identifier] = brush;
      });
    }

    /**
     * Returns the brush with the given identifier
     * @param  {String} identifier
     */

  }, {
    key: 'getBrushByIdentifier',
    value: function getBrushByIdentifier(identifier) {
      return this._brushesById[identifier];
    }

    /**
     * Returns all brushes
     * @return {PhotoEditorSDK.Operations.SpriteOperation.BrushSprite.Brush[]}
     */

  }, {
    key: 'getBrushes',
    value: function getBrushes() {
      return this._brushes;
    }

    /**
     * Returns the first available brush
     * @return {PhotoEditorSDK.Operations.SpriteOperation.BrushSprite.Brush}
     */

  }, {
    key: 'getFirstBrush',
    value: function getFirstBrush() {
      return this._brushes[0];
    }
  }]);

  return BrushManager;
}();

exports.default = BrushManager;

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _baseFontLoader = __webpack_require__(52);

var _baseFontLoader2 = _interopRequireDefault(_baseFontLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FONT_STYLES = {
  italic: 'i'
};

var GoogleFontLoader = function (_BaseFontLoader) {
  _inherits(GoogleFontLoader, _BaseFontLoader);

  function GoogleFontLoader() {
    _classCallCheck(this, GoogleFontLoader);

    return _possibleConstructorReturn(this, (GoogleFontLoader.__proto__ || Object.getPrototypeOf(GoogleFontLoader)).apply(this, arguments));
  }

  _createClass(GoogleFontLoader, [{
    key: 'load',
    value: function load() {
      if (this._fonts.length) {
        this._addStylesheetTag();
      }
      return _get(GoogleFontLoader.prototype.__proto__ || Object.getPrototypeOf(GoogleFontLoader.prototype), 'load', this).call(this);
    }

    /**
     * Appends the <link> tag to the head
     * @private
     */

  }, {
    key: '_addStylesheetTag',
    value: function _addStylesheetTag() {
      var families = this._getFamiliesString();
      var link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = 'https://fonts.googleapis.com/css?family=' + families;

      var head = document.getElementsByTagName('head')[0];
      head.appendChild(link);
    }

    /**
     * Returns the string representation of all Google Fonts families that
     * should be loaded
     * @return {String}
     * @private
     */

  }, {
    key: '_getFamiliesString',
    value: function _getFamiliesString() {
      var families = {};
      this._fonts.forEach(function (font) {
        var fontFamily = font.getFontFamily();
        var fontStyle = font.getFontStyle();
        var fontWeight = font.getFontWeight();
        families[fontFamily] = families[fontFamily] || [];
        if (typeof fontWeight !== 'undefined') {
          families[fontFamily].push('' + fontWeight + (FONT_STYLES[fontStyle] || ''));
        } else {
          families[fontFamily].push(400); // default weight
        }
      });

      var familyStrings = [];
      for (var name in families) {
        var variants = families[name];
        var variantsString = variants.length ? ':' + variants.join(',') : '';
        var nameString = name.replace(' ', '+') + variantsString;
        familyStrings.push(nameString);
      }

      return familyStrings.join('|');
    }
  }]);

  return GoogleFontLoader;
}(_baseFontLoader2.default);

exports.default = GoogleFontLoader;

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _fontRuler = __webpack_require__(179);

var _fontRuler2 = _interopRequireDefault(_fontRuler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var now = typeof window !== 'undefined' && window.performance && window.performance.now ? window.performance.now.bind(window.performance) : __webpack_require__(39);

var OBSERVE_INTERVAL = 50;
var OBSERVE_TIMEOUT = 5000;

var FontObserver = function () {
  function FontObserver(fontVariation) {
    _classCallCheck(this, FontObserver);

    this._fontVariation = fontVariation;

    this._defaultFontRuler = new _fontRuler2.default();
    this._customFontRuler = new _fontRuler2.default(this._fontVariation);
  }

  _createClass(FontObserver, [{
    key: 'observe',
    value: function observe() {
      var _this = this;

      var startedAt = now();

      return new Promise(function (resolve, reject) {
        var interval = window.setInterval(function () {
          var changed = _this._defaultFontRuler.getWidth() !== _this._customFontRuler.getWidth();
          if (changed) {
            window.clearInterval(interval);
            return resolve();
          } else {
            if (now() - startedAt >= OBSERVE_TIMEOUT) {
              var error = new Error('Failed to load font ' + _this._fontVariation.getFontFamily() + '.');
              error.font = _this._fontVariation;
              return reject(error);
            }
          }
        }, OBSERVE_INTERVAL);
      });
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      this._defaultFontRuler.dispose();
      this._customFontRuler.dispose();
    }
  }]);

  return FontObserver;
}();

exports.default = FontObserver;

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _fontVariation = __webpack_require__(47);

var _fontVariation2 = _interopRequireDefault(_fontVariation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FONT_SIZE = 30;
var CHARACTERS = 'abcdefghijklmnopqrstuvwxzy';

var FontRuler = function () {
  function FontRuler(fontVariation) {
    _classCallCheck(this, FontRuler);

    this._fontVariation = fontVariation || new _fontVariation2.default({
      fontFamily: 'Times New Roman',
      fontWeight: 'normal',
      fontStyle: 'normal'
    });

    this._createRuler();
  }

  /**
   * Creates the ruler and attaches it to the DOM
   * @private
   */


  _createClass(FontRuler, [{
    key: '_createRuler',
    value: function _createRuler() {
      this._ruler = document.createElement('div');
      this._ruler.innerText = CHARACTERS;
      document.body.appendChild(this._ruler);
      this._setRulerStyle();
    }

    /**
     * Styles the ruler
     * @private
     */

  }, {
    key: '_setRulerStyle',
    value: function _setRulerStyle() {
      this._ruler.style.cssText = '\n      position: absolute;\n      top: -9999px;\n      left: -9999px;\n      opacity: 0;\n      display: inline-block;\n      font: ' + this._fontVariation.getFontStyle() + ' ' + this._fontVariation.getFontWeight() + ' ' + FONT_SIZE + 'px ' + this._fontVariation.getFontFamily() + ';\n    ';
    }

    /**
     * Sets the font variation to the given one
     * @param {PhotoEditorSDK.UI.ReactUI.FontVariation} fontVariation
     */

  }, {
    key: 'setFontVariation',
    value: function setFontVariation(fontVariation) {
      this._fontVariation = fontVariation;
      this._setRulerStyle();
    }

    /**
     * Returns the width of this ruler
     * @return {Number}
     */

  }, {
    key: 'getWidth',
    value: function getWidth() {
      return this._ruler.offsetWidth;
    }

    /**
     * Removes this ruler from the DOM
     */

  }, {
    key: 'dispose',
    value: function dispose() {
      if (this._ruler) {
        this._ruler.parentNode.removeChild(this._ruler);
        this._ruler = null;
      }
    }
  }]);

  return FontRuler;
}();

exports.default = FontRuler;

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _baseFontLoader = __webpack_require__(52);

var _baseFontLoader2 = _interopRequireDefault(_baseFontLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FileFontLoader = function (_BaseFontLoader) {
  _inherits(FileFontLoader, _BaseFontLoader);

  function FileFontLoader() {
    _classCallCheck(this, FileFontLoader);

    return _possibleConstructorReturn(this, (FileFontLoader.__proto__ || Object.getPrototypeOf(FileFontLoader)).apply(this, arguments));
  }

  _createClass(FileFontLoader, [{
    key: 'load',
    value: function load() {
      var _this2 = this;

      var fontFacesCSS = [];

      this._fonts.forEach(function (variation) {
        var fontPath = _this2._ui.getAssetPath(variation.getFilePath(), false, true);
        fontFacesCSS.push('@font-face {\n        font-family: "' + variation.getFontFamily() + '";\n        src: url(\'' + fontPath + '\') format(\'woff\');\n        font-weight: ' + variation.getFontWeight() + ';\n        font-style: ' + variation.getFontStyle() + ';\n      }');
      });

      var css = fontFacesCSS.join('\n');

      var styleTag = document.createElement('style');
      styleTag.innerHTML = css;

      var head = document.getElementsByTagName('head')[0];
      head.appendChild(styleTag);

      return _get(FileFontLoader.prototype.__proto__ || Object.getPrototypeOf(FileFontLoader.prototype), 'load', this).call(this);
    }
  }]);

  return FileFontLoader;
}(_baseFontLoader2.default);

exports.default = FileFontLoader;

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _serializer = __webpack_require__(53);

var _serializer2 = _interopRequireDefault(_serializer);

var _deserializer = __webpack_require__(54);

var _deserializer2 = _interopRequireDefault(_deserializer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Serialization = function () {
  function Serialization(editor) {
    _classCallCheck(this, Serialization);

    this._editor = editor;
  }

  /**
   * Serializes the editor state
   * @return {Promise}
   */


  _createClass(Serialization, [{
    key: 'serialize',
    value: function serialize() {
      var serializer = new _serializer2.default(this._editor);
      return serializer.serialize.apply(serializer, arguments);
    }

    /**
     * Deserializes the given data
     * @param  {Object} data
     * @return {Promise}
     */

  }, {
    key: 'deserialize',
    value: function deserialize(data) {
      var deserializer = new _deserializer2.default(this._editor, data);
      return deserializer.deserialize();
    }
  }]);

  return Serialization;
}();

exports.default = Serialization;


Serialization.version = '1.0.1';

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _serializer = __webpack_require__(31);

var _serializer2 = _interopRequireDefault(_serializer);

var _deserializer = __webpack_require__(32);

var _deserializer2 = _interopRequireDefault(_deserializer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Serialization = function () {
  function Serialization(editor) {
    _classCallCheck(this, Serialization);

    this._editor = editor;
  }

  /**
   * Serializes the editor state
   * @return {Promise}
   */


  _createClass(Serialization, [{
    key: 'serialize',
    value: function serialize() {
      var serializer = new _serializer2.default(this._editor);
      return serializer.serialize.apply(serializer, arguments);
    }

    /**
     * Deserializes the given data
     * @param  {Object} data
     * @return {Promise}
     */

  }, {
    key: 'deserialize',
    value: function deserialize(data) {
      var deserializer = new _deserializer2.default(this._editor, data);
      return deserializer.deserialize();
    }
  }]);

  return Serialization;
}();

exports.default = Serialization;


Serialization.version = '2.0.0';

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var OverlayManager = function () {
  function OverlayManager(ui, options) {
    var _this = this;

    _classCallCheck(this, OverlayManager);

    this._ui = ui;
    this._options = options;
    this._overlays = _globals.SharedConstants.DEFAULTS.OVERLAYS.slice(0);
    this._overlaysByIdentifier = {};

    if (options.overlays) {
      if (options.replaceOverlays) {
        this._overlays = options.overlays;
      } else {
        this._overlays = this._overlays.concat(options.overlays);
      }
    }

    // Filter available
    if (options.availableOverlays) {
      this._overlays = this._overlays.filter(function (o) {
        return options.availableOverlays.indexOf(o.identifier) !== -1;
      });
    }

    this._overlays.forEach(function (overlay) {
      _this._overlaysByIdentifier[overlay.identifier] = overlay;
    });
  }

  /**
   * Returns the overlays
   * @return {Object[]}
   */


  _createClass(OverlayManager, [{
    key: 'getOverlays',
    value: function getOverlays() {
      return this._overlays;
    }

    /**
     * Returns the overlay with the given identifier
     * @param  {String} identifier
     * @return {Object}
     */

  }, {
    key: 'getOverlayByIdentifier',
    value: function getOverlayByIdentifier(identifier) {
      return this._overlaysByIdentifier[identifier];
    }
  }]);

  return OverlayManager;
}();

exports.default = OverlayManager;

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _serializer = __webpack_require__(185);

var _serializer2 = _interopRequireDefault(_serializer);

var _deserializer = __webpack_require__(186);

var _deserializer2 = _interopRequireDefault(_deserializer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Serialization = function () {
  function Serialization(editor) {
    _classCallCheck(this, Serialization);

    this._editor = editor;
  }

  /**
   * Serializes the editor state
   * @return {Promise}
   */


  _createClass(Serialization, [{
    key: 'serialize',
    value: function serialize() {
      var serializer = new _serializer2.default(this._editor);
      return serializer.serialize.apply(serializer, arguments);
    }

    /**
     * Deserializes the given data
     * @param  {Object} data
     * @return {Promise}
     */

  }, {
    key: 'deserialize',
    value: function deserialize(data) {
      var deserializer = new _deserializer2.default(this._editor, data);
      return deserializer.deserialize();
    }
  }]);

  return Serialization;
}();

exports.default = Serialization;


Serialization.version = '2.0.1';

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _serializer = __webpack_require__(31);

var _serializer2 = _interopRequireDefault(_serializer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var v201Serializer = function (_PreviousSerializer) {
  _inherits(v201Serializer, _PreviousSerializer);

  function v201Serializer() {
    _classCallCheck(this, v201Serializer);

    return _possibleConstructorReturn(this, (v201Serializer.__proto__ || Object.getPrototypeOf(v201Serializer)).apply(this, arguments));
  }

  return v201Serializer;
}(_serializer2.default);

exports.default = v201Serializer;


v201Serializer.version = '2.0.0';

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _deserializer = __webpack_require__(32);

var _deserializer2 = _interopRequireDefault(_deserializer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var v201Deserializer = function (_PreviousDeserializer) {
  _inherits(v201Deserializer, _PreviousDeserializer);

  function v201Deserializer() {
    _classCallCheck(this, v201Deserializer);

    return _possibleConstructorReturn(this, (v201Deserializer.__proto__ || Object.getPrototypeOf(v201Deserializer)).apply(this, arguments));
  }

  return v201Deserializer;
}(_deserializer2.default);

exports.default = v201Deserializer;


v201Deserializer.version = '2.0.1';

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _serializer = __webpack_require__(56);

var _serializer2 = _interopRequireDefault(_serializer);

var _deserializer = __webpack_require__(57);

var _deserializer2 = _interopRequireDefault(_deserializer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Serialization = function () {
  function Serialization(editor) {
    _classCallCheck(this, Serialization);

    this._editor = editor;
  }

  /**
   * Serializes the editor state
   * @return {Promise}
   */


  _createClass(Serialization, [{
    key: 'serialize',
    value: function serialize() {
      var serializer = new _serializer2.default(this._editor);
      return serializer.serialize.apply(serializer, arguments);
    }

    /**
     * Deserializes the given data
     * @param  {Object} data
     * @return {Promise}
     */

  }, {
    key: 'deserialize',
    value: function deserialize(data) {
      var deserializer = new _deserializer2.default(this._editor, data);
      return deserializer.deserialize();
    }
  }]);

  return Serialization;
}();

exports.default = Serialization;


Serialization.version = '3.0.0';

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _serializer = __webpack_require__(189);

var _serializer2 = _interopRequireDefault(_serializer);

var _deserializer = __webpack_require__(190);

var _deserializer2 = _interopRequireDefault(_deserializer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Serialization = function () {
  function Serialization(editor) {
    _classCallCheck(this, Serialization);

    this._editor = editor;
  }

  /**
   * Serializes the editor state
   * @return {Promise}
   */


  _createClass(Serialization, [{
    key: 'serialize',
    value: function serialize() {
      var serializer = new _serializer2.default(this._editor);
      return serializer.serialize.apply(serializer, arguments);
    }

    /**
     * Deserializes the given data
     * @param  {Object} data
     * @return {Promise}
     */

  }, {
    key: 'deserialize',
    value: function deserialize(data) {
      var deserializer = new _deserializer2.default(this._editor, data);
      return deserializer.deserialize();
    }
  }]);

  return Serialization;
}();

exports.default = Serialization;


Serialization.version = '3.1.0';

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _serializer = __webpack_require__(56);

var _serializer2 = _interopRequireDefault(_serializer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var v310Serializer = function (_PreviousSerializer) {
  _inherits(v310Serializer, _PreviousSerializer);

  function v310Serializer() {
    _classCallCheck(this, v310Serializer);

    return _possibleConstructorReturn(this, (v310Serializer.__proto__ || Object.getPrototypeOf(v310Serializer)).apply(this, arguments));
  }

  _createClass(v310Serializer, [{
    key: '_serializeTextDesign',
    value: function _serializeTextDesign(operation, sprite) {
      var options = sprite.serializeOptions(['position', 'rotation', 'flipHorizontally', 'flipVertically', 'text', 'color', 'width', 'seed', 'inverted'], true);

      options.color = {
        rgba: options.color
      };

      var layout = sprite.getLayout();

      if (layout) {
        options.identifier = layout.constructor.identifier;
      }

      return {
        type: 'textdesign',
        options: options
      };
    }
  }]);

  return v310Serializer;
}(_serializer2.default);

exports.default = v310Serializer;


v310Serializer.version = '3.1.0';

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _deserializer = __webpack_require__(57);

var _deserializer2 = _interopRequireDefault(_deserializer);

var _textDesignManager = __webpack_require__(58);

var _textDesignManager2 = _interopRequireDefault(_textDesignManager);

var _fontManager = __webpack_require__(15);

var _fontManager2 = _interopRequireDefault(_fontManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var v310Deserializer = function (_PreviousDeserializer) {
  _inherits(v310Deserializer, _PreviousDeserializer);

  function v310Deserializer() {
    _classCallCheck(this, v310Deserializer);

    return _possibleConstructorReturn(this, (v310Deserializer.__proto__ || Object.getPrototypeOf(v310Deserializer)).apply(this, arguments));
  }

  _createClass(v310Deserializer, [{
    key: '_deserializeTextDesign',
    value: function _deserializeTextDesign(operation, sprite) {
      var _this2 = this;

      var options = sprite.options;
      var position = options.position,
          rotation = options.rotation,
          flipHorizontally = options.flipHorizontally,
          flipVertically = options.flipVertically,
          text = options.text,
          color = options.color,
          width = options.width,
          seed = options.seed,
          inverted = options.inverted,
          identifier = options.identifier;


      var textDesignManager = new _textDesignManager2.default(this._ui, this._getOptions('textdesign'));
      var fontManager = new _fontManager2.default(this._ui, { fonts: _globals.Constants.DEFAULTS.TEXT_DESIGN_FONTS, replaceFonts: true });
      var AssetManager = operation.constructor.TextDesignSprite.AssetManager;
      var fontLoader = this._ui.getFontLoader();

      var Layout = textDesignManager.getLayoutByIdentifier(identifier);

      var layout = new Layout();

      fontLoader.setFonts(fontManager.getFonts());

      AssetManager.setFonts(_extends({}, AssetManager.getFonts(), fontManager.getVariationsByIdentifier()));

      return fontLoader.load().then(function () {
        var images = layout.getImagePaths().map(function (path) {
          return { path: path, fullPath: _this2._ui.getAssetPath(path), image: null };
        });
        return AssetManager.loadImages(images).then(function () {
          layout.onImagesLoaded();

          return operation.createTextDesign({
            position: position,
            rotation: rotation,
            flipHorizontally: flipHorizontally,
            flipVertically: flipVertically,
            text: text,
            color: _globals.Color.fromArray(color.rgba),
            width: width,
            seed: seed,
            inverted: inverted,
            layout: layout
          });
        });
      });
    }
  }]);

  return v310Deserializer;
}(_deserializer2.default);

exports.default = v310Deserializer;


v310Deserializer.version = '3.1.0';

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _globals = __webpack_require__(0);

var _loadingModalComponent = __webpack_require__(192);

var _loadingModalComponent2 = _interopRequireDefault(_loadingModalComponent);

var _warningModalComponent = __webpack_require__(193);

var _warningModalComponent2 = _interopRequireDefault(_warningModalComponent);

var _errorModalComponent = __webpack_require__(194);

var _errorModalComponent2 = _interopRequireDefault(_errorModalComponent);

var _progressModalComponent = __webpack_require__(195);

var _progressModalComponent2 = _interopRequireDefault(_progressModalComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ModalContainerComponent = function (_BaseComponent) {
  _inherits(ModalContainerComponent, _BaseComponent);

  function ModalContainerComponent() {
    var _ref;

    _classCallCheck(this, ModalContainerComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = ModalContainerComponent.__proto__ || Object.getPrototypeOf(ModalContainerComponent)).call.apply(_ref, [this].concat(args)));

    _this._modalManager = _this.props.modalManager;
    _this._bindAll('_onModalManagerUpdate');
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  _createClass(ModalContainerComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      _get(ModalContainerComponent.prototype.__proto__ || Object.getPrototypeOf(ModalContainerComponent.prototype), 'componentDidMount', this).call(this);

      this._modalManager.on('update', this._onModalManagerUpdate);
    }

    /**
     * Gets called when this component is about to be unmounted
     */

  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      _get(ModalContainerComponent.prototype.__proto__ || Object.getPrototypeOf(ModalContainerComponent.prototype), 'componentWillUnmount', this).call(this);

      this._modalManager.off('update', this._onModalManagerUpdate);
    }

    // -------------------------------------------------------------------------- EVENTS

    /**
     * Gets called when the modal manager updates
     * @private
     */

  }, {
    key: '_onModalManagerUpdate',
    value: function _onModalManagerUpdate() {
      this.forceUpdate();
    }

    /**
     * Gets called when a modal is closed. Removes it from the manager.
     * @param  {Modal} modal
     * @private
     */

  }, {
    key: '_onModalClosed',
    value: function _onModalClosed(modal) {
      this._modalManager.removeModal(modal);
    }

    // -------------------------------------------------------------------------- RENDERING

    /**
     * Renders the modals
     * @return {Array.<React.Component>}
     */

  }, {
    key: '_renderModals',
    value: function _renderModals() {
      var _this2 = this;

      var modals = this._modalManager.getModals();
      return modals.map(function (modal) {
        var ModalComponent = void 0;

        switch (modal.type) {
          case 'loading':
            ModalComponent = _loadingModalComponent2.default;
            break;
          case 'warning':
            ModalComponent = _warningModalComponent2.default;
            break;
          case 'error':
            ModalComponent = _errorModalComponent2.default;
            break;
          case 'progress':
            ModalComponent = _progressModalComponent2.default;
            break;
        }

        return _globals.ReactBEM.createElement(ModalComponent, {
          modal: modal,
          onClose: _this2._onModalClosed.bind(_this2, modal) });
      });
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      return _globals.ReactBEM.createElement(
        'div',
        null,
        this._renderModals()
      );
    }
  }]);

  return ModalContainerComponent;
}(_globals.BaseComponent);

exports.default = ModalContainerComponent;


ModalContainerComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var LoadingModalComponent = function (_BaseComponent) {
  _inherits(LoadingModalComponent, _BaseComponent);

  function LoadingModalComponent() {
    _classCallCheck(this, LoadingModalComponent);

    return _possibleConstructorReturn(this, (LoadingModalComponent.__proto__ || Object.getPrototypeOf(LoadingModalComponent)).apply(this, arguments));
  }

  _createClass(LoadingModalComponent, [{
    key: 'renderWithBEM',

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */
    value: function renderWithBEM() {
      var modal = this.props.modal;
      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:modals' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:overlay' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:modal m:loading' },
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:text' },
              modal.text
            )
          )
        )
      );
    }
  }]);

  return LoadingModalComponent;
}(_globals.BaseComponent);

exports.default = LoadingModalComponent;


LoadingModalComponent.propTypes = {
  modal: _globals.PropTypes.object
};

LoadingModalComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var WarningModalComponent = function (_BaseComponent) {
  _inherits(WarningModalComponent, _BaseComponent);

  function WarningModalComponent() {
    _classCallCheck(this, WarningModalComponent);

    return _possibleConstructorReturn(this, (WarningModalComponent.__proto__ || Object.getPrototypeOf(WarningModalComponent)).apply(this, arguments));
  }

  _createClass(WarningModalComponent, [{
    key: 'renderWithBEM',

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */
    value: function renderWithBEM() {
      var modal = this.props.modal;
      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:modals' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:modal m:warning' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:title' },
            modal.title
          ),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:text' },
            modal.text
          ),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:button b:button m:inline', onClick: this.props.onClose },
            'OK'
          )
        )
      );
    }
  }]);

  return WarningModalComponent;
}(_globals.BaseComponent);

exports.default = WarningModalComponent;


WarningModalComponent.propTypes = {
  modal: _globals.PropTypes.object
};

WarningModalComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ErrorModalComponent = function (_BaseComponent) {
  _inherits(ErrorModalComponent, _BaseComponent);

  function ErrorModalComponent() {
    var _ref;

    _classCallCheck(this, ErrorModalComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = ErrorModalComponent.__proto__ || Object.getPrototypeOf(ErrorModalComponent)).call.apply(_ref, [this].concat(args)));

    _this._bindAll('_onClose');
    return _this;
  }

  /**
   * Gets called when the user clicks the close button
   * @private
   */


  _createClass(ErrorModalComponent, [{
    key: '_onClose',
    value: function _onClose() {
      this.props.modal.close();
    }

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */

  }, {
    key: 'renderWithBEM',
    value: function renderWithBEM() {
      var modal = this.props.modal;

      var modalElement = _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:modal m:error' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:title' },
          modal.title
        ),
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:text' },
          modal.text
        ),
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:button b:button m:inline', onClick: this._onClose },
          'OK'
        )
      );

      var content = modal.overlay ? _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:overlay' },
        modalElement
      ) : modalElement;

      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:modals' },
        content
      );
    }
  }]);

  return ErrorModalComponent;
}(_globals.BaseComponent);

exports.default = ErrorModalComponent;


ErrorModalComponent.propTypes = {
  modal: _globals.PropTypes.object
};

ErrorModalComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx ReactBEM.createElement **/
/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ProgressModalComponent = function (_BaseComponent) {
  _inherits(ProgressModalComponent, _BaseComponent);

  function ProgressModalComponent() {
    _classCallCheck(this, ProgressModalComponent);

    return _possibleConstructorReturn(this, (ProgressModalComponent.__proto__ || Object.getPrototypeOf(ProgressModalComponent)).apply(this, arguments));
  }

  _createClass(ProgressModalComponent, [{
    key: 'renderWithBEM',

    /**
     * Renders this component
     * @return {ReactBEM.Element}
     */
    value: function renderWithBEM() {
      var modal = this.props.modal;
      var progress = modal.data.progress;

      var progressStyle = {
        width: ((progress || 0) * 100).toFixed(2) + '%'
      };
      return _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:modals' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:overlay' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:modal m:loading' },
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:text' },
              modal.text
            ),
            _globals.ReactBEM.createElement(
              'bem',
              { specifier: 'b:loadingModal' },
              _globals.ReactBEM.createElement(
                'div',
                { bem: '$e:progressBar' },
                _globals.ReactBEM.createElement('div', { bem: 'e:progress', style: progressStyle })
              )
            )
          )
        )
      );
    }
  }]);

  return ProgressModalComponent;
}(_globals.BaseComponent);

exports.default = ProgressModalComponent;


ProgressModalComponent.propTypes = {
  modal: _globals.PropTypes.object
};

ProgressModalComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(0);

var _editor = __webpack_require__(43);

var _editor2 = _interopRequireDefault(_editor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var LOAD_TIMEOUT = 5000;

var Preloader = function (_EventEmitter) {
  _inherits(Preloader, _EventEmitter);

  function Preloader(ui, options, mediator) {
    _classCallCheck(this, Preloader);

    var _this = _possibleConstructorReturn(this, (Preloader.__proto__ || Object.getPrototypeOf(Preloader)).call(this));

    _this._ui = ui;
    _this._options = options;
    _this._mediator = mediator;

    _this._assets = {};

    // A shallow Editor instance that is only there to check for features etc.
    _this._editor = new _editor2.default(ui, options, mediator, true);

    // Generic assets that are pretty much always required
    _this._assets = ['controls/back.png', 'controls/minus.png', 'controls/plus.png', 'controls/tick.png', 'controls/webcam/shutter.png', 'controls/knobs/remove.png', 'controls/knobs/resize-diagonal-down.png', 'controls/knobs/resize-diagonal-up.png', 'controls/knobs/rotate.png', 'editor/export.png', 'editor/new.png', 'editor/undo.png', ['splash/photo-roll.png', false, true], ['splash/webcam.png', false, true], 'top-bar/back.png', 'close.png'];
    _this._appendControlsAssets();
    return _this;
  }

  /**
   * Adds the control-specific assets if necessary
   * @private
   */


  _createClass(Preloader, [{
    key: '_appendControlsAssets',
    value: function _appendControlsAssets() {
      var controls = this._editor.controls.getAvailable();
      for (var key in controls) {
        var Control = controls[key];
        if (this._editor.controls.isEnabled(key)) {
          this._assets = this._assets.concat(Control.getPreloadAssets(this._editor));
          this._assets.push(Control.iconPath);
        }
      }
    }

    /**
     * Loads the assets, emits progress events
     */

  }, {
    key: 'load',
    value: function load() {
      var _this2 = this;

      var assets = this._assets.slice();
      var assetsCount = assets.length;
      var assetsLoaded = 0;

      /**
       * Called when an asset has been loaded. Increases the asset counter and emits a progress
       * event
       */
      var assetLoaded = function assetLoaded() {
        assetsLoaded++;
        _this2.emit('progress', assetsLoaded / assetsCount);
        if (assetsLoaded === assetsCount) {
          _this2.emit('done');
        }
      };

      /**
       * Logs a warning message that the given asset failed to load for the given reason
       * @param  {String} path
       * @param  {String} reason
       */
      var assetLoadFailed = function assetLoadFailed(path) {
        var reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'timed out';

        _globals.Log.warn('Preloader', path + ' ' + reason + '.');
        assetLoaded();
      };

      /**
       * Creates a timeout for the given asset path. Assumes an asset failed to load when timeout
       * runs out
       * @param  {String} path
       * @return {Number}
       */
      var loadTimeout = function loadTimeout(path) {
        return window.setTimeout(function () {
          assetLoadFailed(path);
        }, LOAD_TIMEOUT);
      };

      assets.forEach(function (asset) {
        var retinaAsset = true;
        var uiAsset = true;
        if (_globals.SDKUtils.isArray(asset)) {
          uiAsset = asset[2];
          retinaAsset = asset[1];
          asset = asset[0];
        }

        var assetPath = _this2._ui.getAssetPath(asset, uiAsset, !retinaAsset);
        var image = new window.Image();
        var timeout = loadTimeout(assetPath);
        image.addEventListener('load', function () {
          _this2._assets[assetPath] = image;
          window.clearTimeout(timeout);
          assetLoaded();
        });
        image.addEventListener('error', function () {
          window.clearTimeout(timeout);
          assetLoadFailed(assetPath, 'was not found');
        });
        image.crossOrigin = _globals.SDKUtils.getCrossOriginValue(_this2._options.crossOrigin); // this._ui.getSDK().getCrossOrigin()
        image.src = assetPath;
      });
    }
  }, {
    key: 'getAsset',
    value: function getAsset(assetPath) {
      return this._assets[assetPath];
    }
  }]);

  return Preloader;
}(_globals.EventEmitter);

exports.default = Preloader;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _provider = __webpack_require__(198);

Object.defineProperty(exports, 'Provider', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_provider).default;
  }
});

var _library = __webpack_require__(199);

Object.defineProperty(exports, 'Library', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_library).default;
  }
});

var _searchSuggestion = __webpack_require__(200);

Object.defineProperty(exports, 'SearchSuggestion', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_searchSuggestion).default;
  }
});

var _photo = __webpack_require__(201);

Object.defineProperty(exports, 'Photo', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_photo).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var _globals = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Provider = function () {
  function Provider() {
    _classCallCheck(this, Provider);
  }

  _createClass(Provider, [{
    key: 'getLibraries',

    /**
     * Returns the libraries
     * @return {Promise}
     * @abstract
     */
    value: function getLibraries() {
      _globals.Log.warn(this.constructor.name, '`getLibraries` is abstract and not implemented.');
      return _globals.Promise.resolve([]);
    }

    /**
     * Returns search suggestions shown on the overview and "no results" page
     * @return {Promise}
     * @abstract
     */

  }, {
    key: 'getSearchSuggestions',
    value: function getSearchSuggestions() {
      _globals.Log.warn(this.constructor.name, '`getSearchSuggestions` is abstract and not implemented.');
      return _globals.Promise.resolve([]);
    }

    /**
     * Returns the photos for the given library
     * @param {PhotoEditorSDK.UI.ReactUI.PhotoRoll.Library} library
     * @return {Promise}
     * @abstract
     */

  }, {
    key: 'getPhotosForLibrary',
    value: function getPhotosForLibrary(library) {
      _globals.Log.warn(this.constructor.name, '`getPhotosForLibrary` is abstract and not implemented.');
      return _globals.Promise.resolve([]);
    }

    /**
     * Searches for photos with the given query
     * @param {String} query
     * @return {Promise}
     */

  }, {
    key: 'searchPhotos',
    value: function searchPhotos(query) {
      _globals.Log.warn(this.constructor.name, '`searchPhotos` is abstract and not implemented.');
      return _globals.Promise.resolve([]);
    }
  }]);

  return Provider;
}();

exports.default = Provider;

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var Library = function Library(data) {
  _classCallCheck(this, Library);

  this.name = data.name;
  this.coverImage = data.coverImage;
};

exports.default = Library;

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var SearchSuggestion = function SearchSuggestion(data) {
  _classCallCheck(this, SearchSuggestion);

  this.query = data.query;
  this.name = this.query;
  this.coverImage = data.coverImage;
};

exports.default = SearchSuggestion;

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* @module */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var Photo = function Photo(library, data) {
  _classCallCheck(this, Photo);

  this.library = library;
  this.title = data.title;
  this.urls = data.urls;
};

exports.default = Photo;

/***/ }),
/* 202 */
/***/ (function(module, exports) {

module.exports = {"pesdk":{"adjustments":{"title":{"name":"Korrekturen"},"text":{"brightness":"Helligkeit","saturation":"Sättigung","contrast":"Kontrast","gamma":"Gamma","clarity":"Klarheit","exposure":"Belichtung","shadows":"Schatten","highlights":"Lichter"}},"brush":{"title":{"name":"Malen"},"text":{"size":"Dicke"}},"camera":{"title":{"headline":"Mache ein Foto!"},"text":{"webcamUnavailable":"Webcam-Bild kann nicht dargestellt werden. (Fehler: ${error})"}},"common":{"title":{"error":"Es ist ein Fehler aufgetreten","imageLoadFail":"Bild konnte nicht geladen werden"},"text":{"color":"Farbe","loading":"Lade...","imageLoadFail":"Beim Laden des Bildes unter ${path} ist ein Fehler aufgetreten."},"button":{"back":"Zurück","cancel":"Abbrechen"}},"editor":{"title":{"zoom":"Zoom","renderingError":"Rendering-Fehler","imageResized_maxMegaPixels":"Bild verkleinert","imageResized_maxDimensions":"Bild verkleinert"},"button":{"export":"Speichern","backgroundImage":"Hintergrundbild","new":"Neu","undo":"Rückgängig"},"text":{"invalidFileType":"Der Dateityp ${fileType} wird nicht unterstützt.","exporting":"Exportiere...","renderingError":"Beim Rendern des Bildes ist ein Fehler aufgetreten.","resizing":"Bild wird bearbeitet...","imageResized_maxMegaPixels":"Da dein Bild die maximale Größe von ${maxMegaPixels} Megapixeln überschreitet, wurde es auf ${width}x${height} Pixel verkleinert.","imageResized_maxDimensions":"Aufgrund von Hardware-Beschränkungen wurde das Bild auf ${width}x${height} Pixel verkleinert."}},"filter":{"title":{"name":"Filter"},"text":{"intensity":"Intensität"},"asset":{"identity":"Original","imgly_lut_celsius":"Celsius","imgly_lut_chest":"Chest","imgly_lut_fixie":"Fixie","imgly_lut_fridge":"Fridge","imgly_lut_front":"Front","imgly_lut_k2":"K2","imgly_lut_mellow":"Mellow","imgly_lut_sin":"Sin","imgly_lut_texas":"Texas","imgly_lut_ad1920":"1920 A.D.","imgly_lut_ancient":"Ancient","imgly_lut_bleached":"Bleached","imgly_lut_bleachedblue":"Bleached Blue","imgly_lut_blues":"Blues","imgly_lut_blueshadows":"Blue Shadows","imgly_lut_breeze":"Breeze","imgly_lut_bw":"B & W","imgly_lut_classic":"Classic","imgly_lut_colorful":"Colorful","imgly_lut_cool":"Cool","imgly_lut_cottoncandy":"Cotton Candy","imgly_lut_creamy":"Creamy","imgly_lut_eighties":"Eighties","imgly_lut_elder":"Elder","imgly_lut_evening":"Evening","imgly_lut_fall":"Fall","imgly_lut_food":"Food","imgly_lut_glam":"Glam","imgly_lut_gobblin":"Gobblin","imgly_lut_highcarb":"High Carb","imgly_lut_highcontrast":"High Contrast","imgly_lut_k1":"K1","imgly_lut_k6":"K6","imgly_lut_kdynamic":"KDynamic","imgly_lut_keen":"Keen","imgly_lut_lenin":"Lenin","imgly_lut_litho":"Litho","imgly_lut_lomo100":"Lomo 100","imgly_lut_lucid":"Lucid","imgly_lut_neat":"Neat","imgly_lut_nogreen":"No Green","imgly_lut_orchid":"Orchid","imgly_lut_pale":"Pale","imgly_lut_pitched":"Pitched","imgly_lut_plate":"Plate","imgly_lut_pola669":"Pola 669","imgly_lut_polasx":"Pola SX","imgly_lut_pro400":"Pro 400","imgly_lut_quozi":"Quozi","imgly_lut_sepiahigh":"Sepia High","imgly_lut_settled":"Settled","imgly_lut_seventies":"Seventies","imgly_lut_soft":"Soft","imgly_lut_steel":"Steel","imgly_lut_summer":"Summer","imgly_lut_sunset":"Sunset","imgly_lut_tender":"Tender","imgly_lut_twilight":"Twilight","imgly_lut_winter":"Winter","imgly_lut_x400":"X400","imgly_filters_analog":"Analog","imgly_filters_bw":"Black & White","imgly_filters_retro":"Retro","imgly_filters_special":"Special","imgly_filters_summer":"Summer","imgly_filters_winter":"Winter","all":"Alle"}},"focus":{"title":{"name":"Focus"},"text":{"blurRadius":"Radius"},"button":{"none":"Original","radial":"Kreisförmig","mirrored":"Gespiegelt"}},"frame":{"title":{"name":"Rahmen"},"text":{"scale":"Größe"},"button":{"none":"Kein Rahmen"},"asset":{"imgly_frame_dia":"Dia","imgly_frame_art_decor":"Art Decor","imgly_frame_black_passepartout":"Black Passepartout","imgly_frame_lowpoly_shadow":"Low Poly","imgly_frame_wood_passepartout":"Wood Passepartout"}},"library":{"title":{"searchResults":"Suchergebnisse für \"${query}\"","photoRollLoadFail":"Laden der Photo Roll fehlgeschlagen"},"text":{"photoRollLoadFail":"Failed to load photos for the photo roll: ${error}","noSearchResults":"Die Photo Roll konnte nicht geladen werden: ${error}"},"placeholder":{"search":"Nach Fotos suchen"}},"splash":{"button":{"upload":"Lade ein Foto hoch"},"title":{"photoRoll":"Kostenloses Bildmaterial","webcam":"Webcam"},"text":{"photoRoll":"Suche dir eines von tausenden Stock Photos aus.","upload":"Klicke hier, um ein Foto von deinem Rechner hochzuladen oder lade es per Drag-and-Drop hoch","webcam":"Klicke hier, um ein Foto mit deiner Webcam zu machen"}},"sticker":{"title":{"name":"Sticker","loadingStickersFailed":"Laden der Sticker fehlgeschlagen"},"asset":{"all":"Alle","imgly_sticker_emoticons":"Emoticons","imgly_sticker_shapes":"Shapes"}},"text":{"title":{"name":"Text","loadingFontsFailed":"Laden der Schriftarten fehlgeschlagen"},"text":{"loadingFontsFailed":"Einige Schriftarten sind möglicherweise nicht verfügbar."},"button":{"size":"Größe","font":"Schriftart","alignment":"Ausrichtung","foreground":"Vordergrund","background":"Hintergrund","takeToFront":"Nach oben"},"placeholder":{"defaultText":"Doppelklick zum Bearbeiten!"}},"transform":{"title":{"name":"Zuschneiden"},"button":{"none":"Original"},"text":{"rotation":"Drehung"},"asset":{"imgly_transform_common_custom":"Frei","imgly_transform_common_square":"Quadratisch","imgly_transform_common_4-3":"4:3","imgly_transform_common_16-9":"16:9","imgly_transform_facebook_ad":"FB Ad","imgly_transform_facebook_post":"FB Post","imgly_transform_facebook_cover":"FB Cover","imgly_transform_facebook_profile":"FB Profile"}}}}

/***/ }),
/* 203 */
/***/ (function(module, exports) {

module.exports = {"pesdk":{"adjustments":{"title":{"name":"Adjust"},"text":{"brightness":"Brightness","saturation":"Saturation","contrast":"Contrast","gamma":"Gamma","clarity":"Clarity","exposure":"Exposure","shadows":"Shadows","highlights":"Highlights","whites":"Whites","blacks":"Blacks","temperature":"Temperature"}},"brush":{"title":{"name":"Brush"},"text":{"size":"Size"}},"camera":{"title":{"headline":"Take a photo!"},"text":{"webcamUnavailable":"Unable to display webcam image (Error: ${error})"}},"common":{"title":{"error":"An error has occurred","imageLoadFail":"Failed to load image"},"text":{"color":"Color","loading":"Loading...","imageLoadFail":"Failed to load the image at ${path}"},"button":{"back":"Back","cancel":"Cancel"}},"editor":{"title":{"zoom":"Zoom","renderingError":"Error while rendering","imageResized_maxMegaPixels":"Image resized","imageResized_maxDimensions":"Image resized"},"button":{"export":"Export","backgroundImage":"Background Image","new":"New","undo":"Undo"},"text":{"invalidFileType":"The file type ${fileType} is not supported.","exporting":"Exporting...","renderingError":"An error has occurred while rendering the image.","resizing":"Resizing...","imageResized_maxMegaPixels":"Your image exceeds the maximum size of ${maxMegaPixels} megapixels and has therefore been resized to ${width}x${height} pixels.","imageResized_maxDimensions":"Due to hardware limitations your image has been resized to ${width}x${height} pixels."}},"filter":{"title":{"name":"Filters"},"text":{"intensity":"Intensity"},"asset":{"identity":"None","imgly_lut_celsius":"Celsius","imgly_lut_chest":"Chest","imgly_lut_fixie":"Fixie","imgly_lut_fridge":"Fridge","imgly_lut_front":"Front","imgly_lut_k2":"K2","imgly_lut_mellow":"Mellow","imgly_lut_sin":"Sin","imgly_lut_texas":"Texas","imgly_lut_ad1920":"1920 A.D.","imgly_lut_ancient":"Ancient","imgly_lut_bleached":"Bleached","imgly_lut_bleachedblue":"Bleached Blue","imgly_lut_blues":"Blues","imgly_lut_blueshadows":"Blue Shadows","imgly_lut_breeze":"Breeze","imgly_lut_bw":"B & W","imgly_lut_classic":"Classic","imgly_lut_colorful":"Colorful","imgly_lut_cool":"Cool","imgly_lut_cottoncandy":"Cotton Candy","imgly_lut_creamy":"Creamy","imgly_lut_eighties":"Eighties","imgly_lut_elder":"Elder","imgly_lut_evening":"Evening","imgly_lut_fall":"Fall","imgly_lut_food":"Food","imgly_lut_glam":"Glam","imgly_lut_gobblin":"Gobblin","imgly_lut_highcarb":"High Carb","imgly_lut_highcontrast":"High Contrast","imgly_lut_k1":"K1","imgly_lut_k6":"K6","imgly_lut_kdynamic":"KDynamic","imgly_lut_keen":"Keen","imgly_lut_lenin":"Lenin","imgly_lut_litho":"Litho","imgly_lut_lomo100":"Lomo 100","imgly_lut_lucid":"Lucid","imgly_lut_neat":"Neat","imgly_lut_nogreen":"No Green","imgly_lut_orchid":"Orchid","imgly_lut_pale":"Pale","imgly_lut_pitched":"Pitched","imgly_lut_plate":"Plate","imgly_lut_pola669":"Pola 669","imgly_lut_polasx":"Pola SX","imgly_lut_pro400":"Pro 400","imgly_lut_quozi":"Quozi","imgly_lut_sepiahigh":"Sepia High","imgly_lut_settled":"Settled","imgly_lut_seventies":"Seventies","imgly_lut_soft":"Soft","imgly_lut_steel":"Steel","imgly_lut_summer":"Summer","imgly_lut_sunset":"Sunset","imgly_lut_tender":"Tender","imgly_lut_twilight":"Twilight","imgly_lut_winter":"Winter","imgly_lut_x400":"X400","imgly_filters_analog":"Analog","imgly_filters_bw":"Black & White","imgly_filters_retro":"Retro","imgly_filters_special":"Special","imgly_filters_summer":"Summer","imgly_filters_winter":"Winter","all":"All"}},"focus":{"title":{"name":"Focus"},"text":{"blurRadius":"Blur radius"},"button":{"none":"None","radial":"Radial","mirrored":"Mirrored"}},"frame":{"title":{"name":"Frame"},"text":{"scale":"Scale"},"button":{"none":"None"},"asset":{"imgly_frame_dia":"Dia","imgly_frame_art_decor":"Art Decor","imgly_frame_black_passepartout":"Black Passepartout","imgly_frame_lowpoly_shadow":"Low Poly","imgly_frame_wood_passepartout":"Wood Passepartout"}},"library":{"title":{"searchResults":"Search results for \"${query}\"","photoRollLoadFail":"Failed to load Photo Roll"},"text":{"photoRollLoadFail":"Failed to load photos for the photo roll: ${error}","noSearchResults":"Sorry, but we couldn't find any photos for <strong>\"${query}\"</strong>."},"placeholder":{"search":"Search for photos"}},"splash":{"button":{"upload":"Upload your image"},"title":{"photoRoll":"Free stock footage","webcam":"Webcam"},"text":{"photoRoll":"Select from thousands of Free Stock Photos","upload":"Upload a picture from your library or just drag and drop","webcam":"Take a picture with your webcam or phone"}},"sticker":{"title":{"name":"Sticker","loadingStickersFailed":"Failed to load stickers"},"asset":{"all":"All","imgly_sticker_emoticons":"Emoticons","imgly_sticker_shapes":"Shapes"}},"text":{"title":{"name":"Text","loadingFontsFailed":"Failed to load fonts"},"text":{"loadingFontsFailed":"Some fonts might not be available."},"button":{"size":"Size","font":"Font","alignment":"Alignment","foreground":"Foreground","background":"Background","takeToFront":"To Front"},"placeholder":{"defaultText":"Double-click to edit"}},"transform":{"title":{"name":"Transform"},"button":{"none":"Original"},"text":{"rotation":"Rotation"},"asset":{"imgly_transform_common_custom":"Custom","imgly_transform_common_square":"Square","imgly_transform_common_4-3":"4:3","imgly_transform_common_16-9":"16:9","imgly_transform_facebook_ad":"FB Ad","imgly_transform_facebook_post":"FB Post","imgly_transform_facebook_cover":"FB Cover","imgly_transform_facebook_profile":"FB Profile"}}}}

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBhNGYyMmRlOWIzNzU5Y2E3OWNjYyIsIndlYnBhY2s6Ly8vLi9nbG9iYWxzLmpzIiwid2VicGFjazovLy8uL2xpYi9tb2RhbC1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvc2Nyb2xsYmFyLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy9jb250cm9scy1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvY29udHJvbHMuanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9kcmFnZ2FibGUtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL3NsaWRlci1vdmVybGF5LWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJwaG90b2VkaXRvcnNkay9qcy9QaG90b0VkaXRvclNES1wiLFwiY29tbW9uanMyXCI6XCJwaG90b2VkaXRvcnNkay9qcy9QaG90b0VkaXRvclNES1wiLFwiYW1kXCI6XCJwaG90b2VkaXRvcnNka1wiLFwicm9vdFwiOlwiUGhvdG9FZGl0b3JTREtcIn0iLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3NjcmVlbnMvc2NyZWVuLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy9jYW52YXMtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9tYW5hZ2Vycy9zdGlja2VyLW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zaGFyZWQvdG9wLWJhci90b3AtYmFyLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zbGlkZXItY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL3Nwcml0ZXMvc3ByaXRlcy1jYW52YXMtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9tYW5hZ2Vycy9mb250LW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcInJvb3RcIjpcIlJlYWN0XCIsXCJjb21tb25qczJcIjpcInJlYWN0XCIsXCJjb21tb25qc1wiOlwicmVhY3RcIixcImFtZFwiOlwicmVhY3RcIn0iLCJ3ZWJwYWNrOi8vLy9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8vbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzIiwid2VicGFjazovLy8vbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zaGFyZWQvbG9nLmpzIiwid2VicGFjazovLy8vbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8vbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvanMvc2hhcmVkL2xvYWRlcnMvanNvbi1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zaGFyZWQvbG9hZGVycy9pbWFnZS1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zY3JlZW5zL3NwbGFzaC9yb3ctY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3NoYXJlZC9pbnZpc2libGUtdXBsb2FkLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zaGFyZWQvdG9wLWJhci9idXR0b24tY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9tYW5hZ2Vycy9maWx0ZXItbWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL3Nwcml0ZXMvaXRlbXMvaXRlbS1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29sb3ItcGlja2VyL2NvbG9yLXBpY2tlci1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2xpYi9mb250LWxvYWRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9zZXJpYWxpemF0aW9uLzIuMC4wL3NlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zaGFyZWQvc2VyaWFsaXphdGlvbi8yLjAuMC9kZXNlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovLy8vbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcyIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2JlbS5qc3giLCJ3ZWJwYWNrOi8vLy4vbGliL3JlYWN0LWJlbS5qcyIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9jb25zdGFudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L25vZGVfbW9kdWxlcy9wZXJmb3JtYW5jZS1ub3cvbGliL3BlcmZvcm1hbmNlLW5vdy5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3NjcmVlbnMvcGhvdG8tcm9sbC9pdGVtcy9zZWFyY2gtc3VnZ2VzdGlvbi1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvc2NyZWVucy9waG90by1yb2xsL3Bob3RvLWxpc3QtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL292ZXJ2aWV3L292ZXJ2aWV3LWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vbGliL2VkaXRvci5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL2luZGV4LmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY2F0ZWdvcnktZHJvcGRvd24vY2F0ZWdvcnktZHJvcGRvd24tY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL3RleHQvZm9udC1wcmV2aWV3LWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zaGFyZWQvYXNzZXRzL2ZvbnQtdmFyaWF0aW9uLmpzIiwid2VicGFjazovLy8vbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvanMvc2hhcmVkL21hbmFnZXJzL2ZyYW1lLW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2ZyYW1lLmpzIiwid2VicGFjazovLy8vbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvanMvc2hhcmVkL3NlcmlhbGl6YXRpb24vMS4wLjAvc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9zZXJpYWxpemF0aW9uLzEuMC4wL2Rlc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZm9udC1sb2FkZXIvbG9hZGVycy9iYXNlLWZvbnQtbG9hZGVyLmpzIiwid2VicGFjazovLy8vbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvanMvc2hhcmVkL3NlcmlhbGl6YXRpb24vMS4wLjEvc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9zZXJpYWxpemF0aW9uLzEuMC4xL2Rlc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9zZXJpYWxpemF0aW9uLzIuMC4wL2JsZW5kLW1vZGVzLmpzIiwid2VicGFjazovLy8vbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvanMvc2hhcmVkL3NlcmlhbGl6YXRpb24vMy4wLjAvc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9zZXJpYWxpemF0aW9uLzMuMC4wL2Rlc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9tYW5hZ2Vycy90ZXh0LWRlc2lnbi1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL2luZGV4LmpzIiwid2VicGFjazovLy8vbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvY3NzL1Bob3RvRWRpdG9yUmVhY3RVSS5zYXNzIiwid2VicGFjazovLy8uL3VpLmpzeCIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwiUmVhY3RET01cIixcImNvbW1vbmpzMlwiOlwicmVhY3QtZG9tXCIsXCJjb21tb25qc1wiOlwicmVhY3QtZG9tXCIsXCJhbWRcIjpcInJlYWN0LWRvbVwifSIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vLy9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8vbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvYmFzZS1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3Nkay9jb3JlL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3Nkay9jb3JlL2xpYi9iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vLy9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zZGsvY29yZS9saWIvYXJyYXktdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL3V0aWxzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zaGFyZWQvdmVuZG9yL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8vbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvbm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJ3ZWJwYWNrOi8vLy9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8vbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwid2VicGFjazovLy8vbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvbmV3LXRvLW9sZC1sb2NhbGl6YXRpb24ta2V5LW1hcC5qc29uIiwid2VicGFjazovLy8uL2xpYi9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL3NoYXJlZC1zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9hc3luYy9hbmltYXRpb24tZnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9hcHAtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3NjcmVlbnMvbG9hZGluZy9sb2FkaW5nLXNjcmVlbi1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvaGVhZGVyLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zY3JlZW5zL3NwbGFzaC9zcGxhc2gtc2NyZWVuLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zY3JlZW5zL3NwbGFzaC91cGxvYWQtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2J1dHRvbi1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8vbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvanMvc2hhcmVkL2xvYWRlcnMvZmlsZS1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zaGFyZWQvbWFuYWdlcnMvbW9kYWwtbWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3NjcmVlbnMvc3BsYXNoL3dlYmNhbS1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvc2NyZWVucy9zcGxhc2gvcGhvdG8tcm9sbC1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvc2NyZWVucy9waG90by1yb2xsL3Bob3RvLXJvbGwtc2NyZWVuLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zY3JlZW5zL3Bob3RvLXJvbGwvdG9wLWJhci90b3AtYmFyLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zY3JlZW5zL3Bob3RvLXJvbGwvdG9wLWJhci90b3AtYmFyLWJ1dHRvbi1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvc2NyZWVucy9waG90by1yb2xsL3RvcC1iYXIvdG9wLWJhci1zZWFyY2gtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3NoYXJlZC90b3AtYmFyL2JhY2stYnV0dG9uLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zY3JlZW5zL3Bob3RvLXJvbGwvb3ZlcnZpZXctY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3NjcmVlbnMvcGhvdG8tcm9sbC9pdGVtcy9saWJyYXJ5LWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zY3JlZW5zL3Bob3RvLXJvbGwvaXRlbXMvcGhvdG8tY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3NjcmVlbnMvcGhvdG8tcm9sbC9zZWFyY2gtcmVzdWx0cy1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvc2NyZWVucy9waG90by1yb2xsL25vLXNlYXJjaC1yZXN1bHRzLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zY3JlZW5zL3dlYmNhbS93ZWJjYW0tc2NyZWVuLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zY3JlZW5zL3dlYmNhbS93ZWJjYW0tY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3NjcmVlbnMvd2ViY2FtL3dlYmNhbS12aWRlby1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvc2NyZWVucy9lZGl0b3IvZWRpdG9yLXNjcmVlbi1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvYmFjay1idXR0b24tY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2RvbmUtYnV0dG9uLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zY3JlZW5zL2VkaXRvci9jYW52YXMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL292ZXJ2aWV3L2luZGV4LmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvb3ZlcnZpZXcvdG9wLWJhci90b3AtYmFyLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy9vdmVydmlldy90b3AtYmFyL25ldy1maWxlLWJ1dHRvbi1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvb3ZlcnZpZXcvdG9wLWJhci9leHBvcnQtYnV0dG9uLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy9vdmVydmlldy90b3AtYmFyL3VuZG8tYnV0dG9uLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy9vdmVydmlldy90b3AtYmFyL3pvb20tY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL292ZXJ2aWV3L292ZXJ2aWV3LWNhbnZhcy1jb250cm9scy1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8vbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvanMvc2hhcmVkL2V4cG9ydGVyLmpzIiwid2VicGFjazovLy8vbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvanMvc2hhcmVkL2Rvd25sb2FkZXIvZmlsZS1kb3dubG9hZGVyLmpzIiwid2VicGFjazovLy8uL2xpYi9pbWFnZS1yZXNpemVyLmpzIiwid2VicGFjazovLy8uL2xpYi9lZGl0b3Ivb3BlcmF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZWRpdG9yL2NvbnRyb2xzLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvYWRqdXN0bWVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy9hZGp1c3RtZW50cy9hZGp1c3RtZW50cy1jb250cm9scy1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvbWluaS1zbGlkZXItY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL3RyYW5zZm9ybS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL3RyYW5zZm9ybS90cmFuc2Zvcm0tY29udHJvbHMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL3RyYW5zZm9ybS90cmFuc2Zvcm0tY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy90cmFuc2Zvcm0vdHJhbnNmb3JtLXRvcC1iYXItY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL2ZpbHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL2ZpbHRlci9maWx0ZXItY29udHJvbHMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NhdGVnb3J5LWRyb3Bkb3duL292ZXJsYXktY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL2ZvY3VzL2luZGV4LmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvZm9jdXMvZm9jdXMtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL2ZvY3VzL2ZvY3VzLWNhbnZhcy1jb250cm9scy1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvZm9jdXMvbGluZWFyLWZvY3VzLWNhbnZhcy1jb250cm9scy1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvZm9jdXMvcmFkaWFsLWZvY3VzLWNhbnZhcy1jb250cm9scy1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvc3RpY2tlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL3N0aWNrZXIvc3RpY2tlci1jb250cm9scy1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvc3RpY2tlci9zdGlja2VyLWl0ZW0tY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL3N0aWNrZXIvc3RpY2tlci1jYW52YXMtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL3Nwcml0ZXMvaXRlbXMvdGV4dC1pdGVtLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy9zcHJpdGVzL2l0ZW1zL3N0aWNrZXItaXRlbS1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvc3ByaXRlcy9pdGVtcy9icnVzaC1pdGVtLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy9zdGlja2VyL3N0aWNrZXItY29udHJvbHMtb3ZlcmxheS1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvdGV4dC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL3RleHQvdGV4dC1jYW52YXMtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL3RleHQvdGV4dC1jb250cm9scy1vdmVybGF5LWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy90ZXh0L3RleHQtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbG9yLXBpY2tlci9vdmVybGF5LWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb2xvci1waWNrZXIvYWxwaGEtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbG9yLXBpY2tlci9zYXR1cmF0aW9uLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb2xvci1waWNrZXIvaHVlLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy90ZXh0L2ZvbnQtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9hc3NldHMvZm9udC5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL2JydXNoL2luZGV4LmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvYnJ1c2gvYnJ1c2gtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL2JydXNoL3ByZXNldC1wcmV2aWV3LWl0ZW0tY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL2JydXNoL2JydXNoLWNhbnZhcy1jb250cm9scy1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvc2VsZWN0aXZlLWJsdXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy9zZWxlY3RpdmUtYmx1ci9zZWxlY3RpdmUtYmx1ci1jb250cm9scy1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvc2VsZWN0aXZlLWJsdXIvc2VsZWN0aXZlLWJsdXItY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy9mcmFtZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL2ZyYW1lL2ZyYW1lLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy9mcmFtZS9mcmFtZS1pdGVtLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vbGliL2VkaXRvci9mZWF0dXJlcy5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZWRpdG9yL3pvb20uanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2VkaXRvci9oaXN0b3J5LmpzIiwid2VicGFjazovLy8vbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvanMvc2hhcmVkL3NlcmlhbGl6YXRpb24vMS4wLjAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8vbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9tYW5hZ2Vycy9icnVzaC1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL2xpYi9mb250LWxvYWRlci9sb2FkZXJzL2dvb2dsZS1mb250LWxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZm9udC1sb2FkZXIvZm9udC1vYnNlcnZlci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZm9udC1sb2FkZXIvZm9udC1ydWxlci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZm9udC1sb2FkZXIvbG9hZGVycy9maWxlLWZvbnQtbG9hZGVyLmpzIiwid2VicGFjazovLy8vbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvanMvc2hhcmVkL3NlcmlhbGl6YXRpb24vMS4wLjEvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zaGFyZWQvc2VyaWFsaXphdGlvbi8yLjAuMC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9tYW5hZ2Vycy9vdmVybGF5LW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zaGFyZWQvc2VyaWFsaXphdGlvbi8yLjAuMS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9zZXJpYWxpemF0aW9uLzIuMC4xL3NlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zaGFyZWQvc2VyaWFsaXphdGlvbi8yLjAuMS9kZXNlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zaGFyZWQvc2VyaWFsaXphdGlvbi8zLjAuMC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9zZXJpYWxpemF0aW9uLzMuMS4wL2luZGV4LmpzIiwid2VicGFjazovLy8vbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvanMvc2hhcmVkL3NlcmlhbGl6YXRpb24vMy4xLjAvc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9zZXJpYWxpemF0aW9uLzMuMS4wL2Rlc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL21vZGFsLWNvbnRhaW5lci1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvbW9kYWxzL2xvYWRpbmctbW9kYWwtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL21vZGFscy93YXJuaW5nLW1vZGFsLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9tb2RhbHMvZXJyb3ItbW9kYWwtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL21vZGFscy9wcm9ncmVzcy1tb2RhbC1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2xpYi9wcmVsb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL3Bob3RvLXJvbGwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbGliL3Bob3RvLXJvbGwvcHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL3Bob3RvLXJvbGwvbGlicmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvcGhvdG8tcm9sbC9zZWFyY2gtc3VnZ2VzdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9saWIvcGhvdG8tcm9sbC9waG90by5qcyIsIndlYnBhY2s6Ly8vLi9sYW5nL2RlLmpzb24iLCJ3ZWJwYWNrOi8vLy4vbGFuZy9lbi5qc29uIl0sIm5hbWVzIjpbIkJhc2U2NCIsIlBob3RvRWRpdG9yU0RLIiwiQ29sb3IiLCJDb2xvck1hdHJpeCIsIk1hdGgiLCJFdmVudEVtaXR0ZXIiLCJFWElGIiwiT3B0aW9uVHlwZSIsIlByb21pc2UiLCJTREtVdGlscyIsIlV0aWxzIiwiUmVuZGVyVHlwZSIsIkltYWdlRm9ybWF0IiwiU0RLIiwiVW5pZm9ybVR5cGUiLCJWZWN0b3IyIiwibm93Iiwid2luZG93IiwicGVyZm9ybWFuY2UiLCJiaW5kIiwicmVxdWlyZSIsIlJlYWN0IiwiQkVNIiwiQ2xhc3NuYW1lcyIsIkJhc2VDb21wb25lbnQiLCJSZWFjdEJFTSIsIkNvbnN0YW50cyIsIlNoYXJlZFN0YXRlIiwiUmVhY3RET00iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIkxvZyIsIkltYWdlTG9hZGVyIiwiUHJvcFR5cGVzIiwiU2hhcmVkQ29uc3RhbnRzIiwiTW9kYWwiLCJ0eXBlIiwidGl0bGUiLCJ0ZXh0Iiwib3ZlcmxheSIsImRhdGEiLCJlbWl0IiwiTW9kYWxNYW5hZ2VyIiwiX21vZGFscyIsIm1vZGFsIiwiYWRkTW9kYWwiLCJwcm9ncmVzcyIsInNldERhdGEiLCJwdXNoIiwib24iLCJyZW1vdmVNb2RhbCIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsIl9pbnN0YW5jZSIsIlNDUk9MTEJBUl9XSURUSCIsIlNjcm9sbGJhckNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwiTkFUSVZFX1NDUk9MTEJBUl9XSURUSCIsImdldFNjcm9sbGJhcldpZHRoIiwiX25lZWRzU3R5bGVGaXhlcyIsIl9pc0RyYWdnaW5nIiwiX2JpbmRBbGwiLCJzdGF0ZSIsImJ1dHRvblNpemUiLCJidXR0b25Qb3NpdGlvbiIsImJ1dHRvblZpc2libGUiLCJ1cGRhdGUiLCJpc01vYmlsZSIsIl91cGRhdGVMaXN0U2l6ZSIsImRpcmVjdGlvbiIsIl9nZXREaXJlY3Rpb24iLCJsaXN0U2Nyb2xsU2l6ZSIsImxpc3RTY3JvbGxQb3NpdGlvbiIsImJhY2tncm91bmRTY3JvbGxTaXplIiwiSE9SSVpPTlRBTCIsIl9saXN0Iiwic2Nyb2xsV2lkdGgiLCJvZmZzZXRXaWR0aCIsInNjcm9sbExlZnQiLCJfbm9kZSIsIlZFUlRJQ0FMIiwic2Nyb2xsSGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0Iiwic2Nyb2xsVG9wIiwic2V0U3RhdGUiLCJlIiwiX2luaXRpYWxCdXR0b25Qb3NpdGlvbiIsImRpZmYiLCJ4IiwieSIsIl9zZXRCdXR0b25Qb3NpdGlvbiIsIm1vdXNlUG9zaXRpb24iLCJnZXRFdmVudFBvc2l0aW9uIiwiX2luaXRpYWxQb3NpdGlvbiIsImNsb25lIiwiYm91bmRpbmdSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZWxlbWVudE9mZnNldCIsImxlZnQiLCJ0b3AiLCJyZWxhdGl2ZVBvc2l0aW9uIiwic3VidHJhY3QiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJfb25CYXJEcmFnIiwiX29uQmFyRHJhZ1N0b3AiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2Nyb2xsYWJsZUJ1dHRvblNpemUiLCJzY3JvbGxhYmxlTGlzdFNpemUiLCJtYXgiLCJtaW4iLCJzY3JvbGxQb3NpdGlvbiIsImNiIiwicGFyZW50U2l6ZSIsInBhcmVudFNjcm9sbFNpemUiLCJjbGllbnRXaWR0aCIsInN0eWxlIiwiaGVpZ2h0IiwiZnVsbERpbWVuc2lvbnMiLCJfZ2V0RnVsbExpc3REaW1lbnNpb25zIiwiX2xpc3RTaXplIiwiX2xpc3RDb250ZW50U2l6ZSIsIndpZHRoIiwicmVjdCIsInJlZnMiLCJyb290IiwibGlzdCIsIl91cGRhdGVCdXR0b25TaXplIiwibmV3TGlzdFNpemUiLCJfb25MaXN0U2Nyb2xsIiwicHJvcHMiLCJjaGlsZHJlbiIsImJ1dHRvblN0eWxlIiwiX2dldEJ1dHRvblN0eWxlIiwic2Nyb2xsYmFyU3R5bGUiLCJkaXNwbGF5IiwiY2hpbGQiLCJjbG9uZUVsZW1lbnQiLCJyZWYiLCJfb25CYXJEcmFnU3RhcnQiLCJfb25CdXR0b25EcmFnU3RhcnQiLCJfb25CdXR0b25EcmFnIiwiX29uQnV0dG9uRHJhZ1N0b3AiLCJfb25CdXR0b25Eb3duIiwiY29udGV4dFR5cGVzIiwiQ29udHJvbHNDb21wb25lbnQiLCJhcmdzIiwiX2hhc0JhY2tCdXR0b24iLCJfaGFzRG9uZUJ1dHRvbiIsIl9iYWNrQnV0dG9uQ2xpY2tlZCIsImlkZW50aWZpZXIiLCJnbG9iYWxTdGF0ZSIsImNvbnRleHQiLCJnZXQiLCJzZXQiLCJvblN3aXRjaENvbnRyb2xzIiwiX29uQmFja0NsaWNrIiwiZm9yY2VkQ29udHJvbCIsIm9wdGlvbnMiLCJiYWNrQnV0dG9uIiwiZG9uZUJ1dHRvbiIsIl9vbkRvbmVDbGljayIsInJlbmRlck92ZXJsYXlDb250cm9scyIsInJlbmRlckNvbnRyb2xzIiwiQ29udHJvbCIsImVkaXRvciIsInRvcEJhckNvbnRyb2xzQ29tcG9uZW50IiwiY29udHJvbHNDb21wb25lbnQiLCJjYW52YXNDb250cm9sc0NvbXBvbmVudCIsImljb25QYXRoIiwibGFuZ3VhZ2VLZXkiLCJkZWZhdWx0T3B0aW9ucyIsIkRyYWdnYWJsZUNvbXBvbmVudCIsImRpc2FibGVkIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJfaW5pdGlhbE1vdXNlUG9zaXRpb24iLCJfb25EcmFnTW92ZSIsIl9vbkRyYWdFbmQiLCJlbGVtZW50Iiwib25TdGFydCIsIm1vdXNlRGlmZiIsIm9uRHJhZyIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsIm9uU3RvcCIsIkFycmF5IiwiRXJyb3IiLCJvbk1vdXNlRG93biIsIl9vbkRyYWdTdGFydCIsIm9uVG91Y2hTdGFydCIsIlNsaWRlck92ZXJsYXlDb21wb25lbnQiLCJ2YWx1ZSIsIm9uQ2hhbmdlIiwiZGVmYXVsdHMiLCJtaWRkbGVEb3QiLCJtaW5WYWx1ZSIsIm1heFZhbHVlIiwibGFiZWwiLCJfb25TbGlkZXJWYWx1ZUNoYW5nZSIsIl9yZW5kZXJTbGlkZXIiLCJTY3JlZW5Db21wb25lbnQiLCJzaG93SGVhZGVyIiwic2NyZWVuQkVNU3BlY2lmaWVyIiwidmlzaWJsZSIsIl9yZW5kZXJIZWFkZXIiLCJfcmVuZGVyU2NyZWVuIiwicHJvcFR5cGVzIiwiYW55IiwiQ2FudmFzQ29udHJvbHNDb21wb25lbnQiLCJjbGlja1Bvc2l0aW9uIiwiY29udGFpbmVyIiwiY29udGFpbmVyUmVjdCIsImNvbnRhaW5lclBvc2l0aW9uIiwicG9zaXRpb25PbkNhbnZhcyIsImNvbnRyb2xzIiwiZ2V0QXZhaWxhYmxlIiwiY29udHJvbCIsImNsaWNrUmVzcG9uc2UiLCJjbGlja0F0UG9zaXRpb24iLCJzZWxlY3RlZFNwcml0ZSIsImdldFNoYXJlZFN0YXRlIiwiZm9yY2VVcGRhdGUiLCJtZWRpYXRvciIsIkVWRU5UUyIsIlpPT01fRE9ORSIsIl9vbkNhbnZhc1pvb21Eb25lIiwib2ZmIiwiU3RpY2tlck1hbmFnZXIiLCJ1aSIsIl91aSIsIl9vcHRpb25zIiwiX2NhdGVnb3JpZXNCeUlkIiwiX2NhdGVnb3JpZXMiLCJfc3RpY2tlcnNCeUlkIiwiX2FkZENhdGVnb3JpZXMiLCJERUZBVUxUUyIsIlNUSUNLRVJfQ0FURUdPUklFUyIsImNhdGVnb3JpZXMiLCJyZXBsYWNlQ2F0ZWdvcmllcyIsIl91cGRhdGVDYXRlZ29yaWVzTWFwIiwiX3VwZGF0ZUFsbENhdGVnb3J5IiwidXJsIiwibG9hZGVyIiwiSlNPTkxvYWRlciIsImxvYWQiLCJ0aGVuIiwicmVzdWx0IiwicmVwbGFjZSIsInNsaWNlIiwibWVyZ2VDYXRlZ29yaWVzIiwiZm9yRWFjaCIsImMiLCJzdGlja2VycyIsInMiLCJhdmFpbGFibGVTdGlja2VycyIsImNhdGVnb3J5IiwiZmlsdGVyIiwic3RpY2tlciIsImxlbmd0aCIsIl9hbGxDYXRlZ29yeSIsImRlZmF1bHROYW1lIiwibWFwIiwicmVkdWNlIiwiYSIsImIiLCJjb25jYXQiLCJhbGwiLCJjYXRlZ29yeU5hbWUiLCJpbmNsdWRlQWxsQ2F0ZWdvcnkiLCJpZCIsInNpemUiLCJpbWFnZXMiLCJtZWRpYSIsIm1lZGlhQmFzZSIsIm1lZGlhVGh1bWIiLCJ1cmlzIiwidXJpIiwiQnJvd3NlciIsImdldElFVmVyc2lvbiIsInN2Z3MiLCJ0ZXN0IiwiZiIsIm5vdFN2Z3MiLCJUb3BCYXJDb21wb25lbnQiLCJyZW5kZXJDb250ZW50IiwiU2xpZGVyQ29tcG9uZW50Iiwic2xpZGVyUG9zaXRpb24iLCJmb3JlZ3JvdW5kTGVmdCIsImZvcmVncm91bmRXaWR0aCIsIl9zZXRWYWx1ZSIsIl9wcmV2aW91c1ZhbHVlIiwibmV3VmFsdWUiLCJwb3NpdGlvbiIsIl9pbml0aWFsU2xpZGVyUG9zaXRpb24iLCJiYXIiLCJiYXJXaWR0aCIsIm5ld1NsaWRlclBvc2l0aW9uIiwiYWRkIiwiZW1pdENoYW5nZSIsImVtaXRSZWxlYXNlIiwicm91bmQiLCJfZGlzcGxheU1pZGRsZURvdCIsImFicyIsInRvRml4ZWQiLCJwb3NpdGl2ZVZhbHVlUHJlZml4IiwidmFsdWVVbml0IiwiX29uTWlkZGxlRG90Q2xpY2siLCJmb3JlZ3JvdW5kUHJvcHMiLCJfZ2V0Rm9yZWdyb3VuZFN0eWxlIiwiY29tcG9uZW50QmVtIiwiX29uS25vYkRyYWdTdGFydCIsIl9vbktub2JEcmFnIiwiX29uS25vYkRyYWdTdG9wIiwiX2dldEtub2JTdHlsZSIsIl9idWlsZFZhbHVlIiwiT3BlcmF0aW9ucyIsIlNwcml0ZU9wZXJhdGlvbiIsIlN0aWNrZXJTcHJpdGUiLCJUZXh0U3ByaXRlIiwiQnJ1c2hTcHJpdGUiLCJTcHJpdGVzQ2FudmFzQ29udHJvbHNDb21wb25lbnQiLCJfY2FudmFzQ2xpY2tEaXNhYmxlZCIsIl9ldmVudHMiLCJPUEVSQVRJT05fVVBEQVRFRCIsIl9vbk9wZXJhdGlvblVwZGF0ZWQiLCJPUEVSQVRJT05fUkVNT1ZFRCIsIl9vbk9wZXJhdGlvblJlbW92ZWQiLCJvcGVyYXRpb24iLCJuZXdPcGVyYXRpb24iLCJvcGVyYXRpb25zIiwiZ2V0T3JDcmVhdGUiLCJzcHJpdGVzIiwiZW5hYmxlZCIsInNldFNoYXJlZFN0YXRlIiwib3BlcmF0aW9uRXhpc3RlZEJlZm9yZSIsImluaXRpYWxPcHRpb25zIiwiZ2V0U3ByaXRlcyIsImhpdFRlc3QiLCJfcGVyZm9ybUhpdFRlc3QiLCJfb25JdGVtQmx1ciIsInNldEZsaXBIb3Jpem9udGFsbHkiLCJnZXRGbGlwSG9yaXpvbnRhbGx5Iiwic2V0RmxpcFZlcnRpY2FsbHkiLCJnZXRGbGlwVmVydGljYWxseSIsInJlbmRlciIsInRha2VTcHJpdGVUb0Zyb250IiwiZm9yY2VTaGFyZWRVcGRhdGUiLCJyZW1vdmVTcHJpdGUiLCJkaXNwb3NlIiwic2V0VGltZW91dCIsImNhbnZhc0RpbWVuc2lvbnMiLCJnZXRDYW52YXNEaW1lbnNpb25zIiwib3V0cHV0RGltZW5zaW9ucyIsImdldE91dHB1dERpbWVuc2lvbnMiLCJkaXZpZGUiLCJfZ2V0Q29udGFpbmVyU3R5bGUiLCJvbkNsaWNrIiwiX29uQ2FudmFzQ2xpY2siLCJzcHJpdGUiLCJoaWRlQ29udGVudCIsIlRleHRJdGVtQ29tcG9uZW50IiwiU3RpY2tlckl0ZW1Db21wb25lbnQiLCJCcnVzaEl0ZW1Db21wb25lbnQiLCJpc1NlbGVjdGVkIiwiU3ByaXRlQ29tcG9uZW50IiwiX2dldENvbXBvbmVudFR5cGVGb3JTcHJpdGUiLCJzcHJpdGVQcm9wcyIsIl9nZXRQcm9wc0ZvclNwcml0ZSIsInNoYXJlZFN0YXRlIiwiX29uU3ByaXRlRHJhZ1N0YXJ0IiwiX29uU3ByaXRlRHJhZ1N0b3AiLCJfb25TcHJpdGVSZW1vdmUiLCJnZXRJZCIsIl9nZXRDb250YWluZXJQcm9wcyIsIl9nZXRJbm5lckNvbnRhaW5lclByb3BzIiwiX3JlbmRlclNwcml0ZUl0ZW1zIiwiX3JlbmRlck92ZXJsYXlDb250cm9scyIsIkZvbnRNYW5hZ2VyIiwiX2ZvbnRzIiwiX3ZhcmlhdGlvbnNCeUlkZW50aWZpZXIiLCJfZm9udHNCeUZvbnRGYW1pbHkiLCJfaW5pdEZvbnRzIiwiYWRkaXRpb25hbEZvbnRzIiwiZm9udHMiLCJyZXBsYWNlRm9udHMiLCJhdmFpbGFibGVWYXJpYXRpb25zIiwiRk9OVFMiLCJkZWZhdWx0VmFyaWF0aW9uIiwiZm9udCIsImZvbnRGYW1pbHkiLCJ2YXJpYXRpb25zIiwidmFyaWF0aW9uIiwiZm9udEluc3RhbmNlIiwiRm9udCIsInZhcmlhdGlvbkluc3RhbmNlIiwiRm9udFZhcmlhdGlvbiIsInNldEZvbnRGYW1pbHkiLCJzZXRGb250IiwiZGVmYXVsdCIsImdldFRleHRNZXRyaWNzIiwid2FybiIsImdldElkZW50aWZpZXIiLCJzZXRWYXJpYXRpb25zIiwiZ2V0VmFyaWF0aW9ucyIsIl9kZWZhdWx0VmFyaWF0aW9uIiwiZGVmYXVsdExldmVscyIsIm5hbWUiLCJiYWNrZ3JvdW5kIiwiY29sb3IiLCJoYXNDb25zb2xlR3JvdXBzIiwiY29uc29sZSIsImdyb3VwIiwiZ3JvdXBDb2xsYXBzZWQiLCJncm91cEVuZCIsImhhc0NvbG9yT3V0cHV0IiwicHJvY2VzcyIsImJyb3dzZXIiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJtYXRjaCIsImdldExvZ1N0eWxlcyIsIkxvZ2dlciIsIm1heExldmVsIiwibGV2ZWxzIiwiX2xldmVscyIsIl9tYXhMZXZlbCIsImdldExldmVsSW5kZXhCeU5hbWUiLCJfY29uc29sZUZ1bmNzIiwidHJhY2UiLCJ0YWciLCJfbG9nIiwibGV2ZWxOYW1lIiwiZmluZEluZGV4IiwibCIsImZpbmQiLCJsZXZlbCIsImdldExldmVsT2JqZWN0QnlOYW1lIiwiY2FuTG9nIiwib3V0cHV0cyIsImFyZyIsInVuZGVmaW5lZCIsInRvT2JqZWN0IiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiY29uc29sZUZ1bmMiLCJsb2ciLCJvdXRwdXRzTGVuIiwic3R5bGVzIiwiaW5pdCIsInNvdXJjZSIsImltYWdlIiwiSW1hZ2UiLCJvbmxvYWQiLCJmbG9vciIsInNyYyIsIkhUTUxDYW52YXNFbGVtZW50IiwidG9EYXRhVVJMIiwidGV4dHVyZSIsImJhc2VUZXh0dXJlIiwiZ2V0QmFzZVRleHR1cmUiLCJyZW5kZXJlcnMiLCJnZXRSZW5kZXJlcnMiLCJnbFJlbmRlcmVyIiwiciIsImdldEZyYW1lIiwiZ2wiLCJnZXRDb250ZXh0IiwiZ2xUZXh0dXJlIiwiZ2V0R0xUZXh0dXJlRm9yUmVuZGVyZXIiLCJsb2dHbFRleHR1cmUiLCJnZXRTb3VyY2UiLCJiaW5kVGV4dHVyZSIsIlRFWFRVUkVfMkQiLCJmcmFtZWJ1ZmZlciIsImNyZWF0ZUZyYW1lYnVmZmVyIiwiYmluZEZyYW1lYnVmZmVyIiwiRlJBTUVCVUZGRVIiLCJmcmFtZWJ1ZmZlclRleHR1cmUyRCIsIkNPTE9SX0FUVEFDSE1FTlQwIiwiVWludDhBcnJheSIsInJlYWRQaXhlbHMiLCJSR0JBIiwiVU5TSUdORURfQllURSIsImRlbGV0ZUZyYW1lYnVmZmVyIiwiY2FudmFzIiwiY3JlYXRlRWxlbWVudCIsImltYWdlRGF0YSIsImNyZWF0ZUltYWdlRGF0YSIsInB1dEltYWdlRGF0YSIsIlRJTUVPVVQiLCJnbG9iYWwiLCJfdXJsIiwiX3BhcnNlZFVybCIsIlVSTCIsInF1ZXJ5Iiwia2V5IiwiX2lzSlNPTlBSZXF1ZXN0IiwiX2xvYWRKU09OUCIsIl9sb2FkSlNPTiIsInJlc29sdmUiLCJyZWplY3QiLCJ4aHIiLCJYRG9tYWluUmVxdWVzdCIsImpzb24iLCJyZXNwb25zZVRleHQiLCJvbmVycm9yIiwib3BlbiIsInNlbmQiLCJYTUxIdHRwUmVxdWVzdCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsIm9FdmVudCIsInJlYWR5U3RhdGUiLCJzdGF0dXMiLCJmYWlsZWQiLCJzdWNjZWVkZWQiLCJmbk5hbWUiLCJyYW5kb20iLCJub2RlIiwiX2NyZWF0ZUpTT05QTm9kZSIsIl9yZW1vdmVKU09OUE5vZGUiLCJKU09OUFVybCIsIl9idWlsZEpTT05QVXJsIiwiaGVhZE5vZGUiLCJxdWVyeVNlbGVjdG9yIiwic2NyaXB0Tm9kZSIsImFwcGVuZENoaWxkIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwicGFyYW1ldGVyIiwicGFyYW0iLCJzZWFyY2giLCJmb3JtYXQiLCJjcm9zc09yaWdpbiIsImNvcnMiLCJsb2FkUHJvbWlzZSIsInN1YnN0ciIsIm9yaWdpbmFsU3JjIiwiX2NyZWF0ZUFuZExvYWRJbWFnZSIsImxvYWRYSFIiLCJtaW1lIiwib3ZlcnJpZGVNaW1lVHlwZSIsIlJvd0NvbXBvbmVudCIsInJvd0JFTSIsIl9tb2RpZmllciIsInRvdGFsUm93cyIsIl9yZW5kZXJDb250ZW50IiwiZnVuYyIsIkludmlzaWJsZVVwbG9hZENvbXBvbmVudCIsIl9maWxlTG9hZGVyIiwiRmlsZUxvYWRlciIsImZpbGVJbnB1dCIsIl9vbk5ld0ZpbGUiLCJmaWxlIiwib25OZXdGaWxlIiwiVG9wQmFyQnV0dG9uQ29tcG9uZW50IiwiYmVtIiwiaWNvbiIsIl9nZXRBc3NldFBhdGgiLCJGaWx0ZXJNYW5hZ2VyIiwiX2ZpbHRlcnNCeUlkZW50aWZpZXIiLCJpZGVudGl0eSIsIkZpbHRlck9wZXJhdGlvbiIsIkZpbHRlcnMiLCJJZGVudGl0eUZpbHRlciIsIkZJTFRFUlMiLCJfaW5pdENhdGVnb3JpZXMiLCJGaWx0ZXIiLCJnZXRGaWx0ZXJCeUlkZW50aWZpZXIiLCJwcm90b3R5cGUiLCJsdXRJbWFnZSIsInJlc29sdXRpb24iLCJob3Jpem9udGFsVGlsZUNvdW50IiwidmVydGljYWxUaWxlQ291bnQiLCJwcmVsb2FkZWRJbWFnZSIsImdldFByZWxvYWRlciIsImdldEFzc2V0IiwiZ2V0QXNzZXRQYXRoIiwiVGhyZWVETFVURmlsdGVyIiwiYXZhaWxhYmxlRmlsdGVycyIsIm5ld0NhdGVnb3JpZXMiLCJmaWx0ZXJzIiwiYWxsQ2F0ZWdvcnkiLCJ1bnNoaWZ0IiwiY2F0ZWdvcnlJZGVudGlmaWVyIiwiSXRlbUNvbXBvbmVudCIsImdldFBvc2l0aW9uIiwibXVsdGlwbHkiLCJfb25TcHJpdGVVcGRhdGUiLCJuZXh0UHJvcHMiLCJvbkRyYWdTdGFydCIsIm9mZnNldCIsIm5ld1Bvc2l0aW9uIiwic2V0UG9zaXRpb24iLCJvbkRyYWdTdG9wIiwiQ29sb3JQaWNrZXJDb21wb25lbnQiLCJfdmFsdWUiLCJpbml0aWFsVmFsdWUiLCJDT0xPUlBJQ0tFUl9PUEVOIiwiX29uQ29sb3JQaWNrZXJPcGVuIiwib3ZlcmxheVZpc2libGUiLCJfdHJhbnNwYXJlbnRQYXR0ZXJuQ2FudmFzIiwiY3JlYXRlVHJhbnNwYXJlbnRQYXR0ZXJuQ2FudmFzIiwiX3JlbmRlckNvbG9yIiwiY29sb3JQaWNrZXIiLCJfZW1pdEV2ZW50IiwicGF0dGVybiIsImNyZWF0ZVBhdHRlcm4iLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsInRvUkdCQSIsIk92ZXJsYXkiLCJfb25WYWx1ZUNoYW5nZSIsIl9vbkNvbG9yUGlja2VyQ2xvc2UiLCJhbHBoYSIsImNsYXNzTmFtZSIsIl9vbkJ1dHRvbkNsaWNrIiwiX3QiLCJGb250TG9hZGVyIiwiX2xvYWRlZEZvbnRzIiwiaSIsInByb3ZpZGVyIiwiZ2V0UHJvdmlkZXIiLCJnZXRGb250RmFtaWx5IiwiZm9udExvYWRlZCIsImxvYWRlcnMiLCJnb29nbGUiLCJHb29nbGVGb250c0xvYWRlciIsIkZpbGVGb250c0xvYWRlciIsImRpc3Bvc2VMb2FkZXJzIiwicHJvbWlzZXMiLCJzZXRGb250TG9hZGVkIiwiY2F0Y2giLCJ2MjAwU2VyaWFsaXplciIsImlucHV0RGltZW5zaW9ucyIsImdldElucHV0RGltZW5zaW9ucyIsInJlc3BvbnNlIiwiZ2V0VGludE1vZGUiLCJ0aW50Q29sb3IiLCJzZXJpYWxpemVPcHRpb24iLCJkaW1lbnNpb25zIiwiZ2V0RGltZW5zaW9ucyIsInBhdGgiLCJicnVzaCIsImdldEJydXNoIiwiaGFzT3B0aW9uIiwiaGFyZG5lc3MiLCJnZXRPcHRpb24iLCJfc2VyaWFsaXplRnJhbWVPcGVyYXRpb24iLCJfc2VyaWFsaXplT3ZlcmxheU9wZXJhdGlvbiIsInNwcml0ZU9wZXJhdGlvbnMiLCJvIiwic3ByaXRlT3BlcmF0aW9uIiwicG9wIiwiX2dldEZyYW1lT3B0aW9ucyIsImludGVuc2l0eSIsImdldEFscGhhIiwiYmxlbmRNb2RlIiwiQmxlbmRNb2RlcyIsImdldEJsZW5kTW9kZSIsInJvdGF0aW9uIiwiZmxpcEhvcml6b250YWxseSIsImZsaXBWZXJ0aWNhbGx5IiwiX2VkaXRvciIsImV4aXN0cyIsIm9yaWVudGF0aW9uT3BlcmF0aW9uIiwicm90YXRlIiwiZ2V0Um90YXRpb24iLCJmbGlwIiwic2V0Um90YXRpb24iLCJmb250SWRlbnRpZmllciIsImdldEZvbnRJZGVudGlmaWVyIiwibWF4V2lkdGgiLCJmb2N1c09wdGlvbnMiLCJzdGFydCIsImVuZCIsInJhZGl1cyIsIlByZXZpb3VzU2VyaWFsaXplciIsInZlcnNpb24iLCJibGVuZE1vZGVCeU5hbWUiLCJmbGlwT2JqZWN0IiwidjIwMERlc2VyaWFsaXplciIsIl9mcmFtZU1hbmFnZXIiLCJGcmFtZU1hbmFnZXIiLCJfZ2V0T3B0aW9ucyIsIm92ZXJsYXlPcHRpb25zIiwiX292ZXJsYXlNYW5hZ2VyIiwiT3ZlcmxheU1hbmFnZXIiLCJfZGVzZXJpYWxpemVGcmFtZSIsIl9kZXNlcmlhbGl6ZU92ZXJsYXkiLCJfZGVzZXJpYWxpemVUcmFuc2Zvcm1PcGVyYXRpb24iLCJvcGVyYXRpb25EYXRhIiwib3JpZW50YXRpb25EYXRhIiwiX2RhdGEiLCJvcCIsImZyYW1lIiwiZnJhbWVEYXRhIiwiZ2V0RnJhbWVCeUlkZW50aWZpZXIiLCJmcmFtZUluc3RhbmNlIiwiRnJhbWUiLCJvdmVybGF5RGF0YSIsImdldE92ZXJsYXlCeUlkZW50aWZpZXIiLCJvdmVybGF5UGF0aCIsImdldFVJIiwicGFyc2VJbnQiLCJzZXRIYXJkbmVzcyIsIl9zdGlja2VyTWFuYWdlciIsImdldFN0aWNrZXJCeUlkZW50aWZpZXIiLCJnZXRVUkxGb3JTdGlja2VyIiwiYWRqdXN0bWVudHMiLCJhdmFpbGFibGVPcHRpb25zIiwic3RydWN0dXJlIiwic3RpY2tlck9wdGlvbnMiLCJmcm9tT2JqZWN0Iiwib3B0aW9uIiwidGludE1vZGUiLCJmcm9tQXJyYXkiLCJjcmVhdGVTdGlja2VyIiwiZ2V0Q3Jvc3NPcmlnaW4iLCJfZmlsdGVyTWFuYWdlciIsImluc3RhbnRpYXRlRmlsdGVyV2l0aElkZW50aWZpZXIiLCJmaWx0ZXJPcGVyYXRpb24iLCJncmFkaWVudFJhZGl1cyIsImJsdXJSYWRpdXMiLCJsZW4iLCJmb250U2l6ZSIsImxpbmVIZWlnaHQiLCJhbGlnbm1lbnQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJmb250TG9hZGVyIiwiX2ZvbnRNYW5hZ2VyIiwiZ2V0VmFyaWF0aW9uQnlJZGVudGlmaWVyIiwiZ2V0RGVmYXVsdEZvbnQiLCJzZXRGb250cyIsImdldEZvbnQiLCJmaXhlZE1heFdpZHRoIiwiY3JlYXRlVGV4dCIsImZvbnRXZWlnaHQiLCJnZXRGb250V2VpZ2h0IiwiUHJldmlvdXNEZXNlcmlhbGl6ZXIiLCJlbGVtZW50U2VwYXJhdG9yIiwibW9kaWZpZXJTZXBhcmF0b3IiLCJibG9ja1ByZWZpeCIsIkJFTU9iamVjdCIsInBhcmVudCIsIl9wYXJlbnQiLCJfdHlwZSIsIl9uYW1lIiwic3RyIiwiYmxvY2siLCJmbGF0dGVuIiwiYXJyIiwiQkVNX1RZUEVTIiwibSIsIl9wYXJzZUJlbVNwZWNpZmllciIsInNwZWNpZmllciIsInBhcnRzIiwic3BsaXQiLCJwYXJ0IiwicGFzcyIsIl9nZXRCZW1JbmZvRm9yTm9kZSIsImlzQmVtTm9kZSIsIm9iaiIsIl9pc05vZGVCRU1hYmxlIiwiaXNWYWxpZEVsZW1lbnQiLCJfYXBwbHlCRU1DbGFzc2VzIiwiY2xhc3NOYW1lcyIsImJlbUluZm8iLCJvd25CZW1PYmplY3QiLCJfX2JlbU9iamVjdCIsImNoaWxkcmVuQmVtT2JqZWN0IiwibW9kaWZpZXIiLCJfdHJhbnNmb3JtVG9SZWFjdCIsInRyYW5zZm9ybSIsIk9WRVJMQVlTIiwidGh1bWJuYWlsIiwiRlJBTUVfQ0FURUdPUklFUyIsIm1ldGFEYXRhIiwiYmFja2dyb3VuZEltYWdlIiwiZnJhbWVzIiwibGF5b3V0TW9kZSIsImltYWdlR3JvdXBzIiwibWlkIiwibW9kZSIsInJpZ2h0IiwiYm90dG9tIiwidGludGFibGUiLCJTZWFyY2hTdWdnZXN0aW9uQ29tcG9uZW50Iiwic2VhcmNoU3VnZ2VzdGlvbiIsImNvdmVySW1hZ2UiLCJfb25DbGljayIsIkNPTFVNTl9XSURUSCIsIlBob3RvTGlzdENvbXBvbmVudCIsIl90b3RhbFBob3Rvc0hlaWdodCIsImxvYWRpbmciLCJwaG90b3MiLCJfbG9hZFBob3RvcyIsInNjcm9sbGJhciIsInBob3RvIiwib25QaG90b0NsaWNrZWQiLCJsaWJyYXJ5IiwiaXNJRWx0ZSIsImNlbGwiLCJnZXRMaXN0IiwiY2VsbEhlaWdodCIsImNvbHVtbkNvdW50IiwiY29sdW1uSGVpZ2h0cyIsImNvbHVtbnMiLCJzaG9ydGVzdENvbHVtbkluZGV4Iiwic2hvcnRlc3RDb2x1bW5IZWlnaHQiLCJJbmZpbml0eSIsIl9vblBob3RvQ2xpY2tlZCIsIl9yZW5kZXJDb2x1bW5zIiwiX2dldEhlYWRsaW5lIiwiY29sdW1uIiwiaW5zdGFuY2UiLCJkaXNwbGF5UHJvZ3Jlc3MiLCJQaG90b1JvbGxQcm92aWRlciIsInBob3RvUm9sbCIsImdldFBob3Rvc0ZvckxpYnJhcnkiLCJfcHJlbG9hZFBob3RvcyIsImNsb3NlIiwiZGlzcGxheUVycm9yIiwiZXJyb3IiLCJtZXNzYWdlIiwidG90YWxQaG90b3MiLCJsb2FkZWRQaG90b3MiLCJfcHJlbG9hZFBob3RvIiwicGhvdG9EaW1lbnNpb25zIiwidXJscyIsInRodW1iIiwiX3JlbmRlclBob3RvcyIsIk92ZXJ2aWV3Q29udHJvbHNDb21wb25lbnQiLCJpdGVtcyIsIm1ha2VJdGVtIiwiX29uSXRlbUNsaWNrIiwiY29udHJvbHNPcmRlciIsImdyb3VwT3JJZGVudGlmaWVyIiwiaXNBcnJheSIsImdyb3VwSXRlbXMiLCJpc0VuYWJsZWQiLCJmaW5hbEl0ZW1zIiwiaXRlbU9yR3JvdXAiLCJsaXN0SXRlbXMiLCJfcmVuZGVyTGlzdEl0ZW1zIiwiRWRpdG9yIiwic2hhbGxvdyIsIl9tZWRpYXRvciIsIl9yZWFkeSIsIl9wYWRkaW5nIiwiX3NoYWxsb3ciLCJfaW5pdFNESyIsIl9vblpvb20iLCJfb25VbmRvIiwiaGlzdG9yeSIsIkVkaXRvckhpc3RvcnkiLCJfc2RrIiwiem9vbSIsIkVkaXRvclpvb20iLCJfaW5pdFNlcmlhbGl6ZXJzIiwiRWRpdG9yT3BlcmF0aW9ucyIsIkVkaXRvckNvbnRyb2xzIiwiZmVhdHVyZXMiLCJFZGl0b3JGZWF0dXJlcyIsIl9ydW5uaW5nIiwiX3JlbmRlclJlcXVlc3RlZCIsIl9yZW5kZXJDYWxsYmFja3MiLCJfYW5pbWF0aW9uRnJhbWVSZXF1ZXN0IiwiX3RpY2siLCJyZXNldEVkaXRvciIsInJlbmRlcmVyIiwiZ2V0UmVuZGVyZXIiLCJpbml0aWFsRGltZW5zaW9ucyIsIm5hdHVyYWxXaWR0aCIsIm5hdHVyYWxIZWlnaHQiLCJtYXhQaXhlbHMiLCJnZXRNYXhNZWdhcGl4ZWxzIiwibWF4RGltZW5zaW9ucyIsImdldE1heERpbWVuc2lvbnMiLCJyZXNldCIsImltYWdlUmVzaXplciIsIkltYWdlUmVzaXplciIsImV4aWYiLCJkb25lIiwicmVzaXplUmVhc29uIiwiX3NldEltYWdlIiwiX2luaXRXYXRlcm1hcmsiLCJuZWVkc1Jlc2l6ZSIsInBhcnNlRXhpZiIsInJlc2l6ZSIsInJlYXNvbiIsIndhdGVybWFya0ltYWdlIiwiX3dhdGVybWFya09wZXJhdGlvbiIsImxvZ0xldmVsIiwiZGlzcGxheVdlbGNvbWVNZXNzYWdlIiwiZGVidWciLCJsaWNlbnNlIiwic21vb3RoRG93bnNjYWxpbmciLCJzbW9vdGhVcHNjYWxpbmciLCJwcmVmZXJyZWRSZW5kZXJlciIsInBpeGVsUmF0aW8iLCJyZW5kZXJlck9wdGlvbnMiLCJ0cmFuc3BhcmVudCIsImNhbGxiYWNrIiwiZml4T2Zmc2V0IiwiZ2V0U3ByaXRlU2NhbGUiLCJzcHJpdGVTY2FsZSIsInNldFNwcml0ZVNjYWxlIiwiZ2V0Q3Jvc3NPcmlnaW5WYWx1ZSIsIl9sIiwiaXNUb29sQWxsb3dlZCIsInRvb2xzIiwibWF4TWVnYVBpeGVscyIsIm1vYmlsZSIsImRlc2t0b3AiLCJpbmNvcnBvcmF0ZVNwcml0ZVNjYWxlIiwiZ2V0T3V0cHV0VGV4dHVyZURpbWVuc2lvbnMiLCJnZXRGaW5hbERpbWVuc2lvbnMiLCJzdWJ0cmFjdFBhZGRpbmciLCJnZXRDYW52YXMiLCJzZXRBbGxPcGVyYXRpb25zVG9EaXJ0eSIsInNldEltYWdlIiwiZG93bmxvYWQiLCJzZXRFbmFibGVkIiwiZXhwb3J0IiwiZXhwb3J0ZXIiLCJFeHBvcnRlciIsIm91dHB1dCIsIkVYUE9SVCIsIl9zZXJpYWxpemVycyIsIlNlcmlhbGl6ZXIiLCJzZXJpYWxpemVyIiwic2VyaWFsaXplIiwiZGVzZXJpYWxpemUiLCJfb2Zmc2V0Iiwic2V0T2Zmc2V0IiwiX2NsYW1wT2Zmc2V0IiwiZ2V0T2Zmc2V0IiwicmVuZGVyZXJEaW1lbnNpb25zIiwiZ2V0V2lkdGgiLCJnZXRIZWlnaHQiLCJtaW5PZmZzZXQiLCJjbGFtcCIsIm1heE9mZnNldCIsIm5ld09mZnNldCIsImNhbGxiYWNrcyIsIl9yZW5kZXIiLCJfYXBwbHlPZmZzZXQiLCJfbGFzdE91dHB1dEJvdW5kcyIsImdldFNwcml0ZSIsImdldEJvdW5kcyIsInN0b3AiLCJwYWRkaW5nIiwidHJhbnNmb3JtT3BlcmF0aW9uIiwidHJhbnNmb3JtQ2hhbmdlIiwiVHJhbnNmb3JtT3BlcmF0aW9uIiwiVHJhbnNmb3JtQ2hhbmdlIiwidHJhbnNmb3JtYWJsZU9wZXJhdGlvbnMiLCJmbGlwcGFibGVPcGVyYXRpb25zIiwiZGVncmVlcyIsIkNhdGVnb3J5RHJvcGRvd25Db21wb25lbnQiLCJzZWxlY3RlZEl0ZW0iLCJGb250UHJldmlld0NvbXBvbmVudCIsIl9yZW5kZXJDYW52YXMiLCJzZGsiLCJnZXRTREsiLCJnZXRQaXhlbFJhdGlvIiwiY2xlYXJSZWN0IiwiZm9udFN0eWxlIiwidGV4dEJhc2VsaW5lIiwidGV4dEFsaWduIiwiZmlsbFRleHQiLCJGT05UX1dFSUdIVFMiLCJib2xkIiwibm9ybWFsIiwiQ29uZmlndXJhYmxlIiwiU1RSSU5HIiwicmVxdWlyZWQiLCJBTEwiLCJ0ZXh0TWV0cmljcyIsIk9CSkVDVCIsImF2YWlsYWJsZSIsImZpbGVQYXRoIiwiQk9PTEVBTiIsIl9mcmFtZXNCeUlkIiwiYXZhaWxhYmxlRnJhbWVzIiwiX2xvYWRlZCIsIl9sb2FkaW5nIiwiX2ZyYW1lIiwiZGVlcENsb25lIiwiZ3JvdXBOYW1lIiwicGFydE5hbWUiLCJfbG9hZFBhcnQiLCJpbWFnZVVybCIsImdldEVkaXRvciIsIlRXSUNFX1BJIiwiUEkiLCJ2MTAwU2VyaWFsaXplciIsIl9zZXJpYWxpemVPcGVyYXRpb25zIiwiX3NlcmlhbGl6ZUlucHV0SW1hZ2UiLCJnZXRJbWFnZSIsImlucHV0SW1hZ2UiLCJjcmVhdGVDYW52YXMiLCJkcmF3SW1hZ2UiLCJkYXRhVXJsIiwiUE5HIiwic3RhY2siLCJnZXRTdGFjayIsIl9zZXJpYWxpemVPcGVyYXRpb24iLCJfc2VyaWFsaXplVHJhbnNmb3JtT3BlcmF0aW9uIiwiX3NlcmlhbGl6ZU9yaWVudGF0aW9uT3BlcmF0aW9uIiwiX3NlcmlhbGl6ZUZpbHRlck9wZXJhdGlvbiIsIl9zZXJpYWxpemVBZGp1c3RtZW50c09wZXJhdGlvbiIsIl9zZXJpYWxpemVTcHJpdGVPcGVyYXRpb24iLCJfc2VyaWFsaXplUmFkaWFsRm9jdXNPcGVyYXRpb24iLCJfc2VyaWFsaXplTGluZWFyRm9jdXNPcGVyYXRpb24iLCJzZXJpYWxpemVPcHRpb25zIiwiZ2V0SW50ZW5zaXR5Iiwib3B0aW9uTmFtZXMiLCJvcHRpb25OYW1lIiwibWlkVmFsdWUiLCJyZXR1cm5PcGVyYXRpb24iLCJzcHJpdGVJdGVtIiwiX3NlcmlhbGl6ZVN0aWNrZXIiLCJfc2VyaWFsaXplVGV4dCIsIl9zZXJpYWxpemVCcnVzaCIsIlRleHREZXNpZ25TcHJpdGUiLCJfc2VyaWFsaXplVGV4dERlc2lnbiIsImdldEFkanVzdG1lbnRzIiwiYWRqdXN0bWVudHNPcHRpb25zIiwiYnJpZ2h0bmVzcyIsImdldEJyaWdodG5lc3MiLCJzYXR1cmF0aW9uIiwiZ2V0U2F0dXJhdGlvbiIsImNvbnRyYXN0IiwiZ2V0Q29udHJhc3QiLCJwYXRocyIsImdldFBhdGhzIiwiX3NlcmlhbGl6ZVBhdGgiLCJwb2ludHMiLCJnZXRDb250cm9sUG9pbnRzIiwicG9pbnQiLCJvcGVyYXRpb25Gb3VuZCIsImdldE5ld0RpbWVuc2lvbnMiLCJCcnVzaCIsInYxMDBEZXNlcmlhbGl6ZXIiLCJfYnJ1c2hNYW5hZ2VyIiwiQnJ1c2hNYW5hZ2VyIiwiZWRpdG9yT3B0aW9ucyIsImdldE9wdGlvbnMiLCJkZWVwRGVmYXVsdHMiLCJjb250cm9sc09wdGlvbnMiLCJfdmFsaWRhdGVWZXJzaW9uIiwiX2Rlc2VyaWFsaXplSW5wdXRJbWFnZSIsIl9kZXNlcmlhbGl6ZU9wZXJhdGlvbnMiLCJpbnN0YW5jZXMiLCJfZGVzZXJpYWxpemVPcGVyYXRpb24iLCJfZGVzZXJpYWxpemVDcm9wT3BlcmF0aW9uIiwiX2Rlc2VyaWFsaXplT3JpZW50YXRpb25PcGVyYXRpb24iLCJfZGVzZXJpYWxpemVGaWx0ZXJPcGVyYXRpb24iLCJfZGVzZXJpYWxpemVBZGp1c3RtZW50c09wZXJhdGlvbiIsIl9kZXNlcmlhbGl6ZVNwcml0ZU9wZXJhdGlvbiIsIl9kZXNlcmlhbGl6ZUZvY3VzT3BlcmF0aW9uIiwiY3JvcE9wdGlvbnMiLCJicm9hZGNhc3RUcmFuc2Zvcm0iLCJBZGp1c3RtZW50c09wZXJhdGlvbiIsImtub3duT3B0aW9ucyIsIm9wZXJhdGlvbk9wdGlvbnMiLCJfZGVzZXJpYWxpemVTcHJpdGUiLCJwIiwic2V0U3ByaXRlcyIsIl9kZXNlcmlhbGl6ZVN0aWNrZXIiLCJfZGVzZXJpYWxpemVUZXh0IiwiX2Rlc2VyaWFsaXplQnJ1c2giLCJfZGVzZXJpYWxpemVUZXh0RGVzaWduIiwiZ2V0Rm9udEJ5Rm9udEZhbWlseSIsImJydXNoU3ByaXRlIiwiY3JlYXRlQnJ1c2giLCJfZGVzZXJpYWxpemVCcnVzaFBhdGgiLCJicnVzaEluc3RhbmNlIiwiX2NyZWF0ZUJydXNoRm9yUGF0aCIsInBhdGhPYmplY3QiLCJjcmVhdGVQYXRoIiwic2V0Q2xvc2VkIiwiYWRkQ29udHJvbFBvaW50IiwiY29sb3JPYmplY3QiLCJicnVzaE9wdGlvbnMiLCJyYXdCcnVzaCIsImdldEZpcnN0QnJ1c2giLCJCcnVzaENsYXNzIiwiX2JydXNoIiwiZXh0ZW5kIiwiZ3JhZGllbnRTaXplIiwiQmFzZUZvbnRMb2FkZXIiLCJfb2JzZXJ2ZXJzIiwiRm9udE9ic2VydmVyIiwib2JzZXJ2ZXIiLCJvYnNlcnZlIiwidjEwMVNlcmlhbGl6ZXIiLCJ0ZXh0dXJlU2NhbGUiLCJ2MTAxRGVzZXJpYWxpemVyIiwiX2Rlc2VyaWFsaXplU2VsZWN0aXZlQmx1ck9wZXJhdGlvbiIsInRyYW5zZm9ybURpbWVuc2lvbnMiLCJzZXRUZXh0dXJlU2NhbGUiLCJPdmVybGF5RmlsdGVyIiwiRW5naW5lIiwiQkxFTkRfTU9ERVMiLCJOT1JNQUwiLCJPVkVSTEFZIiwiSEFSRF9MSUdIVCIsIlNPRlRfTElHSFQiLCJNVUxUSVBMWSIsIkRBUktFTiIsIkxJR0hURU4iLCJTQ1JFRU4iLCJDT0xPUl9CVVJOIiwidjMwMFNlcmlhbGl6ZXIiLCJtZXRhIiwicGxhdGZvcm0iLCJjcmVhdGVkQXQiLCJJU09EYXRlU3RyaW5nIiwiRGF0ZSIsInJnYmEiLCJnZXRUaW50Q29sb3IiLCJlcXVhbHMiLCJzY2FsZSIsIl9yYXRpbyIsIl9zZXJpYWxpemVNaXJyb3JlZEZvY3VzT3BlcmF0aW9uIiwiX3NlcmlhbGl6ZUJsdXJPcGVyYXRpb24iLCJjb250cm9sUG9pbnQxIiwiY29udHJvbFBvaW50MiIsInYzMDBEZXNlcmlhbGl6ZXIiLCJyZXNvbHZlZFVybCIsImdldEZvbnRMb2FkZXIiLCJnZXREZWZhdWx0VmFyaWF0aW9uIiwiZ2V0QnJ1c2hCeUlkZW50aWZpZXIiLCJmcmFtZU9wZXJhdGlvbiIsInNlZWQiLCJpbnZlcnRlZCIsInRleHREZXNpZ25NYW5hZ2VyIiwiVGV4dERlc2lnbk1hbmFnZXIiLCJmb250TWFuYWdlciIsIlRFWFRfREVTSUdOX0ZPTlRTIiwiQXNzZXRNYW5hZ2VyIiwiTGF5b3V0IiwiZ2V0TGF5b3V0QnlJZGVudGlmaWVyIiwibGF5b3V0IiwiZ2V0Rm9udHMiLCJnZXRWYXJpYXRpb25zQnlJZGVudGlmaWVyIiwiZ2V0SW1hZ2VQYXRocyIsImZ1bGxQYXRoIiwibG9hZEltYWdlcyIsIm9uSW1hZ2VzTG9hZGVkIiwiY3JlYXRlVGV4dERlc2lnbiIsIl9kZWZhdWx0TGF5b3V0cyIsIkxheW91dHMiLCJfbGF5b3V0cyIsIl9pbml0IiwiYXZhaWxhYmxlTGF5b3V0cyIsIk9iamVjdCIsImtleXMiLCJrIiwiaXRlbSIsIm1vZHVsZSIsImV4cG9ydHMiLCJQaG90b1JvbGwiLCJDb250cm9scyIsImJkIiwiYnl0ZUFycmF5VG9TdHJpbmciLCJkZWNvZGUiLCJSZWFjdFVJIiwiX2ZvbnRMb2FkZXIiLCJfaW5pdE9wdGlvbnMiLCJfaW5pdExhbmd1YWdlIiwiX2luaXRFdmVudHMiLCJfZGlzcG9zZWQiLCJfaXNSZWFkeSIsIm9uY2UiLCJFRElUT1JfUkVBRFkiLCJfZ2xvYmFsU3RhdGUiLCJfcHJlbG9hZGVyIiwiUHJlbG9hZGVyIiwic2V0TGV2ZWwiLCJfdiIsInJ1biIsIl9yZWdpc3RlcldlYkZvbnRzIiwiY29tcG9uZW50IiwiX2NvbXBvbmVudCIsInJlbmRlclJldHVybnNDb21wb25lbnQiLCJsYW5ndWFnZSIsInByZWxvYWRlciIsImFzc2V0cyIsImVuYWJsZVVwbG9hZCIsImVuYWJsZVdlYmNhbSIsInNob3dDbG9zZUJ1dHRvbiIsInNob3dUb3BCYXIiLCJyZXNwb25zaXZlIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImVuYWJsZVpvb20iLCJlbmFibGVEcmFnIiwiZGlzcGxheVJlc2l6ZU1lc3NhZ2UiLCJmb3JjZUNvbnRyb2xzIiwiZm9yY2VDcm9wIiwib3BlcmF0aW9uc09yZGVyIiwic2hvd0J1dHRvbiIsIklNQUdFIiwiZmlsZUJhc2VuYW1lIiwicXVhbGl0eSIsImV4dGVuc2lvbnMiLCJsYW5ndWFnZXMiLCJiYXNlVXJsIiwicmVzb2x2ZXIiLCJyZWd1bGFyRm9udFBhdGgiLCJsaWdodEZvbnRQYXRoIiwiY3NzIiwiX3dlYkZvbnRzU3R5bGUiLCJpbm5lckhUTUwiLCJoZWFkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJwaXBlRXZlbnRzIiwidW5waXBlRXZlbnRzIiwiX2xhbmd1YWdlcyIsImRlIiwiZW4iLCJfbGFuZ3VhZ2UiLCJpbnRlcnBvbGF0aW9uT3B0aW9ucyIsInRyYW5zbGF0ZSIsImFzc2V0IiwidWlBc3NldCIsImRpc2FibGVSZXRpbmEiLCJyZWdleCIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJfZGlzcG9zZUV2ZW50cyIsIkJhc2VDb250cm9scyIsIlJlYWN0Q29tcG9uZW50Iiwib25FZGl0b3JSZWFkeSIsIm9uUmVhZHkiLCJjb250YWluZXJTdHlsZSIsIkNvbXBvbmVudCIsIlVJIiwiX2JpbmRFdmVudHMiLCJfb25TaGFyZWRTdGF0ZVVwZGF0ZSIsImZpeFN0eWxlcyIsIl91bmJpbmRFdmVudHMiLCJmbk5hbWVzIiwib2xkU3RhdGUiLCJuZXdTdGF0ZSIsInNoYXJlZFN0YXRlRGlkQ2hhbmdlIiwic2hvdWxkU2hhcmVkQ29tcG9uZW50VXBkYXRlIiwicHJvcCIsImJyb2FkY2FzdFVwZGF0ZSIsImV2ZW50TmFtZSIsImhhbmRsZXIiLCJyZW5kZXJXaXRoQkVNIiwib2JqZWN0IiwiZWRpdG9yU2NyZWVuIiwiVUlVdGlscyIsImdldElubmVyRGltZW5zaW9uc0ZvckVsZW1lbnQiLCJjb21wdXRlZFN0eWxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJjbGllbnRYIiwiY2xpZW50WSIsInRvdWNoZXMiLCJzdXBwb3J0c01TQmxvYiIsIm1zVG9CbG9iIiwicGhyYXNlcyIsImZldGNoIiwiaW5mbyIsIm5ld1RvT2xkTG9jYWxpemF0aW9uS2V5TWFwIiwib2xkS2V5IiwiZGVmYXVsdFZhbHVlIiwicGF0aFNlZ21lbnRzIiwic2VnbWVudCIsInZlbmRvciIsIm9wZXJhIiwiaXNUb3VjaERldmljZSIsIkRvY3VtZW50VG91Y2giLCJzZWxlY3QiLCJzZWxlY3RlZEl0ZW1zIiwic2VsZWN0b3IiLCJuZXdJdGVtcyIsIml0ZW1JZGVudGlmaWVyIiwiZ2V0SlNPTlAiLCJjbG9uZUNhdGVnb3JpZXMiLCJpdGVtc1Byb3BlcnR5IiwiZXhpc3RpbmdDYXRlZ29yeSIsIm5ld0NhdGVnb3J5IiwiZ2V0U3R5bGVPYmplY3QiLCJlbCIsInN0eWxlUHJvcGVydGllcyIsInN0eWxlT2JqZWN0IiwicHJvcGVydHkiLCJjYW1lbGl6ZWRBdHRyIiwidG9VcHBlckNhc2UiLCJkZWJvdW5jZSIsImZuIiwid2FpdCIsImltbWVkaWF0ZSIsInRpbWVvdXQiLCJhcmd1bWVudHMiLCJsYXRlciIsImFwcGx5IiwiY2FsbE5vdyIsImNsZWFyVGltZW91dCIsIm91dGVyIiwidmlzaWJpbGl0eSIsIm1zT3ZlcmZsb3dTdHlsZSIsImJvZHkiLCJ3aWR0aE5vU2Nyb2xsIiwib3ZlcmZsb3ciLCJpbm5lciIsIndpZHRoV2l0aFNjcm9sbCIsImNhcGl0YWxpemUiLCJjaGFyQXQiLCJ0b1N0cmluZyIsImNhbGwiLCJnZXRQcm90b3R5cGVPZiIsInByb3RvIiwidmFsdWVzIiwiSFRNTEVsZW1lbnQiLCJub2RlVHlwZSIsIm5vZGVOYW1lIiwidmVjdG9yIiwibmV3U2l6ZSIsInZlY3RvclJhdGlvIiwiY29udGFpbmVyUmF0aW8iLCJ2YWwiLCJuZXdPYmplY3QiLCJzb3VyY2VzIiwiZGVzdCIsIl9kZWVwTWVyZ2UiLCJpc1BsYWluT2JqZWN0IiwicmV2ZXJzZWRTb3VyY2VzIiwicmV2ZXJzZSIsImRlZXBNZXJnZSIsImlzRXh0ZW5kYWJsZSIsImNhbGxQcm9wTmFtZSIsInByb3BOYW1lIiwiVHlwZUVycm9yIiwiQmxvYiIsIkFycmF5QnVmZmVyIiwicmF3RGF0YSIsIm1pbWVTdHJpbmciLCJhcnJheUJ1ZmZlciIsImludEFycmF5IiwiYmxvYiIsImNyZWF0ZU9iamVjdFVSTCIsInYiLCJodG1sSW1hZ2UiLCJvbGRJbmRleCIsIm5ld0luZGV4IiwiYnl0ZUFycmF5IiwiYnl0ZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImpvaW4iLCJudW1iZXIiLCJydWxlIiwiUmVnRXhwIiwibmV3T2JqIiwibmV3T3B0aW9ucyIsImRhdGUiLCJwYWQiLCJuIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJnZXRVVENIb3VycyIsImdldFVUQ01pbnV0ZXMiLCJnZXRVVENTZWNvbmRzIiwib2JqQSIsIm9iakIiLCJrZXlzQSIsImtleXNCIiwiYkhhc093blByb3BlcnR5IiwiaGFzT3duUHJvcGVydHkiLCJjb25kaXRpb24iLCJjb3VudCIsImNvdW50ZXIiLCJlcnJvcnMiLCJvbkZpbm5pc2giLCJvblN1Y2Nlc3MiLCJvbkVycm9yIiwicHJvbWlzZSIsIkFycmF5VXRpbHMiLCJLRVlfU1RSIiwiZW5jb2RlIiwiaW5wdXQiLCJjaHIxIiwiY2hyMiIsImNocjMiLCJlbmMxIiwiZW5jMiIsImVuYzMiLCJlbmM0IiwiaXNOYU4iLCJidWYiLCJiYXNlNjR0ZXN0IiwiZXhlYyIsImFycmF5IiwiZmxhdCIsInRvRmxhdHRlbiIsImFwcFZlcnNpb24iLCJpc0lFMTAiLCJpc0lFMTEiLCJicm93c2VyVmVyc2lvbiIsInByb21pc2VGYWN0b3J5IiwiREVGIiwiYnVpbHRJblByb3AiLCJjeWNsZSIsInNjaGVkdWxpbmdfcXVldWUiLCJUb1N0cmluZyIsInRpbWVyIiwic2V0SW1tZWRpYXRlIiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWciLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVyciIsIlF1ZXVlIiwiZmlyc3QiLCJsYXN0IiwiSXRlbSIsInNlbGYiLCJuZXh0IiwiZHJhaW4iLCJzY2hlZHVsZSIsImlzVGhlbmFibGUiLCJfdGhlbiIsIm9fdHlwZSIsIm5vdGlmeSIsImNoYWluIiwibm90aWZ5SXNvbGF0ZWQiLCJzdWNjZXNzIiwiZmFpbHVyZSIsInJldCIsIm1zZyIsInRyaWdnZXJlZCIsImRlZiIsImRlZl93cmFwcGVyIiwiTWFrZURlZldyYXBwZXIiLCIkcmVzb2x2ZSQiLCIkcmVqZWN0JCIsIml0ZXJhdGVQcm9taXNlcyIsIkNvbnN0cnVjdG9yIiwicmVqZWN0ZXIiLCJpZHgiLCJJSUZFIiwiJHJlc29sdmVyJCIsIk1ha2VEZWYiLCJleGVjdXRvciIsIl9fTlBPX18iLCJleHRyYWN0Q2hhaW4iLCIkY2F0Y2gkIiwicHVibGljUmVzb2x2ZSIsInB1YmxpY1JlamVjdCIsIlByb21pc2VQcm90b3R5cGUiLCJQcm9taXNlJHJlc29sdmUiLCJQcm9taXNlJHJlamVjdCIsIlByb21pc2UkYWxsIiwibXNncyIsIlByb21pc2UkcmFjZSIsIl9Qcm9taXNlIiwidW5pdHNQZXJFbSIsImFzY2VuZGVyIiwiZGVzY2VuZGVyIiwiUkVOREVSIiwiQ0xPU0UiLCJPUEVSQVRJT05fQ1JFQVRFRCIsIkZFQVRVUkVTX0RJU0FCTEVEIiwiRkVBVFVSRVNfRU5BQkxFRCIsIkZFQVRVUkVTX1VQREFURUQiLCJISVNUT1JZX1VQREFURUQiLCJISVNUT1JZX0JFRk9SRV9VTkRPIiwiSElTVE9SWV9VTkRPIiwiV0lORE9XX1JFU0laRSIsIkNPTlRST0xTX1NXSVRDSEVEIiwiVFJBTlNGT1JNX1JFQVBQTFlfUkFUSU8iLCJUUkFOU0ZPUk1fUkFUSU9TIiwicmF0aW8iLCJzZWxlY3RlZCIsIkJSVVNIRVMiLCJCcnVzaGVzIiwiUmFkaWFsQnJ1c2giLCJfc3RhdGUiLCJyQUYiLCJjQUYiLCJsYXN0VGltZSIsInZlbmRvcnMiLCJjdXJyVGltZSIsImdldFRpbWUiLCJ0aW1lVG9DYWxsIiwiQXBwQ29tcG9uZW50IiwiX29uU2NyZWVuTW91bnRlZCIsIl9zY3JlZW5FbGVtZW50cyIsIl9zY3JlZW5zIiwiTG9hZGluZ1NjcmVlbkNvbXBvbmVudCIsInNwbGFzaCIsIlNwbGFzaFNjcmVlbkNvbXBvbmVudCIsIlBob3RvUm9sbFNjcmVlbkNvbXBvbmVudCIsIndlYmNhbSIsIldlYmNhbVNjcmVlbkNvbXBvbmVudCIsIkVkaXRvclNjcmVlbkNvbXBvbmVudCIsImVtcHR5IiwiRW1wdHlTY3JlZW5Db21wb25lbnQiLCJpbml0aWFsU2NyZWVuIiwiX3NjcmVlbkFmdGVyTG9hZGluZyIsIl9wcmV2aW91c1NjcmVlbnNTdGFjayIsImFjdGl2ZVNjcmVlbiIsImFjdGl2ZVNjcmVlbk5hbWUiLCJzY3JlZW5zIiwiU2NyZWVuIiwiZmlyc3RFZGl0b3JMYXVuY2giLCJzd2l0Y2hUb1NjcmVlbiIsInJlbmRlcmVkU2NyZWVucyIsIl9yZW5kZXJTY3JlZW5zIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJpc1JlcXVpcmVkIiwiYXBwIiwiX2NhbnZhcyIsIl9jb250ZXh0IiwiX3ByZWxvYWRlckltYWdlIiwiX3JlbmRlckxvYWRpbmdJbmRpY2F0b3IiLCJjdHgiLCJzYXZlIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwiYXJjIiwibGluZVRvIiwiY2xpcCIsInJlc3RvcmUiLCJnbG9iYWxBbHBoYSIsIkhlYWRlckNvbXBvbmVudCIsImNsb3NlQnV0dG9uIiwiX29uQ2xvc2VDbGljayIsInVwbG9hZEF2YWlsYWJsZSIsIndlYmNhbUF2YWlsYWJsZSIsIl9pc1dlYmNhbUF2YWlsYWJsZSIsInBob3RvUm9sbEF2YWlsYWJsZSIsIl9pc1Bob3RvUm9sbEF2YWlsYWJsZSIsIl9vbkltYWdlIiwiX29uV2ViY2FtQ2xpY2siLCJfb25QaG90b1JvbGxDbGljayIsIlVwbG9hZENvbXBvbmVudCIsIl9kcmFnQ291bnRlciIsImRyYWdBcmVhSG92ZXJlZCIsIm5hdGl2ZUV2ZW50IiwicmV0dXJuVmFsdWUiLCJkYXRhVHJhbnNmZXIiLCJmaWxlcyIsImZpbGVUeXBlIiwiX2hhbmRsZUZpbGUiLCJ1cGxvYWQiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwidGFyZ2V0IiwicmVhZEFzRGF0YVVSTCIsIm9uSW1hZ2UiLCJjZWxsUHJvcHMiLCJvbkRyYWdFbnRlciIsIl9vbkRyYWdFbnRlciIsIm9uRHJhZ092ZXIiLCJfb25EcmFnT3ZlciIsIm9uRHJhZ0xlYXZlIiwiX29uRHJhZ0xlYXZlIiwib25Ecm9wIiwiX29uRHJvcCIsImNvbnRlbnRDZWxsQkVNIiwiQnV0dG9uQ29tcG9uZW50IiwiYmVtU3BlY2lmaWVyIiwidXBwZXJjYXNlIiwic3RyaW5nIiwiX2lucHV0IiwiX29uRmlsZUNoYW5nZSIsImNsaWNrIiwiY2xvc2VPbk92ZXJsYXlDbGljayIsImdldFVVSUQiLCJidXR0b25zIiwiV2ViY2FtQ29tcG9uZW50IiwiUGhvdG9Sb2xsQ29tcG9uZW50Iiwic2VjdGlvbiIsInNlY3Rpb25zSGlzdG9yeSIsImFsbG93U2NyZWVuU3dpdGNoIiwiYWRkVG9TdGFjayIsImhhc1ByZXZpb3VzU2VjdGlvbiIsInN3aXRjaFRvU2VjdGlvbiIsImF1dG9tYXRpY2FsbHkiLCJzZWFyY2hRdWVyeSIsImxvYWRpbmdNb2RhbCIsImRpc3BsYXlMb2FkaW5nIiwicmF3IiwidHJpbSIsImhhc1ByZXZpb3VzU2NyZWVuIiwiX29uU2VhcmNoU3VnZ2VzdGlvbkNsaWNrZWQiLCJfb25MaWJyYXJ5Q2xpY2tlZCIsImNvbnRlbnRDb21wb25lbnQiLCJfb25CYWNrQ2xpY2tlZCIsIl9vblNlYXJjaCIsIl9vbkZpbGVVcGxvYWQiLCJfaXNCYWNrQnV0dG9uVmlzaWJsZSIsIlBob3RvUm9sbFRvcEJhckNvbXBvbmVudCIsIl9vblNlYXJjaFZhbHVlQ2hhbmdlIiwib25CYWNrQ2xpY2tlZCIsIm9uU2VhcmNoIiwib25XZWJjYW1DbGljayIsIm9uRmlsZVVwbG9hZCIsIl9vblVwbG9hZEJ1dHRvbkNsaWNrZWQiLCJfb25XZWJjYW1CdXR0b25DbGlja2VkIiwiYmFja0J1dHRvbkxhYmVsIiwiX3JlbmRlclJpZ2h0QnV0dG9ucyIsIlRvcEJhclNlYXJjaENvbXBvbmVudCIsImFjdGl2ZSIsInBsYWNlaG9sZGVyIiwiX2hpZGRlbklucHV0RHVtbXkiLCJvdmVycmlkZUtleXMiLCJfdXBkYXRlSW5wdXRXaWR0aCIsImlucHV0V2lkdGgiLCJmb2N1cyIsInNlYXJjaEJhckJFTSIsImlucHV0U3R5bGUiLCJfb25CYXJDbGljayIsIl9vbkJsdXIiLCJfb25Gb2N1cyIsIl9vbkNoYW5nZSIsIlRvcEJhckJhY2tCdXR0b25Db21wb25lbnQiLCJPdmVydmlld0NvbXBvbmVudCIsImxpYnJhcmllcyIsInNlYXJjaFN1Z2dlc3Rpb25zIiwiX3Byb3ZpZGVyIiwiX2xvYWQiLCJfb25MaWJyYXJ5Q2xpY2siLCJvbkxpYnJhcnlDbGlja2VkIiwib25TZWFyY2hTdWdnZXN0aW9uQ2xpY2tlZCIsImdldExpYnJhcmllcyIsImdldFNlYXJjaFN1Z2dlc3Rpb25zIiwiX29uU2VhcmNoU3VnZ2VzdGlvbkNsaWNrIiwiX3JlbmRlckxpYnJhcmllcyIsIl9yZW5kZXJTZWFyY2hTdWdnZXN0aW9ucyIsIkxpYnJhcnlDb21wb25lbnQiLCJQaG90b0NvbXBvbmVudCIsIlNlYXJjaFJlc3VsdHNDb21wb25lbnQiLCJzZWFyY2hQaG90b3MiLCJfcmVuZGVyTm90Rm91bmQiLCJOb1NlYXJjaFJlc3VsdHNDb21wb25lbnQiLCJfX2h0bWwiLCJfcmVuZGVyTWVzc2FnZSIsIndlYmNhbVJlYWR5IiwibWFrZVBob3RvIiwiX29uQ2FuY2VsIiwiX29uV2ViY2FtUmVhZHkiLCJfb25TaHV0dGVyQ2xpY2tlZCIsIm5leHRTdGF0ZSIsImVycm9yTW9kYWwiLCJvbkJhY2siLCJfd2ViY2FtIiwiY2FwdHVyZSIsIl9vbldlYmNhbUVycm9yIiwiV2ViY2FtVmlkZW9Db21wb25lbnQiLCJ1c2VGbGFzaEZhbGxiYWNrIiwiY29udGFpbmVyV2lkdGgiLCJjb250YWluZXJIZWlnaHQiLCJfZ2V0VXNlck1lZGlhIiwiX3dlYmNhbVN0cmVhbSIsIl9pbml0R2V0VXNlck1lZGlhIiwiX2NhbGN1bGF0ZUZsYXNoRGltZW5zaW9ucyIsInZpZGVvIiwib3B0aW9uYWwiLCJtaW5XaWR0aCIsImF1ZGlvIiwic3RyZWFtIiwiX3ZpZGVvRWxlbWVudCIsInNyY09iamVjdCIsIm9uV2ViY2FtRXJyb3IiLCJkZWxldGVXZWJjYW0iLCJXZWJjYW0iLCJmbGFzaE5vdGlmeSIsIm9uV2ViY2FtQXZhaWxhYmxlIiwiX2Rpc3Bvc2VXZWJjYW0iLCJtZWRpYURldmljZXMiLCJnZXRVc2VyTWVkaWEiLCJsZWdhY3lHZXRVc2VyTWVkaWEiLCJ3ZWJraXRHZXRVc2VyTWVkaWEiLCJtb3pHZXRVc2VyTWVkaWEiLCJtc0dldFVzZXJNZWRpYSIsInRyYWNrIiwiZ2V0VHJhY2tzIiwiX2ZsYXNoV2ViY2FtIiwiX3JlbGVhc2VDYW1lcmEiLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJfc25hcCIsImN1cnJlbnQiLCJfY29udGFpbmVyIiwiY2xpZW50SGVpZ2h0IiwiX2dldElFSGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJmbGFzaHZhcnMiLCJmbGFzaFVSTCIsInZpZGVvQ29tcG9uZW50IiwiX2dldEZsYXNoRmFsbGJhY2tDb21wb25lbnQiLCJfb25Mb2FkZWRNZXRhZGF0YSIsIm1hcmdpbiIsIldJTkRPV19SRVNJWkVfREVMQVkiLCJfb3ZlcnZpZXdDb250cm9scyIsIl9wcmV2aW91c0NvbnRyb2xzU3RhY2siLCJPdmVydmlld0NvbnRyb2xzIiwiZHJhZ0VuYWJsZWQiLCJfb25OZXdJbWFnZSIsIl9zdGFydEVkaXRvciIsIl9vbkltYWdlUmVzaXplIiwiX29uUmVuZGVyRXJyb3IiLCJfaGFzVXNlZEZvcmNlQ3JvcCIsIl9mb3JjZUNvbnRyb2xzIiwiX2ZvcmNlQ29udHJvbEluZGV4IiwiX3N3aXRjaFRvRnJvY2VDcm9wQ29udHJvbCIsIl9zd2l0Y2hUb05leHRGb3JjZUNvbnRyb2wiLCJfb25XaW5kb3dSZXNpemUiLCJhdmFpbGFibGVDb250cm9scyIsImNvbnRyb2xPYmplY3QiLCJzd2l0Y2hUb0NvbnRyb2xzIiwiZmlyc3RDcm9wIiwiZml4ZWRPcHRpb25zIiwiZGlzcGxheVdhcm5pbmciLCJfcmVzaXplVGltZW91dCIsIl9vbldpbmRvd1Jlc2l6ZURvbmUiLCJpbml0aWFsU3RhdGUiLCJjb250cm9sT3B0aW9ucyIsIm5ld0NvbnRyb2xzIiwiY29udHJvbHNDaGFuZ2VkIiwib25FeGl0IiwiY2xlYXIiLCJvbkVudGVyIiwiaXNBdmFpbGFibGUiLCJUb3BCYXJDb250cm9sc0NvbXBvbmVudCIsImNhbnZhc0NvbnRyb2xzIiwidG9wQmFyQ29udHJvbHMiLCJsYXJnZUNhbnZhc0NvbnRyb2xzIiwiQmFja0J1dHRvbkNvbXBvbmVudCIsIkRvbmVCdXR0b25Db21wb25lbnQiLCJDYW52YXNDb21wb25lbnQiLCJfb25GZWF0dXJlc1VwZGF0ZWQiLCJfaW5pdGlhbFJlbmRlckRvbmUiLCJjYW52YXNQb3NpdGlvbiIsImNhbnZhc09mZnNldCIsInJlc2l6ZVRvIiwiX2dldENvbnRhaW5lckRpbWVuc2lvbnMiLCJpZGVudGlmaWVycyIsImNhbnZhc0NlbGwiLCJzZXRDYW52YXMiLCJfb25ab29tQ2hhbmdlIiwiX2RyYWdTdGFydFBvc2l0aW9uIiwiX2RyYWdJbml0aWFsT2Zmc2V0IiwiZXZlbnRQb3NpdGlvbiIsImRpZmZGcm9tU3RhcnQiLCJsYXN0T2Zmc2V0IiwiY2FudmFzQ29udGVudCIsImNvbnRhaW5lckNvbnRlbnQiLCJsYXJnZUNvbnRyb2xzIiwiem9vbUFsbG93c0RyYWciLCJpc1JlYWR5IiwiZ2V0RGVmYXVsdCIsIl9nZXREcmFnZ2FibGVTdHlsZSIsIk92ZXJ2aWV3Q2FudmFzQ29udHJvbHNDb21wb25lbnQiLCJPdmVydmlld1RvcEJhckNvbXBvbmVudCIsIm5ld0ZpbGVCdXR0b24iLCJ6b29tQ29tcG9uZW50IiwiTmV3RmlsZUJ1dHRvbkNvbXBvbmVudCIsIndlYmNhbUVuYWJsZWQiLCJwaG90b1JvbGxFbmFibGVkIiwiYnV0dG9uTGFiZWwiLCJFeHBvcnRCdXR0b25Db21wb25lbnQiLCJleHBvcnRPcHRpb25zIiwiVW5kb0J1dHRvbkNvbXBvbmVudCIsIl9vbkhpc3RvcnlVcGRhdGVkIiwidW5kbyIsIlpvb21Db21wb25lbnQiLCJfb25ab29tRG9uZSIsIm91dCIsImluIiwiX29uWm9vbU91dENsaWNrIiwiX29uWm9vbUluQ2xpY2siLCJfZG93bmxvYWQiLCJyZW5kZXJUeXBlIiwiX2dldFJlbmRlclR5cGUiLCJfZG93bmxvYWREYXRhIiwiREFUQVVSTCIsIkZpbGVEb3dubG9hZGVyIiwiZG93bmxvYWREYXRhVVJMIiwiTVNCTE9CIiwiZG93bmxvYWRNU0Jsb2IiLCJiYXNlTmFtZSIsImNyZWF0ZUJsb2JVUkxGcm9tRGF0YVVSTCIsImV4dGVuc2lvbiIsImdldEV4dGVuc2lvbkZyb21EYXRhVVJMIiwibGluayIsImhyZWYiLCJtc1NhdmVCbG9iIiwiX2ltYWdlIiwiX21heFBpeGVscyIsIl9tYXhEaW1lbnNpb25zIiwicGl4ZWxzIiwiZXhjZWVkc01heFBpeGVscyIsImV4Y2VlZHNNYXhEaW1lbnNpb25zIiwiY29weSIsIl9nZXREaW1lbnNpb25zQnlNYXhQaXhlbHMiLCJfY3JlYXRlUmVzaXplZEltYWdlQ2FudmFzIiwiaW1hZ2VEaW1lbnNpb25zIiwicmF0aW9IViIsInJhdGlvVkgiLCJzcXJ0IiwiX21hcCIsIl9zdGFjayIsImdldE9wZXJhdGlvbnNTdGFjayIsIl9wcmVmZXJyZWRPcmRlciIsIl9hdmFpbGFibGUiLCJvcGVyYXRpb25OYW1lIiwiT3BlcmF0aW9uIiwiX2ZpeFN0YWNrIiwicmVtb3ZlQXQiLCJzZXREaXJ0eSIsIl9pbnZhbGlkT3BlcmF0aW9uc1NlZW4iLCJyZXF1aXJlZE9wZXJhdGlvbnMiLCJtaXNzaW5nT3BlcmF0aW9ucyIsIm9wZXJhdGlvbklkZW50aWZpZXIiLCJUT09MUyIsIkFkanVzdG1lbnRzQ29udHJvbHMiLCJ0b29sIiwiaXNUb29sRW5hYmxlZCIsIkFkanVzdG1lbnRzQ29udHJvbHNDb21wb25lbnQiLCJJVEVNUyIsIl9vcGVyYXRpb24iLCJzZWxlY3RlZENvbnRyb2xzIiwib3B0aW9uc0VxdWFsIiwiZ2V0RGVmYXVsdE9wdGlvbnMiLCJyZW1vdmUiLCJzZXRPcHRpb24iLCJjb250cm9sc0l0ZW0iLCJzbGlkZXJWYWx1ZSIsInNsaWRlclByb3BzIiwiX2J1aWxkU2xpZGVyUHJvcHMiLCJtaW5pU2xpZGVyIiwiTWluaVNsaWRlckNvbXBvbmVudCIsIlRyYW5zZm9ybUNvbnRyb2xzIiwidHJhbnNmb3JtT3BlcmF0aW9uRXhpc3RlZEJlZm9yZSIsIm9yaWVudGF0aW9uT3BlcmF0aW9uRXhpc3RlZEJlZm9yZSIsImluaXRpYWxUcmFuc2Zvcm1PcHRpb25zIiwiZmluYWxTY2FsZSIsImNhbGN1bGF0ZVNjYWxlIiwiY29zIiwic2luIiwiaGFsZlJlbGF0aXZlU2l6ZSIsIm1pZGRsZUluUGl4ZWxzIiwibWlkZGxlRGlzdGFuY2VGcm9tQ2VudGVyIiwibmV3TWlkZGxlRGlzdGFuY2VGcm9tQ2VudGVyIiwibmV3TWlkZGxlSW5QaXhlbHMiLCJuZXdSZWxhdGl2ZU1pZGRsZSIsIm5ld1N0YXJ0IiwibmV3RW5kIiwiaW5pdGlhbE9yaWVudGF0aW9uT3B0aW9ucyIsImFjdGl2ZVBhZGRpbmciLCJzZXRQYWRkaW5nIiwiZGlzYWJsZSIsIm9yaWVudGF0aW9uUm90YXRpb24iLCJ0cmFuc2Zvcm1PcHRpb25zIiwicmF0aW9zIiwiVHJhbnNmb3JtQ29udHJvbHNDb21wb25lbnQiLCJnZXRSYXRpb3MiLCJUcmFuc2Zvcm1Ub3BCYXJDb21wb25lbnQiLCJUcmFuc2Zvcm1DYW52YXNDb250cm9sc0NvbXBvbmVudCIsIl9yYXRpb3MiLCJfcmVhcHBseVJhdGlvIiwiX3NlbGVjdEluaXRpYWxSYXRpbyIsImhpc3RvcnlJdGVtcyIsInRyYW5zZm9ybUhpc3RvcnlJdGVtIiwiX2dldFRyYW5zZm9ybUhpc3RvcnlJdGVtIiwib3JpZW50YXRpb25IaXN0b3J5SXRlbSIsIl9nZXRPcmllbnRhdGlvbkhpc3RvcnlJdGVtIiwiZXhpc3RlbnQiLCJicm9hZGNhc3RSb3RhdGUiLCJpbnZlcnNlRmxpcCIsImJyb2FkY2FzdEZsaXAiLCJfc2VsZWN0UmF0aW8iLCJfY2FsY3VsYXRlVGV4dHVyZVNjYWxlIiwiX2dldEhpc3RvcnlJdGVtcyIsImVuYWJsZSIsInNldERlZmF1bHRPcHRpb25zIiwic2VsZWN0ZWRSYXRpbyIsIm9wZXJhdGlvblJhdGlvIiwibWF0Y2hpbmdSYXRpb3MiLCJzZWxlY3RlZFJhdGlvcyIsIl9zZXREZWZhdWx0T3B0aW9uc0ZvclJhdGlvIiwibmV3U2hhcmVkU3RhdGUiLCJjYW52YXNSYXRpbyIsIl9vblJvdGF0aW9uQ2hhbmdlIiwiZ3JvdXBPclJhdGlvIiwibm9UcmFuc2Zvcm1JdGVtIiwicmVwbGFjZVJhdGlvcyIsImF2YWlsYWJsZVJhdGlvcyIsInNlbGVjdGFibGVSYXRpb3MiLCJwaWNrUmF0aW9zIiwiTUlOX0RJTUVOU0lPTlMiLCJfdXBkYXRlRGltZW5zaW9ucyIsInRyYW5zZm9ybVNpemUiLCJfaW5pdGlhbFZhbHVlcyIsInRyYW5zZm9ybURpZmZlcmVuY2UiLCJtaW5TdGFydCIsIm1heFN0YXJ0IiwiX2N1cnJlbnREcmFnT3B0aW9uIiwibWF4U2l6ZSIsImJpZ2dlc3RQb3NzaWJsZUNyb3AiLCJjZWlsIiwiZ2V0UGFkZGluZyIsInRvcExlZnQiLCJfZ2V0RGltZW5zaW9uc1N0eWxlcyIsInRvcENlbnRlciIsImNlbnRlckxlZnQiLCJjZW50ZXIiLCJhcmVhU3R5bGVzIiwiX2dldEFyZWFTdHlsZXMiLCJfb25DZW50ZXJEcmFnU3RhcnQiLCJfb25DZW50ZXJEcmFnIiwibmV3Um90YXRpb24iLCJ0ZW1wU3RhcnQiLCJuZXdGbGlwIiwidG1wU3RhcnQiLCJfb25GbGlwQ2xpY2siLCJfb25Sb3RhdGVDbGljayIsIkZpbHRlcnNDb250cm9scyIsIkZpbHRlckNvbnN0cnVjdG9yIiwiZ2V0RmlsdGVyIiwiSW5pdGlhbEZpbHRlckNvbnN0cnVjdG9yIiwic2V0RmlsdGVyIiwiaXNJZGVudGl0eSIsImZpbHRlck9wdGlvbnMiLCJmaWx0ZXJNYW5hZ2VyIiwiZ2V0Q2F0ZWdvcmllcyIsImdldEZpbHRlcnNGb3JDYXRlZ29yeSIsIkZpbHRlcnNDb250cm9sc0NvbXBvbmVudCIsImhpZGVDYXRlZ29yaWVzIiwiRmlsdGVyQ29udHJvbHNDb21wb25lbnQiLCJfaW5pdEZpbHRlck1hbmFnZXIiLCJnZXRDYXRlZ29yeUJ5SWRlbnRpZmllciIsInNldEludGVuc2l0eSIsImN1cnJlbnRGaWx0ZXIiLCJjdXJyZW50RmlsdGVySWRlbnRpZmllciIsImNhdGVnb3J5RHJvcGRvd25WaXNpYmxlIiwiY2F0ZWdvcnlJdGVtcyIsInNlbGVjdGVkQ2F0ZWdvcnkiLCJfb25DYXRlZ29yeUNoYW5nZSIsImNhdGVnb3J5RHJvcGRvd24iLCJfcmVuZGVyQ2F0ZWdvcnlEcm9wZG93biIsIkNhdGVnb3J5RHJvcGRvd25PdmVybGF5Q29tcG9uZW50IiwiRm9jdXNDb250cm9scyIsImluaXRpYWxPcGVyYXRpb24iLCJGb2N1c0NvbnRyb2xzQ29tcG9uZW50IiwiRm9jdXNDYW52YXNDb250cm9sc0NvbXBvbmVudCIsInRvb2xOYW1lIiwiaWNvbk5hbWUiLCJfcmVtb3ZlZE9wZXJhdGlvbiIsInNldEJsdXJSYWRpdXMiLCJwcmV2aW91c09wZXJhdGlvbiIsImN1cnJlbnRPcGVyYXRpb24iLCJmb2N1c09wZXJhdGlvbiIsInNob3J0ZXN0U2lkZSIsImdldEJsdXJSYWRpdXMiLCJfb25CbHVyUmFkaXVzQ2hhbmdlIiwibm9Gb2N1c0l0ZW0iLCJpc0FjdGl2ZSIsIkxpbmVhckZvY3VzQ2FudmFzQ29udHJvbHNDb21wb25lbnQiLCJSYWRpYWxGb2N1c0NhbnZhc0NvbnRyb2xzQ29tcG9uZW50IiwiX2dldENvbnRyb2xzRm9yT3BlcmF0aW9uIiwiYXJlYVBvc2l0aW9uIiwiYXJlYURpbWVuc2lvbnMiLCJrbm9iUG9zaXRpb24iLCJfc2V0U3R5bGVzRnJvbU9wdGlvbnMiLCJfaW5pdGlhbFN0YXJ0IiwiZ2V0U3RhcnQiLCJfaW5pdGlhbEVuZCIsImdldEVuZCIsIl9pbml0aWFsRGlzdCIsInJlbGF0aXZlT2Zmc2V0IiwiX2luaXRpYWxLbm9iUG9zaXRpb24iLCJuZXdLbm9iUG9zaXRpb24iLCJkaXN0YW5jZUZyb21DZW50ZXIiLCJkaXN0IiwiYXRhbjIiLCJtYXJnaW5MZWZ0IiwibWFyZ2luVG9wIiwiTW96VHJhbnNmb3JtIiwibXNUcmFuc2Zvcm0iLCJXZWJraXRUcmFuc2Zvcm0iLCJnZXRTaXplIiwibWlkZGxlIiwiYXJlYVNpemUiLCJ0b3RhbERpc3QiLCJmYWN0b3IiLCJfZ2V0QXJlYVN0eWxlIiwiX2tub2JDaGFuZ2VkTWFudWFsbHkiLCJnZXRSYWRpdXMiLCJkaWFtZXRlciIsIlN0aWNrZXJDb250cm9scyIsImdldFNwcml0ZXNPZlR5cGUiLCJnZXRTcHJpdGVzQXRQb3NpdGlvbiIsIlN0aWNrZXJDb250cm9sc0NvbXBvbmVudCIsIlN0aWNrZXJDYW52YXNDb250cm9sc0NvbXBvbmVudCIsInRvb2x0aXBzIiwiZml4ZWRSYXRpbyIsInNuYXBSb3RhdGlvbiIsInNuYXBSb3RhdGlvblRvbGVyYW5jZSIsImdldFByZWxvYWRBc3NldHMiLCJTdGlja2VyT3ZlcnZpZXdDb250cm9sc0NvbXBvbmVudCIsIl9vbkJlZm9yZUhpc3RvcnlVbmRvIiwiX3Nwcml0ZXMiLCJfc3RpY2tlcnMiLCJfaW5pdFN0aWNrZXJNYW5hZ2VyIiwiZ2V0Q2F0ZWdvcnkiLCJoaXN0b3J5T2JqZWN0Iiwic2tpcEhpc3RvcnkiLCJzdGlja2Vyc0pTT05QYXRoIiwiX2xvYWRFeHRlcm5hbFN0aWNrZXJzIiwibG9hZFRpbWVvdXQiLCJkb25lTG9hZGluZyIsIl9qc29uTG9hZGVkIiwibG9hZEV4dGVybmFsIiwiaG92ZXJlZFN0aWNrZXIiLCJ0b29sdGlwVmlzaWJsZSIsInRvb2x0aXBDYW52YXMiLCJkcmF3U2l6ZSIsImRyYXdQb3NpdGlvbiIsInJlc29sdmVkU3RpY2tlclBhdGgiLCJfY2FsY3VsYXRlSW5pdGlhbFN0aWNrZXJTY2FsZSIsImFkZFNwcml0ZSIsInN0aWNrZXJEaW1lbnNpb25zIiwicmVzaXplVmVjdG9yVG9GaXQiLCJzdGlja2VyUGF0aCIsImhvdmVyZWRTdGlja2VyRWxlbWVudCIsImN1cnJlbnRUYXJnZXQiLCJfcmVuZGVyVG9vbHRpcENhbnZhcyIsIl91cGRhdGVUb29sdGlwUG9zaXRpb24iLCJwYXJlbnRCb3VuZGluZ1JlY3QiLCJ0b29sdGlwUG9zaXRpb24iLCJnZXRTdGlja2Vyc0ZvckNhdGVnb3J5IiwiaXRlbUV2ZW50cyIsIm9uTW91c2VFbnRlciIsIl9vblN0aWNrZXJNb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwiX29uU3RpY2tlck1vdXNlTGVhdmUiLCJfb25TdGlja2VyQ2xpY2siLCJjdXJyZW50Q2F0ZWdvcnkiLCJzZWxlY3RlZENhdGVnb3J5SXRlbSIsInRvb2x0aXAiLCJfcmVuZGVyVG9vbHRpcCIsIl9yZW5kZXJTdGlja2VyIiwiX29uU3ByaXRlRmxpcCIsIl9vblNwcml0ZVRha2VUb0Zyb250IiwiZWRpdE1vZGUiLCJnZXRUZXh0IiwidGV4dGFyZWEiLCJibHVyIiwic2V0VGV4dCIsImVudGVyRWRpdE1vZGUiLCJzZXRWaXNpYmxlIiwiX2VkaXRlZCIsIl9pbml0aWFsVG91Y2hQb3NpdGlvbiIsIl90YXBTdGFydEF0IiwiX2xhc3RUYXBBdCIsIl9vbkl0ZW1Eb3VibGVDbGljayIsIl9kcmFnZ2luZyIsIl9nZXRSb3RhdGlvbktub2JQb3NpdGlvbiIsInNwcml0ZVBvc2l0aW9uIiwiX2dldEFic29sdXRlU3ByaXRlUG9zaXRpb24iLCJrbm9iRGlzdGFuY2VGcm9tQ2VudGVyIiwiYm91bmRpbmdCb3giLCJyYWRpYW5zIiwiX2dldFJlc2l6ZUtub2JQb3NpdGlvbiIsInRleHRSb3RhdGlvbiIsImRpc3RhbmNlVG9Qb3NpdGlvbiIsIm5ld01heFdpZHRoIiwic2V0TWF4V2lkdGgiLCJsZWF2ZUVkaXRNb2RlIiwiZ2V0RE9NU3R5bGUiLCJ0cmFuc2Zvcm1PcmlnaW4iLCJNb3pUcmFuc2Zvcm1PcmlnaW4iLCJtc1RyYW5zZm9ybU9yaWdpbiIsIldlYmtpdFRyYW5zZm9ybU9yaWdpbiIsImhhbGZEaW1lbnNpb25zIiwia25vYnMiLCJfb25Sb3RhdGlvbktub2JEcmFnU3RhcnQiLCJfb25Sb3RhdGlvbktub2JEcmFnIiwiX29uUm90YXRpb25Lbm9iRHJhZ1N0b3AiLCJfZ2V0Um90YXRpb25Lbm9iU3R5bGUiLCJfb25SZXNpemVLbm9iRHJhZ1N0YXJ0IiwiX29uUmVzaXplS25vYkRyYWciLCJfb25SZXNpemVLbm9iRHJhZ1N0b3AiLCJfZ2V0UmVzaXplS25vYlN0eWxlIiwiaXRlbUNvbnRhaW5lclN0eWxlIiwiX2dldEl0ZW1Db250YWluZXJTdHlsZSIsInRleHRBcmVhIiwiX2dldFRleHRTdHlsZSIsIl9vblRleHRDaGFuZ2UiLCJzZWxlY3RlZE92ZXJsYXlDbGFzc05hbWVzIiwib3ZlcmxheVN0eWxlIiwiX29uSXRlbURyYWdTdGFydCIsIl9vbkl0ZW1EcmFnU3RvcCIsIl9vbkl0ZW1EcmFnIiwiX29uSXRlbVRvdWNoU3RhcnQiLCJfb25JdGVtVG91Y2hFbmQiLCJfcmVuZGVySXRlbSIsIl9yZW5kZXJTZWxlY3RlZE92ZXJsYXkiLCJfcmVuZGVyS25vYnMiLCJfaWQiLCJzaWRlIiwiX2dldEJvdHRvbURyYWdLbm9iUG9zaXRpb24iLCJfZ2V0VG9wRHJhZ0tub2JQb3NpdGlvbiIsIl9pbml0aWFsRGltZW5zaW9ucyIsInN0aWNrZXJQb3NpdGlvbiIsImluaXRpYWxLbm9iRGlzdGFuY2VGcm9tQ2VudGVyIiwiX2dldFN0aWNrZXJEaW1lbnNpb25zIiwiaW5pdGlhbERpc3RhbmNlRnJvbUNlbnRlciIsIm5ld0RpbWVuc2lvbnMiLCJuZXh0U25hcCIsInJlbWFpbmRlciIsImxvY2FsRGlzdGFuY2VUb0NlbnRlciIsInByZXZpb3VzTG9jYWxEaXN0YW5jZVRvQ2VudGVyIiwiZGlzdGFuY2VUb0NlbnRlckRpZmYiLCJfZ2V0Um90YXRlS25vYlBvc2l0aW9uIiwicHJvY2Vzc2VkRGltZW5zaW9ucyIsInNwcml0ZURpbWVuc2lvbnMiLCJPVHJhbnNmb3JtIiwic3RpY2tlclJvdGF0aW9uIiwiX2dldEJvdHRvbURyYWdLbm9iU3R5bGUiLCJfZ2V0VG9wRHJhZ0tub2JTdHlsZSIsIl9vblJvdGF0ZUtub2JEcmFnU3RhcnQiLCJfb25Sb3RhdGVLbm9iRHJhZ1N0b3AiLCJfb25Sb3RhdGVLbm9iRHJhZyIsIl9nZXRSb3RhdGVLbm9iU3R5bGUiLCJmaWx0ZXJzU1ZHIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJfZ2V0U3RpY2tlclN0eWxlIiwic3RpY2tlclN0eWxlIiwiYmFzZVVSTCIsImxvY2F0aW9uIiwiaGFzaCIsInN0aWNrZXJJbWFnZVN0eWxlIiwic3ZnU3R5bGUiLCJ4bGlua0hyZWYiLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwiX3JlbmRlclNWR0ZpbHRlciIsIl9hcHBlbmRDYW52YXMiLCJuZXdDYW52YXMiLCJicnVzaENsYXNzTmFtZSIsIl9pc1NlbGVjdGVkIiwiU3RpY2tlckNvbnRyb2xzT3ZlcmxheUNvbXBvbmVudCIsIm9uRmxpcCIsIm9uVGFrZVRvRnJvbnQiLCJvblJlbW92ZSIsIl9vblRha2VUb0Zyb250Q2xpY2siLCJfb25SZW1vdmVDbGljayIsIl9yZW5kZXJJdGVtcyIsIlRleHRDb250cm9scyIsInNldEdsb2JhbFRvb2xTdGF0ZSIsInNhdmVUZXh0U2V0dGluZ3MiLCJkZWZhdWx0Rm9udFZhcmlhdGlvbiIsIlRleHRDb250cm9sc0NvbXBvbmVudCIsIlRleHRDYW52YXNDb250cm9sc0NvbXBvbmVudCIsIl9vblRleHRFZGl0IiwiVGV4dENvbnRyb2xzT3ZlcmxheUNvbXBvbmVudCIsIm9uRWRpdCIsIl9vbkVkaXRDbGljayIsIkFMSUdOTUVOVFMiLCJmb250c0xvYWRlZCIsIl9jcmVhdGVUZXh0IiwibmVlZHNUb0xvYWQiLCJfbG9hZEZvbnRzIiwiZ2V0R2xvYmFsVG9vbFN0YXRlIiwibWF4VGV4dHVyZVNpemUiLCJnZXRNYXhUZXh0dXJlU2l6ZSIsInBpdm90IiwibWF4SGVpZ2h0IiwiZ2V0Rm9udFN0eWxlIiwic2VsZWN0ZWRUZXh0Iiwic2V0Rm9udFNpemUiLCJzZXRGb250V2VpZ2h0Iiwic2V0Rm9udFN0eWxlIiwic2V0Rm9udElkZW50aWZpZXIiLCJnZXRBbGlnbm1lbnQiLCJjdXJyZW50SW5kZXgiLCJuZXh0SW5kZXgiLCJuZXdBbGlnbm1lbnQiLCJzZXRBbGlnbm1lbnQiLCJzZXRDb2xvciIsInNldEJhY2tncm91bmRDb2xvciIsIl9yZW5kZXJGb250U2l6ZU92ZXJsYXlDb250cm9sIiwiX3JlbmRlckZvbnRGYW1pbHlPdmVybGF5Q29udHJvbCIsIm1heEZvbnRTaXplIiwiZ2V0Rm9udFNpemUiLCJfb25Gb250U2l6ZUNoYW5nZSIsIl9zd2l0Y2hUb01vZGUiLCJfb25Gb250Q2hhbmdlIiwiX29uQWxpZ25tZW50Q2xpY2siLCJfcmVuZGVyU2l6ZUl0ZW0iLCJfcmVuZGVyRm9udEl0ZW0iLCJfcmVuZGVyQWxpZ25tZW50SXRlbSIsImZvcmVncm91bmRDb2xvciIsImdldENvbG9yIiwiZ2V0QmFja2dyb3VuZENvbG9yIiwiX29uRm9yZWdyb3VuZENvbG9yQ2hhbmdlIiwiX29uQmFja2dyb3VuZENvbG9yQ2hhbmdlIiwiQ29sb3JQaWNrZXJPdmVybGF5Q29tcG9uZW50IiwiaHN2QXJyIiwidG9IU1YiLCJoIiwiX2hzdiIsIl9vbkRvY3VtZW50Q2xpY2siLCJvbkNsb3NlIiwiYWxwaGFDb21wb25lbnQiLCJfb25Db2xvckNoYW5nZSIsIl9vbkVsZW1lbnRDbGljayIsIkFscGhhQ29tcG9uZW50IiwibmV3UHJvcHMiLCJrbm9iIiwiX2luaXRpYWxBbHBoYSIsIl9zZXRBbHBoYUZyb21Qb3NpdGlvbiIsImNhbnZhc1dpZHRoIiwiYWxwaGFDaGFuZ2UiLCJfc2V0QWxwaGEiLCJncmFkaWVudCIsImNyZWF0ZUxpbmVhckdyYWRpZW50IiwiYWRkQ29sb3JTdG9wIiwidG9IZXgiLCJTYXR1cmF0aW9uQ29tcG9uZW50IiwiX2hzdkNvbG9yIiwiX2luaXRpYWxWYWx1ZSIsIl9pbml0aWFsU2F0dXJhdGlvbiIsIl9zZXRWYWx1ZXNGcm9tUG9zaXRpb24iLCJjYW52YXNIZWlnaHQiLCJzYXR1cmF0aW9uQ2hhbmdlIiwidmFsdWVDaGFuZ2UiLCJfc2V0SFNWIiwiZnJvbUhTViIsImdldEltYWdlRGF0YSIsImciLCJIdWVDb21wb25lbnQiLCJfaW5pdGlhbEh1ZSIsIl9zZXRWYWx1ZUZyb21Qb3NpdGlvbiIsImh1ZUNoYW5nZSIsIl9zZXRIdWUiLCJzdHJva2VTdHlsZSIsInN0cm9rZSIsIkZvbnRDb21wb25lbnQiLCJzZWxlY3RlZElkZW50aWZpZXIiLCJfb25MaXN0SXRlbUNsaWNrIiwiQVJSQVkiLCJCcnVzaENvbnRyb2xzIiwic2l6ZVByZXNldHMiLCJCcnVzaENvbnRyb2xzQ29tcG9uZW50IiwiQnJ1c2hDYW52YXNDb250cm9sc0NvbXBvbmVudCIsIl9icnVzaE9wdGlvbnMiLCJfaGFzUHJlc2V0cyIsIl9oYXNTbGlkZXIiLCJzaXplQ29udHJvbHNFbmFibGVkIiwiX29uU2l6ZVVwZGF0ZWQiLCJwcmV2aW91c0JydXNoIiwiX29uU2l6ZUNsaWNrIiwiZmluYWxEaW1lbnNpb25zIiwibWluU2l6ZSIsImN1cnJlbnRXaWR0aCIsIl9yZW5kZXJTaXplSXRlbXMiLCJfb25Db2xvclVwZGF0ZWQiLCJQcmVzZXRQcmV2aWV3SXRlbUNvbXBvbmVudCIsImZpbGwiLCJfd2luZG93UmVzaXplZCIsIl9kcmF3aW5nIiwiX2xhc3REcmF3UG9zaXRpb24iLCJjdXJzb3JWaXNpYmxlIiwiY3Vyc29yUG9zaXRpb24iLCJfdXBkYXRlQ29udGFpbmVyUmVjdCIsIl9vcHRpb25zQmVmb3JlRHJhdyIsIl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlRHJhdyIsIl9nZXRDdXJzb3JQb3NpdGlvbiIsIl9jdXJyZW50UGF0aCIsIl9vbk1vdXNlTW92ZSIsIl9vbk1vdXNlVXAiLCJvdXRwdXRUZXh0dXJlRGltZW5zaW9ucyIsInNob3VsZERyYXciLCJicnVzaFNpemUiLCJkaXN0YW5jZSIsIl9jb250YWluZXJCb3VuZGluZ1JlY3QiLCJpbm5lckNvbnRhaW5lciIsImV2ZW50IiwiX29uTW91c2VEb3duIiwiX29uTW91c2VFbnRlciIsIl9vbk1vdXNlTGVhdmUiLCJvbk1vdXNlTW92ZSIsIl9vbk1vdXNlTW92ZU9uQ2FudmFzIiwiY3Vyc29yQ2xhc3MiLCJfZ2V0Q3Vyc29yU3R5bGUiLCJTZWxlY3RpdmVCbHVyQ29udHJvbHMiLCJTZWxlY3RpdmVCbHVyQ29udHJvbHNDb21wb25lbnQiLCJTZWxlY3RpdmVCbHVyQ2FudmFzQ29udHJvbHNDT21wb25lbnQiLCJfYnJ1c2hTaXplIiwicHJldmlvdXNWYWx1ZSIsInJlbGVhc2VkIiwiRnJhbWVDb250cm9scyIsImdldFNjYWxlIiwiRnJhbWVDb250cm9sc0NvbXBvbmVudCIsIkZyYW1lT3ZlcnZpZXdDb250cm9sc0NvbXBvbmVudCIsIl9pbml0RnJhbWVNYW5hZ2VyIiwic2V0U2NhbGUiLCJzZXRUaW50Q29sb3IiLCJzZXRGcmFtZSIsImZyYW1lT2JqZWN0IiwiY3VycmVudFNjYWxlIiwiX29uU2NhbGVDaGFuZ2UiLCJnZXRGcmFtZXNGb3JDYXRlZ29yeSIsImN1cnJlbnRGcmFtZSIsIm5vRnJhbWVJdGVtIiwiX29uRnJhbWVDbGljayIsIkZyYW1lSXRlbUNvbXBvbmVudCIsIl9yZW5kZXJGcmFtZSIsInJlc29sdmVkRnJhbWVQYXRoIiwiX2ZlYXR1cmVzIiwiZHJhZyIsImNhcGl0YWxpemVkSWRlbnRpZmllciIsIm9wdGlvbkVuYWJsZWQiLCJNSU5fWk9PTV9ESU1FTlNJT05TIiwiX2lzRGVmYXVsdFpvb20iLCJfem9vbSIsImdldFpvb20iLCJfem9vbUxldmVscyIsInoiLCJuZXdab29tIiwiX2dldENsb3Nlc3Rab29tTGV2ZWwiLCJ6b29tTGV2ZWwiLCJfcHJldmlvdXNab29tIiwiY29uc2lkZXJNaW5pbXVtIiwiZGVmYXVsdFpvb20iLCJtYXhab29tIiwibWluWm9vbSIsImdldE1pbmltdW0iLCJzZXRab29tIiwic2V0VGV4dHVyZVF1YWxpdHkiLCJkZWZhdWx0RGltZW5zaW9ucyIsIm1pbmltdW1EaW1lbnNpb25zIiwiX2hpc3RvcnkiLCJoaXN0b3J5SXRlbSIsImxhc3RJdGVtIiwiU2VyaWFsaXphdGlvbiIsImRlc2VyaWFsaXplciIsIkRlc2VyaWFsaXplciIsIl9icnVzaGVzIiwiX2JydXNoZXNCeUlkIiwiX2FkZEJydXNoZXMiLCJicnVzaGVzIiwicmVwbGFjZUJydXNoZXMiLCJhdmFpbGFibGVCcnVzaGVzIiwiRk9OVF9TVFlMRVMiLCJpdGFsaWMiLCJHb29nbGVGb250TG9hZGVyIiwiX2FkZFN0eWxlc2hlZXRUYWciLCJmYW1pbGllcyIsIl9nZXRGYW1pbGllc1N0cmluZyIsInJlbCIsImZhbWlseVN0cmluZ3MiLCJ2YXJpYW50cyIsInZhcmlhbnRzU3RyaW5nIiwibmFtZVN0cmluZyIsIk9CU0VSVkVfSU5URVJWQUwiLCJPQlNFUlZFX1RJTUVPVVQiLCJmb250VmFyaWF0aW9uIiwiX2ZvbnRWYXJpYXRpb24iLCJfZGVmYXVsdEZvbnRSdWxlciIsIkZvbnRSdWxlciIsIl9jdXN0b21Gb250UnVsZXIiLCJzdGFydGVkQXQiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwiY2hhbmdlZCIsImNsZWFySW50ZXJ2YWwiLCJGT05UX1NJWkUiLCJDSEFSQUNURVJTIiwiX2NyZWF0ZVJ1bGVyIiwiX3J1bGVyIiwiaW5uZXJUZXh0IiwiX3NldFJ1bGVyU3R5bGUiLCJjc3NUZXh0IiwiRmlsZUZvbnRMb2FkZXIiLCJmb250RmFjZXNDU1MiLCJmb250UGF0aCIsImdldEZpbGVQYXRoIiwic3R5bGVUYWciLCJfb3ZlcmxheXMiLCJfb3ZlcmxheXNCeUlkZW50aWZpZXIiLCJvdmVybGF5cyIsInJlcGxhY2VPdmVybGF5cyIsImF2YWlsYWJsZU92ZXJsYXlzIiwidjIwMVNlcmlhbGl6ZXIiLCJ2MjAxRGVzZXJpYWxpemVyIiwidjMxMFNlcmlhbGl6ZXIiLCJnZXRMYXlvdXQiLCJ2MzEwRGVzZXJpYWxpemVyIiwiTW9kYWxDb250YWluZXJDb21wb25lbnQiLCJfbW9kYWxNYW5hZ2VyIiwibW9kYWxNYW5hZ2VyIiwiX29uTW9kYWxNYW5hZ2VyVXBkYXRlIiwibW9kYWxzIiwiZ2V0TW9kYWxzIiwiTW9kYWxDb21wb25lbnQiLCJMb2FkaW5nTW9kYWxDb21wb25lbnQiLCJXYXJuaW5nTW9kYWxDb21wb25lbnQiLCJFcnJvck1vZGFsQ29tcG9uZW50IiwiUHJvZ3Jlc3NNb2RhbENvbXBvbmVudCIsIl9vbk1vZGFsQ2xvc2VkIiwiX3JlbmRlck1vZGFscyIsIm1vZGFsRWxlbWVudCIsIl9vbkNsb3NlIiwiY29udGVudCIsInByb2dyZXNzU3R5bGUiLCJMT0FEX1RJTUVPVVQiLCJfYXNzZXRzIiwiX2FwcGVuZENvbnRyb2xzQXNzZXRzIiwiYXNzZXRzQ291bnQiLCJhc3NldHNMb2FkZWQiLCJhc3NldExvYWRlZCIsImFzc2V0TG9hZEZhaWxlZCIsInJldGluYUFzc2V0IiwiYXNzZXRQYXRoIiwiUHJvdmlkZXIiLCJMaWJyYXJ5IiwiU2VhcmNoU3VnZ2VzdGlvbiIsIlBob3RvIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZCQUE2QjtBQUM3QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDRCQUE0QjtBQUM1QixPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUM3aEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7OztBQ3pMRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixLQUFLOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLDJDQUEyQyxLQUFLO0FBQ2hELDBDQUEwQyxLQUFLO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7c0RDM3RCQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7OztBQ3BoQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3JCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2ZBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNwRkEsa0JBQWtCLG8rVjs7Ozs7Ozs7Ozs7OztBQ2VsQjs7Ozs7O0FBRUEsSUFBTXhqQyxRQUFRLENBQ1o7QUFDRU0sY0FBWSxNQURkO0FBRUVDLGNBQVksQ0FDVjtBQUNFaFAsZ0JBQVksc0JBRGQ7QUFFRTJrQixnQkFBWSxNQUZkO0FBR0VwSCxjQUFVLE1BSFo7QUFJRXlXLGNBQVUsaUNBSlo7QUFLRUgsaUJBQWE7QUFDWHFlLGtCQUFZLElBREQ7QUFFWEMsZ0JBQVUsSUFGQztBQUdYQyxpQkFBVyxDQUFDO0FBSEQ7QUFMZixHQURVO0FBRmQsQ0FEWSxFQWlCWjtBQUNFcmpDLGNBQVksV0FEZDtBQUVFQyxjQUFZLENBQ1Y7QUFDRWhQLGdCQUFZLHFCQURkO0FBRUUya0IsZ0JBQVksUUFGZDtBQUdFcEgsY0FBVSxNQUhaO0FBSUV5VyxjQUFVLGdDQUpaO0FBS0VILGlCQUFhO0FBQ1hxZSxrQkFBWSxJQUREO0FBRVhDLGdCQUFVLElBRkM7QUFHWEMsaUJBQVcsQ0FBQztBQUhEO0FBTGYsR0FEVTtBQUZkLENBakJZLEVBaUNaO0FBQ0VyakMsY0FBWSxTQURkO0FBRUVDLGNBQVksQ0FDVjtBQUNFaFAsZ0JBQVksNEJBRGQ7QUFFRTJrQixnQkFBWSxRQUZkO0FBR0VwSCxjQUFVLE1BSFo7QUFJRXlXLGNBQVUsdUNBSlo7QUFLRUgsaUJBQWE7QUFDWHFlLGtCQUFZLElBREQ7QUFFWEMsZ0JBQVUsSUFGQztBQUdYQyxpQkFBVyxDQUFDO0FBSEQ7QUFMZixHQURVO0FBRmQsQ0FqQ1ksRUFpRFo7QUFDRXJqQyxjQUFZLFFBRGQ7QUFFRUMsY0FBWSxDQUNWO0FBQ0VoUCxnQkFBWSwyQkFEZDtBQUVFMmtCLGdCQUFZLFFBRmQ7QUFHRXBILGNBQVUsTUFIWjtBQUlFeVcsY0FBVSxzQ0FKWjtBQUtFSCxpQkFBYTtBQUNYcWUsa0JBQVksSUFERDtBQUVYQyxnQkFBVSxJQUZDO0FBR1hDLGlCQUFXLENBQUM7QUFIRDtBQUxmLEdBRFU7QUFGZCxDQWpEWSxFQWlFWjtBQUNFcmpDLGNBQVksV0FEZDtBQUVFQyxjQUFZLENBQ1Y7QUFDRWhQLGdCQUFZLDJCQURkO0FBRUUya0IsZ0JBQVksTUFGZDtBQUdFcEgsY0FBVSxNQUhaO0FBSUV5VyxjQUFVLHNDQUpaO0FBS0V4a0IsYUFBUyxJQUxYO0FBTUVxa0IsaUJBQWE7QUFDWHFlLGtCQUFZLElBREQ7QUFFWEMsZ0JBQVUsSUFGQztBQUdYQyxpQkFBVyxDQUFDO0FBSEQ7QUFOZixHQURVO0FBRmQsQ0FqRVksRUFrRlo7QUFDRXJqQyxjQUFZLFNBRGQ7QUFFRUMsY0FBWSxDQUNWO0FBQ0VoUCxnQkFBWSw0QkFEZDtBQUVFMmtCLGdCQUFZLFFBRmQ7QUFHRXBILGNBQVUsTUFIWjtBQUlFeVcsY0FBVSx1Q0FKWjtBQUtFSCxpQkFBYTtBQUNYcWUsa0JBQVksSUFERDtBQUVYQyxnQkFBVSxJQUZDO0FBR1hDLGlCQUFXLENBQUM7QUFIRDtBQUxmLEdBRFU7QUFGZCxDQWxGWSxFQWtHWjtBQUNFcmpDLGNBQVksT0FEZDtBQUVFQyxjQUFZLENBQ1Y7QUFDRWhQLGdCQUFZLDRCQURkO0FBRUUya0IsZ0JBQVksR0FGZDtBQUdFcEgsY0FBVSxNQUhaO0FBSUV5VyxjQUFVLHVDQUpaO0FBS0VILGlCQUFhO0FBQ1hxZSxrQkFBWSxJQUREO0FBRVhDLGdCQUFVLElBRkM7QUFHWEMsaUJBQVcsQ0FBQztBQUhEO0FBTGYsR0FEVTtBQUZkLENBbEdZLEVBa0haO0FBQ0VyakMsY0FBWSxPQURkO0FBRUVDLGNBQVksQ0FDVjtBQUNFaFAsZ0JBQVkseUJBRGQ7QUFFRTJrQixnQkFBWSxRQUZkO0FBR0VwSCxjQUFVLE1BSFo7QUFJRXlXLGNBQVUsb0NBSlo7QUFLRUgsaUJBQWE7QUFDWHFlLGtCQUFZLElBREQ7QUFFWEMsZ0JBQVUsSUFGQztBQUdYQyxpQkFBVyxDQUFDO0FBSEQ7QUFMZixHQURVO0FBRmQsQ0FsSFksRUFrSVo7QUFDRXJqQyxjQUFZLFNBRGQ7QUFFRUMsY0FBWSxDQUNWO0FBQ0VoUCxnQkFBWSxvQkFEZDtBQUVFMmtCLGdCQUFZLFFBRmQ7QUFHRXBILGNBQVUsTUFIWjtBQUlFeVcsY0FBVSwrQkFKWjtBQUtFSCxpQkFBYTtBQUNYcWUsa0JBQVksSUFERDtBQUVYQyxnQkFBVSxJQUZDO0FBR1hDLGlCQUFXLENBQUM7QUFIRDtBQUxmLEdBRFU7QUFGZCxDQWxJWSxFQWtKWjtBQUNFcmpDLGNBQVksTUFEZDtBQUVFQyxjQUFZLENBQ1Y7QUFDRWhQLGdCQUFZLHdCQURkO0FBRUUya0IsZ0JBQVksUUFGZDtBQUdFcEgsY0FBVSxNQUhaO0FBSUV5VyxjQUFVLG1DQUpaO0FBS0VILGlCQUFhO0FBQ1hxZSxrQkFBWSxJQUREO0FBRVhDLGdCQUFVLElBRkM7QUFHWEMsaUJBQVcsQ0FBQztBQUhEO0FBTGYsR0FEVTtBQUZkLENBbEpZLEVBa0taO0FBQ0VyakMsY0FBWSxTQURkO0FBRUVDLGNBQVksQ0FDVjtBQUNFaFAsZ0JBQVksK0JBRGQ7QUFFRTJrQixnQkFBWSxHQUZkO0FBR0VwSCxjQUFVLE1BSFo7QUFJRXlXLGNBQVUsMENBSlo7QUFLRUgsaUJBQWE7QUFDWHFlLGtCQUFZLElBREQ7QUFFWEMsZ0JBQVUsSUFGQztBQUdYQyxpQkFBVyxDQUFDO0FBSEQ7QUFMZixHQURVLEVBWVY7QUFDRXB5QyxnQkFBWSw4QkFEZDtBQUVFMmtCLGdCQUFZLE1BRmQ7QUFHRXBILGNBQVUsTUFIWjtBQUlFeVcsY0FBVSx5Q0FKWjtBQUtFSCxpQkFBYTtBQUNYcWUsa0JBQVksSUFERDtBQUVYQyxnQkFBVSxJQUZDO0FBR1hDLGlCQUFXLENBQUM7QUFIRDtBQUxmLEdBWlU7QUFGZCxDQWxLWSxFQTZMWjtBQUNFcmpDLGNBQVksUUFEZDtBQUVFQyxjQUFZLENBQ1Y7QUFDRWhQLGdCQUFZLHFDQURkO0FBRUUya0IsZ0JBQVksR0FGZDtBQUdFdU8sZUFBVyxRQUhiO0FBSUUzVixjQUFVLE1BSlo7QUFLRXlXLGNBQVUsK0NBTFo7QUFNRUgsaUJBQWE7QUFDWHFlLGtCQUFZLElBREQ7QUFFWEMsZ0JBQVUsSUFGQztBQUdYQyxpQkFBVyxDQUFDO0FBSEQ7QUFOZixHQURVLEVBYVY7QUFDRXB5QyxnQkFBWSxxQ0FEZDtBQUVFMmtCLGdCQUFZLEdBRmQ7QUFHRXVPLGVBQVcsUUFIYjtBQUlFM1YsY0FBVSxNQUpaO0FBS0V5VyxjQUFVLCtDQUxaO0FBTUVILGlCQUFhO0FBQ1hxZSxrQkFBWSxJQUREO0FBRVhDLGdCQUFVLElBRkM7QUFHWEMsaUJBQVcsQ0FBQztBQUhEO0FBTmYsR0FiVTtBQUZkLENBN0xZLEVBME5aO0FBQ0VyakMsY0FBWSxZQURkO0FBRUVDLGNBQVksQ0FDVjtBQUNFaFAsZ0JBQVksdUJBRGQ7QUFFRTJrQixnQkFBWSxRQUZkO0FBR0VwSCxjQUFVLE1BSFo7QUFJRXlXLGNBQVUsa0NBSlo7QUFLRUgsaUJBQWE7QUFDWHFlLGtCQUFZLElBREQ7QUFFWEMsZ0JBQVUsSUFGQztBQUdYQyxpQkFBVyxDQUFDO0FBSEQ7QUFMZixHQURVO0FBRmQsQ0ExTlksRUEwT1o7QUFDRXJqQyxjQUFZLFdBRGQ7QUFFRUMsY0FBWSxDQUNWO0FBQ0VoUCxnQkFBWSx1QkFEZDtBQUVFMmtCLGdCQUFZLFFBRmQ7QUFHRXBILGNBQVUsTUFIWjtBQUlFeVcsY0FBVSxrQ0FKWjtBQUtFSCxpQkFBYTtBQUNYcWUsa0JBQVksSUFERDtBQUVYQyxnQkFBVSxJQUZDO0FBR1hDLGlCQUFXLENBQUM7QUFIRDtBQUxmLEdBRFU7QUFGZCxDQTFPWSxDQUFkLEMsQ0FqQkE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7a0JBNFFlO0FBQ2IzdEMsVUFBUTtBQUNONHRDLFlBQVEsUUFERjtBQUVOM2hCLFlBQVEsUUFGRjtBQUdOMFAsa0JBQWMsY0FIUjtBQUlOa1MsV0FBTyxPQUpEO0FBS041dEMsZUFBVyxXQUxMO0FBTU42dEMsdUJBQW1CLG1CQU5iO0FBT04xbkMsdUJBQW1CLG1CQVBiO0FBUU5FLHVCQUFtQixtQkFSYjtBQVNOeW5DLHVCQUFtQiwwQkFUYjtBQVVOQyxzQkFBa0IseUJBVlo7QUFXTkMsc0JBQWtCLHlCQVhaO0FBWU4xMkIsc0JBQWtCLGtCQVpaO0FBYU4yMkIscUJBQWlCLGdCQWJYO0FBY05DLHlCQUFxQixxQkFkZjtBQWVOQyxrQkFBYyxjQWZSO0FBZ0JOQyxtQkFBZSxlQWhCVDtBQWlCTkMsdUJBQW1CLG1CQWpCYjtBQWtCTkMsNkJBQXlCO0FBbEJuQixHQURLO0FBcUJiM3RDLFlBQVU7QUFDUjR0QyxzQkFBa0IsQ0FDaEIsQ0FDRTtBQUNFanpDLGtCQUFZLCtCQURkO0FBRUU4RyxtQkFBYSxRQUZmO0FBR0Vvc0MsYUFBTyxHQUhUO0FBSUVDLGdCQUFVO0FBSlosS0FERixFQU9FO0FBQ0VuekMsa0JBQVksK0JBRGQ7QUFFRThHLG1CQUFhLFFBRmY7QUFHRW9zQyxhQUFPO0FBSFQsS0FQRixFQVlFO0FBQ0VsekMsa0JBQVksNEJBRGQ7QUFFRThHLG1CQUFhLEtBRmY7QUFHRW9zQyxhQUFPO0FBSFQsS0FaRixFQWlCRTtBQUNFbHpDLGtCQUFZLDZCQURkO0FBRUU4RyxtQkFBYSxNQUZmO0FBR0Vvc0MsYUFBTztBQUhULEtBakJGLENBRGdCLEVBdUJiLENBQ0Q7QUFDRWx6QyxrQkFBWSxrQ0FEZDtBQUVFOEcsbUJBQWEsWUFGZjtBQUdFb3NDLGFBQU8sSUFBSTtBQUhiLEtBREMsRUFNRDtBQUNFbHpDLGtCQUFZLDZCQURkO0FBRUU4RyxtQkFBYSxPQUZmO0FBR0U0WCxrQkFBWSxJQUFJaG9CLHlCQUFlRyxJQUFmLENBQW9CVyxPQUF4QixDQUFnQyxJQUFoQyxFQUFzQyxHQUF0QztBQUhkLEtBTkMsRUFXRDtBQUNFd0ksa0JBQVksK0JBRGQ7QUFFRThHLG1CQUFhLFNBRmY7QUFHRTRYLGtCQUFZLElBQUlob0IseUJBQWVHLElBQWYsQ0FBb0JXLE9BQXhCLENBQWdDLEdBQWhDLEVBQXFDLEdBQXJDO0FBSGQsS0FYQyxFQWdCRDtBQUNFd0ksa0JBQVksZ0NBRGQ7QUFFRThHLG1CQUFhLFVBRmY7QUFHRTRYLGtCQUFZLElBQUlob0IseUJBQWVHLElBQWYsQ0FBb0JXLE9BQXhCLENBQWdDLEdBQWhDLEVBQXFDLEdBQXJDO0FBSGQsS0FoQkMsQ0F2QmEsQ0FEVjtBQStDUjQ3QyxhQUFTLENBQ1AxOEMseUJBQWUyVCxVQUFmLENBQTBCQyxlQUExQixDQUEwQ0csV0FBMUMsQ0FBc0Q0b0MsT0FBdEQsQ0FBOERDLFdBRHZELENBL0NEO0FBa0RSMWtDLFdBQU9IO0FBbERDO0FBckJHLEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOVBmOzs7Ozs7Ozs7OytlQWZBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBZVEzWCxZLEdBQTZCSix3QixDQUE3QkksWTtJQUFjSyxLLEdBQWVULHdCLENBQWZTLEs7SUFBT3FCLEcsR0FBUTlCLHdCLENBQVI4QixHOztJQUVSSixXOzs7QUFDbkIseUJBQXlCO0FBQUEsUUFBWm9DLEtBQVksdUVBQUosRUFBSTs7QUFBQTs7QUFBQTs7QUFFdkIsVUFBSys0QyxNQUFMLEdBQWMvNEMsS0FBZDtBQUZ1QjtBQUd4Qjs7QUFFRDs7Ozs7Ozs7OzBCQUttQztBQUFBLFVBQTlCZ3FDLFFBQThCLHVFQUFuQixFQUFtQjtBQUFBLFVBQWY1cEMsTUFBZSx1RUFBTixJQUFNOztBQUNqQyxVQUFJLFFBQU80cEMsUUFBUCx5Q0FBT0EsUUFBUCxPQUFvQixRQUF4QixFQUFrQztBQUNoQ2hzQyxZQUFJa1gsSUFBSixDQUFTLHNEQUFUO0FBQ0Q7O0FBRUQsVUFBTTYwQixXQUFXcHRDLE1BQU0wakMsTUFBTixDQUFhLEVBQWIsRUFBaUIsS0FBSzBZLE1BQXRCLENBQWpCO0FBQ0EsV0FBS0EsTUFBTCxHQUFjcDhDLE1BQU0wakMsTUFBTixDQUFhLEtBQUswWSxNQUFsQixFQUEwQi9PLFFBQTFCLENBQWQ7O0FBRUEsVUFBSTVwQyxNQUFKLEVBQVk7QUFDVixhQUFLZ3FDLGVBQUwsQ0FBcUJMLFFBQXJCLEVBQStCLEtBQUtnUCxNQUFwQztBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7d0JBSUs1TyxJLEVBQU07QUFDVCxhQUFPLEtBQUs0TyxNQUFMLENBQVk1TyxJQUFaLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7b0NBS2lCSixRLEVBQXlCO0FBQUEsVUFBZkMsUUFBZSx1RUFBSixFQUFJOztBQUN4QyxXQUFLdHJDLElBQUwsQ0FBVSxRQUFWLEVBQW9CcXJDLFFBQXBCLEVBQThCQyxRQUE5QjtBQUNEOztBQUVEOzs7Ozs7NEJBR1M7QUFDUCxXQUFLK08sTUFBTCxHQUFjLEVBQWQ7QUFDRDs7OztFQTlDc0N6OEMsWTs7a0JBQXBCc0IsVzs7Ozs7Ozs7Ozs7O0FDbEJyQjs7Ozs7Ozs7QUFRQTs7QUFFQSxJQUFNbUcsT0FBTyxPQUFPN0csTUFBUCxLQUFrQixXQUFsQixHQUFnQzJkLE1BQWhDLEdBQXlDM2QsTUFBdEQ7QUFDQSxJQUFJODdDLE1BQU1qMUMsS0FBS2pHLHFCQUFmO0FBQ0EsSUFBSW03QyxNQUFNbDFDLEtBQUtoRyxvQkFBZjs7QUFFQSxJQUFJbTdDLFdBQVcsQ0FBZjtBQUNBLElBQU1DLFVBQVUsQ0FBQyxJQUFELEVBQU8sS0FBUCxFQUFjLFFBQWQsRUFBd0IsR0FBeEIsQ0FBaEI7QUFDQSxLQUFLLElBQUl6M0MsSUFBSSxDQUFiLEVBQWdCQSxJQUFJeTNDLFFBQVEvc0MsTUFBWixJQUFzQixDQUFDNHNDLEdBQXZDLEVBQTRDLEVBQUV0M0MsQ0FBOUMsRUFBaUQ7QUFDL0MsVUEyQk81RCxxQkEzQlAsU0FBTWlHLEtBQUtvMUMsUUFBUXozQyxDQUFSLElBQWEsdUJBQWxCLENBQU47QUFDQSxVQTJCTzNELG9CQTNCUCxTQUFNZ0csS0FBS28xQyxRQUFRejNDLENBQVIsSUFBYSxzQkFBbEIsS0FBNkNxQyxLQUFLbzFDLFFBQVF6M0MsQ0FBUixJQUFhLDZCQUFsQixDQUFuRDtBQUNEOztBQUVEO0FBQ0EsSUFBSXMzQyxHQUFKLEVBQVM7QUFBRSxVQXNCRmw3QyxxQkF0QkUsU0FBTWs3QyxJQUFJNTdDLElBQUosQ0FBUzJHLElBQVQsQ0FBTjtBQUFzQjtBQUNqQyxJQUFJazFDLEdBQUosRUFBUztBQUFFLFVBc0JGbDdDLG9CQXRCRSxTQUFNazdDLElBQUk3N0MsSUFBSixDQUFTMkcsSUFBVCxDQUFOO0FBQXNCOztBQUVqQztBQUNBLElBQUksQ0FBQ2kxQyxHQUFMLEVBQVU7QUFDUixVQWlCT2w3QyxxQkFqQlAsU0FBTSxhQUFVMjJCLFFBQVYsRUFBb0JwdEIsT0FBcEIsRUFBNkI7QUFDakMsUUFBTSt4QyxXQUFXLElBQUlqWCxJQUFKLEdBQVdrWCxPQUFYLEVBQWpCO0FBQ0EsUUFBTUMsYUFBYWo5QyxLQUFLMEcsR0FBTCxDQUFTLENBQVQsRUFBWSxNQUFNcTJDLFdBQVdGLFFBQWpCLENBQVosQ0FBbkI7QUFDQSxRQUFNbnNDLEtBQUtnRixXQUFXLFlBQVk7QUFBRTBpQixlQUFTMmtCLFdBQVdFLFVBQXBCO0FBQWlDLEtBQTFELEVBQTREQSxVQUE1RCxDQUFYO0FBQ0FKLGVBQVdFLFdBQVdFLFVBQXRCO0FBQ0EsV0FBT3ZzQyxFQUFQO0FBQ0QsR0FORDtBQU9EOztBQUVEO0FBQ0EsSUFBSSxDQUFDa3NDLEdBQUwsRUFBVTtBQUNSLFVBT09sN0Msb0JBUFAsU0FBTSxhQUFVZ1AsRUFBVixFQUFjO0FBQ2xCMmdDLGlCQUFhM2dDLEVBQWI7QUFDRCxHQUZEO0FBR0Q7O1FBR1FqUCxxQixHQUFQazdDLEc7UUFDT2o3QyxvQixHQUFQazdDLEc7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3QkY7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7OytlQXhCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBd0JxQk0sWTs7O0FBQ25CLDBCQUFzQjtBQUFBOztBQUFBOztBQUFBLHNDQUFObjBDLElBQU07QUFBTkEsVUFBTTtBQUFBOztBQUFBLHVKQUNYQSxJQURXOztBQUFBLFVBb0x0Qm8wQyxnQkFwTHNCLEdBb0xILFVBQUNoa0MsSUFBRCxFQUFPbTNCLEVBQVAsRUFBYztBQUMvQixZQUFLOE0sZUFBTCxDQUF3QmprQyxJQUF4QixlQUF3Q20zQixFQUF4Qzs7QUFFQSxVQUFJbjNCLFNBQVMsUUFBVCxJQUFxQixDQUFDLE1BQUtrd0IsUUFBL0IsRUFBeUM7QUFDdkMsY0FBS0EsUUFBTCxHQUFnQixJQUFoQjtBQUNBLGNBQUt0aEMsS0FBTCxDQUFXNEYsUUFBWCxDQUFvQnRMLElBQXBCLENBQXlCZixtQkFBVXNNLE1BQVYsQ0FBaUIyN0IsWUFBMUM7QUFDRDtBQUNGLEtBM0xxQjs7QUFHcEIsVUFBSzhULFFBQUwsR0FBZ0I7QUFDZDlyQixlQUFTK3JCLGdDQURLO0FBRWRDLGNBQVFDLCtCQUZNO0FBR2R6cUIsaUJBQVcwcUIsa0NBSEc7QUFJZEMsY0FBUUMsK0JBSk07QUFLZHp6QyxjQUFRMHpDLCtCQUxNO0FBTWRDLGFBQU9DO0FBTk8sS0FBaEI7O0FBU0EsUUFBSUMsc0JBQUo7QUFDQSxRQUFJLE1BQUtoMkMsS0FBTCxDQUFXNEIsT0FBWCxDQUFtQndnQyxTQUF2QixFQUFrQztBQUNoQzRULHNCQUFnQixTQUFoQjtBQUNEOztBQUVELFVBQUtDLG1CQUFMLEdBQTJCLFFBQTNCO0FBQ0EsUUFBSSxNQUFLajJDLEtBQUwsQ0FBVzRCLE9BQVgsQ0FBbUJPLE1BQW5CLENBQTBCOFIsS0FBOUIsRUFBcUM7QUFDbkMsWUFBS2dpQyxtQkFBTCxHQUEyQixRQUEzQjtBQUNEOztBQUVELFFBQUksQ0FBQ0QsYUFBTCxFQUFvQjtBQUNsQkEsc0JBQWdCLE1BQUtDLG1CQUFyQjtBQUNEOztBQUVELFVBQUtaLGVBQUwsR0FBdUIsRUFBdkI7O0FBRUEsVUFBSy9ULFFBQUwsR0FBZ0IsS0FBaEI7O0FBRUEsVUFBSzRVLHFCQUFMLEdBQTZCLEVBQTdCO0FBQ0EsVUFBS3Q2QyxLQUFMLEdBQWE7QUFDWHU2QyxvQkFBYyxNQUFLYixRQUFMLENBQWNVLGFBQWQsQ0FESDtBQUVYSSx3QkFBa0JKLGFBRlA7QUFHWEssbUNBQ0dMLGFBREgsRUFDbUIsTUFBS1YsUUFBTCxDQUFjVSxhQUFkLENBRG5CO0FBSFcsS0FBYjtBQS9Cb0I7QUFzQ3JCOztBQUVEOztBQUVBOzs7Ozs7Ozt3Q0FJcUI7QUFDbkIsYUFBTyxDQUFDLENBQUMsS0FBS0UscUJBQUwsQ0FBMkJsdUMsTUFBcEM7QUFDRDs7QUFFRDs7Ozs7Ozt3Q0FJcUI7QUFDbkIsVUFBTTR1QixRQUFRLEtBQUtzZixxQkFBbkI7QUFDQSxhQUFPdGYsTUFBTUEsTUFBTTV1QixNQUFOLEdBQWUsQ0FBckIsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7O21DQUlnQm9KLEksRUFBTTtBQUFBOztBQUNwQixVQUFJa2xDLFNBQVMsSUFBYjtBQUNBLFVBQUlsbEMsU0FBUyxNQUFiLEVBQXFCO0FBQ25Ca2xDLGlCQUFTLEtBQUtKLHFCQUFMLENBQTJCdjFCLEdBQTNCLEVBQVQ7QUFDQSxZQUFJLENBQUMyMUIsTUFBTCxFQUFhO0FBQ1gsZ0JBQU0sSUFBSTl5QyxLQUFKLENBQVUsaUVBQVYsQ0FBTjtBQUNEO0FBQ0YsT0FMRCxNQUtPO0FBQ0wsWUFBSTROLFNBQVMsY0FBYixFQUE2QkEsT0FBTyxLQUFLNmtDLG1CQUFaOztBQUU3QkssaUJBQVMsS0FBS2hCLFFBQUwsQ0FBY2xrQyxJQUFkLENBQVQ7QUFDQSxZQUFJLENBQUNrbEMsTUFBTCxFQUFhO0FBQ1gsZ0JBQU0sSUFBSTl5QyxLQUFKLHNCQUE4QjROLElBQTlCLE9BQU47QUFDRDs7QUFFRCxhQUFLOGtDLHFCQUFMLENBQTJCcjdDLElBQTNCLENBQWdDLEtBQUtlLEtBQUwsQ0FBV3U2QyxZQUEzQztBQUNEOztBQUVELFVBQUksQ0FBQyxLQUFLdjZDLEtBQUwsQ0FBV3k2QyxPQUFYLENBQW1CamxDLElBQW5CLENBQUwsRUFBK0I7QUFDN0IsYUFBS3hWLEtBQUwsQ0FBV3k2QyxPQUFYLENBQW1CamxDLElBQW5CLElBQTJCa2xDLE1BQTNCO0FBQ0Q7O0FBRUQ7QUFDQSxVQUFJLEtBQUsxNkMsS0FBTCxDQUFXdzZDLGdCQUFYLEtBQWdDLFFBQXBDLEVBQThDO0FBQzVDLGVBQU8sS0FBS3g2QyxLQUFMLENBQVd5NkMsT0FBWCxDQUFtQixLQUFLejZDLEtBQUwsQ0FBV3c2QyxnQkFBOUIsQ0FBUDtBQUNEOztBQUVELGFBQU8sSUFBSS85QyxnQkFBSixDQUFZLFVBQUM2ZSxPQUFELEVBQWE7QUFDOUIsZUFBS2hhLFFBQUwsQ0FBYyxFQUFFaTVDLGNBQWNHLE1BQWhCLEVBQXdCRixrQkFBa0JobEMsSUFBMUMsRUFBZCxFQUFnRSxZQUFNO0FBQ3BFOEY7QUFDRCxTQUZEO0FBR0QsT0FKTSxDQUFQO0FBS0Q7O0FBRUQ7Ozs7Ozs7OzZCQUtVakQsSyxFQUFPa2EsVyxFQUFhO0FBQUE7O0FBQUEsVUFDcEJ2c0IsT0FEb0IsR0FDUixLQUFLNUIsS0FERyxDQUNwQjRCLE9BRG9COztBQUU1QkEsY0FBUU8sTUFBUixDQUFlOFIsS0FBZixHQUF1QkEsS0FBdkI7O0FBRUEsVUFBTXNpQyxvQkFBb0IsQ0FBQyxLQUFLbEIsZUFBTCxDQUFxQmhQLFlBQWhEO0FBQ0EsV0FBS21RLGNBQUwsQ0FBb0IsUUFBcEIsRUFDR3J2QyxJQURILENBQ1EsWUFBTTtBQUNWLFlBQUksQ0FBQ292QyxpQkFBTCxFQUF3QjtBQUN0QixpQkFBS2xCLGVBQUwsQ0FBcUJoUCxZQUFyQixDQUFrQzlVLFFBQWxDLENBQTJDdGQsS0FBM0MsRUFBa0RrYSxXQUFsRDtBQUNEO0FBQ0YsT0FMSDtBQU1EOztBQUVEOzs7Ozs7Ozs4QkFLaUI7QUFDZixVQUFJLEtBQUt2eUIsS0FBTCxDQUFXdTZDLFlBQVgsS0FBNEIsS0FBS2IsUUFBTCxDQUFjbnpDLE1BQTlDLEVBQXNEO0FBQ3BELGVBQU85SixpQkFBUThlLE1BQVIsQ0FBZSxJQUFJM1QsS0FBSixDQUFVLDJEQUFWLENBQWYsQ0FBUDtBQUNEOztBQUVELFVBQUksS0FBSzVILEtBQUwsQ0FBV3k2QyxPQUFYLENBQW1CbDBDLE1BQXZCLEVBQStCO0FBQUE7O0FBQzdCLGVBQU8sOEJBQUtrekMsZUFBTCxDQUFxQmhQLFlBQXJCLEVBQWtDM1UsTUFBbEMsd0NBQVA7QUFDRDtBQUNGOztBQUVEOzs7Ozs7O2dDQUlhO0FBQ1gsVUFBSSxLQUFLOTFCLEtBQUwsQ0FBV3U2QyxZQUFYLEtBQTRCLEtBQUtiLFFBQUwsQ0FBY256QyxNQUE5QyxFQUFzRDtBQUNwRCxlQUFPOUosaUJBQVE4ZSxNQUFSLENBQWUsSUFBSTNULEtBQUosQ0FBVSwrREFBVixDQUFmLENBQVA7QUFDRDs7QUFFRCxVQUFJLEtBQUs1SCxLQUFMLENBQVd5NkMsT0FBWCxDQUFtQmwwQyxNQUF2QixFQUErQjtBQUM3QixlQUFPLEtBQUtrekMsZUFBTCxDQUFxQmhQLFlBQXJCLENBQWtDclEsU0FBbEMsRUFBUDtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Z0NBSW9CO0FBQUE7O0FBQ2xCLFVBQUksQ0FBQyxLQUFLcDZCLEtBQUwsQ0FBV3k2QyxPQUFYLENBQW1CbDBDLE1BQXhCLEVBQWdDO0FBQzlCLGVBQU85SixpQkFBUThlLE1BQVIsQ0FBZSxJQUFJM1QsS0FBSixDQUFVLDJCQUFWLENBQWYsQ0FBUDtBQUNEO0FBQ0QsYUFBTywrQkFBSzZ4QyxlQUFMLENBQXFCaFAsWUFBckIsRUFBa0NuVSxTQUFsQyx5Q0FBUDtBQUNEOztBQUVEOzs7Ozs7OztnQ0FLYTczQixJLEVBQU07QUFDakIsVUFBSSxDQUFDLEtBQUt1QixLQUFMLENBQVd5NkMsT0FBWCxDQUFtQmwwQyxNQUF4QixFQUFnQztBQUM5QixlQUFPOUosaUJBQVE4ZSxNQUFSLENBQWUsSUFBSTNULEtBQUosQ0FBVSwyQkFBVixDQUFmLENBQVA7QUFDRDtBQUNELGFBQU8sS0FBSzZ4QyxlQUFMLENBQXFCaFAsWUFBckIsQ0FBa0NsVSxXQUFsQyxDQUE4QzkzQixJQUE5QyxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7c0NBSW1CO0FBQ2pCLGFBQU87QUFDTDZMLFlBQUksS0FBS2xHLEtBQUwsQ0FBV2tHLEVBRFY7QUFFTHRFLGlCQUFTLEtBQUs1QixLQUFMLENBQVc0QixPQUZmO0FBR0xnRSxrQkFBVSxLQUFLNUYsS0FBTCxDQUFXNEYsUUFIaEI7QUFJTHZFLHFCQUFhLEtBQUtyQixLQUFMLENBQVdxQjtBQUpuQixPQUFQO0FBTUQ7Ozs7O0FBV0Q7Ozs7O3FDQUtrQjtBQUFBOztBQUNoQixVQUFJbzFDLGtCQUFrQixFQUF0Qjs7QUFEZ0IsaUNBR1BybEMsSUFITztBQUlkLFlBQU1rbEMsU0FBUyxPQUFLMTZDLEtBQUwsQ0FBV3k2QyxPQUFYLENBQW1CamxDLElBQW5CLENBQWY7QUFDQSxZQUFNM00sVUFBVSxPQUFLN0ksS0FBTCxDQUFXdTZDLFlBQVgsS0FBNEJHLE1BQTVDO0FBQ0FHLHdCQUFnQjU3QyxJQUFoQixDQUNFLGdDQUFDLE1BQUQsSUFBUSxLQUFLO0FBQUEsbUJBQU0sT0FBS3U2QyxnQkFBTCxDQUFzQmhrQyxJQUF0QixFQUE0Qm0zQixFQUE1QixDQUFOO0FBQUEsV0FBYixFQUFvRCxLQUFLLE1BQXpELEVBQStELFNBQVM5akMsT0FBeEUsR0FERjtBQU5jOztBQUdoQixXQUFLLElBQUkyTSxJQUFULElBQWlCLEtBQUt4VixLQUFMLENBQVd5NkMsT0FBNUIsRUFBcUM7QUFBQSxjQUE1QmpsQyxJQUE0QjtBQU1wQzs7QUFFRCxhQUFPcWxDLGVBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs2QkFJVTtBQUNSLGFBQU9uOUMsa0JBQVM2dUIsU0FBVCxDQUFtQjtBQUFBO0FBQUEsVUFBSyxLQUFJLFVBQVQ7QUFDeEIsd0NBQUMsaUNBQUQ7QUFDRSx3QkFBYzV0Qix1QkFBYXN3QixRQUQ3QixHQUR3QjtBQUl2QixhQUFLNnJCLGNBQUw7QUFKdUIsT0FBbkIsQ0FBUDtBQU1EOzs7O0VBNU51Q3g5QyxlQUFNa3NDLFM7O2tCQUEzQitQLFk7OztBQStOckJBLGFBQWF3QixpQkFBYixHQUFpQztBQUMvQnp3QyxNQUFJcE0sbUJBQVVzc0MsTUFBVixDQUFpQndRLFVBRFU7QUFFL0JoeEMsWUFBVTlMLG1CQUFVc3NDLE1BQVYsQ0FBaUJ3USxVQUZJO0FBRy9CaDFDLFdBQVM5SCxtQkFBVXNzQyxNQUFWLENBQWlCd1EsVUFISztBQUkvQnYxQyxlQUFhdkgsbUJBQVVzc0MsTUFBVixDQUFpQndRO0FBSkMsQ0FBakM7O0FBT0F6QixhQUFhdndDLFNBQWIsR0FBeUI7QUFDdkJzQixNQUFJcE0sbUJBQVVzc0MsTUFBVixDQUFpQndRLFVBREU7QUFFdkJoeEMsWUFBVTlMLG1CQUFVc3NDLE1BQVYsQ0FBaUJ3USxVQUZKO0FBR3ZCaDFDLFdBQVM5SCxtQkFBVXNzQyxNQUFWLENBQWlCd1EsVUFISDtBQUl2QnYxQyxlQUFhdkgsbUJBQVVzc0MsTUFBVixDQUFpQndRO0FBSlAsQ0FBekIsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqUEE7O0FBQ0E7Ozs7Ozs7Ozs7K2VBaEJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0lBZ0JxQnJCLHNCOzs7QUFDbkIsb0NBQXNCO0FBQUE7O0FBQUE7O0FBQUEsc0NBQU52MEMsSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEsMktBQ1hBLElBRFc7O0FBR3BCLFVBQUtwRixLQUFMLEdBQWEsRUFBRWpCLFVBQVUsQ0FBWixFQUFiOztBQUVBLFVBQUsrbUMsVUFBTCxHQUFrQixNQUFLcGdDLE9BQUwsQ0FBYTRFLEVBQWIsQ0FBZ0IyVixZQUFoQixFQUFsQjtBQUNBLFVBQUs2bEIsVUFBTCxDQUFnQjVtQyxFQUFoQixDQUFtQixVQUFuQixFQUErQixVQUFDSCxRQUFELEVBQWM7QUFDM0MsWUFBS2lCLEtBQUwsQ0FBV2pCLFFBQVgsR0FBc0JBLFFBQXRCO0FBQ0QsS0FGRDtBQUdBLFVBQUsrbUMsVUFBTCxDQUFnQjVtQyxFQUFoQixDQUFtQixNQUFuQixFQUEyQixZQUFNO0FBQy9CLFlBQUtrRixLQUFMLENBQVc2MkMsR0FBWCxDQUFlTCxjQUFmLENBQThCLGNBQTlCO0FBQ0QsS0FGRDtBQVRvQjtBQVlyQjs7QUFFRDs7Ozs7Ozt3Q0FHcUI7QUFBQTs7QUFDbkI7QUFEbUIsb0JBRVUxOUMsTUFGVjtBQUFBLFVBRVg2cEMsZ0JBRlcsV0FFWEEsZ0JBRlc7O0FBR25CLFdBQUttVSxPQUFMLEdBQWUsS0FBS3AzQyxJQUFMLENBQVV5VyxNQUF6QjtBQUNBLFdBQUsyZ0MsT0FBTCxDQUFhdDNDLEtBQWIsR0FBcUIsS0FBS3MzQyxPQUFMLENBQWFuNkMsV0FBYixHQUEyQmdtQyxnQkFBaEQ7QUFDQSxXQUFLbVUsT0FBTCxDQUFhMzNDLE1BQWIsR0FBc0IsS0FBSzIzQyxPQUFMLENBQWE5NUMsWUFBYixHQUE0QjJsQyxnQkFBbEQ7QUFDQSxXQUFLb1UsUUFBTCxHQUFnQixLQUFLRCxPQUFMLENBQWE3aEMsVUFBYixDQUF3QixJQUF4QixDQUFoQjs7QUFFQSxXQUFLK2hDLGVBQUwsR0FBdUIsSUFBSWwrQyxPQUFPb2IsS0FBWCxFQUF2QjtBQUNBLFdBQUs4aUMsZUFBTCxDQUFxQjM0QyxnQkFBckIsQ0FBc0MsTUFBdEMsRUFBOEMsWUFBTTtBQUNsRCxlQUFLcWpDLFVBQUwsQ0FBZ0J4NkIsSUFBaEI7QUFDQSw0Q0FBc0IsT0FBS2duQixLQUEzQjtBQUNELE9BSEQ7QUFJQSxXQUFLOG9CLGVBQUwsQ0FBcUI3OUIsV0FBckIsR0FBbUMsV0FBbkM7QUFDQSxXQUFLNjlCLGVBQUwsQ0FBcUIzaUMsR0FBckIsR0FBMkIsS0FBSy9TLE9BQUwsQ0FBYTRFLEVBQWIsQ0FBZ0I2VixZQUFoQixDQUE2QixlQUE3QixFQUE4QyxJQUE5QyxDQUEzQjs7QUFFQSxXQUFLK1IsUUFBTCxHQUFnQixJQUFoQjtBQUNBLFdBQUtJLEtBQUwsR0FBYSxLQUFLQSxLQUFMLENBQVdsMUIsSUFBWCxDQUFnQixJQUFoQixDQUFiO0FBQ0Q7O0FBRUQ7Ozs7OzsyQ0FHd0I7QUFDdEI7QUFDQSxXQUFLODBCLFFBQUwsR0FBZ0IsS0FBaEI7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7OzRCQUdTO0FBQ1AsV0FBS21wQix1QkFBTDtBQUNBLFVBQUksS0FBS25wQixRQUFULEVBQW1CO0FBQ2pCLDRDQUFzQixLQUFLSSxLQUEzQjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OENBSTJCO0FBQUEsb0JBQ0MsS0FBSzRvQixPQUROO0FBQUEsVUFDakJ0M0MsS0FEaUIsV0FDakJBLEtBRGlCO0FBQUEsVUFDVkwsTUFEVSxXQUNWQSxNQURVOztBQUV6QixVQUFNKzNDLE1BQU0sS0FBS0gsUUFBakI7QUFDQUcsVUFBSTdpQixTQUFKLENBQWMsQ0FBZCxFQUFpQixDQUFqQixFQUFvQjcwQixLQUFwQixFQUEyQkwsTUFBM0I7O0FBRUErM0MsVUFBSUMsSUFBSjtBQUNBRCxVQUFJRSxTQUFKO0FBQ0FGLFVBQUlHLE1BQUosQ0FBVzczQyxRQUFRLENBQW5CLEVBQXNCTCxTQUFTLENBQS9CO0FBQ0ErM0MsVUFBSUksR0FBSixDQUFROTNDLFFBQVEsQ0FBaEIsRUFBbUJMLFNBQVMsQ0FBNUIsRUFBK0JLLFFBQVEsQ0FBdkMsRUFBMEMsQ0FBQ3ZILEtBQUtpK0IsRUFBTixHQUFXLEdBQXJELEVBQTBEaitCLEtBQUtpK0IsRUFBTCxHQUFVLENBQVYsR0FBYyxLQUFLdDZCLEtBQUwsQ0FBV2pCLFFBQXpCLEdBQW9DMUMsS0FBS2krQixFQUFMLEdBQVUsR0FBeEcsRUFBNkcsS0FBN0c7QUFDQWdoQixVQUFJSyxNQUFKLENBQVcvM0MsUUFBUSxDQUFuQixFQUFzQkwsU0FBUyxDQUEvQjtBQUNBKzNDLFVBQUlNLElBQUo7QUFDQU4sVUFBSXpnQixTQUFKLENBQ0UsS0FBS3VnQixlQURQLEVBRUUsQ0FGRixFQUVLLENBRkwsRUFFUSxLQUFLQSxlQUFMLENBQXFCeDNDLEtBRjdCLEVBRW9DLEtBQUt3M0MsZUFBTCxDQUFxQjczQyxNQUZ6RCxFQUdFLENBSEYsRUFHSyxDQUhMLEVBR1FLLEtBSFIsRUFHZUwsTUFIZjtBQUtBKzNDLFVBQUlPLE9BQUo7O0FBRUFQLFVBQUlDLElBQUo7QUFDQUQsVUFBSVEsV0FBSixHQUFrQixJQUFsQjtBQUNBUixVQUFJemdCLFNBQUosQ0FDRSxLQUFLdWdCLGVBRFAsRUFFRSxDQUZGLEVBRUssQ0FGTCxFQUVRLEtBQUtBLGVBQUwsQ0FBcUJ4M0MsS0FGN0IsRUFFb0MsS0FBS3czQyxlQUFMLENBQXFCNzNDLE1BRnpELEVBR0UsQ0FIRixFQUdLLENBSEwsRUFHUUssS0FIUixFQUdlTCxNQUhmO0FBS0ErM0MsVUFBSU8sT0FBSjtBQUNEOztBQUVEOzs7Ozs7OztvQ0FLaUI7QUFDZixhQUFRO0FBQUE7QUFBQSxVQUFLLEtBQUksa0JBQVQ7QUFDTjtBQUFBO0FBQUEsWUFBSyxLQUFJLGFBQVQ7QUFDRSxzREFBUSxLQUFJLFVBQVosRUFBdUIsS0FBSSxRQUEzQjtBQURGO0FBRE0sT0FBUjtBQUtEOzs7O0VBckdpRG56Qyx5Qjs7a0JBQS9CaXhDLHNCOzs7QUF3R3JCQSx1QkFBdUJ6MEMsWUFBdkIsR0FBc0N6SCx1QkFBY3lILFlBQXBELEM7Ozs7Ozs7Ozs7Ozs7OztBQzNHQTs7Ozs7OytlQWZBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0lBZXFCNjJDLGU7OztBQUNuQiw2QkFBc0I7QUFBQTs7QUFBQTs7QUFBQSxzQ0FBTjMyQyxJQUFNO0FBQU5BLFVBQU07QUFBQTs7QUFBQSw2SkFDWEEsSUFEVzs7QUFHcEIsVUFBS3JGLFFBQUwsQ0FBYyxlQUFkO0FBSG9CO0FBSXJCOztBQUVEOzs7Ozs7OztvQ0FJaUI7QUFDZixXQUFLMkYsT0FBTCxDQUFhc0UsUUFBYixDQUFzQnRMLElBQXRCLENBQTJCZixtQkFBVXNNLE1BQVYsQ0FBaUI2dEMsS0FBNUM7QUFDRDs7QUFFRDs7Ozs7OztvQ0FJaUI7QUFDZixVQUFJa0Usb0JBQUo7QUFDQSxVQUFJLEtBQUt0MkMsT0FBTCxDQUFhTSxPQUFiLENBQXFCNGdDLGVBQXpCLEVBQTBDO0FBQ3hDb1Ysc0JBQWU7QUFBQTtBQUFBLFlBQUssS0FBSSxVQUFULEVBQW9CLFNBQVMsS0FBS0MsYUFBbEM7QUFDYixtREFBSyxLQUFJLFNBQVQsRUFBbUIsS0FBSyxLQUFLajlCLGFBQUwsQ0FBbUIsV0FBbkIsRUFBZ0MsSUFBaEMsQ0FBeEI7QUFEYSxTQUFmO0FBR0Q7O0FBRUQsYUFBUTtBQUFBO0FBQUEsVUFBSyxLQUFJLFdBQVQ7QUFDTjtBQUFBO0FBQUEsWUFBSyxLQUFJLFNBQVQ7QUFBb0IsZUFBS3RaLE9BQUwsQ0FBYU0sT0FBYixDQUFxQjFIO0FBQXpDLFNBRE07QUFFTDA5QztBQUZLLE9BQVI7QUFJRDs7OztFQS9CMEN2K0Msc0I7O2tCQUF4QnMrQyxlOzs7QUFrQ3JCQSxnQkFBZ0I3MkMsWUFBaEIsR0FBK0J6SCx1QkFBY3lILFlBQTdDLEM7Ozs7Ozs7Ozs7Ozs7OztBQ3BDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFuQkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7SUFtQnFCMjBDLHFCOzs7QUFDbkIsbUNBQWU7QUFBQTs7QUFBQTs7QUFHYixVQUFLOTVDLFFBQUwsQ0FDRSxnQkFERixFQUVFLG1CQUZGLEVBR0UsVUFIRjtBQUhhO0FBUWQ7O0FBRUQ7O0FBRUE7Ozs7Ozs7O3dDQUlxQjtBQUNuQixXQUFLcUUsS0FBTCxDQUFXNjJDLEdBQVgsQ0FBZUwsY0FBZixDQUE4QixXQUE5QjtBQUNEOztBQUVEOzs7Ozs7O3FDQUlrQjtBQUNoQixXQUFLeDJDLEtBQUwsQ0FBVzYyQyxHQUFYLENBQWVMLGNBQWYsQ0FBOEIsUUFBOUI7QUFDRDs7QUFFRDs7Ozs7Ozs7NkJBS1V2aUMsSyxFQUFPO0FBQ2YsV0FBS2pVLEtBQUwsQ0FBVzYyQyxHQUFYLENBQWV0bEIsUUFBZixDQUF3QnRkLEtBQXhCO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7O3lDQUtzQjtBQUNwQixhQUFPLENBQUMxYixlQUFNMEQsUUFBTixFQUFELElBQXFCLEtBQUtxRixPQUFMLENBQWFNLE9BQWIsQ0FBcUIyZ0MsWUFBckIsS0FBc0MsS0FBbEU7QUFDRDs7QUFFRDs7Ozs7Ozs7NENBS3lCO0FBQ3ZCLGFBQU8sQ0FBQyxDQUFDLEtBQUtqaEMsT0FBTCxDQUFhTSxPQUFiLENBQXFCb3BCLFNBQXJCLENBQStCck0sUUFBeEM7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7Ozs7b0NBS2lCO0FBQ2YsVUFBTW9OLFFBQVEsRUFBZDtBQUNBLFVBQUloUyxZQUFZLENBQWhCOztBQUVBLFVBQU0rOUIsa0JBQWtCLEtBQUt4MkMsT0FBTCxDQUFhTSxPQUFiLENBQXFCMGdDLFlBQTdDO0FBQ0EsVUFBSXdWLGVBQUosRUFBcUIvOUI7O0FBRXJCLFVBQU1nK0Isa0JBQWtCLEtBQUtDLGtCQUFMLEVBQXhCO0FBQ0EsVUFBSUQsZUFBSixFQUFxQmgrQjs7QUFFckIsVUFBTWsrQixxQkFBcUIsS0FBS0MscUJBQUwsRUFBM0I7QUFDQSxVQUFJRCxrQkFBSixFQUF3QmwrQjs7QUFFeEIsVUFBSSs5QixlQUFKLEVBQXFCO0FBQ25CL3JCLGNBQU1seEIsSUFBTixDQUFXLGdDQUFDLHlCQUFEO0FBQ1QsbUJBQVMsS0FBS3M5QyxRQURMO0FBRVQscUJBQVdwK0IsU0FGRixHQUFYO0FBR0Q7O0FBRUQsVUFBSWcrQixlQUFKLEVBQXFCO0FBQ25CaHNCLGNBQU1seEIsSUFBTixDQUFXLGdDQUFDLHlCQUFEO0FBQ1QsbUJBQVMsS0FBS3U5QyxjQURMO0FBRVQscUJBQVdyK0IsU0FGRixHQUFYO0FBR0Q7O0FBRUQsVUFBSWsrQixrQkFBSixFQUF3QjtBQUN0QmxzQixjQUFNbHhCLElBQU4sQ0FBVyxnQ0FBQyw0QkFBRDtBQUNULG1CQUFTLEtBQUt3OUMsaUJBREw7QUFFVCxxQkFBV3QrQixTQUZGLEdBQVg7QUFHRDs7QUFFRCxhQUFRO0FBQUE7QUFBQSxVQUFLLEtBQUksaUJBQVQ7QUFDTjtBQUFBO0FBQUEsWUFBSyxLQUFJLGFBQVQ7QUFDR2dTO0FBREg7QUFETSxPQUFSO0FBS0Q7Ozs7RUFyR2dEem5CLHlCOztrQkFBOUJteEMscUI7OztBQXdHckJBLHNCQUFzQjMwQyxZQUF0QixHQUFxQ3pILHVCQUFjeUgsWUFBbkQsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3R0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBcEJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFvQnFCdzNDLGU7OztBQUNuQiw2QkFBZTtBQUFBOztBQUFBOztBQUdiLFVBQUt4K0IsU0FBTCxHQUFpQixRQUFqQjs7QUFFQSxVQUFLbmUsUUFBTCxDQUNFLFVBREYsRUFFRSxjQUZGLEVBRWtCLGFBRmxCLEVBRWlDLGNBRmpDLEVBRWlELFNBRmpEOztBQUtBLFVBQUs0OEMsWUFBTCxHQUFvQixDQUFwQjtBQUNBLFVBQUszOEMsS0FBTCxHQUFhLEVBQUU0OEMsaUJBQWlCLEtBQW5CLEVBQWI7QUFYYTtBQVlkOztBQUVEOztBQUVBOzs7Ozs7Ozs7O2lDQU1jcjdDLEMsRUFBRztBQUNmQSxRQUFFeUYsY0FBRjs7QUFFQSxXQUFLMjFDLFlBQUw7QUFDQSxXQUFLcjdDLFFBQUwsQ0FBYyxFQUFFczdDLGlCQUFpQixJQUFuQixFQUFkO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztnQ0FNYXI3QyxDLEVBQUc7QUFDZEEsUUFBRXlGLGNBQUY7QUFDRDs7QUFFRDs7Ozs7Ozs7aUNBS2N6RixDLEVBQUc7QUFDZkEsUUFBRXlGLGNBQUY7O0FBRUEsV0FBSzIxQyxZQUFMO0FBQ0EsVUFBSSxLQUFLQSxZQUFMLEtBQXNCLENBQTFCLEVBQTZCO0FBQzNCLGFBQUtyN0MsUUFBTCxDQUFjLEVBQUVzN0MsaUJBQWlCLEtBQW5CLEVBQWQ7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs0QkFLU3I3QyxDLEVBQUc7QUFBQTs7QUFDVkEsUUFBRTBGLGVBQUY7QUFDQTFGLFFBQUV5RixjQUFGO0FBQ0F6RixVQUFJQSxFQUFFczdDLFdBQU47QUFDQXQ3QyxRQUFFdTdDLFdBQUYsR0FBZ0IsS0FBaEI7O0FBRUEsV0FBS3g3QyxRQUFMLENBQWMsRUFBRXM3QyxpQkFBaUIsS0FBbkIsRUFBZCxFQUEwQyxZQUFNO0FBQzlDLFlBQUksQ0FBQ3I3QyxFQUFFdzdDLFlBQVAsRUFBcUI7O0FBRXJCLFlBQUksQ0FBQ3g3QyxFQUFFdzdDLFlBQUYsQ0FBZUMsS0FBZixDQUFxQixDQUFyQixFQUF3QjMrQyxJQUF4QixDQUE2QmdZLEtBQTdCLENBQW1DLFdBQW5DLENBQUwsRUFBc0Q7QUFDcEQsaUJBQU8xWCx1QkFBYXN3QixRQUFiLENBQXNCTyxZQUF0QixDQUNMLE9BQUs3TSxFQUFMLENBQVEsMEJBQVIsQ0FESyxFQUVMLE9BQUtBLEVBQUwsQ0FBUSxtQ0FBUixFQUE2QyxFQUFFczZCLFVBQVUxN0MsRUFBRXc3QyxZQUFGLENBQWVDLEtBQWYsQ0FBcUIsQ0FBckIsRUFBd0IzK0MsSUFBcEMsRUFBN0MsQ0FGSyxDQUFQO0FBSUQ7O0FBRUQsZUFBSzYrQyxXQUFMLENBQWlCMzdDLEVBQUV3N0MsWUFBRixDQUFlQyxLQUFmLENBQXFCLENBQXJCLENBQWpCO0FBQ0QsT0FYRDtBQVlEOztBQUVEOzs7Ozs7Ozs2QkFLVXo3QyxDLEVBQUc7QUFDWCxXQUFLdUMsSUFBTCxDQUFVcTVDLE1BQVYsQ0FBaUJ0aEMsSUFBakI7QUFDRDs7QUFFRDs7Ozs7Ozs7Z0NBS2E4QyxJLEVBQU07QUFBQTs7QUFDakIsVUFBTXkrQixTQUFTLElBQUlsZ0QsT0FBT21nRCxVQUFYLEVBQWY7QUFDQUQsYUFBTzdrQyxNQUFQLEdBQWlCLFlBQU07QUFDckIsZUFBTyxVQUFDaFgsQ0FBRCxFQUFPO0FBQ1osY0FBTTlDLE9BQU84QyxFQUFFKzdDLE1BQUYsQ0FBUzl4QyxNQUF0QjtBQUNBLGNBQU02TSxRQUFRLElBQUluYixPQUFPb2IsS0FBWCxFQUFkOztBQUVBRCxnQkFBTTVWLGdCQUFOLENBQXVCLE1BQXZCLEVBQStCLFlBQU07QUFDbkMsbUJBQUs4NUMsUUFBTCxDQUFjbGtDLEtBQWQ7QUFDRCxXQUZEOztBQUlBQSxnQkFBTUksR0FBTixHQUFZaGEsSUFBWjtBQUNELFNBVEQ7QUFVRCxPQVhlLENBV2JrZ0IsSUFYYSxDQUFoQjtBQVlBeStCLGFBQU9HLGFBQVAsQ0FBcUI1K0IsSUFBckI7QUFDRDs7QUFFRDs7Ozs7Ozs7NkJBS1V0RyxLLEVBQU87QUFDZixXQUFLalUsS0FBTCxDQUFXbzVDLE9BQVgsSUFDRSxLQUFLcDVDLEtBQUwsQ0FBV281QyxPQUFYLENBQW1CbmxDLEtBQW5CLENBREY7QUFFRDs7QUFFRDs7QUFFQTs7Ozs7Ozs7cUNBS2tCO0FBQ2hCLFVBQU1vbEMsWUFBWTtBQUNoQkMscUJBQWEsS0FBS0MsWUFERjtBQUVoQkMsb0JBQVksS0FBS0MsV0FGRDtBQUdoQkMscUJBQWEsS0FBS0MsWUFIRjtBQUloQkMsZ0JBQVEsS0FBS0M7QUFKRyxPQUFsQjs7QUFPQSxVQUFJLEtBQUtqK0MsS0FBTCxDQUFXNDhDLGVBQWYsRUFBZ0M7QUFDOUJhLGtCQUFVaDdCLFNBQVYsR0FBc0IsWUFBdEI7QUFDRDs7QUFFRCxVQUFJeTdCLGlCQUFpQixlQUFyQjtBQUNBO0FBQ0EsVUFBSSxLQUFLeDRDLE9BQUwsQ0FBYU0sT0FBYixDQUFxQjJnQyxZQUFyQixLQUFzQyxLQUF0QyxJQUNBLEtBQUtqaEMsT0FBTCxDQUFhTSxPQUFiLENBQXFCb3BCLFNBQXJCLENBQStCck0sUUFBL0IsS0FBNEMsSUFEaEQsRUFDc0Q7QUFDcERtN0IsMEJBQWtCLGVBQWxCO0FBQ0Q7O0FBRUQsYUFDRTtBQUFBO0FBQUEsVUFBSyxLQUFJLGtCQUFUO0FBQ0U7QUFBQTtBQUFBLFlBQUssS0FBSSxjQUFUO0FBQ0U7QUFBQTtBQUFBLHVCQUFLLEtBQUtBLGNBQVYsRUFBMEIsU0FBUyxLQUFLMXdCLFFBQXhDLElBQXNEaXdCLFNBQXREO0FBQ0UsNENBQUMsa0NBQUQsSUFBMEIsS0FBSSxRQUE5QixFQUF1QyxXQUFXLEtBQUtsQixRQUF2RCxHQURGO0FBRUU7QUFBQyx1Q0FBRDtBQUFBLGdCQUFpQixLQUFJLFVBQXJCLEVBQWdDLGVBQWhDO0FBQ0csbUJBQUs1NUIsRUFBTCxDQUFRLDRCQUFSO0FBREgsYUFGRjtBQUtFO0FBQUE7QUFBQSxnQkFBSyxLQUFJLGVBQVQ7QUFDRyxtQkFBS0EsRUFBTCxDQUFRLDBCQUFSO0FBREg7QUFMRjtBQURGO0FBREYsT0FERjtBQWVEOzs7O0VBakswQzNFLHNCOztrQkFBeEIwK0IsZTs7O0FBb0tyQkEsZ0JBQWdCMXpDLFNBQWhCLEdBQTRCO0FBQzFCdzBDLFdBQVN0L0MsbUJBQVVtZ0IsSUFBVixDQUFlMjhCO0FBREUsQ0FBNUI7O0FBSUEwQixnQkFBZ0J4M0MsWUFBaEIsR0FBK0I4WSx1QkFBYTlZLFlBQTVDLEM7Ozs7Ozs7Ozs7Ozs7OztBQzlLQTs7Ozs7OytlQWhCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBZ0JxQmk1QyxlOzs7Ozs7Ozs7Ozs7QUFDbkI7Ozs7b0NBSWlCO0FBQ2YsVUFBSUMsZUFBZSxVQUFuQjtBQUNBLFVBQUksS0FBS2g2QyxLQUFMLENBQVdpNkMsU0FBZixFQUEwQjtBQUN4QkQsd0JBQWdCLGNBQWhCO0FBQ0Q7O0FBRUQsYUFDRTtBQUFBO0FBQUEsVUFBUSxLQUFLQSxZQUFiLEVBQTJCLFdBQVcsS0FBS2g2QyxLQUFMLENBQVdxZSxTQUFqRCxFQUE0RCxTQUFTLEtBQUtyZSxLQUFMLENBQVdrTyxPQUFoRjtBQUNHLGFBQUtsTyxLQUFMLENBQVdDO0FBRGQsT0FERjtBQUtEOzs7O0VBaEIwQzVHLHNCOztrQkFBeEIwZ0QsZTs7O0FBbUJyQkEsZ0JBQWdCbjFDLFNBQWhCLEdBQTRCO0FBQzFCc0osV0FBU3BVLG1CQUFVbWdCLElBRE87QUFFMUJoYSxZQUFVbkcsbUJBQVUrSyxHQUFWLENBQWMreEMsVUFGRTtBQUcxQnY0QixhQUFXdmtCLG1CQUFVb2dEO0FBSEssQ0FBNUI7O0FBTUFILGdCQUFnQmo1QyxZQUFoQixHQUErQnpILHVCQUFjeUgsWUFBN0MsQzs7Ozs7Ozs7Ozs7Ozs7O0FDNUJBOztBQUNBOzs7Ozs7Ozs7OytlQWhCQTtBQUNBOzs7Ozs7Ozs7Ozs7OztJQWlCcUJzWixVOzs7QUFDbkIsc0JBQWFzMEIsS0FBYixFQUFvQjtBQUFBOztBQUFBOztBQUVsQixVQUFLeUwsTUFBTCxHQUFjekwsS0FBZDtBQUNBLFVBQUswTCxhQUFMLEdBQXFCLE1BQUtBLGFBQUwsQ0FBbUJwaEQsSUFBbkIsT0FBckI7QUFDQSxVQUFLbWhELE1BQUwsQ0FBWTk3QyxnQkFBWixDQUE2QixRQUE3QixFQUF1QyxNQUFLKzdDLGFBQTVDO0FBSmtCO0FBS25COztBQUVEOzs7Ozs7OzJCQUdRO0FBQ04sV0FBS0QsTUFBTCxDQUFZdDJDLEtBQVosR0FBb0IsSUFBcEI7QUFDQSxXQUFLczJDLE1BQUwsQ0FBWUUsS0FBWjtBQUNEOztBQUVEOzs7Ozs7OztnQ0FLYTkvQixJLEVBQU07QUFBQTs7QUFDakIsVUFBTXkrQixTQUFTLElBQUlsZ0QsT0FBT21nRCxVQUFYLEVBQWY7QUFDQUQsYUFBTzdrQyxNQUFQLEdBQWlCLFlBQU07QUFDckIsZUFBTyxVQUFDaFgsQ0FBRCxFQUFPO0FBQ1osY0FBTTlDLE9BQU84QyxFQUFFKzdDLE1BQUYsQ0FBUzl4QyxNQUF0QjtBQUNBLGNBQU02TSxRQUFRLElBQUluYixPQUFPb2IsS0FBWCxFQUFkOztBQUVBRCxnQkFBTTVWLGdCQUFOLENBQXVCLE1BQXZCLEVBQStCLFlBQU07QUFDbkMsbUJBQUsvRCxJQUFMLENBQVUsTUFBVixFQUFrQjJaLEtBQWxCO0FBQ0QsV0FGRDs7QUFJQUEsZ0JBQU01VixnQkFBTixDQUF1QixPQUF2QixFQUFnQyxhQUFLO0FBQ25DLG1CQUFPOUQsdUJBQWFzd0IsUUFBYixDQUFzQk8sWUFBdEIsQ0FDTCxPQUFLN00sRUFBTCxDQUFRLGNBQVIsQ0FESyxFQUVMLE9BQUtBLEVBQUwsQ0FBUSwrQkFBUixDQUZLLENBQVA7QUFJRCxXQUxEOztBQU9BdEssZ0JBQU1JLEdBQU4sR0FBWWhhLElBQVo7QUFDRCxTQWhCRDtBQWlCRCxPQWxCZSxDQWtCYmtnQixJQWxCYSxDQUFoQjtBQW1CQXkrQixhQUFPRyxhQUFQLENBQXFCNStCLElBQXJCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7b0NBSWlCO0FBQUEsVUFDUHErQixLQURPLEdBQ0csS0FBS3VCLE1BRFIsQ0FDUHZCLEtBRE87O0FBRWYsVUFBSSxDQUFDQSxNQUFNNXdDLE1BQVgsRUFBbUI7O0FBRW5CLFdBQUs4d0MsV0FBTCxDQUFpQkYsTUFBTSxDQUFOLENBQWpCO0FBQ0Q7O0FBRUQ7Ozs7Ozs4QkFHVztBQUNULFdBQUt1QixNQUFMLENBQVkzN0MsbUJBQVosQ0FBZ0MsUUFBaEMsRUFBMEMsS0FBSzQ3QyxhQUEvQztBQUNEOzs7O0VBN0RxQ2xpRCxxQjs7a0JBQW5Ca2lCLFU7Ozs7Ozs7Ozs7Ozs7OztBQ0hyQjs7Ozs7OytlQWZBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBZ0JNcGdCLEs7OztBQUNKLGlCQUFhQyxJQUFiLEVBQW1CQyxLQUFuQixFQUEwQkMsSUFBMUIsRUFBOEU7QUFBQSxRQUE5Q0MsT0FBOEMsdUVBQXBDLEtBQW9DO0FBQUEsUUFBN0JrZ0QsbUJBQTZCLHVFQUFQLEtBQU87O0FBQUE7O0FBQUE7O0FBRTVFLFVBQUszeEMsRUFBTCxHQUFVclEsa0JBQVNpaUQsT0FBVCxFQUFWO0FBQ0EsVUFBS3RnRCxJQUFMLEdBQVlBLElBQVo7QUFDQSxVQUFLQyxLQUFMLEdBQWFBLEtBQWI7QUFDQSxVQUFLQyxJQUFMLEdBQVlBLElBQVo7QUFDQSxVQUFLQyxPQUFMLEdBQWVBLE9BQWY7QUFDQSxVQUFLa2dELG1CQUFMLEdBQTJCQSxtQkFBM0I7QUFDQSxVQUFLNzFDLE9BQUwsR0FBZSxJQUFmO0FBQ0EsVUFBS3BLLElBQUwsR0FBWSxJQUFaO0FBVDRFO0FBVTdFOztBQUVEOzs7Ozs7Ozs0QkFJU0EsSSxFQUFNO0FBQ2IsV0FBS0EsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsV0FBS0MsSUFBTCxDQUFVLFFBQVY7QUFDRDs7QUFFRDs7Ozs7OzRCQUdTO0FBQ1AsV0FBS21LLE9BQUwsR0FBZSxLQUFmO0FBQ0EsV0FBS25LLElBQUwsQ0FBVSxPQUFWO0FBQ0Q7O0FBRUQ7Ozs7Ozs2QkFHVTtBQUNSLFdBQUtBLElBQUwsQ0FBVSxRQUFWO0FBQ0Q7Ozs7RUFuQ2lCcEMscUI7O0lBc0NDcUMsWTs7O0FBQ25CLDBCQUFlO0FBQUE7O0FBQUE7O0FBR2IsV0FBS0MsT0FBTCxHQUFlLEVBQWY7QUFIYTtBQUlkOztBQUVEOzs7Ozs7Ozs7bUNBS2dCTixLLEVBQXVCO0FBQUEsVUFBaEJFLE9BQWdCLHVFQUFOLElBQU07O0FBQ3JDLFVBQU1LLFFBQVEsSUFBSVQsS0FBSixDQUFVLFNBQVYsRUFBcUJFLEtBQXJCLEVBQTRCLElBQTVCLEVBQWtDRSxPQUFsQyxDQUFkO0FBQ0EsV0FBS00sUUFBTCxDQUFjRCxLQUFkO0FBQ0EsYUFBT0EsS0FBUDtBQUNEOztBQUVEOzs7Ozs7OztvQ0FLaUJOLEksRUFBb0I7QUFBQSxVQUFkUSxRQUFjLHVFQUFILENBQUc7O0FBQ25DLFVBQU1GLFFBQVEsSUFBSVQsS0FBSixDQUFVLFVBQVYsRUFBc0IsSUFBdEIsRUFBNEJHLElBQTVCLENBQWQ7QUFDQU0sWUFBTUcsT0FBTixDQUFjLEVBQUVELGtCQUFGLEVBQWQ7QUFDQSxXQUFLRCxRQUFMLENBQWNELEtBQWQ7QUFDQSxhQUFPQSxLQUFQO0FBQ0Q7OztpQ0FFYVAsSyxFQUFrQztBQUFBLFVBQTNCQyxJQUEyQix1RUFBcEIsRUFBb0I7QUFBQSxVQUFoQkMsT0FBZ0IsdUVBQU4sSUFBTTs7QUFDOUMsVUFBTUssUUFBUSxJQUFJVCxLQUFKLENBQVUsT0FBVixFQUFtQkUsS0FBbkIsRUFBMEIsSUFBMUIsRUFBZ0NFLE9BQWhDLEVBQXlDLElBQXpDLENBQWQ7QUFDQUssWUFBTUcsT0FBTixDQUFjLEVBQUVULFVBQUYsRUFBZDtBQUNBLFdBQUtPLFFBQUwsQ0FBY0QsS0FBZDtBQUNBLGFBQU9BLEtBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7OzttQ0FPZ0JQLEssRUFBT0MsSSxFQUF3QztBQUFBLFVBQWxDcWdELE9BQWtDLHVFQUF4QixDQUFDLElBQUQsQ0FBd0I7QUFBQSxVQUFoQnBnRCxPQUFnQix1RUFBTixJQUFNOztBQUM3RCxVQUFNSyxRQUFRLElBQUlULEtBQUosQ0FBVSxTQUFWLEVBQXFCRSxLQUFyQixFQUE0QkMsSUFBNUIsRUFBa0NDLE9BQWxDLENBQWQ7QUFDQUssWUFBTUcsT0FBTixDQUFjLEVBQUU0L0MsZ0JBQUYsRUFBZDtBQUNBLFdBQUs5L0MsUUFBTCxDQUFjRCxLQUFkO0FBQ0EsYUFBT0EsS0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7O2lDQU9jUCxLLEVBQU9DLEksRUFBc0I7QUFBQSxVQUFoQkMsT0FBZ0IsdUVBQU4sSUFBTTs7QUFDekMsVUFBTUssUUFBUSxJQUFJVCxLQUFKLENBQVUsT0FBVixFQUFtQkUsS0FBbkIsRUFBMEJDLElBQTFCLEVBQWdDQyxPQUFoQyxDQUFkO0FBQ0EsV0FBS00sUUFBTCxDQUFjRCxLQUFkO0FBQ0EsYUFBT0EsS0FBUDtBQUNEOztBQUVEOzs7Ozs7OzZCQUlVQSxLLEVBQU87QUFBQTs7QUFDZixXQUFLRCxPQUFMLENBQWFLLElBQWIsQ0FBa0JKLEtBQWxCO0FBQ0FBLFlBQU1LLEVBQU4sQ0FBUyxPQUFULEVBQWtCLFlBQU07QUFDdEIsZUFBS1IsSUFBTCxDQUFVLFFBQVY7QUFDRCxPQUZEO0FBR0FHLFlBQU1LLEVBQU4sQ0FBUyxRQUFULEVBQW1CLFlBQU07QUFDdkIsZUFBS0MsV0FBTCxDQUFpQk4sS0FBakI7QUFDRCxPQUZEO0FBR0FBLFlBQU1LLEVBQU4sQ0FBUyxRQUFULEVBQW1CLFlBQU07QUFDdkIsZUFBS1IsSUFBTCxDQUFVLFFBQVY7QUFDRCxPQUZEO0FBR0EsV0FBS0EsSUFBTCxDQUFVLFFBQVY7QUFDRDs7QUFFRDs7Ozs7OztnQ0FJYUcsSyxFQUFPO0FBQ2xCLFVBQU1PLFFBQVEsS0FBS1IsT0FBTCxDQUFhUyxPQUFiLENBQXFCUixLQUFyQixDQUFkO0FBQ0EsV0FBS0QsT0FBTCxDQUFhVSxNQUFiLENBQW9CRixLQUFwQixFQUEyQixDQUEzQjtBQUNBLFdBQUtWLElBQUwsQ0FBVSxRQUFWO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Z0NBSWE7QUFDWCxhQUFPLEtBQUtFLE9BQVo7QUFDRDs7QUFFRDs7Ozs7Ozt3QkFJdUI7QUFDckIsVUFBSSxDQUFDLEtBQUtXLFNBQVYsRUFBcUI7QUFDbkIsYUFBS0EsU0FBTCxHQUFpQixJQUFJWixZQUFKLEVBQWpCO0FBQ0Q7QUFDRCxhQUFPLEtBQUtZLFNBQVo7QUFDRDs7OztFQTdHdUNqRCxxQjs7a0JBQXJCcUMsWTs7Ozs7Ozs7Ozs7Ozs7O0FDdkNyQjs7QUFDQTs7Ozs7Ozs7OzsrZUFqQkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztJQWlCcUJrZ0QsZTs7O0FBQ25CLDZCQUFzQjtBQUFBOztBQUFBOztBQUFBLHNDQUFOejVDLElBQU07QUFBTkEsVUFBTTtBQUFBOztBQUFBLDZKQUNYQSxJQURXOztBQUdwQixVQUFLdkYsZ0JBQUwsR0FBd0IsSUFBeEI7QUFDQSxVQUFLcWUsU0FBTCxHQUFpQixRQUFqQjtBQUpvQjtBQUtyQjs7QUFFRDs7Ozs7Ozs7O2dDQUthO0FBQ1gsVUFBSXZoQixlQUFNNFEsT0FBTixDQUFjNGdCLE9BQWQsQ0FBc0IsRUFBdEIsQ0FBSixFQUErQjtBQUFBLG9CQUNILEtBQUtycUIsSUFERjtBQUFBLFlBQ3JCc3FCLElBRHFCLFNBQ3JCQSxJQURxQjtBQUFBLFlBQ2Y1dkIsT0FEZSxTQUNmQSxPQURlOztBQUU3QixZQUFNOHZCLGFBQWFGLEtBQUtodEIsWUFBeEI7QUFDQTVDLGdCQUFROEUsS0FBUixDQUFjQyxNQUFkLEdBQTBCK3FCLFVBQTFCO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQTs7Ozs7Ozs7cUNBS2tCO0FBQ2hCLFVBQU1ockIsUUFBUTtBQUNac3BCLGtDQUF3QixLQUFLNU4sYUFBTCxDQUFtQixtQkFBbkIsRUFBd0MsSUFBeEMsRUFBOEMsSUFBOUMsQ0FBeEI7QUFEWSxPQUFkOztBQUlBLGFBQ0U7QUFBQTtBQUFBLFVBQUssS0FBSSxrQkFBVDtBQUNFO0FBQUE7QUFBQSxZQUFLLEtBQUksY0FBVDtBQUNFO0FBQUE7QUFBQSxjQUFLLEtBQUksZUFBVCxFQUF5QixTQUFTLEtBQUt3TyxRQUF2QyxFQUFpRCxPQUFPbHFCLEtBQXhELEVBQStELEtBQUksTUFBbkU7QUFDRSxxREFBSyxLQUFJLFdBQVQsRUFBcUIsS0FBSSxTQUF6QixHQURGO0FBRUU7QUFBQTtBQUFBLGdCQUFLLEtBQUksWUFBVDtBQUNHLG1CQUFLcWYsRUFBTCxDQUFRLDJCQUFSO0FBREgsYUFGRjtBQUtFO0FBQUE7QUFBQSxnQkFBSyxLQUFJLGVBQVQ7QUFDRyxtQkFBS0EsRUFBTCxDQUFRLDBCQUFSO0FBREg7QUFMRjtBQURGO0FBREYsT0FERjtBQWVEOzs7O0VBaEQwQzNFLHNCOztrQkFBeEI2Z0MsZTs7O0FBbURyQkEsZ0JBQWdCMzVDLFlBQWhCLEdBQStCOFksdUJBQWE5WSxZQUE1QyxDOzs7Ozs7Ozs7Ozs7Ozs7QUN0REE7O0FBQ0E7Ozs7Ozs7Ozs7K2VBakJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFpQnFCNDVDLGtCOzs7QUFDbkIsZ0NBQXNCO0FBQUE7O0FBQUE7O0FBQUEsc0NBQU4xNUMsSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEsbUtBQ1hBLElBRFc7O0FBR3BCLFVBQUt2RixnQkFBTCxHQUF3QixJQUF4QjtBQUNBLFVBQUtxZSxTQUFMLEdBQWlCLFdBQWpCO0FBSm9CO0FBS3JCOztBQUVEOzs7Ozs7Ozs7Z0NBS2E7QUFDWCxVQUFJdmhCLGVBQU00USxPQUFOLENBQWM0Z0IsT0FBZCxDQUFzQixFQUF0QixDQUFKLEVBQStCO0FBQUEsb0JBQ0gsS0FBS3JxQixJQURGO0FBQUEsWUFDckJzcUIsSUFEcUIsU0FDckJBLElBRHFCO0FBQUEsWUFDZjV2QixPQURlLFNBQ2ZBLE9BRGU7O0FBRTdCLFlBQU04dkIsYUFBYUYsS0FBS2h0QixZQUF4QjtBQUNBNUMsZ0JBQVE4RSxLQUFSLENBQWNDLE1BQWQsR0FBMEIrcUIsVUFBMUI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7OztxQ0FLa0I7QUFDaEIsVUFBTWhyQixRQUFRO0FBQ1pzcEIsa0NBQXdCLEtBQUs1TixhQUFMLENBQW1CLHVCQUFuQixFQUE0QyxJQUE1QyxFQUFrRCxJQUFsRCxDQUF4QjtBQURZLE9BQWQ7O0FBSUEsYUFDRTtBQUFBO0FBQUEsVUFBSyxLQUFJLGtCQUFUO0FBQ0U7QUFBQTtBQUFBLFlBQUssS0FBSSxjQUFUO0FBQ0U7QUFBQTtBQUFBLGNBQUssS0FBSSxlQUFULEVBQXlCLFNBQVMsS0FBS3dPLFFBQXZDLEVBQWlELE9BQU9scUIsS0FBeEQsRUFBK0QsS0FBSSxNQUFuRTtBQUNFLHFEQUFLLEtBQUksV0FBVCxFQUFxQixLQUFJLFNBQXpCLEdBREY7QUFFRTtBQUFBO0FBQUEsZ0JBQUssS0FBSSxZQUFUO0FBQ0csbUJBQUtxZixFQUFMLENBQVEsOEJBQVI7QUFESCxhQUZGO0FBS0U7QUFBQTtBQUFBLGdCQUFLLEtBQUksZUFBVDtBQUNHLG1CQUFLQSxFQUFMLENBQVEsNkJBQVI7QUFESDtBQUxGO0FBREY7QUFERixPQURGO0FBZUQ7Ozs7RUE5QzZDM0Usc0I7O2tCQUEzQjhnQyxrQjs7O0FBaURyQkEsbUJBQW1CNTVDLFlBQW5CLEdBQWtDOFksdUJBQWE5WSxZQUEvQyxDOzs7Ozs7Ozs7Ozs7Ozs7QUNwREE7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQXRCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBc0JxQjQwQyx3Qjs7O0FBQ25CLHNDQUFzQjtBQUFBOztBQUFBOztBQUFBLHNDQUFOMTBDLElBQU07QUFBTkEsVUFBTTtBQUFBOztBQUFBLCtLQUNYQSxJQURXOztBQUdwQixVQUFLcEYsS0FBTCxHQUFhO0FBQ1grK0MsZUFBUyxVQURFO0FBRVhDLHVCQUFpQjtBQUZOLEtBQWI7O0FBS0EsVUFBS2ovQyxRQUFMLENBQ0UsbUJBREYsRUFFRSw0QkFGRixFQUdFLGlCQUhGLEVBSUUsZUFKRixFQUtFLGdCQUxGLEVBTUUsZ0JBTkYsRUFPRSxXQVBGO0FBUm9CO0FBaUJyQjs7QUFFRDs7QUFFQTs7Ozs7Ozs7eUNBSXNCO0FBQ3BCLGFBQU8sQ0FBQyxDQUFDLEtBQUtDLEtBQUwsQ0FBV2cvQyxlQUFYLENBQTJCNXlDLE1BQXBDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztvQ0FNaUIyeUMsTyxFQUFzRDtBQUFBLFVBQTdDRSxpQkFBNkMsdUVBQXpCLElBQXlCO0FBQUEsVUFBbkJDLFVBQW1CLHVFQUFOLElBQU07O0FBQ3JFLFVBQUlILFlBQVksTUFBaEIsRUFBd0I7QUFDdEIsWUFBSSxDQUFDLEtBQUtJLGtCQUFMLEVBQUwsRUFBZ0M7QUFDOUIsY0FBSUYsaUJBQUosRUFBdUI7QUFDckIsbUJBQU8sS0FBSzc2QyxLQUFMLENBQVc2MkMsR0FBWCxDQUFlTCxjQUFmLENBQThCLE1BQTlCLENBQVA7QUFDRCxXQUZELE1BRU87QUFDTCxtQkFBTyxLQUFLd0UsZUFBTCxDQUFxQixVQUFyQixDQUFQO0FBQ0Q7QUFDRjtBQUNETCxrQkFBVSxLQUFLLytDLEtBQUwsQ0FBV2cvQyxlQUFYLENBQTJCajZCLEdBQTNCLEVBQVY7QUFDRCxPQVRELE1BU08sSUFBSSxLQUFLL2tCLEtBQUwsQ0FBVysrQyxPQUFYLEtBQXVCQSxPQUF2QixJQUFrQ0csVUFBdEMsRUFBa0Q7QUFDdkQsYUFBS2wvQyxLQUFMLENBQVdnL0MsZUFBWCxDQUEyQi8vQyxJQUEzQixDQUFnQyxLQUFLZSxLQUFMLENBQVcrK0MsT0FBM0M7QUFDRDs7QUFFRCxXQUFLejlDLFFBQUwsQ0FBYyxFQUFFeTlDLGdCQUFGLEVBQWQ7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7Ozs7O3NDQU1tQjd3QixPLEVBQWdDO0FBQUEsVUFBdkJteEIsYUFBdUIsdUVBQVAsS0FBTzs7QUFDakQsV0FBS3IvQyxLQUFMLENBQVdrdUIsT0FBWCxHQUFxQkEsT0FBckI7QUFDQSxXQUFLa3hCLGVBQUwsQ0FBcUIsU0FBckIsRUFBZ0MsSUFBaEMsRUFBc0MsQ0FBQ0MsYUFBdkM7QUFDRDs7QUFFRDs7Ozs7Ozs7K0NBSzRCL3hCLGdCLEVBQWtCO0FBQzVDLFdBQUt0dEIsS0FBTCxDQUFXcy9DLFdBQVgsR0FBeUJoeUIsaUJBQWlCclMsS0FBMUM7QUFDQSxXQUFLbWtDLGVBQUwsQ0FBcUIsUUFBckI7QUFDRDs7QUFFRDs7Ozs7Ozs7b0NBS2lCcHhCLEssRUFBTztBQUFBOztBQUN0QixVQUFNdXhCLGVBQWU1Z0QsdUJBQWFzd0IsUUFBYixDQUFzQnV3QixjQUF0QixDQUFxQyxLQUFLNzhCLEVBQUwsQ0FBUSwyQkFBUixDQUFyQyxDQUFyQjs7QUFFQSxVQUFNdEssUUFBUSxJQUFJbmIsT0FBT29iLEtBQVgsRUFBZDtBQUNBRCxZQUFNNVYsZ0JBQU4sQ0FBdUIsTUFBdkIsRUFBK0IsWUFBTTtBQUNuQzg4QyxxQkFBYWh3QixLQUFiO0FBQ0EsZUFBS25yQixLQUFMLENBQVc2MkMsR0FBWCxDQUFldGxCLFFBQWYsQ0FBd0J0ZCxLQUF4QixFQUErQixJQUEvQjtBQUNELE9BSEQ7QUFJQUEsWUFBTTVWLGdCQUFOLENBQXVCLE9BQXZCLEVBQWdDLFlBQU07QUFDcEM4OEMscUJBQWFod0IsS0FBYjtBQUNBNXdCLCtCQUFhc3dCLFFBQWIsQ0FBc0JPLFlBQXRCLENBQ0UsT0FBSzdNLEVBQUwsQ0FBUSxrQ0FBUixDQURGLEVBRUUsT0FBS0EsRUFBTCxDQUFRLGlDQUFSLEVBQTJDLEVBQUV5QixNQUFNL0wsTUFBTUksR0FBZCxFQUEzQyxDQUZGO0FBSUQsT0FORDtBQU9BSixZQUFNa0YsV0FBTixHQUFvQjdnQixrQkFBU280QixtQkFBVCxDQUE2QixLQUFLcHZCLE9BQUwsQ0FBYU0sT0FBYixDQUFxQnVYLFdBQWxELENBQXBCO0FBQ0FsRixZQUFNSSxHQUFOLEdBQVl1VixNQUFNK0IsSUFBTixDQUFXMHZCLEdBQXZCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7cUNBSWtCO0FBQ2hCLFdBQUtMLGVBQUwsQ0FBcUIsTUFBckI7QUFDRDs7QUFFRDs7Ozs7Ozs7OEJBS1dua0MsSyxFQUFPO0FBQ2hCLFVBQUksQ0FBQ0EsTUFBTXlrQyxJQUFOLEdBQWF0ekMsTUFBbEIsRUFBMEI7QUFDeEIsYUFBS3BNLEtBQUwsQ0FBV3MvQyxXQUFYLEdBQXlCLElBQXpCO0FBQ0EsZUFBTyxLQUFLRixlQUFMLENBQXFCLE1BQXJCLEVBQTZCLEtBQTdCLENBQVA7QUFDRDs7QUFFRCxXQUFLcC9DLEtBQUwsQ0FBV3MvQyxXQUFYLEdBQXlCcmtDLEtBQXpCO0FBQ0EsV0FBS21rQyxlQUFMLENBQXFCLFFBQXJCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O3FDQUtrQjtBQUNoQixXQUFLaDdDLEtBQUwsQ0FBVzYyQyxHQUFYLENBQWVMLGNBQWYsQ0FBOEIsUUFBOUI7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7OztrQ0FJZXZpQyxLLEVBQU87QUFDcEIsV0FBS2pVLEtBQUwsQ0FBVzYyQyxHQUFYLENBQWV0bEIsUUFBZixDQUF3QnRkLEtBQXhCO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7OzJDQUt3QjtBQUN0QixhQUFPLEtBQUtyWSxLQUFMLENBQVdnL0MsZUFBWCxDQUEyQjV5QyxNQUEzQixLQUFzQyxDQUF0QyxJQUNMLEtBQUtoSSxLQUFMLENBQVc2MkMsR0FBWCxDQUFlMEUsaUJBQWYsRUFERjtBQUVEOztBQUVEOztBQUVBOzs7Ozs7OztxQ0FLa0I7QUFDaEIsY0FBUSxLQUFLMy9DLEtBQUwsQ0FBVysrQyxPQUFuQjtBQUNFLGFBQUssUUFBTDtBQUNFLGlCQUFRLGdDQUFDLGdDQUFEO0FBQ04sbUJBQU8sS0FBSy8rQyxLQUFMLENBQVdzL0MsV0FEWjtBQUVOLDRCQUFnQixLQUFLendCLGVBRmY7QUFHTix1Q0FBMkIsS0FBSyt3QiwwQkFIMUIsR0FBUjtBQUlGLGFBQUssU0FBTDtBQUNFLGlCQUFRLGdDQUFDLDRCQUFEO0FBQ04seUJBQWFsakQsa0JBQVNvNEIsbUJBQVQsQ0FBNkIsS0FBS3B2QixPQUFMLENBQWFNLE9BQWIsQ0FBcUJ1WCxXQUFsRCxDQURQO0FBRU4scUJBQVMsS0FBS3ZkLEtBQUwsQ0FBV2t1QixPQUZkO0FBR04sNEJBQWdCLEtBQUtXLGVBSGYsR0FBUjtBQUlGLGFBQUssVUFBTDtBQUNFLGlCQUFRLGdDQUFDLDJCQUFEO0FBQ04sOEJBQWtCLEtBQUtneEIsaUJBRGpCO0FBRU4sdUNBQTJCLEtBQUtEO0FBRjFCLFlBQVI7QUFaSjtBQWlCRDs7QUFFRDs7Ozs7Ozs7b0NBS2lCO0FBQ2YsVUFBTUUsbUJBQW1CLEtBQUsxaEMsY0FBTCxFQUF6Qjs7QUFFQSxhQUFRO0FBQUE7QUFBQSxVQUFLLEtBQUksb0JBQVQ7QUFDTix3Q0FBQyx5QkFBRDtBQUNFLHlCQUFlLEtBQUsyaEMsY0FEdEI7QUFFRSxvQkFBVSxLQUFLQyxTQUZqQjtBQUdFLHVCQUFhLEtBQUtoZ0QsS0FBTCxDQUFXcy9DLFdBSDFCO0FBSUUsd0JBQWMsS0FBS1csYUFKckI7QUFLRSx5QkFBZSxLQUFLekQsY0FMdEI7QUFNRSxzQkFBWSxLQUFLMEQsb0JBQUwsRUFOZDtBQU9FLDJCQUFpQixLQUFLdjlCLEVBQUwsQ0FBUSwwQkFBUixDQVBuQjtBQVFFLGVBQUksZ0JBUk4sR0FETTtBQVVMbTlCO0FBVkssT0FBUjtBQVlEOzs7O0VBek1tRHAzQyx5Qjs7QUE0TXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrQkFsTnFCb3hDLHdCO0FBb05yQkEseUJBQXlCNTBDLFlBQXpCLEdBQXdDd0QsMEJBQWdCeEQsWUFBeEQsQzs7Ozs7Ozs7Ozs7Ozs7O0FDNU5BOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBckJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFxQnFCaTdDLHdCOzs7QUFDbkIsc0NBQXNCO0FBQUE7O0FBQUE7O0FBQUEsc0NBQU4vNkMsSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEsK0tBQ1hBLElBRFc7O0FBR3BCLFVBQUtyRixRQUFMLENBQ0Usd0JBREYsRUFFRSx3QkFGRixFQUdFLGdCQUhGLEVBSUUsc0JBSkYsRUFLRSxZQUxGOztBQVFBLFVBQUtxZ0Qsb0JBQUwsR0FBNEJ6akQsZUFBTXN3QyxRQUFOLENBQWUsTUFBS21ULG9CQUFwQixFQUEwQyxHQUExQyxDQUE1QjtBQVhvQjtBQVlyQjs7QUFFRDs7QUFFQTs7Ozs7Ozs7cUNBSWtCO0FBQ2hCLFdBQUtoOEMsS0FBTCxDQUFXaThDLGFBQVgsSUFDRSxLQUFLajhDLEtBQUwsQ0FBV2k4QyxhQUFYLEVBREY7QUFFRDs7QUFFRDs7Ozs7Ozs7eUNBS3NCcDRDLEssRUFBTztBQUMzQixXQUFLN0QsS0FBTCxDQUFXazhDLFFBQVgsSUFDRSxLQUFLbDhDLEtBQUwsQ0FBV2s4QyxRQUFYLENBQW9CcjRDLEtBQXBCLENBREY7QUFFRDs7QUFFRDs7Ozs7Ozs2Q0FJMEI7QUFDeEIsV0FBS25FLElBQUwsQ0FBVXE1QyxNQUFWLENBQWlCdGhDLElBQWpCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7NkNBSTBCO0FBQ3hCLFdBQUt6WCxLQUFMLENBQVdtOEMsYUFBWCxJQUNFLEtBQUtuOEMsS0FBTCxDQUFXbThDLGFBQVgsRUFERjtBQUVEOztBQUVEOzs7Ozs7OzsrQkFLWTVoQyxJLEVBQU07QUFDaEIsV0FBS3ZhLEtBQUwsQ0FBV284QyxZQUFYLElBQ0UsS0FBS3A4QyxLQUFMLENBQVdvOEMsWUFBWCxDQUF3QjdoQyxJQUF4QixDQURGO0FBRUQ7O0FBRUQ7O0FBRUE7Ozs7Ozs7O3lDQUtzQjtBQUNwQixhQUFPLENBQUNoaUIsZUFBTTBELFFBQU4sRUFBRCxJQUFxQixLQUFLcUYsT0FBTCxDQUFhTSxPQUFiLENBQXFCMmdDLFlBQXJCLEtBQXNDLEtBQWxFO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OzBDQUt1QjtBQUFBLFVBQ2IzZ0MsT0FEYSxHQUNELEtBQUtOLE9BREosQ0FDYk0sT0FEYTs7QUFFckIsVUFBSTQ0QyxVQUFVLEVBQWQ7O0FBRUEsVUFBSTU0QyxRQUFRMGdDLFlBQVosRUFBMEI7QUFDeEJrWSxnQkFBUTMvQyxJQUFSLENBQWEsZ0NBQUMsK0JBQUQ7QUFDWCxnQkFBTSxLQUFLK2YsYUFBTCxDQUFtQix1QkFBbkIsRUFBNEMsSUFBNUMsQ0FESztBQUVYLG1CQUFTLEtBQUt5aEM7QUFGSCxVQUFiO0FBSUQ7O0FBRUQsVUFBSSxLQUFLckUsa0JBQUwsRUFBSixFQUErQjtBQUM3QndDLGdCQUFRMy9DLElBQVIsQ0FBYSxnQ0FBQywrQkFBRDtBQUNYLGdCQUFNLEtBQUsrZixhQUFMLENBQW1CLHVCQUFuQixFQUE0QyxJQUE1QyxDQURLO0FBRVgsbUJBQVMsS0FBSzBoQztBQUZILFVBQWI7QUFJRDs7QUFFRCxhQUFPOUIsT0FBUDtBQUNEOztBQUVEOzs7Ozs7O29DQUlpQjtBQUNmLFVBQUkzNEMsbUJBQUo7QUFDQSxVQUFJLEtBQUs3QixLQUFMLENBQVc2QixVQUFmLEVBQTJCO0FBQ3pCQSxxQkFBYyxnQ0FBQyw2QkFBRDtBQUNaLGlCQUFPLEtBQUs3QixLQUFMLENBQVd1OEMsZUFETjtBQUVaLG1CQUFTLEtBQUtaLGNBRkYsR0FBZDtBQUdEO0FBQ0QsYUFBUTtBQUFBO0FBQUEsVUFBSyxLQUFJLGlCQUFUO0FBQ047QUFBQTtBQUFBLFlBQUssS0FBSSxRQUFUO0FBQ0U7QUFBQTtBQUFBLGNBQUssS0FBSSxTQUFUO0FBQ0U7QUFBQTtBQUFBLGdCQUFLLEtBQUksZUFBVDtBQUNHOTVDO0FBREgsYUFERjtBQUtFO0FBQUE7QUFBQSxnQkFBSyxLQUFJLG9CQUFUO0FBQ0UsOENBQUMsK0JBQUQ7QUFDRSw2QkFBYSxLQUFLN0IsS0FBTCxDQUFXazdDLFdBRDFCO0FBRUUsMEJBQVUsS0FBS2Msb0JBRmpCLEdBREY7QUFJRSw4Q0FBQyxrQ0FBRCxJQUEwQixXQUFXLEtBQUsxaEMsVUFBMUMsRUFBc0QsS0FBSSxRQUExRDtBQUpGLGFBTEY7QUFZRTtBQUFBO0FBQUEsZ0JBQUssS0FBSSxnQkFBVDtBQUNHLG1CQUFLa2lDLG1CQUFMO0FBREg7QUFaRjtBQURGO0FBRE0sT0FBUjtBQW9CRDs7OztFQW5JbUQveUMseUI7O2tCQUFqQ3N5Qyx3Qjs7O0FBc0lyQkEseUJBQXlCajdDLFlBQXpCLEdBQXdDMkksMEJBQWdCM0ksWUFBeEQsQzs7Ozs7Ozs7Ozs7Ozs7O0FDN0lBOzs7Ozs7K2VBaEJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFnQnFCMloscUI7Ozs7Ozs7Ozs7OztBQUNuQjs7OztvQ0FJaUI7QUFDZixhQUFRO0FBQUE7QUFBQSxVQUFLLFdBQVUsV0FBZjtBQUNOO0FBQUE7QUFBQSxZQUFLLEtBQUksZUFBVCxFQUF5QixTQUFTLEtBQUt6YSxLQUFMLENBQVdrTyxPQUE3QztBQUNFLG1EQUFLLEtBQUksUUFBVCxFQUFrQixLQUFLLEtBQUtsTyxLQUFMLENBQVcyYSxJQUFsQztBQURGO0FBRE0sT0FBUjtBQUtEOzs7O0VBWGdEdGhCLHNCOztrQkFBOUJvaEIscUI7OztBQWNyQkEsc0JBQXNCM1osWUFBdEIsR0FBcUN6SCx1QkFBY3lILFlBQW5ELEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEJBOzs7Ozs7K2VBaEJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFnQnFCMjdDLHFCOzs7QUFDbkIsbUNBQXNCO0FBQUE7O0FBQUE7O0FBQUEsc0NBQU56N0MsSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEseUtBQ1hBLElBRFc7O0FBR3BCLFVBQUtyRixRQUFMLENBQ0UsVUFERixFQUVFLFNBRkYsRUFHRSxXQUhGLEVBSUUsYUFKRjs7QUFPQSxVQUFLQyxLQUFMLEdBQWE7QUFDWDhnRCxjQUFRLEtBREc7QUFFWEMsbUJBQWEsTUFBS3ArQixFQUFMLENBQVEsa0NBQVIsQ0FGRjtBQUdYMWEsYUFBTyxNQUFLN0QsS0FBTCxDQUFXazdDLFdBQVgsSUFBMEI7QUFIdEIsS0FBYjtBQVZvQjtBQWVyQjs7QUFFRDs7QUFFQTs7Ozs7Ozs7OENBSTJCditCLFMsRUFBVztBQUNwQyxVQUFJQSxVQUFVdStCLFdBQVYsSUFBeUIsS0FBS3QvQyxLQUFMLENBQVdpSSxLQUF4QyxFQUErQztBQUM3QyxhQUFLakksS0FBTCxDQUFXOGdELE1BQVgsR0FBb0IsSUFBcEI7QUFDRCxPQUZELE1BRU87QUFDTCxhQUFLOWdELEtBQUwsQ0FBVzhnRCxNQUFYLEdBQW9CLEtBQXBCO0FBQ0Q7O0FBRUQsV0FBS3gvQyxRQUFMLENBQWM7QUFDWjJHLGVBQU84WSxVQUFVdStCLFdBQVYsSUFBeUI7QUFEcEIsT0FBZDtBQUdEOzs7eUNBRXFCO0FBQ3BCLFdBQUt4N0MsSUFBTCxDQUFVZ3ZDLEtBQVYsQ0FBZ0I3cUMsS0FBaEIsR0FBd0IsS0FBS2pJLEtBQUwsQ0FBV2lJLEtBQW5DO0FBQ0Q7O0FBRUQ7Ozs7Ozt3Q0FHcUI7QUFBQTs7QUFDbkI7QUFDQSxXQUFLKzRDLGlCQUFMLEdBQXlCeCtDLFNBQVNnWSxhQUFULENBQXVCLEtBQXZCLENBQXpCOztBQUVBLFVBQU1xeUIsY0FBY2x3QyxlQUFNK3ZDLGNBQU4sQ0FBcUIsS0FBSzVvQyxJQUFMLENBQVVndkMsS0FBL0IsQ0FBcEI7QUFDQSxVQUFNbU8sZUFBZSxDQUNuQixNQURtQixFQUVuQixZQUZtQixFQUduQixXQUhtQixFQUluQixZQUptQixFQUtuQixlQUxtQixFQU1uQixnQkFObUIsRUFPbkIsZUFQbUIsRUFRbkIsWUFSbUIsRUFTbkIsY0FUbUIsRUFVbkIsYUFWbUIsRUFXbkIsZUFYbUIsRUFZbkIsWUFabUIsQ0FBckI7QUFjQUEsbUJBQWFyMUMsT0FBYixDQUFxQixVQUFDc1AsR0FBRCxFQUFTO0FBQzVCLGVBQUs4bEMsaUJBQUwsQ0FBdUIxOUMsS0FBdkIsQ0FBNkI0WCxHQUE3QixJQUFvQzJ4QixZQUFZM3hCLEdBQVosQ0FBcEM7QUFDRCxPQUZEOztBQUlBLFdBQUs4bEMsaUJBQUwsQ0FBdUIxOUMsS0FBdkIsQ0FBNkJnTCxRQUE3QixHQUF3QyxVQUF4QztBQUNBLFdBQUsweUMsaUJBQUwsQ0FBdUIxOUMsS0FBdkIsQ0FBNkJqQixHQUE3QixHQUFtQyxTQUFuQztBQUNBLFdBQUsyK0MsaUJBQUwsQ0FBdUIxOUMsS0FBdkIsQ0FBNkJsQixJQUE3QixHQUFvQyxTQUFwQzs7QUFFQSxXQUFLMEIsSUFBTCxDQUFVQyxJQUFWLENBQWVpWixXQUFmLENBQTJCLEtBQUtna0MsaUJBQWhDOztBQUVBLFdBQUtFLGlCQUFMO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7d0NBSXFCO0FBQUE7O0FBQ25CLFdBQUtGLGlCQUFMLENBQXVCOVksU0FBdkIsR0FBbUMsS0FBS2xvQyxLQUFMLENBQVdpSSxLQUFYLElBQW9CLEtBQUtqSSxLQUFMLENBQVcrZ0QsV0FBbEU7QUFDQWh2QyxpQkFBVyxZQUFNO0FBQ2YsZUFBS3pRLFFBQUwsQ0FBYztBQUNaNi9DLHNCQUFZLE9BQUtILGlCQUFMLENBQXVCamdELFdBQXZCLEdBQXFDO0FBRHJDLFNBQWQ7QUFHRCxPQUpELEVBSUcsQ0FKSDtBQUtEOztBQUVEOztBQUVBOzs7Ozs7O2tDQUllO0FBQ2IsV0FBSytDLElBQUwsQ0FBVWd2QyxLQUFWLENBQWdCc08sS0FBaEI7QUFDRDs7QUFFRDs7Ozs7OzsrQkFJWTtBQUNWLFdBQUs5L0MsUUFBTCxDQUFjLEVBQUV3L0MsUUFBUSxJQUFWLEVBQWQ7QUFDRDs7QUFFRDs7Ozs7Ozs4QkFJVztBQUNULFVBQUksS0FBSzlnRCxLQUFMLENBQVdpSSxLQUFYLEtBQXFCLEVBQXJCLElBQTJCLENBQUMsS0FBSzdELEtBQUwsQ0FBV2s3QyxXQUEzQyxFQUF3RDtBQUN0RCxhQUFLaCtDLFFBQUwsQ0FBYyxFQUFFdy9DLFFBQVEsS0FBVixFQUFkO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7OEJBS1d2L0MsQyxFQUFHO0FBQ1osV0FBS3ZCLEtBQUwsQ0FBV2lJLEtBQVgsR0FBbUIxRyxFQUFFKzdDLE1BQUYsQ0FBU3IxQyxLQUE1QjtBQUNBLFdBQUs4QixXQUFMOztBQUVBLFdBQUszRixLQUFMLENBQVc4RCxRQUFYLElBQ0UsS0FBSzlELEtBQUwsQ0FBVzhELFFBQVgsQ0FBb0IsS0FBS2xJLEtBQUwsQ0FBV2lJLEtBQS9CLENBREY7QUFFRDs7QUFFRDs7QUFFQTs7Ozs7OztvQ0FJaUI7QUFDZixVQUFJbzVDLGVBQWUsY0FBbkI7QUFDQSxVQUFJMTZDLFdBQVcsNkJBQWY7QUFDQSxVQUFJLEtBQUszRyxLQUFMLENBQVc4Z0QsTUFBZixFQUF1QjtBQUNyQk8sd0JBQWdCLFdBQWhCO0FBQ0ExNkMsbUJBQVcsNEJBQVg7QUFDRDtBQUNEQSxpQkFBVyxLQUFLcVksYUFBTCxDQUFtQnJZLFFBQW5CLEVBQTZCLElBQTdCLENBQVg7O0FBRUEsVUFBTTI2QyxhQUFhO0FBQ2pCMTlDLGVBQU8sS0FBSzVELEtBQUwsQ0FBV21oRCxVQUFYLEdBQXdCO0FBRGQsT0FBbkI7O0FBSUEsYUFBUTtBQUFBO0FBQUEsVUFBSyxXQUFVLG9CQUFmO0FBQ047QUFBQTtBQUFBLFlBQUssS0FBS0UsWUFBVixFQUF3QixLQUFJLE1BQTVCLEVBQW1DLFNBQVMsS0FBS0UsV0FBakQ7QUFDRTtBQUFBO0FBQUEsY0FBSyxLQUFJLFdBQVQ7QUFDRTtBQUFBO0FBQUEsZ0JBQUssS0FBSSxTQUFUO0FBQ0UsdURBQUssS0FBSzU2QyxRQUFWLEVBQW9CLEtBQUksU0FBeEI7QUFERixhQURGO0FBSUU7QUFBQTtBQUFBLGdCQUFLLEtBQUksa0JBQVQ7QUFDRTtBQUNFLHFCQUFJLFNBRE47QUFFRSxxQkFBSSxPQUZOO0FBR0UsNkJBQWEsS0FBSzNHLEtBQUwsQ0FBVytnRCxXQUgxQjtBQUlFLHdCQUFRLEtBQUtTLE9BSmY7QUFLRSx5QkFBUyxLQUFLQyxRQUxoQjtBQU1FLDBCQUFVLEtBQUtDLFNBTmpCO0FBT0UsOEJBQWMsS0FBSzFoRCxLQUFMLENBQVdpSSxLQVAzQjtBQVFFLHVCQUFPcTVDLFVBUlQ7QUFERjtBQUpGO0FBREY7QUFETSxPQUFSO0FBb0JEOzs7O0VBMUtnRDdqRCxzQjs7a0JBQTlCb2pELHFCOzs7QUE2S3JCQSxzQkFBc0IzN0MsWUFBdEIsR0FBcUN6SCx1QkFBY3lILFlBQW5ELEM7Ozs7Ozs7Ozs7Ozs7OztBQy9LQTs7Ozs7OytlQWhCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBZ0JxQnk4Qyx5Qjs7Ozs7Ozs7Ozs7O0FBQ25COztBQUVBOzs7O29DQUlpQjtBQUNmLGFBQVE7QUFBQTtBQUFBLFVBQUssV0FBVSxXQUFmO0FBQ047QUFBQTtBQUFBLFlBQUssS0FBSSxlQUFULEVBQXlCLFNBQVMsS0FBS3Y5QyxLQUFMLENBQVdrTyxPQUE3QztBQUNFLG1EQUFLLEtBQUksUUFBVCxFQUFrQixLQUFLLEtBQUswTSxhQUFMLENBQW1CLGtCQUFuQixFQUF1QyxJQUF2QyxDQUF2QixHQURGO0FBRUU7QUFBQTtBQUFBLGNBQUssS0FBSSxTQUFUO0FBQW9CLGlCQUFLNWEsS0FBTCxDQUFXbUU7QUFBL0I7QUFGRjtBQURNLE9BQVI7QUFNRDs7OztFQWRvRDlLLHNCOztrQkFBbENra0QseUI7OztBQWlCckJBLDBCQUEwQno4QyxZQUExQixHQUF5Q3pILHVCQUFjeUgsWUFBdkQsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25CQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBbkJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFtQnFCMDhDLGlCOzs7QUFDbkIsK0JBQXNCO0FBQUE7O0FBQUE7O0FBQUEsc0NBQU54OEMsSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEsaUtBQ1hBLElBRFc7O0FBR3BCLFVBQUt2RixnQkFBTCxHQUF3QixJQUF4QjtBQUNBLFVBQUtHLEtBQUwsR0FBYTtBQUNYNHRCLGVBQVMsSUFERTtBQUVYaTBCLGlCQUFXLEVBRkE7QUFHWEMseUJBQW1CO0FBSFIsS0FBYjs7QUFNQSxVQUFLL2hELFFBQUwsQ0FDRSxpQkFERixFQUVFLDBCQUZGOztBQUtBLFFBQU1vdkIsb0JBQW9CLE1BQUt6cEIsT0FBTCxDQUFhTSxPQUFiLENBQXFCb3BCLFNBQXJCLENBQStCck0sUUFBekQ7QUFDQSxVQUFLZy9CLFNBQUwsR0FBaUIsSUFBSTV5QixpQkFBSixFQUFqQjtBQWhCb0I7QUFpQnJCOztBQUVEOzs7Ozs7Ozs7Z0NBS2E7QUFDWCxVQUFJeHlCLGVBQU00USxPQUFOLENBQWM0Z0IsT0FBZCxDQUFzQixFQUF0QixDQUFKLEVBQStCO0FBQUEsb0JBQ0QsS0FBS3JxQixJQURKO0FBQUEsWUFDckJzcUIsSUFEcUIsU0FDckJBLElBRHFCO0FBQUEsWUFDZmhsQixTQURlLFNBQ2ZBLFNBRGU7O0FBRTdCLFlBQUksRUFBRWdsQixRQUFRaGxCLFNBQVYsQ0FBSixFQUEwQjtBQUN4QjtBQUNEO0FBQ0QsWUFBTWtsQixhQUFhRixLQUFLaHRCLFlBQXhCO0FBQ0FnSSxrQkFBVTlGLEtBQVYsQ0FBZ0JDLE1BQWhCLEdBQTRCK3FCLFVBQTVCO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQTs7Ozs7O3dDQUdxQjtBQUFBOztBQUNuQjs7QUFFQSxVQUFNenZCLFFBQVFGLHVCQUFhc3dCLFFBQWIsQ0FBc0J1d0IsY0FBdEIsQ0FBcUMsS0FBSzc4QixFQUFMLENBQVEsMkJBQVIsQ0FBckMsQ0FBZDtBQUNBLFdBQUtxL0IsS0FBTCxHQUNHejJDLElBREgsQ0FDUSxpQkFBb0M7QUFBQTtBQUFBLFlBQWxDczJDLFNBQWtDO0FBQUEsWUFBdkJDLGlCQUF1Qjs7QUFDeENqakQsY0FBTTB3QixLQUFOO0FBQ0EsWUFBSXN5QixVQUFVejFDLE1BQVYsS0FBcUIsQ0FBekIsRUFBNEI7QUFDMUIsaUJBQUs2MUMsZUFBTCxDQUFxQkosVUFBVSxDQUFWLENBQXJCLEVBQW1DLElBQW5DO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsaUJBQUt2Z0QsUUFBTCxDQUFjO0FBQ1pzc0IscUJBQVMsS0FERztBQUVaaTBCLGdDQUZZO0FBR1pDO0FBSFksV0FBZDtBQUtEO0FBQ0YsT0FaSDtBQWFEOztBQUVEOztBQUVBOzs7Ozs7Ozs7b0NBTWlCNXpCLE8sRUFBZ0M7QUFBQSxVQUF2Qm14QixhQUF1Qix1RUFBUCxLQUFPOztBQUMvQyxXQUFLajdDLEtBQUwsQ0FBVzg5QyxnQkFBWCxJQUNFLEtBQUs5OUMsS0FBTCxDQUFXODlDLGdCQUFYLENBQTRCaDBCLE9BQTVCLEVBQXFDbXhCLGFBQXJDLENBREY7QUFFRDs7QUFFRDs7Ozs7Ozs7NkNBSzBCL3hCLGdCLEVBQWtCO0FBQzFDLFdBQUtscEIsS0FBTCxDQUFXKzlDLHlCQUFYLElBQ0UsS0FBSy85QyxLQUFMLENBQVcrOUMseUJBQVgsQ0FBcUM3MEIsZ0JBQXJDLENBREY7QUFFRDs7QUFFRDs7QUFFQTs7Ozs7Ozs7NEJBS1M7QUFDUCxVQUFJOUosV0FBVyxDQUNiLEtBQUt1K0IsU0FBTCxDQUFlSyxZQUFmLEVBRGEsRUFFYixLQUFLTCxTQUFMLENBQWVNLG9CQUFmLEVBRmEsQ0FBZjtBQUlBLGFBQU81bEQsaUJBQVFtUSxHQUFSLENBQVk0VyxRQUFaLENBQVA7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7Ozs7dUNBS29CO0FBQUE7O0FBQ2xCLFVBQU0yTSxRQUFRLEtBQUtud0IsS0FBTCxDQUFXNmhELFNBQVgsQ0FBcUJ0MUMsR0FBckIsQ0FBeUIsVUFBQzJoQixPQUFELEVBQWE7QUFDbEQsZUFBUSxnQ0FBQywwQkFBRDtBQUNOLG1CQUFTLE9BQUsrekIsZUFEUjtBQUVOLG1CQUFTL3pCLE9BRkgsR0FBUjtBQUdELE9BSmEsQ0FBZDtBQUtBLGFBQVE7QUFBQTtBQUFBLFVBQUksS0FBSSxRQUFSO0FBQ047QUFBQTtBQUFBLFlBQUssV0FBVSxhQUFmO0FBQ0U7QUFBQTtBQUFBLGNBQUssS0FBSSxZQUFUO0FBQUE7QUFBQSxXQURGO0FBRUU7QUFBQTtBQUFBLGNBQUksS0FBSSxnQkFBUjtBQUNHaUM7QUFESDtBQUZGO0FBRE0sT0FBUjtBQVFEOztBQUVEOzs7Ozs7OzsrQ0FLNEI7QUFBQTs7QUFDMUIsVUFBSSxDQUFDLEtBQUtud0IsS0FBTCxDQUFXOGhELGlCQUFYLENBQTZCMTFDLE1BQWxDLEVBQTBDLE9BQU8sSUFBUDs7QUFFMUMsVUFBTStqQixRQUFRLEtBQUtud0IsS0FBTCxDQUFXOGhELGlCQUFYLENBQTZCdjFDLEdBQTdCLENBQWlDLFVBQUMrZ0IsZ0JBQUQsRUFBc0I7QUFDbkUsZUFBUSxnQ0FBQyxtQ0FBRDtBQUNOLG1CQUFTLE9BQUtnMUIsd0JBRFI7QUFFTiw0QkFBa0JoMUIsZ0JBRlosR0FBUjtBQUdELE9BSmEsQ0FBZDs7QUFNQSxhQUFRO0FBQUE7QUFBQSxVQUFJLEtBQUksUUFBUjtBQUNOO0FBQUE7QUFBQSxZQUFLLFdBQVUsYUFBZjtBQUNFO0FBQUE7QUFBQSxjQUFLLEtBQUksWUFBVDtBQUFBO0FBQUEsV0FERjtBQUVFO0FBQUE7QUFBQSxjQUFJLEtBQUksZ0JBQVI7QUFDRzZDO0FBREg7QUFGRjtBQURNLE9BQVI7QUFRRDs7QUFFRDs7Ozs7Ozs7cUNBS2tCO0FBQ2hCLGFBQVE7QUFBQTtBQUFBLFVBQUssS0FBSSxpQ0FBVDtBQUNOO0FBQUE7QUFBQSxZQUFLLEtBQUksUUFBVCxFQUFrQixLQUFJLE1BQXRCO0FBQ0U7QUFBQTtBQUFBLGNBQUssS0FBSSxhQUFULEVBQXVCLEtBQUksV0FBM0I7QUFDRTtBQUFBO0FBQUEsZ0JBQUssS0FBSSxrQkFBVDtBQUNFO0FBQUE7QUFBQSxrQkFBSSxLQUFJLGNBQVI7QUFDRyxxQkFBS295QixnQkFBTCxFQURIO0FBRUcscUJBQUtDLHdCQUFMO0FBRkg7QUFERjtBQURGO0FBREY7QUFETSxPQUFSO0FBWUQ7O0FBRUQ7Ozs7Ozs7b0NBSWlCO0FBQ2YsVUFBSSxDQUFDLEtBQUt4aUQsS0FBTCxDQUFXNHRCLE9BQWhCLEVBQXlCO0FBQ3ZCLGVBQU8sS0FBS3hQLGNBQUwsRUFBUDtBQUNELE9BRkQsTUFFTztBQUNMLGVBQU8sNENBQVA7QUFDRDtBQUNGOzs7O0VBL0s0QzNnQixzQjs7a0JBQTFCbWtELGlCOzs7QUFrTHJCQSxrQkFBa0IxOEMsWUFBbEIsR0FBaUN6SCx1QkFBY3lILFlBQS9DLEM7Ozs7Ozs7Ozs7Ozs7OztBQ3ZMQTs7Ozs7OytlQWhCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBZ0JxQnU5QyxnQjs7O0FBQ25CLDhCQUFzQjtBQUFBOztBQUFBOztBQUFBLHNDQUFOcjlDLElBQU07QUFBTkEsVUFBTTtBQUFBOztBQUFBLCtKQUNYQSxJQURXOztBQUdwQixVQUFLckYsUUFBTCxDQUNFLFVBREY7QUFIb0I7QUFNckI7O0FBRUQ7O0FBRUE7Ozs7Ozs7OytCQUlZO0FBQ1YsV0FBS3FFLEtBQUwsQ0FBV2tPLE9BQVgsSUFDRSxLQUFLbE8sS0FBTCxDQUFXa08sT0FBWCxDQUFtQixLQUFLbE8sS0FBTCxDQUFXOHBCLE9BQTlCLENBREY7QUFFRDs7QUFFRDs7QUFFQTs7Ozs7OztvQ0FJaUI7QUFBQSxVQUNQQSxPQURPLEdBQ0ssS0FBSzlwQixLQURWLENBQ1A4cEIsT0FETzs7QUFFZixVQUFNNXFCLFFBQVE7QUFDWnNwQixrQ0FBd0JzQixRQUFRWCxVQUFoQztBQURZLE9BQWQ7O0FBSUEsYUFDRTtBQUFBO0FBQUEsVUFBSyxXQUFVLDJCQUFmO0FBQ0U7QUFBQTtBQUFBLFlBQUksS0FBSSxRQUFSLEVBQWlCLE9BQU9qcUIsS0FBeEIsRUFBK0IsU0FBUyxLQUFLa3FCLFFBQTdDO0FBQ0UsbURBQUssS0FBSSxXQUFULEdBREY7QUFFRTtBQUFBO0FBQUEsY0FBSyxLQUFJLFFBQVQ7QUFBbUJVLG9CQUFRMVk7QUFBM0I7QUFGRjtBQURGLE9BREY7QUFRRDs7OztFQXhDMkMvWCxzQjs7a0JBQXpCZ2xELGdCOzs7QUEyQ3JCQSxpQkFBaUJ2OUMsWUFBakIsR0FBZ0N6SCx1QkFBY3lILFlBQTlDLEM7Ozs7Ozs7Ozs7Ozs7OztBQzdDQTs7Ozs7OytlQWhCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBZ0JxQnc5QyxjOzs7Ozs7Ozs7Ozs7QUFDbkI7O0FBRUE7Ozs7b0NBSWlCO0FBQUEsVUFDUDEwQixLQURPLEdBQ0csS0FBSzVwQixLQURSLENBQ1A0cEIsS0FETzs7QUFFZixhQUNFO0FBQUE7QUFBQSxVQUFLLFdBQVUseUJBQWY7QUFDRTtBQUFBO0FBQUEsWUFBSSxLQUFJLFNBQVIsRUFBa0IsU0FBUyxLQUFLNXBCLEtBQUwsQ0FBV2tPLE9BQXRDO0FBQ0UsbURBQUssS0FBSSxXQUFULEdBREY7QUFFRTtBQUFBO0FBQUEsY0FBSyxLQUFJLFNBQVQ7QUFBb0IwYixrQkFBTTF2QjtBQUExQixXQUZGO0FBR0UsbURBQUssS0FBSSxTQUFULEVBQW1CLEtBQUswdkIsTUFBTStCLElBQU4sQ0FBV0MsS0FBbkM7QUFIRjtBQURGLE9BREY7QUFTRDs7OztFQWxCeUN2eUIsc0I7O2tCQUF2QmlsRCxjOzs7QUFxQnJCQSxlQUFleDlDLFlBQWYsR0FBOEJ6SCx1QkFBY3lILFlBQTVDLEM7Ozs7Ozs7Ozs7Ozs7OztBQ3ZCQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBbkJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFtQnFCeTlDLHNCOzs7Ozs7Ozs7Ozs7QUFDbkI7O0FBRUE7Ozs7OENBSTJCditDLEssRUFBTztBQUNoQyxVQUFJQSxNQUFNNlcsS0FBTixLQUFnQixLQUFLN1csS0FBTCxDQUFXNlcsS0FBL0IsRUFBc0M7QUFDcEMsYUFBSzZTLFdBQUwsQ0FBaUIxcEIsTUFBTTZXLEtBQXZCO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQTs7Ozs7Ozs7bUNBS2dCO0FBQ2QsYUFBTyxLQUFLMEgsRUFBTCxDQUFRLG1DQUFSLEVBQTZDO0FBQ2xEMUgsZUFBTyxLQUFLN1csS0FBTCxDQUFXNlc7QUFEZ0MsT0FBN0MsQ0FBUDtBQUdEOztBQUVEOzs7Ozs7OztrQ0FLdUM7QUFBQTs7QUFBQSxVQUExQkEsS0FBMEIsdUVBQWxCLEtBQUs3VyxLQUFMLENBQVc2VyxLQUFPOztBQUNyQyxXQUFLMFMsa0JBQUwsR0FBMEIsQ0FBMUI7QUFDQSxVQUFNOXVCLFFBQVFGLHVCQUFhc3dCLFFBQWIsQ0FBc0JDLGVBQXRCLENBQXNDLEtBQUt2TSxFQUFMLENBQVEsMkJBQVIsQ0FBdEMsQ0FBZDtBQUNBLFVBQU13TSxvQkFBb0IsS0FBS3pwQixPQUFMLENBQWFNLE9BQWIsQ0FBcUJvcEIsU0FBckIsQ0FBK0JyTSxRQUF6RDtBQUNBLFVBQU1BLFdBQVcsSUFBSW9NLGlCQUFKLEVBQWpCOztBQUVBcE0sZUFBUzYvQixZQUFULENBQXNCM25DLEtBQXRCLEVBQ0cxUCxJQURILENBQ1EsVUFBQ3NpQixNQUFELEVBQVk7QUFDaEIsZUFBTyxPQUFLeUIsY0FBTCxDQUFvQnpCLE1BQXBCLEVBQTRCaHZCLEtBQTVCLENBQVA7QUFDRCxPQUhILEVBSUcwTSxJQUpILENBSVEsVUFBQ3NpQixNQUFELEVBQVk7QUFDaEIsZUFBS3ZzQixRQUFMLENBQWMsRUFBRXVzQixjQUFGLEVBQVVELFNBQVMsS0FBbkIsRUFBZDtBQUNBL3VCLGNBQU0wd0IsS0FBTjtBQUNELE9BUEg7QUFRRDs7QUFFRDs7QUFFQTs7Ozs7Ozs7c0NBS21CO0FBQ2pCLGFBQVEsZ0NBQUMsa0NBQUQ7QUFDTixlQUFPLEtBQUtuckIsS0FBTCxDQUFXNlcsS0FEWjtBQUVOLG1DQUEyQixLQUFLN1csS0FBTCxDQUFXKzlDLHlCQUZoQyxHQUFSO0FBR0Q7O0FBRUQ7Ozs7Ozs7b0NBSWlCO0FBQ2YsVUFBSSxDQUFDLEtBQUtuaUQsS0FBTCxDQUFXNHRCLE9BQWhCLEVBQXlCO0FBQ3ZCLFlBQUksS0FBSzV0QixLQUFMLENBQVc2dEIsTUFBWCxDQUFrQnpoQixNQUFsQixLQUE2QixDQUFqQyxFQUFvQztBQUNsQyxpQkFBTyxLQUFLeTJDLGVBQUwsRUFBUDtBQUNELFNBRkQsTUFFTztBQUNMLGlCQUFPLEtBQUs1eUIsYUFBTCxFQUFQO0FBQ0Q7QUFDRixPQU5ELE1BTU87QUFDTCxlQUFPLDRDQUFQO0FBQ0Q7QUFDRjs7OztFQTFFaUR2Qyw0Qjs7a0JBQS9CaTFCLHNCOzs7QUE2RXJCQSx1QkFBdUJ6OUMsWUFBdkIsR0FBc0N3b0IsNkJBQW1CeG9CLFlBQXpELEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEZBOztBQUNBOzs7Ozs7Ozs7OytlQWpCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBaUJxQjQ5Qyx3Qjs7O0FBQ25CLHNDQUFzQjtBQUFBOztBQUFBOztBQUFBLHNDQUFOMTlDLElBQU07QUFBTkEsVUFBTTtBQUFBOztBQUFBLCtLQUNYQSxJQURXOztBQUdwQixVQUFLckYsUUFBTCxDQUNFLDBCQURGOztBQUlBLFFBQU1vdkIsb0JBQW9CLE1BQUt6cEIsT0FBTCxDQUFhTSxPQUFiLENBQXFCb3BCLFNBQXJCLENBQStCck0sUUFBekQ7QUFDQSxVQUFLZy9CLFNBQUwsR0FBaUIsSUFBSTV5QixpQkFBSixFQUFqQjs7QUFFQSxVQUFLbnZCLEtBQUwsR0FBYTtBQUNYOGhELHlCQUFtQjtBQURSLEtBQWI7QUFWb0I7QUFhckI7O0FBRUQ7O0FBRUE7Ozs7Ozs7Ozs2Q0FLMEJ4MEIsZ0IsRUFBa0I7QUFDMUMsV0FBS2xwQixLQUFMLENBQVcrOUMseUJBQVgsSUFDRSxLQUFLLzlDLEtBQUwsQ0FBVys5Qyx5QkFBWCxDQUFxQzcwQixnQkFBckMsQ0FERjtBQUVEOztBQUVEOztBQUVBOzs7Ozs7d0NBR3FCO0FBQUE7O0FBQ25COztBQUVBLFdBQUt5MEIsU0FBTCxDQUFlTSxvQkFBZixHQUNHOTJDLElBREgsQ0FDUSxVQUFDdTJDLGlCQUFELEVBQXVCO0FBQzNCLGVBQUt4Z0QsUUFBTCxDQUFjO0FBQ1p3Z0Q7QUFEWSxTQUFkO0FBR0QsT0FMSDtBQU1EOztBQUVEOztBQUVBOzs7Ozs7OztxQ0FLa0I7QUFDaEIsYUFBTyxFQUFFaUIsUUFBUSxLQUFLcGdDLEVBQUwsQ0FBUSxvQ0FBUixFQUE4QztBQUM3RDFILGlCQUFPLEtBQUs3VyxLQUFMLENBQVc2VztBQUQyQyxTQUE5QyxDQUFWLEVBQVA7QUFHRDs7QUFFRDs7Ozs7Ozs7K0NBSzRCO0FBQUE7O0FBQzFCLFVBQUksQ0FBQyxLQUFLamIsS0FBTCxDQUFXOGhELGlCQUFYLENBQTZCMTFDLE1BQWxDLEVBQTBDLE9BQU8sSUFBUDs7QUFFMUMsVUFBTStqQixRQUFRLEtBQUtud0IsS0FBTCxDQUFXOGhELGlCQUFYLENBQTZCdjFDLEdBQTdCLENBQWlDLFVBQUMrZ0IsZ0JBQUQsRUFBc0I7QUFDbkUsZUFBUSxnQ0FBQyxtQ0FBRDtBQUNOLG1CQUFTLE9BQUtnMUIsd0JBRFI7QUFFTiw0QkFBa0JoMUIsZ0JBRlosR0FBUjtBQUdELE9BSmEsQ0FBZDs7QUFNQSxhQUFRO0FBQUE7QUFBQTtBQUNOO0FBQUE7QUFBQSxZQUFLLEtBQUksWUFBVDtBQUFBO0FBQUEsU0FETTtBQUVOO0FBQUE7QUFBQSxZQUFJLEtBQUksZ0JBQVI7QUFDRzZDO0FBREg7QUFGTSxPQUFSO0FBTUQ7O0FBRUQ7Ozs7Ozs7b0NBSWlCO0FBQ2YsYUFBUTtBQUFBO0FBQUEsVUFBSyxLQUFJLGlDQUFUO0FBQ047QUFBQTtBQUFBLFlBQUssS0FBSSxRQUFUO0FBQ0U7QUFBQTtBQUFBLGNBQUssS0FBSSxhQUFUO0FBQ0U7QUFBQTtBQUFBLGdCQUFLLEtBQUksa0JBQVQ7QUFDRSx1REFBSyxLQUFJLG1CQUFULEVBQTZCLHlCQUF5QixLQUFLNnlCLGNBQUwsRUFBdEQsR0FERjtBQUVHLG1CQUFLUix3QkFBTDtBQUZIO0FBREY7QUFERjtBQURNLE9BQVI7QUFVRDs7OztFQTlGbUQva0Qsc0I7O2tCQUFqQ3FsRCx3Qjs7O0FBaUdyQkEseUJBQXlCNTlDLFlBQXpCLEdBQXdDekgsdUJBQWN5SCxZQUF0RCxDOzs7Ozs7Ozs7Ozs7Ozs7QUNyR0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQWxCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztJQWtCcUI4MEMscUI7OztBQUNuQixtQ0FBZTtBQUFBOztBQUFBOztBQUViLFVBQUtqNkMsUUFBTCxDQUFjLFdBQWQsRUFBMkIsZ0JBQTNCLEVBQTZDLG1CQUE3QztBQUNBLFVBQUtDLEtBQUwsR0FBYSxFQUFFaWpELGFBQWEsS0FBZixFQUFiO0FBSGE7QUFJZDs7QUFFRDs7QUFFQTs7Ozs7Ozs7cUNBSWtCO0FBQ2hCLFdBQUszaEQsUUFBTCxDQUFjLEVBQUUyaEQsYUFBYSxJQUFmLEVBQWQ7QUFDRDs7QUFFRDs7Ozs7OztnQ0FJYTtBQUNYLFdBQUs3K0MsS0FBTCxDQUFXNjJDLEdBQVgsQ0FBZUwsY0FBZixDQUE4QixNQUE5QjtBQUNEOztBQUVEOzs7Ozs7O3dDQUlxQjtBQUFBOztBQUNuQixVQUFNYixTQUFTLEtBQUtqMkMsSUFBTCxDQUFVaTJDLE1BQXpCO0FBQ0FBLGFBQU9tSixTQUFQLEdBQ0czM0MsSUFESCxDQUNRLFVBQUM4TSxLQUFELEVBQVc7QUFDZixlQUFLalUsS0FBTCxDQUFXNjJDLEdBQVgsQ0FBZXRsQixRQUFmLENBQXdCdGQsS0FBeEI7QUFDRCxPQUhILEVBSUdxTCxLQUpILENBSVMsVUFBQ25pQixDQUFELEVBQU87QUFDWnZELHFCQUFJeXhCLEtBQUosQ0FBVWx1QixDQUFWO0FBQ0QsT0FOSDtBQU9EOztBQUVEOztBQUVBOzs7Ozs7OztvQ0FLaUI7QUFDZixhQUFRO0FBQUE7QUFBQSxVQUFLLEtBQUksaUJBQVQ7QUFFTjtBQUFDLG1DQUFEO0FBQUE7QUFDRSxtQkFBTyxLQUFLb2hCLEVBQUwsQ0FBUSw2QkFBUixDQURUO0FBRUU7QUFBQTtBQUFBLGNBQUssV0FBVSxXQUFmO0FBQ0U7QUFBQTtBQUFBLGdCQUFLLEtBQUksZ0JBQVQsRUFBMEIsU0FBUyxLQUFLd2dDLFNBQXhDO0FBQ0csbUJBQUt4Z0MsRUFBTCxDQUFRLDRCQUFSO0FBREgsYUFERjtBQUlFO0FBQUE7QUFBQSxnQkFBSyxLQUFJLFNBQVQ7QUFDRyxtQkFBS0EsRUFBTCxDQUFRLDZCQUFSO0FBREg7QUFKRjtBQUZGLFNBRk07QUFjTjtBQUFBO0FBQUEsWUFBSyxLQUFJLDZCQUFUO0FBQ0U7QUFBQTtBQUFBLGNBQUssS0FBSSxvQkFBVDtBQUNFLDRDQUFDLHlCQUFEO0FBQ0UsbUJBQUksUUFETjtBQUVFLHVCQUFTLEtBQUt5Z0MsY0FGaEI7QUFHRSxzQkFBUSxLQUFLRCxTQUhmO0FBREY7QUFERixTQWRNO0FBdUJOO0FBQUE7QUFBQSxZQUFLLEtBQUksZ0NBQVQ7QUFDRTtBQUFBO0FBQUEsY0FBSyxLQUFJLFFBQVQ7QUFDRTtBQUFBO0FBQUEsZ0JBQUssV0FBVSxnQkFBZjtBQUNFO0FBQUE7QUFBQTtBQUNFLHVCQUFJLGtCQUROO0FBRUUsMkJBQVMsS0FBS0UsaUJBRmhCO0FBR0UsNkJBQVcsS0FBS3JqRCxLQUFMLENBQVdpakQsV0FBWCxHQUF5QixXQUF6QixHQUF1QyxLQUhwRDtBQUlFLHlEQUFLLEtBQUksUUFBVCxFQUFrQixLQUFLLEtBQUtqa0MsYUFBTCxDQUFtQiw2QkFBbkIsRUFBa0QsSUFBbEQsQ0FBdkI7QUFKRjtBQURGO0FBREY7QUFERjtBQXZCTSxPQUFSO0FBb0NEOzs7O0VBcEZnRHRXLHlCOztrQkFBOUJzeEMscUI7OztBQXVGckJBLHNCQUFzQjkwQyxZQUF0QixHQUFxQ3dELDBCQUFnQnhELFlBQXJELEM7Ozs7Ozs7Ozs7Ozs7OztBQzNGQTs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQWxCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBa0JxQjI1QyxlOzs7QUFDbkIsNkJBQWU7QUFBQTs7QUFBQTs7QUFFYixVQUFLOStDLFFBQUwsQ0FDRSxnQkFERixFQUVFLGdCQUZGOztBQUtBLFVBQUtDLEtBQUwsR0FBYSxFQUFFaWpELGFBQWEsS0FBZixFQUFiO0FBUGE7QUFRZDs7QUFFRDs7QUFFQTs7Ozs7Ozs7OzBDQUt1QmxpQyxTLEVBQVd1aUMsUyxFQUFXO0FBQzNDO0FBQ0EsYUFBTyxLQUFQO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7cUNBSWtCO0FBQ2hCLFdBQUtsL0MsS0FBTCxDQUFXa2xDLE9BQVgsSUFBc0IsS0FBS2xsQyxLQUFMLENBQVdrbEMsT0FBWCxFQUF0QjtBQUNBLFdBQUtob0MsUUFBTCxDQUFjLEVBQUUyaEQsYUFBYSxJQUFmLEVBQWQ7QUFDRDs7O21DQUVlbE4sRyxFQUFLO0FBQUE7O0FBQ25CLFVBQU13TixhQUFhNWtELHVCQUFhc3dCLFFBQWIsQ0FBc0JPLFlBQXRCLENBQ2pCLEtBQUs3TSxFQUFMLENBQVEsMEJBQVIsQ0FEaUIsRUFFakIsS0FBS0EsRUFBTCxDQUFRLHFDQUFSLEVBQStDLEVBQUU4TSxPQUFPc21CLEdBQVQsRUFBL0MsQ0FGaUIsQ0FBbkI7QUFJQXdOLGlCQUFXcmtELEVBQVgsQ0FBYyxPQUFkLEVBQXVCO0FBQUEsZUFBTSxPQUFLa0YsS0FBTCxDQUFXby9DLE1BQVgsRUFBTjtBQUFBLE9BQXZCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Z0NBSWE7QUFDWCxVQUFJLENBQUMsS0FBS3hqRCxLQUFMLENBQVdpakQsV0FBaEIsRUFBNkI7QUFDM0I7QUFDRDs7QUFFRCxhQUFPLEtBQUtRLE9BQUwsQ0FBYUMsT0FBYixFQUFQO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7b0NBSWlCO0FBQUE7O0FBQ2YsYUFDRTtBQUFBO0FBQUEsVUFBSyxLQUFJLFdBQVQsRUFBcUIsS0FBSSxXQUF6QjtBQUNFLHdDQUFDLDhCQUFEO0FBQ0Usb0JBQVUsS0FBSzFrQyxhQUFMLENBQW1CLHFCQUFuQixDQURaO0FBRUUsZUFBSyxpQkFBTTtBQUFFLG1CQUFLeWtDLE9BQUwsR0FBZTlXLEVBQWY7QUFBbUIsV0FGbEM7QUFHRSx5QkFBZSxLQUFLZ1gsY0FIdEI7QUFJRSw2QkFBbUIsS0FBS1AsY0FKMUI7QUFERixPQURGO0FBU0Q7Ozs7RUF0RTBDM2xELHNCOztrQkFBeEJvaEQsZTs7O0FBeUVyQkEsZ0JBQWdCNzFDLFNBQWhCLEdBQTRCO0FBQzFCc2dDLFdBQVNwckMsbUJBQVVtZ0I7QUFETyxDQUE1Qjs7QUFJQXdnQyxnQkFBZ0IzNUMsWUFBaEIsR0FBK0J6SCx1QkFBY3lILFlBQTdDLEM7Ozs7Ozs7Ozs7Ozs7OztBQ2hGQTs7Ozs7OytlQWpCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTs7SUFJcUIwK0Msb0I7OztBQUNuQixnQ0FBYXgvQyxLQUFiLEVBQW9CO0FBQUE7O0FBQUEsNElBQ1pBLEtBRFk7O0FBR2xCLFVBQUtyRSxRQUFMLENBQWMsbUJBQWQ7O0FBRUEsVUFBS0MsS0FBTCxHQUFhO0FBQ1htOEMsdUJBQWlCLEtBRE47QUFFWDBILHdCQUFrQixLQUZQO0FBR1hDLHNCQUFnQixJQUhMO0FBSVhDLHVCQUFpQjtBQUpOLEtBQWI7O0FBT0EsVUFBS0MsYUFBTCxHQUFxQixJQUFyQjtBQUNBLFVBQUtDLGFBQUwsR0FBcUIsSUFBckI7QUFia0I7QUFjbkI7Ozs7d0NBRW9CO0FBQUE7O0FBQ25CLFdBQUtDLGlCQUFMO0FBQ0EsV0FBS0MseUJBQUw7O0FBRUEsVUFBSSxLQUFLSCxhQUFULEVBQXdCO0FBQ3RCLGFBQUtBLGFBQUwsQ0FBbUI7QUFDakJJLGlCQUFPO0FBQ0xDLHNCQUFVLENBQ1IsRUFBQ0MsVUFBVSxHQUFYLEVBRFEsRUFFUixFQUFDQSxVQUFVLEdBQVgsRUFGUSxFQUdSLEVBQUNBLFVBQVUsSUFBWCxFQUhRLEVBSVIsRUFBQ0EsVUFBVSxJQUFYLEVBSlEsRUFLUixFQUFDQSxVQUFVLElBQVgsRUFMUSxFQU1SLEVBQUNBLFVBQVUsSUFBWCxFQU5RO0FBREwsV0FEVTtBQVdqQkMsaUJBQU87QUFYVSxTQUFuQixFQWFHaDVDLElBYkgsQ0FhUSxrQkFBVTtBQUNkLGlCQUFLMDRDLGFBQUwsR0FBcUJPLE1BQXJCO0FBQ0EsY0FBTUosUUFBUSxPQUFLSyxhQUFuQjs7QUFFQSxjQUFJLGVBQWVMLEtBQW5CLEVBQTBCO0FBQ3hCQSxrQkFBTU0sU0FBTixHQUFrQkYsTUFBbEI7QUFDRCxXQUZELE1BRU87QUFDTEosa0JBQU0zckMsR0FBTixHQUFZdmIsT0FBTzhkLEdBQVAsQ0FBV3ExQixlQUFYLENBQTJCbVUsTUFBM0IsQ0FBWjtBQUNEO0FBQ0YsU0F0QkgsRUF1Qkc5Z0MsS0F2QkgsQ0F1QlMsaUJBQVM7QUFDZCxjQUFJLE9BQUt0ZixLQUFMLENBQVd1Z0QsYUFBZixFQUE4QjtBQUM1QixtQkFBS3ZnRCxLQUFMLENBQVd1Z0QsYUFBWCxDQUF5QmwxQixLQUF6QjtBQUNEO0FBQ0YsU0EzQkg7QUE0QkQsT0E3QkQsTUE2Qk87QUFDTCxZQUFJbTFCLGVBQWUsS0FBbkI7O0FBRUE7QUFDQTtBQUNBLFlBQUksQ0FBQzFuRCxPQUFPMm5ELE1BQVosRUFBb0I7QUFDbEIzbkQsaUJBQU8ybkQsTUFBUCxHQUFnQixFQUFoQjtBQUNBRCx5QkFBZSxJQUFmO0FBQ0Q7O0FBRUQxbkQsZUFBTzJuRCxNQUFQLENBQWNDLFdBQWQsR0FBNEIsVUFBQ3ptRCxJQUFELEVBQU8wM0MsR0FBUCxFQUFlO0FBQ3pDLGtCQUFRMTNDLElBQVI7QUFDRSxpQkFBSyxZQUFMO0FBQ0UscUJBQUtpRCxRQUFMLENBQWMsRUFBRTY2QyxpQkFBaUIsSUFBbkIsRUFBZCxFQUNFLFlBQU07QUFBRSx1QkFBSy8zQyxLQUFMLENBQVcyZ0QsaUJBQVgsSUFBZ0MsT0FBSzNnRCxLQUFMLENBQVcyZ0QsaUJBQVgsRUFBaEM7QUFBZ0UsZUFEMUU7QUFFQSxxQkFBTzduRCxPQUFPMm5ELE1BQVAsQ0FBY0MsV0FBckI7QUFDQSxrQkFBSUYsWUFBSixFQUFrQjtBQUNoQix1QkFBTzFuRCxPQUFPMm5ELE1BQWQ7QUFDRDtBQUNEO0FBQ0YsaUJBQUssT0FBTDtBQUNFLHFCQUFLemdELEtBQUwsQ0FBV3VnRCxhQUFYLElBQTRCLE9BQUt2Z0QsS0FBTCxDQUFXdWdELGFBQVgsQ0FBeUI1TyxHQUF6QixDQUE1QjtBQUNBLHFCQUFPNzRDLE9BQU8ybkQsTUFBUCxDQUFjQyxXQUFyQjtBQUNBLGtCQUFJRixZQUFKLEVBQWtCO0FBQ2hCLHVCQUFPMW5ELE9BQU8ybkQsTUFBZDtBQUNEO0FBQ0Q7QUFmSjtBQWlCRCxTQWxCRDtBQW1CRDtBQUNGOzs7MkNBRXVCO0FBQ3RCLFdBQUtHLGNBQUw7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7d0NBUXFCO0FBQ25CO0FBQ0EsVUFBSTd1QyxVQUFVOHVDLFlBQWQsRUFBNEI7QUFDMUIsWUFBSTl1QyxVQUFVOHVDLFlBQVYsQ0FBdUJDLFlBQTNCLEVBQXlDO0FBQ3ZDLGVBQUtsQixhQUFMLEdBQXFCN3RDLFVBQVU4dUMsWUFBVixDQUF1QkMsWUFBdkIsQ0FBb0M5bkQsSUFBcEMsQ0FBeUMrWSxVQUFVOHVDLFlBQW5ELENBQXJCO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBLFVBQUksQ0FBQyxLQUFLakIsYUFBVixFQUF5QjtBQUN2QixZQUFNbUIscUJBQXFCaHZDLFVBQVUrdUMsWUFBVixJQUEwQi91QyxVQUFVaXZDLGtCQUFwQyxJQUEwRGp2QyxVQUFVa3ZDLGVBQXBFLElBQXVGbHZDLFVBQVVtdkMsY0FBNUg7O0FBRUEsWUFBSUgsa0JBQUosRUFBd0I7QUFDdEIsZUFBS25CLGFBQUwsR0FBcUI7QUFBQSxtQkFBVyxJQUFJdm5ELE9BQUosQ0FBWSxVQUFDNmUsT0FBRCxFQUFVQyxNQUFWO0FBQUEscUJBQXFCNHBDLG1CQUFtQjdXLElBQW5CLENBQXdCbjRCLFNBQXhCLEVBQW1DblEsT0FBbkMsRUFBNENzVixPQUE1QyxFQUFxREMsTUFBckQsQ0FBckI7QUFBQSxhQUFaLENBQVg7QUFBQSxXQUFyQjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQSxVQUFJLENBQUMsS0FBS3lvQyxhQUFWLEVBQXlCO0FBQ3ZCLGFBQUsxaUQsUUFBTCxDQUFjLEVBQUV1aUQsa0JBQWtCLElBQXBCLEVBQWQ7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7cUNBTWtCO0FBQ2hCLFVBQUksS0FBS0ksYUFBVCxFQUF3QjtBQUN0QixZQUFNTyxTQUFTLEtBQUtQLGFBQXBCO0FBQ0EsWUFBTXNCLFFBQVFmLE9BQU9nQixTQUFQLEdBQW1CLENBQW5CLENBQWQ7QUFDQSxZQUFJRCxLQUFKLEVBQVc7QUFDVEEsZ0JBQU05dEIsSUFBTjtBQUNELFNBRkQsTUFFTyxJQUFJK3NCLE9BQU8vc0IsSUFBWCxFQUFpQjtBQUN0QitzQixpQkFBTy9zQixJQUFQO0FBQ0Q7QUFDRixPQVJELE1BUU8sSUFBSSxLQUFLZ3VCLFlBQVQsRUFBdUI7QUFDNUIsYUFBS0EsWUFBTCxDQUFrQkMsY0FBbEI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7OEJBTVc7QUFBQTs7QUFDVCxVQUFJLENBQUMsS0FBSzFsRCxLQUFMLENBQVdtOEMsZUFBaEIsRUFBaUM7QUFDL0IsZUFBTzEvQyxRQUFROGUsTUFBUixDQUFlLElBQUkzVCxLQUFKLENBQVUsNEJBQVYsQ0FBZixDQUFQO0FBQ0Q7O0FBRUQsVUFBSSxLQUFLNjhDLGFBQUwsSUFBc0IsQ0FBQyxLQUFLZ0IsWUFBaEMsRUFBOEM7QUFDNUMsZUFBTyxJQUFJaHBELE9BQUosQ0FBWSxVQUFDNmUsT0FBRCxFQUFVQyxNQUFWLEVBQXFCO0FBQ3RDLGNBQU02b0MsUUFBUSxPQUFLSyxhQUFuQjtBQUNBLGNBQUlMLE1BQU1sb0MsVUFBTixLQUFxQixDQUF6QixFQUE0QjtBQUMxQlgsbUJBQU8sSUFBSTNULEtBQUosQ0FBVSw0QkFBVixDQUFQO0FBQ0QsV0FGRCxNQUVPO0FBQ0wsZ0JBQU0yUyxTQUFTL1gsU0FBU2dZLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBZjtBQUNBRCxtQkFBTzNXLEtBQVAsR0FBZXdnRCxNQUFNdUIsVUFBckI7QUFDQXByQyxtQkFBT2hYLE1BQVAsR0FBZ0I2Z0QsTUFBTXdCLFdBQXRCOztBQUVBLGdCQUFNbGdELFVBQVU2VSxPQUFPbEIsVUFBUCxDQUFrQixJQUFsQixDQUFoQjtBQUNBM1Qsb0JBQVFtMUIsU0FBUixDQUFrQnVwQixLQUFsQixFQUF5QixDQUF6QixFQUE0QixDQUE1Qjs7QUFFQSxnQkFBTS9yQyxRQUFRLElBQUluYixPQUFPb2IsS0FBWCxFQUFkO0FBQ0FELGtCQUFNNVYsZ0JBQU4sQ0FBdUIsTUFBdkIsRUFBK0IsWUFBTTtBQUNuQzZZLHNCQUFRakQsS0FBUjtBQUNELGFBRkQ7QUFHQUEsa0JBQU1JLEdBQU4sR0FBWThCLE9BQU81QixTQUFQLENBQWlCLFlBQWpCLENBQVo7QUFDRDtBQUNGLFNBbEJNLENBQVA7QUFtQkQsT0FwQkQsTUFvQk8sSUFBSSxLQUFLOHNDLFlBQVQsRUFBdUI7QUFDNUIsZUFBTyxJQUFJaHBELE9BQUosQ0FBWSxVQUFDNmUsT0FBRCxFQUFVQyxNQUFWLEVBQXFCO0FBQ3RDLGNBQU15MEIsVUFBVSxPQUFLeVYsWUFBTCxDQUFrQkksS0FBbEIsRUFBaEI7QUFDQSxjQUFNeHRDLFFBQVEsSUFBSUMsS0FBSixFQUFkO0FBQ0FELGdCQUFNRSxNQUFOLEdBQWUsWUFBTTtBQUFFK0Msb0JBQVFqRCxLQUFSO0FBQWdCLFdBQXZDO0FBQ0FBLGdCQUFNSSxHQUFOLCtCQUFzQ3UzQixPQUF0QztBQUNELFNBTE0sQ0FBUDtBQU1EOztBQUVELGFBQU92ekMsUUFBUThlLE1BQVIsQ0FBZSxJQUFJM1QsS0FBSixDQUFVLDRCQUFWLENBQWYsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7O21DQVV5QjtBQUFBLFVBQVg1RSxHQUFXLHVFQUFMLEdBQUs7O0FBQ3ZCLFVBQUk4aUQsVUFBVSxLQUFLQyxVQUFuQjs7QUFFQSxXQUFLLElBQUlqakMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJLElBQXBCLEVBQTBCQSxHQUExQixFQUErQjtBQUM3QixZQUFJZ2pDLFFBQVFFLFlBQVIsR0FBdUJoakQsR0FBM0IsRUFBZ0M7QUFDOUI7QUFDRDs7QUFFRCxZQUFJOGlELFFBQVE3b0MsVUFBWixFQUF3QjtBQUN0QjZvQyxvQkFBVUEsUUFBUTdvQyxVQUFsQjtBQUNELFNBRkQsTUFFTztBQUNMO0FBQ0Q7QUFDRjtBQUNELGFBQU82b0MsUUFBUUUsWUFBUixHQUF1QmhqRCxHQUF2QixHQUE2QjhpRCxRQUFRRSxZQUFyQyxHQUFvRCxJQUEzRDtBQUNEOztBQUVEOzs7Ozs7Ozs7Z0RBTTZCO0FBQzNCLFVBQU1qQyxrQkFBa0IsT0FBTyxLQUFLa0MsWUFBTCxNQUF1Qi9vRCxPQUFPZ3BELFdBQXJDLENBQXhCO0FBQ0EsVUFBTXRpRCxRQUFTLElBQUksQ0FBTCxHQUFVbWdELGVBQVYsSUFBNkIsR0FBM0M7QUFDQSxVQUFNeGdELFNBQVN3Z0QsbUJBQW1CLEdBQWxDOztBQUVBLFdBQUt6aUQsUUFBTCxDQUFjO0FBQ1p3aUQsd0JBQWdCbGdELEtBREo7QUFFWm1nRCx5QkFBaUJ4Z0Q7QUFGTCxPQUFkO0FBSUQ7O0FBRUQ7Ozs7Ozs7O2lEQUs4QjtBQUFBOztBQUM1QixVQUFNSyxRQUFRLEtBQUs1RCxLQUFMLENBQVc4akQsY0FBWCxJQUE2QixHQUEzQztBQUNBLFVBQU12Z0QsU0FBUyxLQUFLdkQsS0FBTCxDQUFXK2pELGVBQVgsSUFBOEIsR0FBN0M7O0FBRUEsVUFBTW9DLHVCQUFxQnZpRCxLQUFyQixnQkFBcUNMLE1BQXJDLDZEQUFOOztBQUVBLGFBQ0U7QUFBQTtBQUFBLFVBQVEsU0FBUSw0Q0FBaEIsRUFBNkQsTUFBSywrQkFBbEUsRUFBa0csT0FBT0ssS0FBekcsRUFBZ0gsUUFBUUwsTUFBeEgsRUFBZ0ksS0FBSyxnQkFBSztBQUFFLG1CQUFLa2lELFlBQUwsR0FBb0Jsa0QsQ0FBcEI7QUFBdUIsV0FBbkssRUFBcUssT0FBTSxRQUEzSztBQUNFLHVDQUFPLE1BQUssT0FBWixFQUFvQixPQUFNLGFBQTFCLEdBREY7QUFFRSx1Q0FBTyxNQUFLLG1CQUFaLEVBQWdDLE9BQU0sUUFBdEMsR0FGRjtBQUdFLHVDQUFPLE1BQUssaUJBQVosRUFBOEIsT0FBTSxPQUFwQyxHQUhGO0FBSUUsdUNBQU8sTUFBSyxPQUFaLEVBQW9CLE9BQU8sS0FBSzZDLEtBQUwsQ0FBV2dpRCxRQUF0QyxHQUpGO0FBS0UsdUNBQU8sTUFBSyxNQUFaLEVBQW1CLE9BQU0sT0FBekIsR0FMRjtBQU1FLHVDQUFPLE1BQUssTUFBWixFQUFtQixPQUFNLE9BQXpCLEdBTkY7QUFPRSx1Q0FBTyxNQUFLLFNBQVosRUFBc0IsT0FBTSxNQUE1QixHQVBGO0FBUUUsdUNBQU8sTUFBSyxTQUFaLEVBQXNCLE9BQU0sU0FBNUIsR0FSRjtBQVNFLHVDQUFPLE1BQUssV0FBWixFQUF3QixPQUFPRCxTQUEvQjtBQVRGLE9BREY7QUFhRDs7QUFFRDs7Ozs7Ozs7d0NBS3FCO0FBQUE7O0FBQ25CLFdBQUs3a0QsUUFBTCxDQUFjLEVBQUU2NkMsaUJBQWlCLElBQW5CLEVBQWQsRUFDRSxZQUFNO0FBQUUsZUFBSy8zQyxLQUFMLENBQVcyZ0QsaUJBQVgsSUFBZ0MsT0FBSzNnRCxLQUFMLENBQVcyZ0QsaUJBQVgsRUFBaEM7QUFBZ0UsT0FEMUU7QUFFRDs7OzZCQUVTO0FBQUE7O0FBQ1IsVUFBTXNCLGlCQUFpQixLQUFLcm1ELEtBQUwsQ0FBVzZqRCxnQkFBWCxHQUNuQixLQUFLeUMsMEJBQUwsRUFEbUIsR0FFbkI7QUFDQSxlQUFPLEVBQUMxaUQsT0FBTyxNQUFSLEVBRFA7QUFFQSxzQkFGQTtBQUdBLGFBQUssZ0JBQUs7QUFBRSxpQkFBSzZnRCxhQUFMLEdBQXFCbGpELENBQXJCO0FBQXdCLFNBSHBDO0FBSUEsMEJBQWtCLEtBQUtnbEQsaUJBSnZCLEdBRko7O0FBUUEsYUFDRTtBQUFBO0FBQUE7QUFDRSxpQkFBTztBQUNMM2lELG1CQUFPLEtBQUs1RCxLQUFMLENBQVc2akQsZ0JBQVgsR0FBOEIsS0FBSzdqRCxLQUFMLENBQVc4akQsY0FBekMsR0FBMEQsTUFENUQ7QUFFTHZnRCxvQkFBUSxLQUFLdkQsS0FBTCxDQUFXNmpELGdCQUFYLEdBQThCLEtBQUs3akQsS0FBTCxDQUFXK2pELGVBQXpDLEdBQTJELE1BRjlEO0FBR0x0L0MscUJBQVMsT0FISjtBQUlMK2hELG9CQUFRLE1BSkg7QUFLTHhZLHNCQUFVO0FBTEwsV0FEVDtBQVFFLGVBQUssaUJBQU07QUFBRSxtQkFBSytYLFVBQUwsR0FBa0JwWixFQUFsQjtBQUFzQixXQVJyQztBQVNJMFo7QUFUSixPQURGO0FBYUQ7Ozs7RUExUitDNW9ELHNCOztrQkFBN0JtbUQsb0I7OztBQTZSckJBLHFCQUFxQjU2QyxTQUFyQixHQUFpQztBQUMvQm85QyxZQUFVbG9ELG1CQUFVb2dELE1BRFc7QUFFL0J5RyxxQkFBbUI3bUQsbUJBQVVtZ0IsSUFGRTtBQUcvQnNtQyxpQkFBZXptRCxtQkFBVW1nQjtBQUhNLENBQWpDLEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaFNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUF0QkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQXNCQSxJQUFNb29DLHNCQUFzQixHQUE1Qjs7SUFDcUJ4TSxxQjs7O0FBQ25CLG1DQUFzQjtBQUFBOztBQUFBOztBQUFBLHNDQUFONzBDLElBQU07QUFBTkEsVUFBTTtBQUFBOztBQUFBLHlLQUNYQSxJQURXOztBQUdwQixVQUFLc2hELGlCQUFMLEdBQXlCeDJCLG1DQUF6Qjs7QUFFQSxVQUFLbndCLFFBQUwsQ0FDRSxrQkFERixFQUVFLGNBRkYsRUFHRSxpQkFIRixFQUlFLHFCQUpGLEVBS0UsZ0JBTEYsRUFNRSxhQU5GLEVBT0UsZ0JBUEY7O0FBVUEsVUFBSzRtRCxzQkFBTCxHQUE4QixFQUE5QjtBQUNBLFVBQUszbUQsS0FBTCxHQUFhO0FBQ1gyeEIsWUFBTSxJQURLO0FBRVhub0IsZ0JBQVVvOUMsa0JBRkM7QUFHWEMsbUJBQWEsSUFIRjtBQUlYM3pDLG1CQUFhLElBQUl0VixvQkFBSjtBQUpGLEtBQWI7O0FBT0EsVUFBSzZuQixPQUFMLEdBQWUsSUFBSXNMLGdCQUFKLENBQ2IsTUFBS3JyQixPQUFMLENBQWE0RSxFQURBLEVBRWIsTUFBSzVFLE9BQUwsQ0FBYU0sT0FGQSxFQUdiLE1BQUtOLE9BQUwsQ0FBYXNFLFFBSEEsQ0FBZjtBQUtBLFVBQUt5YixPQUFMLENBQWF2bUIsRUFBYixDQUFnQixXQUFoQixFQUE2QixNQUFLNG5ELFdBQWxDO0FBQ0EsVUFBS3JoQyxPQUFMLENBQWF2bUIsRUFBYixDQUFnQixPQUFoQixFQUF5QixNQUFLNm5ELFlBQTlCO0FBQ0EsVUFBS3RoQyxPQUFMLENBQWF2bUIsRUFBYixDQUFnQixRQUFoQixFQUEwQixNQUFLOG5ELGNBQS9CO0FBQ0EsVUFBS3ZoQyxPQUFMLENBQWF2bUIsRUFBYixDQUFnQixjQUFoQixFQUFnQyxNQUFLK25ELGNBQXJDOztBQUVBLFVBQUtDLGlCQUFMLEdBQXlCLEtBQXpCOztBQUVBLFVBQUtDLGNBQUwsR0FBc0IsTUFBS3poRCxPQUFMLENBQWFNLE9BQWIsQ0FBcUJPLE1BQXJCLENBQTRCNGdDLGFBQWxEO0FBQ0EsVUFBS2lnQixrQkFBTCxHQUEwQixDQUExQjtBQXBDb0I7QUFxQ3JCOztBQUVEOztBQUVBOzs7Ozs7O3dDQUdxQjtBQUFBOztBQUNuQjs7QUFEbUIsVUFHWHBoRCxPQUhXLEdBR0MsS0FBS04sT0FITixDQUdYTSxPQUhXO0FBQUEsa0NBSVUsS0FBS04sT0FBTCxDQUFhTSxPQUFiLENBQXFCTyxNQUovQjtBQUFBLFVBSVg4UixLQUpXLHlCQUlYQSxLQUpXO0FBQUEsVUFJSit1QixTQUpJLHlCQUlKQSxTQUpJOzs7QUFNbkIsV0FBS3pSLFFBQUwsQ0FBY3RkLEtBQWQ7QUFDQSxXQUFLb04sT0FBTCxDQUFhL1QsTUFBYjs7QUFFQSxXQUFLK1QsT0FBTCxDQUFhdm1CLEVBQWIsQ0FBZ0IsT0FBaEIsRUFBeUIsWUFBTTtBQUM3QixZQUFJa29DLFNBQUosRUFBZTtBQUNiLGlCQUFLaWdCLHlCQUFMO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsaUJBQUtDLHlCQUFMO0FBQ0Q7QUFDRixPQU5EOztBQVFBLFVBQUl0aEQsUUFBUThnQyxVQUFaLEVBQXdCO0FBQ3RCNXBDLGVBQU91RixnQkFBUCxDQUF3QixRQUF4QixFQUFrQyxLQUFLOGtELGVBQXZDO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7OzJDQUd3QjtBQUN0Qjs7QUFFQSxXQUFLOWhDLE9BQUwsQ0FBYTNULE9BQWI7QUFIc0IsVUFJZDlMLE9BSmMsR0FJRixLQUFLTixPQUpILENBSWRNLE9BSmM7O0FBS3RCLFVBQUlBLFFBQVE4Z0MsVUFBWixFQUF3QjtBQUN0QjVwQyxlQUFPMEYsbUJBQVAsQ0FBMkIsUUFBM0IsRUFBcUMsS0FBSzJrRCxlQUExQztBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7bUNBSWdCO0FBQ2QsV0FBSzloQyxPQUFMLENBQWFXLEtBQWI7QUFDRDs7QUFFRDs7OztnREFFNkI7QUFDM0IsVUFBTW9oQyxvQkFBb0IsS0FBSy9oQyxPQUFMLENBQWFqYyxRQUFiLENBQXNCQyxZQUF0QixFQUExQjtBQUNBLFVBQU1nK0MsZ0JBQWdCRCxrQkFBa0IsV0FBbEIsQ0FBdEI7O0FBRUEsVUFBSSxDQUFDQyxhQUFMLEVBQW9CO0FBQ2xCO0FBQ0Q7O0FBRUQsV0FBS0MsZ0JBQUwsQ0FBc0JELGFBQXRCLEVBQXFDLEVBQXJDLEVBQXlDLElBQXpDLEVBQStDLEVBQUVyZ0IsV0FBVyxJQUFiLEVBQW1CdWdCLFdBQVcsSUFBOUIsRUFBL0M7QUFDQSxXQUFLVCxpQkFBTCxHQUF5QixJQUF6QjtBQUNEO0FBQ0Q7Ozs7Ozs7Z0RBSTZCO0FBQzNCLFVBQUksS0FBS0Usa0JBQUwsR0FBMEIsS0FBS0QsY0FBTCxDQUFvQi82QyxNQUFsRCxFQUEwRDtBQUFBLG9DQUMzQixLQUFLKzZDLGNBQUwsQ0FBb0IsS0FBS0Msa0JBQXpCLENBRDJCO0FBQUEsWUFDaEQxOUMsT0FEZ0QseUJBQ2hEQSxPQURnRDtBQUFBLFlBQ3ZDMUQsT0FEdUMseUJBQ3ZDQSxPQUR1Qzs7QUFFeEQsWUFBTXdoRCxvQkFBb0IsS0FBSy9oQyxPQUFMLENBQWFqYyxRQUFiLENBQXNCQyxZQUF0QixFQUExQjtBQUNBLFlBQU1nK0MsZ0JBQWdCRCxrQkFBa0I5OUMsT0FBbEIsQ0FBdEI7O0FBRUEsWUFBSWsrQyxlQUFlbHJELGtCQUFTeUwsUUFBVCxDQUFrQjtBQUNuQ3BDLHlCQUFlO0FBRG9CLFNBQWxCLEVBRWhCQyxPQUZnQixDQUFuQjs7QUFJQSxZQUFJLENBQUN5aEQsYUFBTCxFQUFvQjtBQUNsQixnQkFBTSxJQUFJNy9DLEtBQUosOERBQXNFOEIsT0FBdEUsT0FBTjtBQUNEOztBQUVELGFBQUtnK0MsZ0JBQUwsQ0FBc0JELGFBQXRCLEVBQXFDLEVBQXJDLEVBQXlDLElBQXpDLEVBQStDRyxZQUEvQztBQUNBLGFBQUtSLGtCQUFMO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQTs7Ozs7Ozs7bUNBS2dCN2xELEMsRUFBRztBQUNqQjVDLDZCQUFhc3dCLFFBQWIsQ0FBc0JPLFlBQXRCLENBQ0UsS0FBSzdNLEVBQUwsQ0FBUSxtQ0FBUixDQURGLEVBRUUsS0FBS0EsRUFBTCxDQUFRLGtDQUFSLENBRkYsRUFHRSxJQUhGO0FBS0Eza0IsbUJBQUl5eEIsS0FBSixDQUFVLEtBQUsvdkIsV0FBTCxDQUFpQjhWLElBQTNCLEVBQWlDLHdDQUF3Q2pVLEVBQUVtdUIsT0FBM0U7QUFDRDs7QUFFRDs7Ozs7OztrQ0FJZTtBQUNiLFdBQUtnNEIsZ0JBQUwsQ0FBc0JkLGtCQUF0QjtBQUNEOztBQUVEOzs7Ozs7O3FDQUlrQjtBQUFBOztBQUNoQixVQUFNckgsZUFBZTVnRCx1QkFBYXN3QixRQUFiLENBQXNCdXdCLGNBQXRCLENBQXFDLEtBQUs3OEIsRUFBTCxDQUFRLDRCQUFSLENBQXJDLENBQXJCO0FBQ0EsV0FBSzhDLE9BQUwsQ0FBYWtnQixJQUFiLENBQWtCLFNBQWxCLEVBQTZCLGlCQUE0QjtBQUFBLFlBQXpCemhCLFVBQXlCLFNBQXpCQSxVQUF5QjtBQUFBLFlBQWIwUCxNQUFhLFNBQWJBLE1BQWE7O0FBQ3ZEMnJCLHFCQUFhaHdCLEtBQWI7O0FBRUEsWUFBSSxPQUFLN3BCLE9BQUwsQ0FBYU0sT0FBYixDQUFxQk8sTUFBckIsQ0FBNEIyZ0Msb0JBQWhDLEVBQXNEO0FBQ3BEdm9DLGlDQUFhc3dCLFFBQWIsQ0FBc0I0NEIsY0FBdEIsQ0FDRSxPQUFLbGxDLEVBQUwsc0NBQTJDaVIsTUFBM0MsQ0FERixFQUVFLE9BQUtqUixFQUFMLHFDQUEwQ2lSLE1BQTFDLEVBQ0U7QUFDRXNCLDJCQUFlLE9BQUt6UCxPQUFMLENBQWFxTixnQkFBYixFQURqQjtBQUVFbHZCLG1CQUFPc2dCLFdBQVd4aUIsQ0FGcEI7QUFHRTZCLG9CQUFRMmdCLFdBQVd2aUI7QUFIckIsV0FERixDQUZGO0FBU0Q7QUFDRixPQWREO0FBZUQ7O0FBRUQ7Ozs7Ozs7c0NBSW1CO0FBQ2pCLFVBQUksS0FBS21tRCxjQUFULEVBQXlCO0FBQ3ZCNXFELGVBQU93d0MsWUFBUCxDQUFvQixLQUFLb2EsY0FBekI7QUFDQSxhQUFLQSxjQUFMLEdBQXNCLElBQXRCO0FBQ0Q7QUFDRCxXQUFLQSxjQUFMLEdBQXNCNXFELE9BQU82VSxVQUFQLENBQWtCLEtBQUtnMkMsbUJBQXZCLEVBQTRDdEIsbUJBQTVDLENBQXRCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7MENBSXVCO0FBQ3JCLFdBQUsxa0MsVUFBTCxDQUFnQnBrQixtQkFBVXNNLE1BQVYsQ0FBaUJxdUMsYUFBakM7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7Ozs7OztxQ0FPa0I5dUMsUSxFQUFtRTtBQUFBLFVBQXpEdytDLFlBQXlELHVFQUExQyxFQUEwQztBQUFBLFVBQXRDdnpCLFFBQXNDLHVFQUEzQixJQUEyQjtBQUFBLFVBQXJCd3pCLGNBQXFCLHVFQUFKLEVBQUk7O0FBQ25GLFVBQUlDLGNBQWMsSUFBbEI7QUFDQSxVQUFJMStDLGFBQWEsTUFBakIsRUFBeUI7QUFDdkIwK0Msc0JBQWMsS0FBS3ZCLHNCQUFMLENBQTRCNWhDLEdBQTVCLEVBQWQ7QUFDRCxPQUZELE1BRU8sSUFBSXZiLGFBQWEsTUFBYixJQUF1QkEsYUFBYW85QyxrQkFBeEMsRUFBMEQ7QUFDL0QsWUFBSSxLQUFLbGhELE9BQUwsQ0FBYU0sT0FBYixDQUFxQk8sTUFBckIsQ0FBNEI2Z0MsU0FBNUIsSUFBeUMsQ0FBQyxLQUFLOGYsaUJBQW5ELEVBQXNFO0FBQ3BFLGlCQUFPLEtBQUtHLHlCQUFMLEVBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsWUFBSSxLQUFLRCxrQkFBTCxHQUEwQixLQUFLRCxjQUFMLENBQW9CLzZDLE1BQWxELEVBQTBEO0FBQ3hELGlCQUFPLEtBQUtrN0MseUJBQUwsRUFBUDtBQUNEOztBQUVEWSxzQkFBY3RCLGtCQUFkO0FBQ0EsYUFBS0Qsc0JBQUwsR0FBOEIsRUFBOUI7QUFDRCxPQWJNLE1BYUE7QUFDTHVCLHNCQUFjMStDLFFBQWQ7QUFDQSxhQUFLbTlDLHNCQUFMLENBQTRCMW5ELElBQTVCLENBQWlDLEtBQUtlLEtBQUwsQ0FBV3dKLFFBQTVDO0FBQ0Q7O0FBRUQsVUFBTTIrQyxrQkFBa0IsS0FBS25vRCxLQUFMLENBQVd3SixRQUFYLEtBQXdCMCtDLFdBQWhEOztBQUVBO0FBQ0E7QUFDQSxVQUFJLEtBQUtsb0QsS0FBTCxDQUFXd0osUUFBWCxDQUFvQjQrQyxNQUF4QixFQUFnQztBQUM5QixhQUFLcG9ELEtBQUwsQ0FBV3dKLFFBQVgsQ0FBb0I0K0MsTUFBcEIsQ0FBMkI5WixJQUEzQixDQUNFLEtBQUt4cUMsSUFBTCxDQUFVMEYsUUFEWjtBQUdEOztBQUVELFdBQUt4SixLQUFMLENBQVdrVCxXQUFYLENBQXVCbTFDLEtBQXZCO0FBQ0EsV0FBS3JvRCxLQUFMLENBQVdrVCxXQUFYLENBQXVCdE4sR0FBdkIsQ0FBMkJvaUQsWUFBM0IsRUFBeUMsS0FBekM7O0FBRUEsVUFBSW5xQixrQkFBa0JuaEMsa0JBQVN5TCxRQUFULENBQ3BCekwsa0JBQVN5TCxRQUFULENBQ0U4L0MsY0FERixFQUVFLEtBQUt2aUQsT0FBTCxDQUFhTSxPQUFiLENBQXFCTyxNQUFyQixDQUE0QnMzQixlQUE1QixDQUE0Q3FxQixZQUFZMWlELFVBQXhELENBRkYsQ0FEb0IsRUFLcEIwaUQsWUFBWXJoRCxjQUxRLENBQXRCOztBQVFBO0FBQ0EsVUFBSXFoRCxZQUFZSSxPQUFoQixFQUF5QjtBQUN2Qkosb0JBQVlJLE9BQVosQ0FBb0JoYSxJQUFwQixDQUF5QixLQUFLeHFDLElBQUwsQ0FBVTBGLFFBQW5DLEVBQ0UsS0FBS3hKLEtBQUwsQ0FBV2tULFdBRGIsRUFFRTJxQixlQUZGO0FBR0Q7O0FBRUQsVUFBSXNxQixlQUFKLEVBQXFCO0FBQ25CLGFBQUs3bUQsUUFBTCxDQUFjO0FBQ1prSSxvQkFBVTArQyxXQURFO0FBRVpycUI7QUFGWSxTQUFkLEVBR0dwSixRQUhIO0FBSUQsT0FMRCxNQUtPO0FBQ0wsZUFBT0EsWUFBWUEsVUFBbkI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7OzhCQUlXO0FBQ1QsYUFBTyxLQUFLejBCLEtBQUwsQ0FBVzJ4QixJQUFsQjtBQUNEOztBQUVEOzs7Ozs7Ozs4QkFLaUI7QUFBQTs7QUFBQSx5Q0FBTnZzQixJQUFNO0FBQU5BLFlBQU07QUFBQTs7QUFDZixhQUFPLElBQUkzSSxPQUFKLENBQVksVUFBQzZlLE9BQUQsRUFBVUMsTUFBVixFQUFxQjtBQUN0QyxlQUFLbXNDLGdCQUFMLENBQXNCLE1BQXRCLEVBQThCLEVBQTlCLEVBQWtDLFlBQU07QUFBQTs7QUFDdEMsNEJBQUtqaUMsT0FBTCxFQUFhcVEsTUFBYixnQkFBdUIxd0IsSUFBdkIsRUFDR21HLElBREgsQ0FDUStQLE9BRFIsRUFFR29JLEtBRkgsQ0FFU25JLE1BRlQ7QUFHRCxTQUpEO0FBS0QsT0FOTSxDQUFQO0FBT0Q7O0FBRUQ7Ozs7Ozs7Z0NBSWE7QUFDWCxhQUFPLEtBQUtrSyxPQUFaO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Z0NBSW9CO0FBQUE7O0FBQ2xCLGFBQU8saUJBQUtBLE9BQUwsRUFBYTZRLFNBQWIsMkJBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Z0NBS2E3M0IsSSxFQUFNO0FBQ2pCLGFBQU8sS0FBS2duQixPQUFMLENBQWE4USxXQUFiLENBQXlCOTNCLElBQXpCLENBQVA7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7Ozs7c0NBS21CO0FBQ2pCLGFBQU8sS0FBS2duQixPQUFMLENBQWErTCxPQUFiLENBQXFCKzJCLFdBQXJCLEVBQVA7QUFDRDs7QUFFRDs7Ozs7OztzQ0FJbUI7QUFDakIsYUFBTztBQUNMaGlELGdCQUFRLEtBQUtrZixPQURSO0FBRUxuYixZQUFJLEtBQUs1RSxPQUFMLENBQWE0RSxFQUZaO0FBR0x0RSxpQkFBUyxLQUFLTixPQUFMLENBQWFNLE9BSGpCO0FBSUx5a0Msc0JBQWMsSUFKVDtBQUtMemdDLGtCQUFVLEtBQUt0RSxPQUFMLENBQWFzRSxRQUxsQjtBQU1MdkUscUJBQWEsS0FBS0MsT0FBTCxDQUFhRDtBQU5yQixPQUFQO0FBUUQ7O0FBRUQ7Ozs7Ozs7OzZCQUtVNFMsSyxFQUFPa2EsVyxFQUFhO0FBQzVCLFdBQUs2MEIsa0JBQUwsR0FBMEIsQ0FBMUI7QUFDQSxXQUFLM2hDLE9BQUwsQ0FBYWtRLFFBQWIsQ0FBc0J0ZCxLQUF0QixFQUE2QmthLFdBQTdCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O29DQUtpQjtBQUNmLFVBQU1wdEIsb0JBQW9CLEtBQUtuRixLQUFMLENBQVd3SixRQUFYLENBQW9CL0MsaUJBQTlDO0FBQ0EsVUFBSXlDLDBCQUEwQixLQUFLbEosS0FBTCxDQUFXd0osUUFBWCxDQUFvQjlDLHVCQUFsRDtBQUNBLFVBQUksQ0FBQ3dDLHVCQUFMLEVBQThCO0FBQzVCQSxrQ0FBMEIwOUMsbUJBQWlCbGdELHVCQUEzQztBQUNEO0FBQ0QsVUFBSThoRCwwQkFBMEIsS0FBS3hvRCxLQUFMLENBQVd3SixRQUFYLENBQW9CaEQsdUJBQWxEO0FBQ0EsVUFBSSxDQUFDZ2lELHVCQUFMLEVBQThCO0FBQzVCQSxrQ0FBMEI1QixtQkFBaUJwZ0QsdUJBQTNDO0FBQ0Q7O0FBRUQsVUFBSWdELGlCQUFKO0FBQUEsVUFBY2kvQyx1QkFBZDtBQUFBLFVBQThCQyx1QkFBOUI7O0FBRUEsVUFBSUYsMkJBQTJCLEtBQUs5aUQsT0FBTCxDQUFhTSxPQUFiLENBQXFCNmdDLFVBQXBELEVBQWdFO0FBQzlENmhCLHlCQUFrQixnQ0FBQyx1QkFBRDtBQUNoQix1QkFBYSxLQUFLMW9ELEtBQUwsQ0FBV2tULFdBRFI7QUFFaEIsbUJBQVMsS0FBS2xULEtBQUwsQ0FBVzY5QixlQUZKO0FBR2hCLGVBQUssS0FBS3o1QixLQUFMLENBQVc2MkMsR0FIQTtBQUloQixlQUFJLGdCQUpZLEdBQWxCO0FBS0Q7O0FBRUQsVUFBSTkxQyxpQkFBSixFQUF1QjtBQUNyQnFFLG1CQUFZLGdDQUFDLGlCQUFEO0FBQ1YsNEJBQWtCLEtBQUtrK0MsZ0JBRGI7QUFFVix1QkFBYSxLQUFLMW5ELEtBQUwsQ0FBV2tULFdBRmQ7QUFHVixtQkFBUyxLQUFLbFQsS0FBTCxDQUFXNjlCLGVBSFY7QUFJVixlQUFLLEtBQUt6NUIsS0FBTCxDQUFXNjJDLEdBSk47QUFLVixlQUFLLEtBQUtqN0MsS0FBTCxDQUFXd0osUUFBWCxDQUFvQmhFLFVBQXBCLEdBQWlDLFdBTDVCO0FBTVYsZUFBSSxVQU5NLEdBQVo7QUFPRDs7QUFFRCxVQUFJMEQsdUJBQUosRUFBNkI7QUFDM0J1L0MseUJBQWtCLGdDQUFDLHVCQUFEO0FBQ2hCLDRCQUFrQixLQUFLZixnQkFEUDtBQUVoQix1QkFBYSxLQUFLMW5ELEtBQUwsQ0FBV2tULFdBRlI7QUFHaEIsbUJBQVMsS0FBS2xULEtBQUwsQ0FBVzY5QixlQUhKO0FBSWhCLGVBQUssS0FBS3o1QixLQUFMLENBQVc2MkMsR0FKQTtBQUtoQixlQUFLLEtBQUtqN0MsS0FBTCxDQUFXd0osUUFBWCxDQUFvQmhFLFVBQXBCLEdBQWlDLGlCQUx0QjtBQU1oQixlQUFJLGdCQU5ZLEdBQWxCO0FBT0Q7O0FBRUQsVUFBSTQ0QyxlQUFlLGlCQUFuQjtBQUNBLFVBQUksQ0FBQyxLQUFLMTRDLE9BQUwsQ0FBYU0sT0FBYixDQUFxQjJDLFVBQTFCLEVBQXNDO0FBQ3BDeTFDLHdCQUFnQixhQUFoQjtBQUNEOztBQUVELGFBQVE7QUFBQTtBQUFBLFVBQUssS0FBS0EsWUFBVjtBQUNMc0ssc0JBREs7QUFHTjtBQUFDLG1DQUFEO0FBQUE7QUFDRSxpQkFBSSxRQUROO0FBRUUsMkJBQWUsS0FBSzFvRCxLQUFMLENBQVd3SixRQUFYLENBQW9CbS9DLG1CQUZyQztBQUdHRjtBQUhILFNBSE07QUFTTjtBQUFBO0FBQUEsWUFBSyxLQUFJLGdDQUFUO0FBQ0U7QUFBQTtBQUFBLGNBQUssS0FBSSxRQUFUO0FBQ0dqL0M7QUFESDtBQURGO0FBVE0sT0FBUjtBQWVEOzs7O0VBMVpnRGQseUI7O2tCQUE5QnV4QyxxQjs7O0FBNlpyQkEsc0JBQXNCYyxpQkFBdEIsR0FBMEM7QUFDeEN6d0MsTUFBSXBNLG1CQUFVc3NDLE1BQVYsQ0FBaUJ3USxVQURtQjtBQUV4Q3owQyxVQUFRckksbUJBQVVzc0MsTUFBVixDQUFpQndRLFVBRmU7QUFHeENoeEMsWUFBVTlMLG1CQUFVc3NDLE1BQVYsQ0FBaUJ3USxVQUhhO0FBSXhDaDFDLFdBQVM5SCxtQkFBVXNzQyxNQUFWLENBQWlCd1EsVUFKYztBQUt4Q3ZRLGdCQUFjdnNDLG1CQUFVc3NDLE1BQVYsQ0FBaUJ3USxVQUxTO0FBTXhDdjFDLGVBQWF2SCxtQkFBVXNzQyxNQUFWLENBQWlCd1E7QUFOVSxDQUExQzs7QUFTQWYsc0JBQXNCLzBDLFlBQXRCLEdBQXFDd0QsMEJBQWdCeEQsWUFBckQsQzs7Ozs7Ozs7Ozs7Ozs7O0FDL2FBOzs7Ozs7K2VBaEJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFnQnFCMGpELG1COzs7Ozs7Ozs7Ozs7QUFDbkI7Ozs7b0NBSWlCO0FBQ2YsYUFBUTtBQUFBO0FBQUEsVUFBSyxXQUFVLGFBQWY7QUFDTjtBQUFBO0FBQUEsWUFBSyxLQUFJLHNCQUFUO0FBQ0U7QUFBQTtBQUFBLGNBQUssS0FBSSxnQkFBVCxFQUEwQixTQUFTLEtBQUt4a0QsS0FBTCxDQUFXa08sT0FBOUM7QUFDRSxxREFBSyxLQUFJLFFBQVQsRUFBa0IsS0FBSyxLQUFLME0sYUFBTCxDQUFtQixtQkFBbkIsRUFBd0MsSUFBeEMsQ0FBdkI7QUFERjtBQURGO0FBRE0sT0FBUjtBQU9EOzs7O0VBYjhDdmhCLHNCOztrQkFBNUJtckQsbUI7OztBQWdCckJBLG9CQUFvQjFqRCxZQUFwQixHQUFtQ3pILHVCQUFjeUgsWUFBakQsQzs7Ozs7Ozs7Ozs7Ozs7O0FDbEJBOzs7Ozs7K2VBaEJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFnQnFCMmpELG1COzs7Ozs7Ozs7Ozs7QUFDbkI7Ozs7b0NBSWlCO0FBQ2YsYUFBUTtBQUFBO0FBQUEsVUFBSyxXQUFVLGFBQWY7QUFDTjtBQUFBO0FBQUEsWUFBSyxLQUFJLHNCQUFUO0FBQ0U7QUFBQTtBQUFBLGNBQUssS0FBSSxnQkFBVCxFQUEwQixTQUFTLEtBQUt6a0QsS0FBTCxDQUFXa08sT0FBOUM7QUFDRSxxREFBSyxLQUFJLFFBQVQsRUFBa0IsS0FBSyxLQUFLME0sYUFBTCxDQUFtQixtQkFBbkIsRUFBd0MsSUFBeEMsQ0FBdkI7QUFERjtBQURGO0FBRE0sT0FBUjtBQU9EOzs7O0VBYjhDdmhCLHNCOztrQkFBNUJvckQsbUI7OztBQWdCckJBLG9CQUFvQjNqRCxZQUFwQixHQUFtQ3pILHVCQUFjeUgsWUFBakQsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsQkE7Ozs7Ozs7OytlQWhCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBa0JxQjRqRCxlOzs7QUFDbkIsNkJBQXNCO0FBQUE7O0FBQUE7O0FBQUEsc0NBQU4xakQsSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEsNkpBQ1hBLElBRFc7O0FBR3BCLFVBQUtyRixRQUFMLENBQ0UsY0FERixFQUVFLGFBRkYsRUFHRSxZQUhGLEVBSUUsaUJBSkYsRUFLRSxvQkFMRixFQU1FLGVBTkY7O0FBU0EsVUFBS3FRLE9BQUwsdURBQ0d6UyxtQkFBVXNNLE1BQVYsQ0FBaUJxdUMsYUFEcEIsRUFDb0MsTUFBS2lQLGVBRHpDLGtDQUVHNXBELG1CQUFVc00sTUFBVixDQUFpQml1QyxnQkFGcEIsRUFFdUMsTUFBSzZRLGtCQUY1Qzs7QUFLQSxVQUFLQyxrQkFBTCxHQUEwQixLQUExQjs7QUFFQSxVQUFLaHBELEtBQUwsR0FBYTtBQUNYaXBELHNCQUFnQixJQUFJanNELGdCQUFKLEVBREw7QUFFWGtzRCxvQkFBYyxJQUFJbHNELGdCQUFKO0FBRkgsS0FBYjtBQW5Cb0I7QUF1QnJCOztBQUVEOztBQUVBOzs7Ozs7OztzQ0FJbUI7QUFBQSxVQUNUdUosTUFEUyxHQUNFLEtBQUtiLE9BRFAsQ0FDVGEsTUFEUzs7QUFFakIsVUFBTSt4QixNQUFNL3hCLE9BQU9neUIsTUFBUCxFQUFaO0FBQ0FELFVBQUk2d0IsUUFBSixDQUFhLEtBQUtDLHVCQUFMLEVBQWI7QUFDQTdpRCxhQUFPb3JCLElBQVAsQ0FBWS9yQixHQUFaLENBQWdCLE1BQWhCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O3VDQUtvQnlqRCxXLEVBQWE7QUFDL0IsVUFBSUEsWUFBWWhxRCxPQUFaLENBQW9CLE1BQXBCLE1BQWdDLENBQUMsQ0FBckMsRUFBd0M7QUFDdEMsYUFBSzBLLFdBQUw7QUFDRDtBQUNGOztBQUVEOztBQUVBOzs7Ozs7d0NBR3FCO0FBQ25COztBQURtQixVQUdYeEQsTUFIVyxHQUdBLEtBQUtiLE9BSEwsQ0FHWGEsTUFIVzs7QUFJbkIsVUFBTWlzQixXQUFXanNCLE9BQU9rc0IsV0FBUCxFQUFqQjs7QUFKbUIsa0JBTVksS0FBSzN1QixJQU5qQjtBQUFBLFVBTVh3bEQsVUFOVyxTQU1YQSxVQU5XO0FBQUEsVUFNQy91QyxNQU5ELFNBTUNBLE1BTkQ7O0FBT25CLFVBQU0zVyxRQUFRMGxELFdBQVd2b0QsV0FBekI7QUFDQSxVQUFNd0MsU0FBUytsRCxXQUFXbG9ELFlBQTFCO0FBQ0FveEIsZUFBUysyQixTQUFULENBQW1CaHZDLE1BQW5CO0FBQ0FpWSxlQUFTMjJCLFFBQVQsQ0FBa0IsSUFBSW5zRCxnQkFBSixDQUFZNEcsS0FBWixFQUFtQkwsTUFBbkIsQ0FBbEIsRUFBOEMsSUFBOUM7O0FBRUFnRCxhQUFPb3JCLElBQVAsQ0FBWXp5QixFQUFaLENBQWUsS0FBZixFQUFzQixLQUFLc3FELGFBQTNCO0FBQ0Q7O0FBRUQ7Ozs7OzsyQ0FHd0I7QUFBQSxVQUNkampELE1BRGMsR0FDSCxLQUFLYixPQURGLENBQ2RhLE1BRGM7O0FBRXRCQSxhQUFPb3JCLElBQVAsQ0FBWXZuQixHQUFaLENBQWdCLEtBQWhCLEVBQXVCLEtBQUtvL0MsYUFBNUI7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7OztvQ0FJaUI7QUFDZixXQUFLei9DLFdBQUw7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7Ozs7aUNBS2N4SSxDLEVBQUc7QUFBQSxVQUNQZ0YsTUFETyxHQUNJLEtBQUtiLE9BRFQsQ0FDUGEsTUFETzs7QUFFZixVQUFJLENBQUNBLE9BQU95ckIsUUFBUCxDQUFnQnRCLFNBQWhCLENBQTBCLE1BQTFCLENBQUwsRUFBd0M7O0FBRXhDbnZCLFFBQUV5RixjQUFGOztBQUVBLFdBQUt5aUQsa0JBQUwsR0FBMEI5c0QsZUFBTW1GLGdCQUFOLENBQXVCUCxFQUFFczdDLFdBQXpCLENBQTFCO0FBQ0EsV0FBSzZNLGtCQUFMLEdBQTBCbmpELE9BQU9vd0IsU0FBUCxHQUFtQjMwQixLQUFuQixFQUExQjtBQUNBUSxlQUFTQyxnQkFBVCxDQUEwQixXQUExQixFQUF1QyxLQUFLMEUsV0FBNUM7QUFDQTNFLGVBQVNDLGdCQUFULENBQTBCLFdBQTFCLEVBQXVDLEtBQUswRSxXQUE1QztBQUNBM0UsZUFBU0MsZ0JBQVQsQ0FBMEIsU0FBMUIsRUFBcUMsS0FBSzJFLFVBQTFDO0FBQ0E1RSxlQUFTQyxnQkFBVCxDQUEwQixVQUExQixFQUFzQyxLQUFLMkUsVUFBM0M7QUFDRDs7QUFFRDs7Ozs7Ozs7Z0NBS2E3RixDLEVBQUc7QUFDZCxVQUFNb29ELGdCQUFnQmh0RCxlQUFNbUYsZ0JBQU4sQ0FBdUJQLENBQXZCLENBQXRCO0FBQ0EsVUFBTXFvRCxnQkFBZ0JELGNBQ25CM25ELEtBRG1CLEdBRW5CTyxRQUZtQixDQUVWLEtBQUtrbkQsa0JBRkssQ0FBdEI7O0FBSUEsVUFBTXZ5QixZQUFZLEtBQUt3eUIsa0JBQUwsQ0FDZjFuRCxLQURlLEdBRWYyTSxHQUZlLENBRVhpN0MsYUFGVyxDQUFsQjs7QUFOYyxVQVVOcmpELE1BVk0sR0FVSyxLQUFLYixPQVZWLENBVU5hLE1BVk07O0FBV2QsVUFBTXNqRCxhQUFhdGpELE9BQU9vd0IsU0FBUCxHQUFtQjMwQixLQUFuQixFQUFuQjtBQUNBdUUsYUFBT2t3QixTQUFQLENBQWlCUyxTQUFqQjtBQUNBLFVBQUksQ0FBQzN3QixPQUFPb3dCLFNBQVAsR0FBbUIyTCxNQUFuQixDQUEwQnVuQixVQUExQixDQUFMLEVBQTRDO0FBQzFDdGpELGVBQU9tTCxNQUFQO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7K0JBS1luUSxDLEVBQUc7QUFDYmlCLGVBQVNJLG1CQUFULENBQTZCLFdBQTdCLEVBQTBDLEtBQUt1RSxXQUEvQztBQUNBM0UsZUFBU0ksbUJBQVQsQ0FBNkIsV0FBN0IsRUFBMEMsS0FBS3VFLFdBQS9DO0FBQ0EzRSxlQUFTSSxtQkFBVCxDQUE2QixTQUE3QixFQUF3QyxLQUFLd0UsVUFBN0M7QUFDQTVFLGVBQVNJLG1CQUFULENBQTZCLFVBQTdCLEVBQXlDLEtBQUt3RSxVQUE5QztBQUNEOztBQUVEOztBQUVBOzs7Ozs7Ozs4Q0FLMkI7QUFBQSxVQUNqQmtpRCxVQURpQixHQUNGLEtBQUt4bEQsSUFESCxDQUNqQndsRCxVQURpQjs7QUFFekIsYUFBTyxJQUFJdHNELGdCQUFKLENBQVlzc0QsV0FBV3ZvRCxXQUF2QixFQUFvQ3VvRCxXQUFXbG9ELFlBQS9DLENBQVA7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7Ozt5Q0FJc0I7QUFDcEIsYUFBTztBQUNMaUIsYUFBSyxLQUFLckMsS0FBTCxDQUFXaXBELGNBQVgsQ0FBMEJ0bkQsQ0FBMUIsR0FBOEIsS0FBSzNCLEtBQUwsQ0FBV2twRCxZQUFYLENBQXdCdm5ELENBRHREO0FBRUxTLGNBQU0sS0FBS3BDLEtBQUwsQ0FBV2lwRCxjQUFYLENBQTBCdm5ELENBQTFCLEdBQThCLEtBQUsxQixLQUFMLENBQVdrcEQsWUFBWCxDQUF3QnhuRDtBQUZ2RCxPQUFQO0FBSUQ7O0FBRUQ7Ozs7Ozs7b0NBSWlCO0FBQ2YsVUFBSW9vRCxnQkFBZ0IsSUFBcEI7QUFDQSxVQUFJQyxtQkFBbUIsSUFBdkI7QUFDQSxVQUFJLEtBQUszbEQsS0FBTCxDQUFXNGxELGFBQWYsRUFBOEI7QUFDNUJELDJCQUFtQixLQUFLM2xELEtBQUwsQ0FBV0MsUUFBOUI7QUFDRCxPQUZELE1BRU87QUFDTHlsRCx3QkFBZ0IsS0FBSzFsRCxLQUFMLENBQVdDLFFBQTNCO0FBQ0Q7O0FBUGMsVUFTUGtDLE1BVE8sR0FTSSxLQUFLYixPQVRULENBU1BhLE1BVE87O0FBVWYsVUFBTTBqRCxpQkFBaUIxakQsT0FBTzJqRCxPQUFQLE1BQW9CM2pELE9BQU9vckIsSUFBUCxDQUFZaHNCLEdBQVosS0FBb0JZLE9BQU9vckIsSUFBUCxDQUFZdzRCLFVBQVosRUFBL0Q7QUFDQSxVQUFNdEQsY0FBY3RnRCxPQUFPeXJCLFFBQVAsQ0FBZ0J0QixTQUFoQixDQUEwQixNQUExQixLQUFxQ3U1QixjQUF6RDs7QUFFQSxhQUNFO0FBQUE7QUFBQSxVQUFLLEtBQUksNkJBQVQ7QUFDRTtBQUFBO0FBQUEsWUFBSyxLQUFJLG9CQUFULEVBQThCLEtBQUksWUFBbEM7QUFDRTtBQUFBO0FBQUE7QUFDRSxtQkFBSSxrQkFETjtBQUVFLHlCQUFXcEQsY0FBYyxjQUFkLEdBQStCLElBRjVDO0FBR0UsNEJBQWMsS0FBSy8rQyxZQUhyQjtBQUlFLDJCQUFhLEtBQUtBLFlBSnBCO0FBS0UscUJBQU8sS0FBS3NpRCxrQkFBTCxFQUxUO0FBTUU7QUFDRSxtQkFBSSxVQUROO0FBRUUsbUJBQUksUUFGTixHQU5GO0FBU0dOO0FBVEgsV0FERjtBQVlHQztBQVpIO0FBREYsT0FERjtBQWtCRDs7OztFQTVNMEN0c0Qsc0I7O2tCQUF4QnFyRCxlOzs7QUErTXJCQSxnQkFBZ0I1akQsWUFBaEIsR0FBK0J6SCx1QkFBY3lILFlBQTdDLEM7Ozs7Ozs7Ozs7Ozs7QUNwTkE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBbEJBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBbUJNMGhELGdCOzs7Ozs7Ozs7O0VBQXlCNWhCLGtCOztBQUkvQjs7Ozs7OztBQUtBNGhCLGlCQUFpQnBnRCx1QkFBakIsR0FBMkNxSCx5QkFBM0M7O0FBRUE7Ozs7O0FBS0ErNEMsaUJBQWlCbmdELGlCQUFqQixHQUFxQ3lwQixtQ0FBckM7O0FBRUE7Ozs7OztBQU1BMDJCLGlCQUFpQmxnRCx1QkFBakIsR0FBMkMyakQseUNBQTNDOztrQkFFZXpELGdCOzs7Ozs7Ozs7Ozs7Ozs7QUM5QmY7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFyQkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztJQXFCcUIwRCx1Qjs7Ozs7Ozs7Ozs7O0FBQ25COzs7O29DQUlpQjtBQUNmLFVBQUlDLGdCQUFnQixJQUFwQjtBQUNBLFVBQUksS0FBSzdrRCxPQUFMLENBQWFNLE9BQWIsQ0FBcUIwZ0MsWUFBekIsRUFBdUM7QUFDckM2akIsd0JBQWdCLGdDQUFDLGdDQUFELElBQXdCLEtBQUssS0FBS25tRCxLQUFMLENBQVc2MkMsR0FBeEMsR0FBaEI7QUFDRDs7QUFFRCxVQUFJdVAsZ0JBQWdCLElBQXBCO0FBQ0EsVUFBSSxLQUFLOWtELE9BQUwsQ0FBYU0sT0FBYixDQUFxQk8sTUFBckIsQ0FBNEJ5Z0MsVUFBaEMsRUFBNEM7QUFDMUN3akIsd0JBQWdCLGdDQUFDLHVCQUFELE9BQWhCO0FBQ0Q7O0FBRUQsYUFBUTtBQUFBO0FBQUEsVUFBSyxXQUFVLFdBQWY7QUFDTjtBQUFBO0FBQUEsWUFBSyxLQUFJLFFBQVQ7QUFDR0Q7QUFESCxTQURNO0FBS047QUFBQTtBQUFBLFlBQUssS0FBSSxTQUFUO0FBQ0UsMENBQUMsNkJBQUQsT0FERjtBQUVFLDBDQUFDLCtCQUFEO0FBRkYsU0FMTTtBQVVMQztBQVZLLE9BQVI7QUFZRDs7OztFQTVCa0QzOEMseUI7O2tCQUFoQ3k4Qyx1Qjs7O0FBK0JyQkEsd0JBQXdCcGxELFlBQXhCLEdBQXVDMkksMEJBQWdCM0ksWUFBdkQsQzs7Ozs7Ozs7Ozs7Ozs7O0FDdENBOztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBbEJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFrQnFCdWxELHNCOzs7QUFDbkIsb0NBQXNCO0FBQUE7O0FBQUE7O0FBQUEsc0NBQU5ybEQsSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEsMktBQ1hBLElBRFc7O0FBR3BCLFVBQUtyRixRQUFMLENBQ0UsWUFERixFQUVFLGdCQUZGO0FBSG9CO0FBT3JCOztBQUVEOztBQUVBOzs7Ozs7OzsrQkFJWXNZLEssRUFBTztBQUFBLFVBQ1Q5UixNQURTLEdBQ0UsS0FBS2IsT0FEUCxDQUNUYSxNQURTOztBQUVqQkEsYUFBTzBzQixLQUFQO0FBQ0Exc0IsYUFBT292QixRQUFQLENBQWdCdGQsS0FBaEI7QUFDQTlSLGFBQU9vckIsSUFBUCxDQUFZL3JCLEdBQVosQ0FBZ0IsTUFBaEI7QUFDRDs7QUFFRDs7Ozs7OztxQ0FJa0I7QUFBQSxVQUNSSSxPQURRLEdBQ0ksS0FBS04sT0FEVCxDQUNSTSxPQURROztBQUVoQixVQUFNMGtELGdCQUFpQjFrRCxRQUFRMmdDLFlBQVIsS0FBeUIsS0FBekIsSUFBa0NocUMsZUFBTTBELFFBQU4sRUFBekQ7QUFDQSxVQUFNc3FELG1CQUFtQixDQUFDLENBQUMza0QsUUFBUW9wQixTQUFSLENBQWtCck0sUUFBN0M7QUFDQSxVQUFJMm5DLGlCQUFpQixDQUFDQyxnQkFBdEIsRUFBd0M7QUFDdEMsYUFBSzdtRCxJQUFMLENBQVVxNUMsTUFBVixDQUFpQnRoQyxJQUFqQjtBQUNELE9BRkQsTUFFTyxJQUFJOHVDLGdCQUFKLEVBQXNCO0FBQzNCLGFBQUt2bUQsS0FBTCxDQUFXNjJDLEdBQVgsQ0FBZUwsY0FBZixDQUE4QixXQUE5QjtBQUNELE9BRk0sTUFFQTtBQUNMLGFBQUt4MkMsS0FBTCxDQUFXNjJDLEdBQVgsQ0FBZUwsY0FBZixDQUE4QixRQUE5QjtBQUNEO0FBQ0Y7O0FBRUQ7O0FBRUE7Ozs7Ozs7b0NBSWlCO0FBQUEsVUFDUDUwQyxPQURPLEdBQ0ssS0FBS04sT0FEVixDQUNQTSxPQURPOzs7QUFHZixVQUFJNGtELGNBQWMsSUFBbEI7QUFDQSxVQUFJNWtELFFBQVFvcEIsU0FBUixDQUFrQnJNLFFBQXRCLEVBQWdDO0FBQzlCNm5DLHNCQUFjLEtBQUtqb0MsRUFBTCxDQUFRLHFDQUFSLENBQWQ7QUFDRCxPQUZELE1BRU87QUFDTGlvQyxzQkFBYyxLQUFLam9DLEVBQUwsQ0FBUSx5QkFBUixDQUFkO0FBQ0Q7O0FBRUQsYUFBUTtBQUFBO0FBQUE7QUFDTix3Q0FBQyxrQ0FBRCxJQUEwQixXQUFXLEtBQUtqRSxVQUExQyxFQUFzRCxLQUFJLFFBQTFELEdBRE07QUFFTix3Q0FBQyx5QkFBRDtBQUNFLGlCQUFPa3NDLFdBRFQ7QUFFRSxnQkFBSyxnQkFGUDtBQUdFLG1CQUFTLEtBQUtsb0MsY0FIaEI7QUFGTSxPQUFSO0FBT0Q7Ozs7RUEvRGlEamxCLHNCOztrQkFBL0JndEQsc0I7OztBQWtFckJBLHVCQUF1QnZsRCxZQUF2QixHQUFzQ3pILHVCQUFjeUgsWUFBcEQsQzs7Ozs7Ozs7Ozs7Ozs7O0FDdEVBOztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBbEJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFrQnFCMmxELHFCOzs7QUFDbkIsbUNBQXNCO0FBQUE7O0FBQUE7O0FBQUEsc0NBQU56bEQsSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEseUtBQ1hBLElBRFc7O0FBR3BCLFVBQUtyRixRQUFMLENBQ0UsZ0JBREY7QUFIb0I7QUFNckI7O0FBRUQ7O0FBRUE7Ozs7Ozs7O3FDQUlrQjtBQUFBOztBQUFBLHFCQUMwQixLQUFLMkYsT0FEL0I7QUFBQSxVQUNSTSxPQURRLFlBQ1JBLE9BRFE7QUFBQSxVQUNDTyxNQURELFlBQ0NBLE1BREQ7QUFBQSxVQUNTa2tDLFlBRFQsWUFDU0EsWUFEVDs7QUFFaEIsVUFBTXFnQixnQkFBZ0I5a0QsUUFBUU8sTUFBUixDQUFldXZCLE1BQXJDOztBQUVBMlUsbUJBQWFpZCxnQkFBYixDQUE4QixNQUE5QixFQUFzQyxJQUF0QyxFQUE0QyxZQUFNO0FBQ2hELFlBQU1uSSxlQUFlNWdELHVCQUFhc3dCLFFBQWIsQ0FBc0J1d0IsY0FBdEIsQ0FBcUMsT0FBSzc4QixFQUFMLENBQVEsNkJBQVIsQ0FBckMsQ0FBckI7O0FBRUE7QUFDQTVRLG1CQUFXLFlBQU07QUFDZnhMLGlCQUFPdXZCLE1BQVAsQ0FBY2cxQixjQUFjbDFCLFFBQTVCLEVBQ0dycUIsSUFESCxDQUNRLFlBQU07QUFDVmcwQyx5QkFBYWh3QixLQUFiO0FBQ0QsV0FISCxFQUlHN0wsS0FKSCxDQUlTLFVBQUNuaUIsQ0FBRCxFQUFPO0FBQ1o1QyxtQ0FBYXN3QixRQUFiLENBQXNCTyxZQUF0QixDQUFtQyxPQUFLN00sRUFBTCxDQUFRLDBCQUFSLENBQW5DLEVBQXdFcGhCLEVBQUVtdUIsT0FBMUU7QUFDQTZ2Qix5QkFBYWh3QixLQUFiO0FBQ0QsV0FQSDtBQVFELFNBVEQsRUFTRyxHQVRIO0FBVUQsT0FkRDtBQWVEOztBQUVEOztBQUVBOzs7Ozs7O29DQUlpQjtBQUFBLFVBQ1B2cEIsT0FETyxHQUNLLEtBQUtOLE9BRFYsQ0FDUE0sT0FETzs7QUFFZixVQUFJLENBQUNBLFFBQVFPLE1BQVIsQ0FBZXV2QixNQUFmLENBQXNCd1IsVUFBM0IsRUFBdUMsT0FBTyxJQUFQOztBQUV2QyxhQUFRLGdDQUFDLHlCQUFEO0FBQ04sZUFBTSxNQURBO0FBRU4sZUFBTyxLQUFLM2tCLEVBQUwsQ0FBUSw0QkFBUixDQUZEO0FBR04sY0FBSyxtQkFIQztBQUlOLGlCQUFTLEtBQUtELGNBSlIsR0FBUjtBQUtEOzs7O0VBbkRnRGpsQixzQjs7a0JBQTlCb3RELHFCOzs7QUFzRHJCQSxzQkFBc0IzbEQsWUFBdEIsR0FBcUN6SCx1QkFBY3lILFlBQW5ELEM7Ozs7Ozs7Ozs7Ozs7OztBQzFEQTs7QUFDQTs7Ozs7Ozs7Ozs7OytlQWpCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBaUJxQjZsRCxtQjs7O0FBQ25CLGlDQUFzQjtBQUFBOztBQUFBOztBQUFBLHNDQUFOM2xELElBQU07QUFBTkEsVUFBTTtBQUFBOztBQUFBLHFLQUNYQSxJQURXOztBQUdwQixVQUFLckYsUUFBTCxDQUNFLGdCQURGLEVBRUUsbUJBRkYsRUFHRSxvQkFIRjs7QUFNQSxVQUFLcVEsT0FBTCx1REFDR3pTLG1CQUFVc00sTUFBVixDQUFpQmt1QyxlQURwQixFQUNzQyxNQUFLNlMsaUJBRDNDLGtDQUVHcnRELG1CQUFVc00sTUFBVixDQUFpQml1QyxnQkFGcEIsRUFFdUMsTUFBSzZRLGtCQUY1QztBQVRvQjtBQWFyQjs7QUFFRDs7QUFFQTs7Ozs7Ozs7eUNBSXNCO0FBQ3BCLFdBQUtoL0MsV0FBTDtBQUNEOztBQUVEOzs7Ozs7O3dDQUlxQjtBQUNuQixXQUFLQSxXQUFMO0FBQ0Q7O0FBRUQ7Ozs7Ozs7cUNBSWtCO0FBQUEsVUFDUnhELE1BRFEsR0FDRyxLQUFLYixPQURSLENBQ1JhLE1BRFE7O0FBRWhCQSxhQUFPaXJCLE9BQVAsQ0FBZXk1QixJQUFmO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7b0NBSWlCO0FBQUEsVUFDUDFrRCxNQURPLEdBQ0ksS0FBS2IsT0FEVCxDQUNQYSxNQURPOztBQUVmLFVBQUksQ0FBQ0EsT0FBT2lyQixPQUFQLENBQWUrMkIsV0FBZixFQUFMLEVBQW1DLE9BQU8sSUFBUDs7QUFFbkMsYUFBUSxnQ0FBQyx5QkFBRDtBQUNOLGVBQU8sS0FBSzVsQyxFQUFMLENBQVEsMEJBQVIsQ0FERDtBQUVOLGNBQUssaUJBRkM7QUFHTixpQkFBUyxLQUFLRCxjQUhSLEdBQVI7QUFJRDs7OztFQXpEOENqbEIsc0I7O2tCQUE1QnN0RCxtQjs7O0FBNERyQkEsb0JBQW9CN2xELFlBQXBCLEdBQW1DekgsdUJBQWN5SCxZQUFqRCxDOzs7Ozs7Ozs7Ozs7Ozs7QUMvREE7Ozs7Ozs7OytlQWhCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBZ0JxQmdtRCxhOzs7QUFDbkIsMkJBQXNCO0FBQUE7O0FBQUE7O0FBQUEsc0NBQU45bEQsSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEseUpBQ1hBLElBRFc7O0FBR3BCLFVBQUtyRixRQUFMLENBQ0UsaUJBREYsRUFFRSxnQkFGRixFQUdFLGFBSEYsRUFJRSxvQkFKRjs7QUFPQSxVQUFLcVEsT0FBTCx1REFDR3pTLG1CQUFVc00sTUFBVixDQUFpQkMsU0FEcEIsRUFDZ0MsTUFBS2loRCxXQURyQyxrQ0FFR3h0RCxtQkFBVXNNLE1BQVYsQ0FBaUJpdUMsZ0JBRnBCLEVBRXVDLE1BQUs2USxrQkFGNUM7QUFWb0I7QUFjckI7O0FBRUQ7O0FBRUE7Ozs7Ozs7O3lDQUlzQjtBQUNwQixXQUFLaC9DLFdBQUw7QUFDRDs7QUFFRDs7Ozs7OztrQ0FJZTtBQUNiLFdBQUtBLFdBQUw7QUFDRDs7QUFFRDs7Ozs7Ozs7b0NBS2lCeEksQyxFQUFHO0FBQUEsVUFDVmdGLE1BRFUsR0FDQyxLQUFLYixPQUROLENBQ1ZhLE1BRFU7O0FBRWxCLFVBQUksQ0FBQ0EsT0FBT3lyQixRQUFQLENBQWdCdEIsU0FBaEIsQ0FBMEIsTUFBMUIsQ0FBTCxFQUF3Qzs7QUFFeENucUIsYUFBT29yQixJQUFQLENBQVl5NUIsR0FBWjtBQUNEOztBQUVEOzs7Ozs7OzttQ0FLZ0I3cEQsQyxFQUFHO0FBQUEsVUFDVGdGLE1BRFMsR0FDRSxLQUFLYixPQURQLENBQ1RhLE1BRFM7O0FBRWpCLFVBQUksQ0FBQ0EsT0FBT3lyQixRQUFQLENBQWdCdEIsU0FBaEIsQ0FBMEIsTUFBMUIsQ0FBTCxFQUF3Qzs7QUFFeENucUIsYUFBT29yQixJQUFQLENBQVkwNUIsRUFBWjtBQUNEOztBQUVEOztBQUVBOzs7Ozs7O29DQUlpQjtBQUFBLFVBQ1A5a0QsTUFETyxHQUNJLEtBQUtiLE9BRFQsQ0FDUGEsTUFETzs7QUFFZixVQUFNb3JCLE9BQU9wckIsT0FBT29yQixJQUFQLENBQVloc0IsR0FBWixFQUFiO0FBQ0EsVUFBTW1MLFVBQVV2SyxPQUFPeXJCLFFBQVAsQ0FBZ0J0QixTQUFoQixDQUEwQixNQUExQixDQUFoQjs7QUFFQSxhQUNFO0FBQUE7QUFBQSxVQUFLLFdBQVUsZ0JBQWY7QUFDRTtBQUFBO0FBQUEsWUFBSyxLQUFJLFNBQVQ7QUFFRTtBQUFBO0FBQUEsY0FBSyxLQUFJLHFCQUFUO0FBQ0UsdUJBQVMsS0FBSzQ2QixlQURoQjtBQUVFLHlCQUFXeDZDLFVBQVUsSUFBVixHQUFpQixhQUY5QjtBQUdFLHFEQUFLLEtBQUksU0FBVCxFQUFtQixLQUFLLEtBQUtrTyxhQUFMLENBQW1CLG9CQUFuQixFQUF5QyxJQUF6QyxDQUF4QjtBQUhGLFdBRkY7QUFRRTtBQUFBO0FBQUEsY0FBSyxLQUFJLFNBQVQ7QUFDRyxpQkFBSzJELEVBQUwsQ0FBUSx5QkFBUixDQURIO0FBQ3NDLHVEQUR0QztBQUVHdG1CLGlCQUFLeVMsS0FBTCxDQUFXNmlCLE9BQU8sR0FBbEIsQ0FGSDtBQUFBO0FBQUEsV0FSRjtBQWFFO0FBQUE7QUFBQTtBQUNFLG1CQUFJLG9CQUROO0FBRUUsdUJBQVMsS0FBSzQ1QixjQUZoQjtBQUdFLHlCQUFXejZDLFVBQVUsSUFBVixHQUFpQixhQUg5QjtBQUlFLHFEQUFLLEtBQUksU0FBVCxFQUFtQixLQUFLLEtBQUtrTyxhQUFMLENBQW1CLG1CQUFuQixFQUF3QyxJQUF4QyxDQUF4QjtBQUpGO0FBYkY7QUFERixPQURGO0FBeUJEOzs7O0VBL0Z3Q3ZoQixzQjs7a0JBQXRCeXRELGE7OztBQWtHckJBLGNBQWNobUQsWUFBZCxHQUE2QnpILHVCQUFjeUgsWUFBM0MsQzs7Ozs7Ozs7Ozs7Ozs7O0FDcEdBOztBQUNBOzs7Ozs7Ozs7OytlQWpCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBaUJxQm1sRCwrQjs7O0FBQ25CLDZDQUFzQjtBQUFBOztBQUFBOztBQUFBLHNDQUFOamxELElBQU07QUFBTkEsVUFBTTtBQUFBOztBQUFBLDZMQUNYQSxJQURXOztBQUVwQixVQUFLckYsUUFBTCxDQUFjLFVBQWQ7QUFGb0I7QUFHckI7O0FBRUQ7O0FBRUE7Ozs7Ozs7Ozs2QkFLVXdCLEMsRUFBRztBQUNYLFdBQUs2UCxlQUFMLENBQXFCelUsZUFBTW1GLGdCQUFOLENBQXVCUCxDQUF2QixDQUFyQjtBQUNEOztBQUVEOztBQUVBOzs7Ozs7Ozt5Q0FLc0I7QUFDcEIsVUFBSSxDQUFDLEtBQUttRSxPQUFMLENBQWFhLE1BQWIsQ0FBb0IyakQsT0FBcEIsRUFBTCxFQUFvQztBQUNsQyxlQUFPLEVBQUU5bkQsTUFBTSxDQUFSLEVBQVdDLEtBQUssQ0FBaEIsRUFBbUJ1QixPQUFPLENBQTFCLEVBQTZCTCxRQUFRLENBQXJDLEVBQVA7QUFDRDs7QUFIbUIsa0NBS1ksS0FBS21DLE9BQUwsQ0FBYWEsTUFBYixDQUFvQmd5QixNQUFwQixHQUE2QmhCLFNBQTdCLEdBQXlDQyxTQUF6QyxFQUxaO0FBQUEsVUFLWjkxQixDQUxZLHlCQUtaQSxDQUxZO0FBQUEsVUFLVEMsQ0FMUyx5QkFLVEEsQ0FMUztBQUFBLFVBS05pQyxLQUxNLHlCQUtOQSxLQUxNO0FBQUEsVUFLQ0wsTUFMRCx5QkFLQ0EsTUFMRDs7QUFNcEIsYUFBTztBQUNMbkIsY0FBTVYsQ0FERDtBQUVMVyxhQUFLVixDQUZBO0FBR0xpQyxvQkFISztBQUlMTDtBQUpLLE9BQVA7QUFNRDs7QUFFRDs7QUFFQTs7Ozs7OztvQ0FJaUI7QUFDZixhQUFRO0FBQUE7QUFBQTtBQUNOLGVBQUksc0NBREU7QUFFTixlQUFJLFdBRkU7QUFHTjtBQUNFLGVBQUksb0NBRE47QUFFRSxlQUFJLGdCQUZOO0FBR0UsaUJBQU8sS0FBSzhPLGtCQUFMLEVBSFQ7QUFJRSxtQkFBUyxLQUFLbWIsUUFKaEI7QUFLRSx3QkFBYyxLQUFLQSxRQUxyQjtBQUhNLE9BQVI7QUFVRDs7OztFQXZEMER0a0IsaUM7O2tCQUF4Q21oRCwrQjs7O0FBMERyQkEsZ0NBQWdDbmxELFlBQWhDLEdBQStDZ0Usa0NBQXdCaEUsWUFBdkUsQzs7Ozs7Ozs7Ozs7OztxakJDN0VBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBY0E7O0FBQ0E7Ozs7Ozs7O0lBRXFCOHdCLFE7QUFDbkIsb0JBQWFzQyxHQUFiLEVBQWtCdHlCLE9BQWxCLEVBQTJCNHZCLFFBQTNCLEVBQXFDO0FBQUE7O0FBQ25DLFNBQUtsRSxJQUFMLEdBQVk0RyxHQUFaO0FBQ0EsU0FBSzl0QixRQUFMLEdBQWdCeEUsT0FBaEI7QUFDQSxTQUFLd2xELFNBQUwsR0FBaUI1MUIsUUFBakI7QUFDRDs7QUFFRDs7Ozs7Ozs7OEJBSVU7QUFBQTs7QUFDUixVQUFNNjFCLGFBQWEsS0FBS0MsY0FBTCxFQUFuQjs7QUFFQSxhQUFPLEtBQUtoNkIsSUFBTCxDQUFVb0UsTUFBVixDQUFpQjIxQixVQUFqQixFQUE2QixLQUFLamhELFFBQUwsQ0FBYzhTLE1BQTNDLEVBQW1ELEtBQUs5UyxRQUFMLENBQWNpOUIsT0FBakUsRUFDSmw4QixJQURJLENBQ0MsVUFBQzlNLElBQUQsRUFBVTtBQUNkLFlBQUksTUFBSytzRCxTQUFULEVBQW9CO0FBQ2xCLGdCQUFLRyxhQUFMLENBQW1CRixVQUFuQixFQUErQmh0RCxJQUEvQjtBQUNEO0FBQ0QsZUFBT0EsSUFBUDtBQUNELE9BTkksQ0FBUDtBQU9EOztBQUVEOzs7Ozs7Ozs7a0NBTWVndEQsVSxFQUFZaHRELEksRUFBTTtBQUMvQixjQUFRZ3RELFVBQVI7QUFDRSxhQUFLN3VELG9CQUFXZ3ZELE9BQWhCO0FBQ0VDLG1DQUFlQyxlQUFmLENBQStCcnRELElBQS9CLEVBQXFDLEtBQUsrTCxRQUFMLENBQWNnOUIsWUFBbkQ7QUFDQTtBQUNGLGFBQUs1cUMsb0JBQVdtdkQsTUFBaEI7QUFDRUYsbUNBQWVHLGNBQWYsQ0FBOEJ2dEQsSUFBOUIsRUFBb0MsS0FBSytMLFFBQUwsQ0FBY2c5QixZQUFsRDtBQUNBO0FBTko7QUFRRDs7QUFFRDs7Ozs7Ozs7cUNBS2tCO0FBQ2hCLFVBQU14aEMsVUFBVSxLQUFLd0UsUUFBckI7QUFDQSxVQUFJeEUsUUFBUTNILElBQVIsS0FBaUJ6QixvQkFBVzJxQyxLQUE1QixJQUFxQyxDQUFDLEtBQUtpa0IsU0FBL0MsRUFBMEQ7QUFDeEQsZUFBT3hsRCxRQUFRM0gsSUFBZjtBQUNELE9BRkQsTUFFTztBQUNMLFlBQUkxQixlQUFNdXVDLGNBQU4sRUFBSixFQUE0QjtBQUMxQixpQkFBT3R1QyxvQkFBV212RCxNQUFsQjtBQUNELFNBRkQsTUFFTztBQUNMLGlCQUFPbnZELG9CQUFXZ3ZELE9BQWxCO0FBQ0Q7QUFDRjtBQUNGOzs7Ozs7a0JBeERrQjUxQixROzs7Ozs7Ozs7Ozs7O3FqQkNsQnJCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBY0E7Ozs7SUFFcUI2MUIsYzs7Ozs7Ozs7QUFDbkI7Ozs7O29DQUt3QnB0RCxJLEVBQTBDO0FBQUEsVUFBcEN3dEQsUUFBb0MsdUVBQXpCLHVCQUF5Qjs7QUFDaEUsVUFBTTlnRCxNQUFNLEtBQUsrZ0Qsd0JBQUwsQ0FBOEJ6dEQsSUFBOUIsQ0FBWjtBQUNBLFVBQU0wdEQsWUFBWSxLQUFLQyx1QkFBTCxDQUE2QjN0RCxJQUE3QixDQUFsQjs7QUFFQSxVQUFJNHRELE9BQU83cEQsU0FBU2dZLGFBQVQsQ0FBdUIsR0FBdkIsQ0FBWDtBQUNBNnhDLFdBQUt6MkIsUUFBTCxHQUFtQnEyQixRQUFuQixTQUErQkUsU0FBL0I7QUFDQUUsV0FBS0MsSUFBTCxHQUFZbmhELEdBQVo7QUFDQTNJLGVBQVNzckMsSUFBVCxDQUFjOXdCLFdBQWQsQ0FBMEJxdkMsSUFBMUI7QUFDQUEsV0FBSzVOLEtBQUw7QUFDQWo4QyxlQUFTc3JDLElBQVQsQ0FBYzV3QixXQUFkLENBQTBCbXZDLElBQTFCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O21DQUt1QjV0RCxJLEVBQTBDO0FBQUEsVUFBcEN3dEQsUUFBb0MsdUVBQXpCLHVCQUF5Qjs7QUFDL0Q5MUMsZ0JBQVVvMkMsVUFBVixDQUFxQjl0RCxJQUFyQixFQUE4Qnd0RCxRQUE5QjtBQUNEOztBQUVEOzs7Ozs7Ozs0Q0FLZ0N4dEQsSSxFQUFNO0FBQ3BDLFVBQU13eEMsYUFBYXh4QyxLQUFLOHNCLEtBQUwsQ0FBVyxHQUFYLEVBQWdCLENBQWhCLEVBQW1CQSxLQUFuQixDQUF5QixHQUF6QixFQUE4QixDQUE5QixFQUFpQ0EsS0FBakMsQ0FBdUMsR0FBdkMsRUFBNEMsQ0FBNUMsQ0FBbkI7QUFDQSxhQUFPMGtCLFdBQVcxa0IsS0FBWCxDQUFpQixHQUFqQixFQUFzQnhHLEdBQXRCLEVBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs2Q0FJaUN0bUIsSSxFQUFNO0FBQ3JDLFVBQUksQ0FBQ3ZCLE9BQU80eUMsSUFBUixJQUFnQixDQUFDNXlDLE9BQU84ZCxHQUF4QixJQUErQixDQUFDKzBCLFdBQWhDLElBQStDLENBQUM3MUIsVUFBcEQsRUFBZ0U7QUFDOUQsZUFBT3piLElBQVA7QUFDRDs7QUFFRCxVQUFNdXhDLFVBQVUvekMsZ0JBQU9rcEMsTUFBUCxDQUFjMW1DLEtBQUs4c0IsS0FBTCxDQUFXLEdBQVgsRUFBZ0IsQ0FBaEIsQ0FBZCxDQUFoQjtBQUNBLFVBQU0wa0IsYUFBYXh4QyxLQUFLOHNCLEtBQUwsQ0FBVyxHQUFYLEVBQWdCLENBQWhCLEVBQW1CQSxLQUFuQixDQUF5QixHQUF6QixFQUE4QixDQUE5QixFQUFpQ0EsS0FBakMsQ0FBdUMsR0FBdkMsRUFBNEMsQ0FBNUMsQ0FBbkI7O0FBRUE7QUFDQSxVQUFNMmtCLGNBQWMsSUFBSUgsV0FBSixDQUFnQkMsUUFBUTVqQyxNQUF4QixDQUFwQjtBQUNBLFVBQU0rakMsV0FBVyxJQUFJajJCLFVBQUosQ0FBZWcyQixXQUFmLENBQWpCO0FBQ0EsV0FBSyxJQUFJcHRCLElBQUksQ0FBYixFQUFnQkEsSUFBSWt0QixRQUFRNWpDLE1BQTVCLEVBQW9DMFcsR0FBcEMsRUFBeUM7QUFDdkNxdEIsaUJBQVNydEIsQ0FBVCxJQUFja3RCLFFBQVFsdEIsQ0FBUixDQUFkO0FBQ0Q7O0FBRUQ7QUFDQSxVQUFNc3RCLE9BQU8sSUFBSWx6QyxPQUFPNHlDLElBQVgsQ0FBZ0IsQ0FBQ0ksV0FBRCxDQUFoQixFQUErQjtBQUMxQzd4QyxjQUFNNHhDO0FBRG9DLE9BQS9CLENBQWI7QUFHQSxhQUFPL3lDLE9BQU84ZCxHQUFQLENBQVdxMUIsZUFBWCxDQUEyQkQsSUFBM0IsQ0FBUDtBQUNEOzs7Ozs7a0JBN0RrQnliLGM7Ozs7Ozs7Ozs7Ozs7cWpCQ2pCckI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFjQTs7OztJQUVxQjE0QixZO0FBQ25CLHdCQUFhOWEsS0FBYixFQUFvQndhLFNBQXBCLEVBQStCRSxhQUEvQixFQUE4QztBQUFBOztBQUM1QyxTQUFLeTVCLE1BQUwsR0FBY24wQyxLQUFkO0FBQ0EsU0FBS28wQyxVQUFMLEdBQWtCNTVCLFNBQWxCO0FBQ0EsU0FBSzY1QixjQUFMLEdBQXNCMzVCLGFBQXRCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O2tDQUllO0FBQ2IsVUFBTTdPLGFBQWEsSUFBSWxuQixnQkFBSixDQUFZLEtBQUt3dkQsTUFBTCxDQUFZNW9ELEtBQXhCLEVBQStCLEtBQUs0b0QsTUFBTCxDQUFZanBELE1BQTNDLENBQW5CO0FBQ0EsVUFBTW9wRCxTQUFTem9DLFdBQVd4aUIsQ0FBWCxHQUFld2lCLFdBQVd2aUIsQ0FBekM7QUFDQSxVQUFNaXJELG1CQUFtQkQsU0FBUyxLQUFLRixVQUF2QztBQUNBLFVBQU1JLHVCQUF3QixLQUFLSCxjQUFMLEtBQXdCLElBQXhCLEtBQzNCeG9DLFdBQVd4aUIsQ0FBWCxHQUFlLEtBQUtnckQsY0FBcEIsSUFBc0N4b0MsV0FBV3ZpQixDQUFYLEdBQWUsS0FBSytxRCxjQUQvQixDQUE5Qjs7QUFHQSxhQUFPRSxvQkFBb0JDLG9CQUEzQjtBQUNEOztBQUVEOzs7Ozs7OzZCQUlVO0FBQUE7O0FBQ1IsVUFBSWo1QixTQUFTLElBQWI7QUFDQSxVQUFJclosU0FBUyxJQUFiO0FBQ0EsVUFBTXdZLGdCQUFnQixLQUFLMjVCLGNBQTNCOztBQUVBLGFBQU8sSUFBSWp3RCxnQkFBSixDQUFZLFVBQUM2ZSxPQUFELEVBQVVDLE1BQVYsRUFBcUI7QUFDdENyZSxlQUFPNlUsVUFBUCxDQUFrQixZQUFNO0FBQ3RCLGNBQU0yZ0Isb0JBQW9CLElBQUkxMUIsZ0JBQUosQ0FBWSxNQUFLd3ZELE1BQUwsQ0FBWTVvRCxLQUF4QixFQUErQixNQUFLNG9ELE1BQUwsQ0FBWWpwRCxNQUEzQyxDQUExQjtBQUNBLGNBQU0yZ0IsYUFBYXdPLGtCQUFrQjF3QixLQUFsQixFQUFuQjs7QUFFQTtBQUNBLGNBQUlraUIsV0FBV3hpQixDQUFYLEdBQWV3aUIsV0FBV3ZpQixDQUExQixHQUE4QixNQUFLOHFELFVBQXZDLEVBQW1EO0FBQ2pEdm9DLHVCQUFXNG9DLElBQVgsQ0FBZ0IsTUFBS0MseUJBQUwsRUFBaEI7QUFDQW41QixxQkFBUyxlQUFUO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsY0FBSWIsa0JBQWtCLElBQWxCLEtBQ0M3TyxXQUFXeGlCLENBQVgsR0FBZXF4QixhQUFmLElBQ0Q3TyxXQUFXdmlCLENBQVgsR0FBZW94QixhQUZmLENBQUosRUFFbUM7QUFDakMsZ0JBQUl3UCxRQUFRbG1DLEtBQUsyRyxHQUFMLENBQ1YrdkIsZ0JBQWdCN08sV0FBV3hpQixDQURqQixFQUVWcXhCLGdCQUFnQjdPLFdBQVd2aUIsQ0FGakIsQ0FBWjtBQUlBdWlCLHVCQUFXckQsUUFBWCxDQUFvQjBoQixLQUFwQjtBQUNBM08scUJBQVMsZUFBVDtBQUNEOztBQUVEMVAscUJBQVcxTCxLQUFYO0FBQ0ErQixtQkFBUyxNQUFLeXlDLHlCQUFMLENBQStCOW9DLFVBQS9CLENBQVQ7O0FBRUE1SSxrQkFBUSxFQUFFZixjQUFGLEVBQVUySixzQkFBVixFQUFzQjBQLGNBQXRCLEVBQVI7QUFDRCxTQTVCRCxFQTRCRyxJQTVCSDtBQTZCRCxPQTlCTSxDQUFQO0FBK0JEOztBQUVEOzs7Ozs7Ozs7OzhDQU8yQjFQLFUsRUFBMEM7QUFBQSxVQUE5QitvQyxlQUE4Qix1RUFBWi9vQyxVQUFZOztBQUNuRSxVQUFNN0wsUUFBUSxLQUFLbTBDLE1BQW5COztBQUVBLFVBQU1qeUMsU0FBUy9YLFNBQVNnWSxhQUFULENBQXVCLFFBQXZCLENBQWY7QUFDQUQsYUFBTzNXLEtBQVAsR0FBZXNnQixXQUFXeGlCLENBQTFCO0FBQ0E2WSxhQUFPaFgsTUFBUCxHQUFnQjJnQixXQUFXdmlCLENBQTNCOztBQUVBLFVBQU1zZixTQUFTaUQsV0FBV2xpQixLQUFYLEdBQ1pPLFFBRFksQ0FDSDBxRCxlQURHLEVBRVo3NkMsTUFGWSxDQUVMLENBRkssQ0FBZjs7QUFJQSxVQUFNMU0sVUFBVTZVLE9BQU9sQixVQUFQLENBQWtCLElBQWxCLENBQWhCO0FBQ0EzVCxjQUFRbTFCLFNBQVIsQ0FBa0J4aUIsS0FBbEIsRUFDRSxDQURGLEVBQ0ssQ0FETCxFQUVFQSxNQUFNelUsS0FGUixFQUVleVUsTUFBTTlVLE1BRnJCLEVBR0UwZCxPQUFPdmYsQ0FIVCxFQUdZdWYsT0FBT3RmLENBSG5CLEVBSUVzckQsZ0JBQWdCdnJELENBSmxCLEVBSXFCdXJELGdCQUFnQnRyRCxDQUpyQztBQUtBLGFBQU80WSxNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O2dEQUs2QjtBQUMzQixVQUFNbEMsUUFBUSxLQUFLbTBDLE1BQW5CO0FBQ0EsVUFBTTM1QixZQUFZLEtBQUs0NUIsVUFBdkI7O0FBRUEsVUFBTVMsVUFBVTcwQyxNQUFNelUsS0FBTixHQUFjeVUsTUFBTTlVLE1BQXBDO0FBQ0EsVUFBTTRwRCxVQUFVOTBDLE1BQU05VSxNQUFOLEdBQWU4VSxNQUFNelUsS0FBckM7O0FBRUEsYUFBTyxJQUFJNUcsZ0JBQUosQ0FDTFgsS0FBSyt3RCxJQUFMLENBQVV2NkIsWUFBWXE2QixPQUF0QixDQURLLEVBRUw3d0QsS0FBSyt3RCxJQUFMLENBQVV2NkIsWUFBWXM2QixPQUF0QixDQUZLLEVBR0wzMEMsS0FISyxFQUFQO0FBSUQ7Ozs7OztrQkExR2tCMmEsWTs7Ozs7Ozs7Ozs7OztxakJDakJyQjtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWNBOzs7O0FBQ0E7Ozs7OztJQUVxQnJCLGdCO0FBQ25CLDRCQUFhdnJCLE1BQWIsRUFBcUIreEIsR0FBckIsRUFBMEJ0dUIsUUFBMUIsRUFBb0M7QUFBQTs7QUFDbEMsU0FBS3liLE9BQUwsR0FBZWxmLE1BQWY7QUFDQSxTQUFLbXJCLElBQUwsR0FBWTRHLEdBQVo7QUFDQSxTQUFLckgsU0FBTCxHQUFpQmpuQixRQUFqQjs7QUFFQSxTQUFLcWpELElBQUwsR0FBWSxFQUFaOztBQUVBO0FBQ0EsU0FBS0MsTUFBTCxHQUFjLEtBQUs1N0IsSUFBTCxJQUFhLEtBQUtBLElBQUwsQ0FBVTY3QixrQkFBVixFQUEzQjtBQUNBLFNBQUtDLGVBQUwsR0FBdUIsS0FBSy9uQyxPQUFMLENBQWFrWSxVQUFiLEdBQTBCcDNCLE1BQTFCLENBQWlDOGdDLGVBQXhEOztBQUVBLFNBQUtvbUIsVUFBTCxHQUFrQixFQUFsQjs7QUFYa0MsUUFhMUI1OUMsVUFiMEIsR0FhWDNULHdCQWJXLENBYTFCMlQsVUFiMEI7O0FBY2xDLFNBQUssSUFBSTY5QyxhQUFULElBQTBCNzlDLFVBQTFCLEVBQXNDO0FBQ3BDLFVBQU04OUMsWUFBWTk5QyxXQUFXNjlDLGFBQVgsQ0FBbEI7QUFDQSxXQUFLRCxVQUFMLENBQWdCRSxVQUFVbm9ELFVBQTFCLElBQXdDbW9ELFNBQXhDO0FBQ0Q7O0FBRUQsUUFBTTNuRCxVQUFVTyxPQUFPbzNCLFVBQVAsRUFBaEI7QUFuQmtDLFFBb0IxQmh0QixVQXBCMEIsR0FvQlgzSyxRQUFRMGhDLFVBcEJHLENBb0IxQi8yQixVQXBCMEI7O0FBcUJsQyxTQUFLLElBQUl1SyxHQUFULElBQWdCdkssVUFBaEIsRUFBNEI7QUFDMUIsVUFBTUYsWUFBWUUsV0FBV3VLLEdBQVgsQ0FBbEI7QUFDQSxXQUFLdXlDLFVBQUwsQ0FBZ0JoOUMsVUFBVWpMLFVBQTFCLElBQXdDaUwsU0FBeEM7QUFDRDs7QUFFRCxRQUFJLEtBQUs2OEMsTUFBVCxFQUFpQjtBQUNmLFdBQUtNLFNBQUw7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7MkJBS1Fwb0QsVSxFQUFZO0FBQ2xCLGFBQU8sQ0FBQyxDQUFDLEtBQUs2bkQsSUFBTCxDQUFVN25ELFVBQVYsQ0FBVDtBQUNEOztBQUVEOzs7Ozs7O3dCQUlLaUwsUyxFQUFXO0FBQUE7O0FBQ2QsVUFBTWpMLGFBQWFpTCxVQUFVL1EsV0FBVixDQUFzQjhGLFVBQXpDO0FBQ0FpTCxnQkFBVXZSLEVBQVYsQ0FBYSxRQUFiLEVBQXVCLFlBQU07QUFDM0IsY0FBSyt4QixTQUFMLENBQWV2eUIsSUFBZixDQUFvQmYsbUJBQVVzTSxNQUFWLENBQWlCb0csaUJBQXJDLEVBQXdESSxTQUF4RDtBQUNELE9BRkQ7QUFHQSxVQUFNclIsUUFBUSxLQUFLb3VELGVBQUwsQ0FBcUJudUQsT0FBckIsQ0FBNkJtRyxVQUE3QixDQUFkO0FBQ0EsVUFBSXBHLFVBQVUsQ0FBQyxDQUFmLEVBQWtCO0FBQ2hCLGNBQU0sSUFBSXdJLEtBQUosNkJBQXFDcEMsVUFBckMsNENBQU47QUFDRDtBQUNELFdBQUs4bkQsTUFBTCxDQUFZMW5ELEdBQVosQ0FBZ0J4RyxLQUFoQixFQUF1QnFSLFNBQXZCO0FBQ0EsV0FBSzQ4QyxJQUFMLENBQVU3bkQsVUFBVixJQUF3QmlMLFNBQXhCOztBQUVBLFdBQUt3Z0IsU0FBTCxDQUFldnlCLElBQWYsQ0FBb0JmLG1CQUFVc00sTUFBVixDQUFpQjh0QyxpQkFBckMsRUFBd0R0bkMsU0FBeEQ7QUFDRDs7QUFFRDs7Ozs7OzsyQkFJUUEsUyxFQUFXO0FBQ2pCLFVBQU1qTCxhQUFhaUwsVUFBVS9RLFdBQVYsQ0FBc0I4RixVQUF6QztBQUNBLFVBQU13MUIsUUFBUSxLQUFLc3lCLE1BQUwsQ0FBWXJ5QixRQUFaLEVBQWQ7O0FBRUE7QUFDQSxhQUFPLEtBQUtveUIsSUFBTCxDQUFVN25ELFVBQVYsQ0FBUDs7QUFFQTtBQUNBLFVBQU1wRyxRQUFRNDdCLE1BQ1h6dUIsR0FEVyxDQUNQLFVBQUNpYixFQUFEO0FBQUEsZUFBUUEsR0FBRzluQixXQUFILENBQWU4RixVQUF2QjtBQUFBLE9BRE8sRUFFWG5HLE9BRlcsQ0FFSG9SLFVBQVUvUSxXQUFWLENBQXNCOEYsVUFGbkIsQ0FBZDs7QUFJQSxVQUFJcEcsVUFBVSxDQUFDLENBQWYsRUFBa0I7QUFDaEIsYUFBS2t1RCxNQUFMLENBQVlPLFFBQVosQ0FBcUJ6dUQsS0FBckI7O0FBRUE7QUFDQTtBQUNBLGFBQUssSUFBSTBqQixJQUFJMWpCLFFBQVEsQ0FBckIsRUFBd0IwakIsSUFBSWtZLE1BQU01dUIsTUFBbEMsRUFBMEMwVyxHQUExQyxFQUErQztBQUM3QyxjQUFNclMsYUFBWXVxQixNQUFNbFksQ0FBTixDQUFsQjtBQUNBLGNBQUksQ0FBQ3JTLFVBQUwsRUFBZ0I7QUFDaEJBLHFCQUFVcTlDLFFBQVYsQ0FBbUIsSUFBbkI7QUFDRDs7QUFFRCxhQUFLNzhCLFNBQUwsQ0FBZXZ5QixJQUFmLENBQW9CZixtQkFBVXNNLE1BQVYsQ0FBaUJzRyxpQkFBckMsRUFBd0RFLFNBQXhEO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7d0JBS0tqTCxVLEVBQVk7QUFDZixhQUFPLEtBQUs2bkQsSUFBTCxDQUFVN25ELFVBQVYsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7O2dDQU9hQSxVLEVBQTBCO0FBQUEsVUFBZFEsT0FBYyx1RUFBSixFQUFJOztBQUNyQyxVQUFJLEtBQUtxbkQsSUFBTCxDQUFVN25ELFVBQVYsQ0FBSixFQUEyQjtBQUN6QixZQUFNaUwsWUFBWSxLQUFLNDhDLElBQUwsQ0FBVTduRCxVQUFWLENBQWxCO0FBQ0FpTCxrQkFBVTdLLEdBQVYsQ0FBY0ksT0FBZCxFQUF1QixLQUF2QjtBQUNBLGVBQU95SyxTQUFQO0FBQ0QsT0FKRCxNQUlPO0FBQ0wsWUFBTWs5QyxZQUFZLEtBQUtGLFVBQUwsQ0FBZ0Jqb0QsVUFBaEIsQ0FBbEI7QUFDQSxZQUFNaUwsY0FBWSxJQUFJazlDLFNBQUosQ0FBYyxLQUFLajhCLElBQW5CLEVBQXlCMXJCLE9BQXpCLENBQWxCO0FBQ0EsYUFBSzJJLEdBQUwsQ0FBUzhCLFdBQVQ7QUFDQSxlQUFPQSxXQUFQO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7OzsrQkFJWTtBQUNWLGFBQU8sS0FBSzY4QyxNQUFaO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O2dDQUthOW5ELFUsRUFBWTtBQUN2QixhQUFPLENBQUMsQ0FBQyxLQUFLaW9ELFVBQUwsQ0FBZ0Jqb0QsVUFBaEIsQ0FBVDtBQUNEOztBQUVEOzs7Ozs7O21DQUlnQjtBQUNkLGFBQU8sS0FBS2lvRCxVQUFaO0FBQ0Q7O0FBRUQ7Ozs7Ozs0QkFHUztBQUNQLFdBQUtKLElBQUwsR0FBWSxFQUFaO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztnQ0FNYTtBQUFBOztBQUNYLFVBQU1yeUIsUUFBUSxLQUFLc3lCLE1BQUwsQ0FBWXJ5QixRQUFaLEdBQXVCdnZCLEtBQXZCLEVBQWQ7QUFDQSxXQUFLNGhELE1BQUwsQ0FBWWpGLEtBQVo7O0FBRUFydEIsWUFBTXB2QixPQUFOLENBQWMsVUFBQ0csQ0FBRCxFQUFPO0FBQ25CLGVBQUs0QyxHQUFMLENBQVM1QyxDQUFUO0FBQ0QsT0FGRDtBQUdEOzs7Ozs7a0JBcktrQitsQixnQjs7Ozs7Ozs7Ozs7OztxakJDbEJyQjtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWNBOztJQUFZa1QsUTs7QUFDWjs7Ozs7O0lBRXFCalQsYztBQUNuQiwwQkFBYXhyQixNQUFiLEVBQXFCK3hCLEdBQXJCLEVBQTBCdHVCLFFBQTFCLEVBQW9DO0FBQUE7O0FBQ2xDLFNBQUt5YixPQUFMLEdBQWVsZixNQUFmO0FBQ0EsU0FBS21yQixJQUFMLEdBQVk0RyxHQUFaO0FBQ0EsU0FBS3JILFNBQUwsR0FBaUJqbkIsUUFBakI7O0FBRUEsU0FBSytqRCxzQkFBTCxHQUE4QixFQUE5QjtBQUNBLFNBQUt2akQsUUFBTCxHQUFnQixLQUFLaWIsT0FBTCxDQUFha1ksVUFBYixFQUFoQjtBQUNBLFNBQUs4dkIsVUFBTCxHQUFrQi93RCxrQkFBUzJqQyxNQUFULENBQWdCLEVBQWhCLEVBQW9CMkUsUUFBcEIsRUFBOEIsS0FBS3g2QixRQUFMLENBQWNrOUIsVUFBZCxDQUF5QmwrQixRQUF2RCxDQUFsQjtBQUNEOztBQUVEOzs7Ozs7Ozs7OEJBS1doRSxVLEVBQVk7QUFBQTs7QUFDckIsVUFBTWtFLFVBQVUsS0FBSy9ELEdBQUwsQ0FBU0gsVUFBVCxDQUFoQjs7QUFFQSxVQUFJLENBQUNrRSxPQUFMLEVBQWM7QUFDWjFMLHFCQUFJc3RDLElBQUosQ0FBUyxnREFBZ0Q5bEMsVUFBekQ7QUFDQSxlQUFPLEtBQVA7QUFDRDs7QUFFRCxVQUFNd29ELHFCQUFxQnRrRCxRQUFRc2tELGtCQUFSLElBQThCLEVBQXpEO0FBQ0EsVUFBTUMsb0JBQW9CLEVBQTFCO0FBQ0FELHlCQUFtQnBpRCxPQUFuQixDQUEyQiwrQkFBdUI7QUFDaEQsWUFBSSxDQUFDLE1BQUs2WixPQUFMLENBQWE5VSxVQUFiLENBQXdCNDNDLFdBQXhCLENBQW9DMkYsbUJBQXBDLENBQUwsRUFBK0Q7QUFDN0RELDRCQUFrQmh2RCxJQUFsQixDQUF1Qml2RCxtQkFBdkI7QUFDRDtBQUNGLE9BSkQ7O0FBTUEsVUFBSUQsa0JBQWtCN2hELE1BQXRCLEVBQThCO0FBQzVCO0FBQ0EsWUFBSSxLQUFLMmhELHNCQUFMLENBQTRCMXVELE9BQTVCLENBQW9DbUcsVUFBcEMsTUFBb0QsQ0FBQyxDQUF6RCxFQUE0RDtBQUMxRCxlQUFLdW9ELHNCQUFMLENBQTRCOXVELElBQTVCLENBQWlDdUcsVUFBakM7QUFDQXhILHVCQUFJeXhCLEtBQUosZUFBdUJqcUIsVUFBdkIsbUNBQStEeW9ELGtCQUFrQjdoRCxNQUFsQixLQUE2QixDQUE3QixHQUFpQyxjQUFqQyxHQUFrRCxnQkFBakgsbUJBQThJNmhELGtCQUFrQjFoRCxHQUFsQixDQUFzQjtBQUFBLHlCQUFVc1ksQ0FBVjtBQUFBLFdBQXRCLEVBQXVDaXNCLElBQXZDLENBQTRDLElBQTVDLENBQTlJO0FBQ0Q7QUFDRCxlQUFPLEtBQVA7QUFDRDs7QUFFRCxhQUFPcG5DLFFBQVE2K0MsV0FBUixJQUF1QjcrQyxRQUFRNitDLFdBQVIsQ0FBb0IsS0FBSzlpQyxPQUF6QixDQUE5QjtBQUNEOztBQUVEOzs7Ozs7Ozt3QkFLS2pnQixVLEVBQVk7QUFDZixhQUFPLEtBQUtpb0QsVUFBTCxDQUFnQmpvRCxVQUFoQixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7bUNBSWdCO0FBQ2QsYUFBTyxLQUFLaW9ELFVBQVo7QUFDRDs7Ozs7O2tCQTNEa0IxN0IsYzs7Ozs7Ozs7Ozs7Ozs7O0FDSHJCOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBaEJBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLElBQU1vOEIsUUFBUSxDQUNaLFlBRFksRUFDRSxTQURGLEVBQ2EsVUFEYixFQUN5QixVQUR6QixFQUNxQyxZQURyQyxFQUNtRCxZQURuRCxFQUNpRSxTQURqRSxFQUM0RSxPQUQ1RSxFQUNxRixRQURyRixFQUMrRixRQUQvRixFQUN5RyxhQUR6RyxDQUFkOztBQUlBOzs7Ozs7O0lBTU1DLG1COzs7Ozs7Ozs7Ozs7QUFDSjs7Ozs7Ozs0QkFPZ0JsN0MsVyxFQUFhO0FBQUEsVUFDbkIzTSxNQURtQixHQUNSLEtBQUtiLE9BREcsQ0FDbkJhLE1BRG1COztBQUUzQixVQUFNeUsseUJBQXlCekssT0FBT29LLFVBQVAsQ0FBa0IrVSxNQUFsQixDQUF5QixhQUF6QixDQUEvQjtBQUNBLFVBQU1qVixZQUFZbEssT0FBT29LLFVBQVAsQ0FBa0JDLFdBQWxCLENBQThCLGFBQTlCLENBQWxCO0FBQ0EsVUFBTUssaUJBQWlCUixVQUFVaXJCLGdCQUFWLEVBQXZCOztBQUVBLFdBQUszcUIsY0FBTCxDQUFvQixFQUFFTixvQkFBRixFQUFhTyw4Q0FBYixFQUFxQ0MsOEJBQXJDLEVBQXBCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Z0NBT29CMUssTSxFQUFRO0FBQzFCLGFBQU9BLE9BQU95dUIsYUFBUCxDQUFxQixZQUFyQixLQUNMbTVCLE1BQU1qaUQsTUFBTixDQUFhLFVBQUNtaUQsSUFBRDtBQUFBLGVBQVU5bkQsT0FBTytuRCxhQUFQLENBQXFCRCxJQUFyQixDQUFWO0FBQUEsT0FBYixFQUFtRGppRCxNQUFuRCxHQUE0RCxDQUQ5RDtBQUVEOztBQUVEOzs7Ozs7OztxQ0FLeUI3RixNLEVBQVE7QUFDL0IsYUFBTzRuRCxNQUNKamlELE1BREksQ0FDRyxVQUFDbWlELElBQUQ7QUFBQSxlQUFVOW5ELE9BQU8rbkQsYUFBUCxDQUFxQkQsSUFBckIsQ0FBVjtBQUFBLE9BREgsRUFFSjloRCxHQUZJLENBRUEsVUFBQzhoRCxJQUFEO0FBQUEseUNBQWtDQSxJQUFsQztBQUFBLE9BRkEsQ0FBUDtBQUdEOzs7O0VBdEMrQnJwQixrQjs7QUF5Q2xDOzs7Ozs7O0FBS0FvcEIsb0JBQW9CM25ELGlCQUFwQixHQUF3QzhuRCxzQ0FBeEM7O0FBRUE7Ozs7O0FBS0FILG9CQUFvQjVvRCxVQUFwQixHQUFpQyxhQUFqQzs7QUFFQTs7Ozs7QUFLQTRvRCxvQkFBb0J6bkQsUUFBcEIsR0FBK0IsbUNBQS9COztBQUVBOzs7OztBQUtBeW5ELG9CQUFvQnhuRCxXQUFwQixHQUFrQyw4QkFBbEM7O0FBRUE7Ozs7QUFJQXduRCxvQkFBb0J2bkQsY0FBcEIsR0FBcUMsRUFBckM7O0FBSUE7Ozs7QUFJQXVuRCxvQkFBb0JKLGtCQUFwQixHQUF5QyxDQUFDLGFBQUQsQ0FBekM7O2tCQUVlSSxtQjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvRmY7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBcEJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFtQlF6dkIsb0IsR0FBeUI3aEMsYUFBSStTLFUsQ0FBN0I4dUIsb0I7OztBQUVSLElBQU02dkIsUUFBUSxDQUFDLFlBQUQsRUFBZSxZQUFmLEVBQTZCLFVBQTdCLEVBQXlDLE9BQXpDLEVBQWtELFNBQWxELEVBQTZELFVBQTdELEVBQXlFLFNBQXpFLEVBQW9GLFlBQXBGLEVBQWtHLFFBQWxHLEVBQTRHLFFBQTVHLEVBQXNILGFBQXRILENBQWQ7O0lBRXFCRCw0Qjs7O0FBQ25CLDBDQUFzQjtBQUFBOztBQUFBOztBQUFBLHNDQUFObnBELElBQU07QUFBTkEsVUFBTTtBQUFBOztBQUFBLHVMQUNYQSxJQURXOztBQUdwQixVQUFLckYsUUFBTCxDQUNFLHNCQURGOztBQUhvQixRQU9ad0csTUFQWSxHQU9ELE1BQUtiLE9BUEosQ0FPWmEsTUFQWTs7QUFRcEIsVUFBS2tvRCxVQUFMLEdBQWtCbG9ELE9BQU9vSyxVQUFQLENBQWtCQyxXQUFsQixDQUE4QixhQUE5QixDQUFsQjs7QUFFQSxVQUFLNVEsS0FBTCxHQUFhLEVBQUUwdUQsa0JBQWtCLElBQXBCLEVBQWI7QUFWb0I7QUFXckI7O0FBRUQ7O0FBRUE7Ozs7Ozs7OztpQ0FLY250RCxDLEVBQUc7QUFBQSxVQUNQZ0YsTUFETyxHQUNJLEtBQUtiLE9BRFQsQ0FDUGEsTUFETzs7QUFFZixVQUFNeUsseUJBQXlCLEtBQUtsSCxjQUFMLENBQW9CLHdCQUFwQixDQUEvQjtBQUNBLFVBQU1tSCxpQkFBaUIsS0FBS25ILGNBQUwsQ0FBb0IsZ0JBQXBCLENBQXZCOztBQUVBLFVBQUksQ0FBQyxLQUFLMmtELFVBQUwsQ0FBZ0JFLFlBQWhCLENBQTZCMTlDLGNBQTdCLENBQUwsRUFBbUQ7QUFDakQxSyxlQUFPaXJCLE9BQVAsQ0FBZTdpQixHQUFmLENBQW1CLEtBQUs4L0MsVUFBeEIsRUFDRXg5QyxjQURGLEVBRUVELHNCQUZGO0FBR0Q7O0FBRUQsVUFBTW5LLGlCQUFpQixLQUFLNG5ELFVBQUwsQ0FBZ0JHLGlCQUFoQixFQUF2QjtBQUNBLFVBQUksS0FBS0gsVUFBTCxDQUFnQkUsWUFBaEIsQ0FBNkI5bkQsY0FBN0IsQ0FBSixFQUFrRDtBQUNoRE4sZUFBT29LLFVBQVAsQ0FBa0JrK0MsTUFBbEIsQ0FBeUIsS0FBS0osVUFBOUI7QUFDRDs7QUFFRCwrSkFBbUJsdEQsQ0FBbkI7QUFDRDs7QUFFRDs7Ozs7Ozs7eUNBS3NCMEcsSyxFQUFPO0FBQUEsVUFDbkJ5bUQsZ0JBRG1CLEdBQ0UsS0FBSzF1RCxLQURQLENBQ25CMHVELGdCQURtQjs7QUFFM0IsVUFBTTlsQyxTQUFTK1YscUJBQXFCaGYsU0FBckIsQ0FBK0I2SSxnQkFBL0IsQ0FBZ0RrbUMsZ0JBQWhELENBQWY7QUFGMkIsVUFHbkJybUQsUUFIbUIsR0FHY3VnQixNQUhkLENBR25CdmdCLFFBSG1CO0FBQUEsVUFHVHl6QixRQUhTLEdBR2NsVCxNQUhkLENBR1RrVCxRQUhTO0FBQUEsVUFHQ3h6QixRQUhELEdBR2NzZ0IsTUFIZCxDQUdDdGdCLFFBSEQ7OztBQUszQkwsY0FBUUEsUUFBUSxDQUFSLEdBQ0g2ekIsV0FBVyxDQUFDQSxXQUFXenpCLFFBQVosSUFBd0JKLEtBQXhCLEdBQWdDLEdBRHhDLEdBRUg2ekIsV0FBVyxDQUFDeHpCLFdBQVd3ekIsUUFBWixJQUF3Qjd6QixLQUF4QixHQUFnQyxHQUZoRDs7QUFJQSxXQUFLd21ELFVBQUwsQ0FBZ0JLLFNBQWhCLENBQTBCSixnQkFBMUIsRUFBNEN6bUQsS0FBNUM7O0FBVDJCLFVBV25CMUIsTUFYbUIsR0FXUixLQUFLYixPQVhHLENBV25CYSxNQVhtQjs7QUFZM0JBLGFBQU9tTCxNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OzttQ0FNZ0JxOUMsWSxFQUFjeHRELEMsRUFBRztBQUMvQixXQUFLRCxRQUFMLENBQWMsRUFBRW90RCxrQkFBa0JLLFlBQXBCLEVBQWQ7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7Ozs7c0NBS21CdnBELFUsRUFBWTtBQUM3QixVQUFNb2pCLFNBQVMrVixxQkFBcUJoZixTQUFyQixDQUErQjZJLGdCQUEvQixDQUFnRGhqQixVQUFoRCxDQUFmO0FBRDZCLFVBRXJCNkMsUUFGcUIsR0FFWXVnQixNQUZaLENBRXJCdmdCLFFBRnFCO0FBQUEsVUFFWHl6QixRQUZXLEdBRVlsVCxNQUZaLENBRVhrVCxRQUZXO0FBQUEsVUFFRHh6QixRQUZDLEdBRVlzZ0IsTUFGWixDQUVEdGdCLFFBRkM7OztBQUk3QixVQUFJTCxRQUFRLEtBQUt3bUQsVUFBTCxHQUNSLEtBQUtBLFVBQUwsQ0FBZ0JocUMsU0FBaEIsQ0FBMEJqZixVQUExQixDQURRLEdBRVJzMkIsUUFGSjs7QUFJQSxVQUFJa3pCLGNBQWMsQ0FBQy9tRCxTQUFTNnpCLFFBQVQsR0FDZixDQUFDN3pCLFFBQVFJLFFBQVQsS0FBc0J5ekIsV0FBV3p6QixRQUFqQyxJQUE2QyxDQUQ5QixHQUVmLENBQUNKLFFBQVE2ekIsUUFBVCxLQUFzQnh6QixXQUFXd3pCLFFBQWpDLENBRmMsSUFFZ0MsR0FGbEQ7O0FBSUEsYUFBTztBQUNMenpCLGtCQUFVLENBQUMsR0FETjtBQUVMQyxrQkFBVSxHQUZMO0FBR0xMLGVBQU8rbUQsV0FIRjtBQUlMNy9DLG1CQUFXLEdBSk47QUFLTEQsNkJBQXFCLEdBTGhCO0FBTUwzRyxlQUFPLEtBQUtvYSxFQUFMLDZCQUFrQ25kLFVBQWxDLENBTkY7QUFPTDRDLG1CQUFXLElBUE47QUFRTEYsa0JBQVUsS0FBS007QUFSVixPQUFQO0FBVUQ7O0FBRUQ7Ozs7NENBRXlCO0FBQUEsVUFDZmttRCxnQkFEZSxHQUNNLEtBQUsxdUQsS0FEWCxDQUNmMHVELGdCQURlOztBQUV2QixVQUFJLENBQUNBLGdCQUFMLEVBQXVCOztBQUV2QixVQUFNTyxjQUFjLEtBQUtDLGlCQUFMLENBQXVCUixnQkFBdkIsQ0FBcEI7QUFDQSxhQUFRLGdDQUFDLGdDQUFELEVBQTRCTyxXQUE1QixDQUFSO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O3VDQUtvQjtBQUFBOztBQUNsQixhQUFPVCxNQUNKdGlELE1BREksQ0FDRyxVQUFDMDRCLElBQUQ7QUFBQSxlQUFVLE9BQUtsL0IsT0FBTCxDQUFhYSxNQUFiLENBQW9CK25ELGFBQXBCLENBQWtDMXBCLElBQWxDLENBQVY7QUFBQSxPQURILEVBRUpyNEIsR0FGSSxDQUVBLFVBQUNxNEIsSUFBRCxFQUFVO0FBQ2IsWUFBTS94QixhQUFhLE9BQUs3UyxLQUFMLENBQVcwdUQsZ0JBQVgsS0FBZ0M5cEIsSUFBbkQ7QUFDQSxZQUFNbmlCLFlBQVk1UCxhQUFhLFdBQWIsR0FBMkIsSUFBN0M7O0FBRUEsWUFBSXM4QyxtQkFBSjtBQUNBO0FBQ0EsWUFBSSxDQUFDdDhDLFVBQUQsSUFBZSxLQUFuQixFQUEwQjtBQUFFO0FBQzFCLGNBQU1vOEMsY0FBYyxPQUFLQyxpQkFBTCxDQUF1QnRxQixJQUF2QixDQUFwQjtBQUNBdXFCLHVCQUFjO0FBQUE7QUFBQSxjQUFLLFdBQVUsdUJBQWY7QUFDWjtBQUFBO0FBQUEsZ0JBQUssS0FBSSxjQUFUO0FBQ0UsOENBQUMsNkJBQUQsRUFBeUJGLFdBQXpCO0FBREY7QUFEWSxXQUFkO0FBS0Q7QUFDRDs7QUFFQSxlQUFRO0FBQUE7QUFBQTtBQUNOLGlCQUFJLFFBREU7QUFFTixpQkFBS3JxQixJQUZDO0FBR04sK0JBQWlCQSxJQUhYO0FBSU47QUFBQTtBQUFBLGNBQUssV0FBVSxhQUFmO0FBQ0U7QUFBQTtBQUFBLGdCQUFLLEtBQUksdUJBQVQsRUFBaUMsU0FBUyxPQUFLbGlCLGNBQUwsQ0FBb0J0bEIsSUFBcEIsQ0FBeUIsTUFBekIsRUFBK0J3bkMsSUFBL0IsQ0FBMUMsRUFBZ0YsV0FBV25pQixTQUEzRjtBQUNFLHVEQUFLLEtBQUksUUFBVCxFQUFrQixLQUFLLE9BQUt6RCxhQUFMLDJCQUEyQzRsQixJQUEzQyxXQUF1RCxJQUF2RCxDQUF2QixHQURGO0FBRUU7QUFBQTtBQUFBLGtCQUFLLEtBQUksU0FBVDtBQUFvQix1QkFBS2ppQixFQUFMLDZCQUFrQ2lpQixJQUFsQztBQUFwQixlQUZGO0FBR0d1cUI7QUFISDtBQURGO0FBSk0sU0FBUjtBQVlELE9BOUJJLENBQVA7QUErQkQ7O0FBRUQ7Ozs7Ozs7cUNBSWtCO0FBQ2hCLFVBQU10K0IsWUFBWSxLQUFLQyxnQkFBTCxFQUFsQjs7QUFFQSxhQUFRO0FBQUE7QUFBQSxVQUFLLEtBQUksZUFBVDtBQUNOO0FBQUMsc0NBQUQ7QUFBQTtBQUNFO0FBQUE7QUFBQSxjQUFJLEtBQUksU0FBUjtBQUNHRDtBQURIO0FBREY7QUFETSxPQUFSO0FBT0Q7Ozs7RUFwS3VEMXJCLDJCOztrQkFBckNvcEQsNEI7OztBQXVLckJBLDZCQUE2QnJwRCxZQUE3QixHQUE0Q0MsNEJBQWtCRCxZQUE5RCxDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2pMQTs7Ozs7OytlQWZBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0lBZXFCa3FELG1COzs7QUFDbkIsaUNBQXNCO0FBQUE7O0FBQUE7O0FBQUEsc0NBQU5ocUQsSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEscUtBQ1hBLElBRFc7O0FBR3BCLFVBQUtwRixLQUFMLEdBQWE7QUFDWGlJLGFBQU8sTUFBSzdELEtBQUwsQ0FBVzZELEtBQVgsSUFBb0IsQ0FEaEI7QUFFWCtGLHNCQUFnQixDQUZMO0FBR1hDLHNCQUFnQixDQUhMO0FBSVhDLHVCQUFpQjtBQUpOLEtBQWI7QUFIb0I7QUFTckI7O0FBRUQ7O0FBRUE7Ozs7Ozs7d0NBR3FCO0FBQ25CO0FBQ0EsV0FBS0MsU0FBTCxDQUFlLEtBQUtuTyxLQUFMLENBQVdpSSxLQUExQixFQUFpQyxLQUFqQztBQUNEOztBQUVEOzs7Ozs7OzhDQUkyQjdELEssRUFBTztBQUNoQyxVQUFJQSxNQUFNNkQsS0FBTixLQUFnQixLQUFLakksS0FBTCxDQUFXaUksS0FBL0IsRUFBc0M7QUFDcEMsYUFBS2tHLFNBQUwsQ0FBZS9KLE1BQU02RCxLQUFyQixFQUE0QixLQUE1QjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7O29DQUtpQjtBQUNmLGFBQU8sRUFBRTdGLE1BQU0sS0FBS3BDLEtBQUwsQ0FBV2dPLGNBQW5CLEVBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7MENBS3VCO0FBQ3JCLGFBQU87QUFDTDVMLGNBQU0sS0FBS3BDLEtBQUwsQ0FBV2lPLGNBRFo7QUFFTHJLLGVBQU8sS0FBSzVELEtBQUwsQ0FBV2tPO0FBRmIsT0FBUDtBQUlEOztBQUVEOztBQUVBOzs7Ozs7O3dDQUlxQjtBQUNuQixhQUFPLEtBQUs5SixLQUFMLENBQVdnRSxTQUFYLEtBQXlCLEtBQWhDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs4QkFNV0gsSyxFQUEwQjtBQUFBLFVBQW5CMkcsVUFBbUIsdUVBQU4sSUFBTTs7QUFDbkMzRyxjQUFRNUwsS0FBS3lTLEtBQUwsQ0FBVzdHLEtBQVgsQ0FBUjtBQURtQyxtQkFFSixLQUFLN0QsS0FGRDtBQUFBLFVBRTNCaUUsUUFGMkIsVUFFM0JBLFFBRjJCO0FBQUEsVUFFakJDLFFBRmlCLFVBRWpCQSxRQUZpQjs7QUFHbkMsVUFBTXZKLFdBQVcsQ0FBQ2tKLFFBQVFJLFFBQVQsS0FBc0JDLFdBQVdELFFBQWpDLENBQWpCOztBQUVBO0FBTG1DLFVBTTNCbUcsR0FOMkIsR0FNbkIsS0FBSzFLLElBTmMsQ0FNM0IwSyxHQU4yQjs7QUFPbkMsVUFBTUMsV0FBV0QsSUFBSXpOLFdBQXJCO0FBQ0EsVUFBTWlOLGlCQUFpQlMsV0FBVzFQLFFBQWxDOztBQUVBO0FBQ0EsVUFBSW1QLGtCQUFrQm5QLFdBQVcwUCxRQUFqQztBQUNBLFVBQUlSLGlCQUFpQixDQUFyQjtBQUNBLFVBQUksS0FBS2MsaUJBQUwsRUFBSixFQUE4QjtBQUM1QmIsMEJBQWtCN1IsS0FBSzJTLEdBQUwsQ0FBU2pRLFdBQVcsR0FBcEIsSUFBMkIwUCxRQUE3QztBQUNBUix5QkFBaUJsUCxXQUFXLEdBQVgsR0FDWjBQLFdBQVcsR0FBWCxHQUFpQlAsZUFETCxHQUViLEtBRko7QUFHRDs7QUFFRCxXQUFLNU0sUUFBTCxDQUFjLEVBQUUyRyxZQUFGLEVBQVMrRiw4QkFBVCxFQUF5QkUsZ0NBQXpCLEVBQTBDRCw4QkFBMUMsRUFBZDtBQUNEOztBQUVEOztBQUVBOzs7Ozs7O29DQUlpQjtBQUNmLFVBQU1vQixrQkFBa0I7QUFDdEIvTCxlQUFPLEtBQUtnTSxtQkFBTDtBQURlLE9BQXhCOztBQUlBLGFBQVE7QUFBQTtBQUFBLFVBQUssS0FBSSxlQUFUO0FBQ047QUFBQTtBQUFBLFlBQUssS0FBSSxRQUFULEVBQWtCLEtBQUksS0FBdEI7QUFDRSxtREFBSyxLQUFJLGVBQVQsR0FERjtBQUVFLDREQUFLLEtBQUksZUFBVCxJQUE2QkQsZUFBN0IsRUFGRjtBQUdFLG1EQUFLLEtBQUksUUFBVCxFQUFrQixPQUFPLEtBQUtNLGFBQUwsRUFBekI7QUFIRjtBQURNLE9BQVI7QUFPRDs7OztFQTlHOENsUyxzQjs7a0JBQTVCMnhELG1COzs7QUFpSHJCQSxvQkFBb0JscUQsWUFBcEIsR0FBbUN6SCx1QkFBY3lILFlBQWpELEM7Ozs7Ozs7Ozs7Ozs7OztBQ25IQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFuQkE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7Ozs7OztJQU1NbXFELGlCOzs7Ozs7Ozs7Ozs7QUFDSjs7Ozs7Ozs0QkFPZ0JuOEMsVyxFQUFhO0FBQUEsVUFDbkIzTSxNQURtQixHQUNSLEtBQUtiLE9BREcsQ0FDbkJhLE1BRG1COzs7QUFHM0IsVUFBTStvRCxrQ0FBa0Mvb0QsT0FBT29LLFVBQVAsQ0FBa0IrVSxNQUFsQixDQUF5QixXQUF6QixDQUF4QztBQUNBLFVBQU1pUyxxQkFBcUJweEIsT0FBT29LLFVBQVAsQ0FBa0JDLFdBQWxCLENBQThCLFdBQTlCLENBQTNCO0FBQ0ErbUIseUJBQW1COUIsVUFBbkIsQ0FBOEIsS0FBOUIsRUFBcUMsS0FBckM7O0FBRUEsVUFBTTA1QixvQ0FBb0NocEQsT0FBT29LLFVBQVAsQ0FBa0IrVSxNQUFsQixDQUF5QixhQUF6QixDQUExQztBQUNBLFVBQU1DLHVCQUF1QnBmLE9BQU9vSyxVQUFQLENBQWtCQyxXQUFsQixDQUE4QixhQUE5QixDQUE3Qjs7QUFFQSxVQUFNL0osaUJBQWlCO0FBQ3JCd2YsYUFBSyxJQUFJcnBCLGdCQUFKLENBQVksQ0FBWixFQUFlLENBQWYsQ0FEZ0I7QUFFckJzb0Isa0JBQVUsQ0FGVztBQUdyQmMsZUFBTyxJQUFJcHBCLGdCQUFKLENBQVksQ0FBWixFQUFlLENBQWYsQ0FIYztBQUlyQjZqQyxzQkFBYztBQUpPLE9BQXZCOztBQU9BLFVBQU1qZCxrQkFBa0IrVCxtQkFBbUI5VCxrQkFBbkIsQ0FBc0MsS0FBdEMsQ0FBeEI7QUFDQSxVQUFNNk8sb0JBQW9CaUYsbUJBQW1CMEYsZ0JBQW5CLENBQW9DelosZUFBcEMsQ0FBMUI7O0FBRUEsVUFBSTRyQywwQkFBMEIzb0QsY0FBOUI7QUFDQSxVQUFJeW9ELCtCQUFKLEVBQXFDO0FBQ25DRSxrQ0FBMEI3M0IsbUJBQW1CK0QsZ0JBQW5CLEVBQTFCO0FBQ0EsZUFBTzh6Qix3QkFBd0IxK0MsT0FBL0I7O0FBRUE7QUFKbUMsb0NBS0YwK0MsdUJBTEU7QUFBQSxZQUszQnBwQyxLQUwyQix5QkFLM0JBLEtBTDJCO0FBQUEsWUFLcEJDLEdBTG9CLHlCQUtwQkEsR0FMb0I7QUFBQSxZQUtmZixRQUxlLHlCQUtmQSxRQUxlOztBQU1uQyxZQUFNbXFDLGFBQWE5M0IsbUJBQW1CKzNCLGNBQW5CLENBQWtDcHFDLFFBQWxDLENBQW5CO0FBQ0EsWUFBTTFCLG1CQUFrQitULG1CQUFtQjlULGtCQUFuQixDQUFzQyxLQUF0QyxDQUF4QjtBQUNBLFlBQU04ckMsTUFBTXR6RCxLQUFLc3pELEdBQUwsQ0FBU3JxQyxRQUFULENBQVo7QUFDQSxZQUFNc3FDLE1BQU12ekQsS0FBS3V6RCxHQUFMLENBQVN0cUMsUUFBVCxDQUFaOztBQUVBLFlBQU11cUMsbUJBQW1CeHBDLElBQUlya0IsS0FBSixHQUFZTyxRQUFaLENBQXFCNmpCLEtBQXJCLEVBQTRCaFUsTUFBNUIsQ0FBbUMsQ0FBbkMsQ0FBekI7QUFDQSxZQUFNMDlDLGlCQUFpQjFwQyxNQUFNcGtCLEtBQU4sR0FDcEIyTSxHQURvQixDQUNoQmtoRCxnQkFEZ0IsRUFFcEJodkMsUUFGb0IsQ0FFWCtDLGdCQUZXLENBQXZCOztBQUlBLFlBQU1tc0MsMkJBQTJCRCxlQUM5QnZ0RCxRQUQ4QixDQUNyQnFoQixpQkFBZ0I1aEIsS0FBaEIsR0FBd0I2ZSxRQUF4QixDQUFpQyxHQUFqQyxDQURxQixDQUFqQzs7QUFHQTtBQUNBLFlBQU1tdkMsOEJBQThCLElBQUloekQsZ0JBQUosQ0FDbEMreUQseUJBQXlCcnVELENBQXpCLEdBQTZCaXVELEdBQTdCLEdBQW1DSSx5QkFBeUJwdUQsQ0FBekIsR0FBNkJpdUQsR0FEOUIsRUFFbENHLHlCQUF5QnJ1RCxDQUF6QixHQUE2Qmt1RCxHQUE3QixHQUFtQ0cseUJBQXlCcHVELENBQXpCLEdBQTZCZ3VELEdBRjlCLEVBR2xDOXVDLFFBSGtDLENBR3pCNHVDLFVBSHlCLENBQXBDOztBQUtBLFlBQU1RLG9CQUFvQnJzQyxpQkFBZ0I1aEIsS0FBaEIsR0FBd0I2ZSxRQUF4QixDQUFpQyxHQUFqQyxFQUN2QmxTLEdBRHVCLENBQ25CcWhELDJCQURtQixDQUExQjs7QUFHQSxZQUFNRSxvQkFBb0JELGtCQUFrQmp1RCxLQUFsQixHQUEwQm9RLE1BQTFCLENBQWlDd1IsZ0JBQWpDLENBQTFCOztBQUVBLFlBQU11c0MsV0FBV0Qsa0JBQWtCbHVELEtBQWxCLEdBQTBCTyxRQUExQixDQUFtQ3N0RCxpQkFBaUI3dEQsS0FBakIsR0FBeUI2ZSxRQUF6QixDQUFrQzR1QyxVQUFsQyxDQUFuQyxDQUFqQjtBQUNBLFlBQU1XLFNBQVNGLGtCQUFrQmx1RCxLQUFsQixHQUEwQjJNLEdBQTFCLENBQThCa2hELGlCQUFpQjd0RCxLQUFqQixHQUF5QjZlLFFBQXpCLENBQWtDNHVDLFVBQWxDLENBQTlCLENBQWY7O0FBRUFELGdDQUF3QnBwQyxLQUF4QixHQUFnQytwQyxRQUFoQztBQUNBWCxnQ0FBd0JucEMsR0FBeEIsR0FBOEIrcEMsTUFBOUI7QUFDRDs7QUFFRDdwRCxhQUFPbTRCLGtCQUFQLENBQTBCL0csa0JBQTFCLEVBQThDOXdCLGNBQTlDOztBQUVBLFVBQU13cEQsNEJBQTRCMXFDLHFCQUFxQitWLGdCQUFyQixFQUFsQztBQUNBLFVBQU00MEIsZ0JBQWdCLENBQUMsRUFBRCxFQUFLLENBQUwsRUFBUSxLQUFLLEVBQWIsRUFBaUIsQ0FBakIsQ0FBdEI7QUFDQS9wRCxhQUFPc3VCLGNBQVAsQ0FBc0I4QyxtQkFBbUIrM0IsY0FBbkIsRUFBdEI7QUFDQW5wRCxhQUFPd2YsV0FBUCxDQUFtQnlwQyx3QkFBd0JscUMsUUFBM0M7QUFDQS9lLGFBQU9ncUQsVUFBUCxDQUFrQkQsYUFBbEI7O0FBRUE7QUFDQTtBQUNBMzRCLHlCQUFtQi94QixHQUFuQixDQUF1QmlCLGNBQXZCLEVBQXVDeW9ELCtCQUF2Qzs7QUFFQS9vRCxhQUFPb3JCLElBQVAsQ0FBWS9yQixHQUFaLENBQWdCLE1BQWhCLEVBQXdCLFlBQU07QUFDNUI7QUFDQVcsZUFBT3lyQixRQUFQLENBQWdCdytCLE9BQWhCLENBQXdCLE1BQXhCLEVBQWdDLE1BQWhDO0FBQ0QsT0FIRCxFQUdHLEtBSEg7O0FBS0EsV0FBS3ovQyxjQUFMLENBQW9CO0FBQ2xCeStDLHdEQURrQjtBQUVsQmEsNERBRmtCO0FBR2xCNS9DLG1CQUFXa25CLGtCQUhPO0FBSWxCaFMsa0RBSmtCO0FBS2xCMnFDLG9DQUxrQjtBQU1sQmYsNEVBTmtCO0FBT2xCRCx3RUFQa0I7QUFRbEJscEMsZUFBT3BwQixpQkFBUTJyQixVQUFSLENBQW1CNm1DLHdCQUF3QnBwQyxLQUEzQyxDQVJXO0FBU2xCQyxhQUFLcnBCLGlCQUFRMnJCLFVBQVIsQ0FBbUI2bUMsd0JBQXdCbnBDLEdBQTNDLENBVGE7QUFVbEJmLGtCQUFVa3FDLHdCQUF3QmxxQyxRQVZoQjtBQVdsQm1yQyw2QkFBcUI5cUMscUJBQXFCRSxXQUFyQixFQVhIO0FBWWxCTCx3QkFBZ0JHLHFCQUFxQmxVLGlCQUFyQixFQVpFO0FBYWxCOFQsMEJBQWtCSSxxQkFBcUJwVSxtQkFBckIsRUFiQTtBQWNsQm1oQiw0Q0Fka0I7QUFlbEI5TztBQWZrQixPQUFwQjtBQWlCRDs7QUFFRDs7Ozs7Ozs7O2dDQU1vQnJkLE0sRUFBUTtBQUMxQixhQUFPQSxPQUFPeXVCLGFBQVAsQ0FBcUIsV0FBckIsS0FDTHp1QixPQUFPK25ELGFBQVAsQ0FBcUIsV0FBckIsQ0FERjtBQUVEOztBQUVEOzs7Ozs7OztxQ0FLeUIvbkQsTSxFQUFRO0FBQy9CLFVBQU1QLFVBQVVPLE9BQU9vM0IsVUFBUCxFQUFoQjtBQUNBLFVBQU0reUIsbUJBQW1CaDBELGtCQUFTeUwsUUFBVCxDQUN2Qm5DLFFBQVFPLE1BQVIsQ0FBZXMzQixlQUFmLENBQStCdFIsU0FEUixFQUV2QixLQUFLMWxCLGNBRmtCLENBQXpCOztBQUtBLFVBQUk0L0IsU0FBUyxDQUNYLG1DQURXLEVBRVgsa0NBRlcsRUFHWCwrQkFIVyxFQUlYLCtCQUpXLENBQWI7O0FBT0E7QUFDQSxVQUFNa3FCLFNBQVNDLHFDQUEyQkMsU0FBM0IsQ0FBcUNILGdCQUFyQyxDQUFmO0FBQ0FDLGFBQU8va0QsT0FBUCxDQUFlLFVBQUNnbEIsV0FBRCxFQUFpQjtBQUM5QixZQUFJanBCLE1BQU02b0IsT0FBTixDQUFjSSxXQUFkLENBQUosRUFBZ0M7QUFDOUJBLHNCQUFZaGxCLE9BQVosQ0FBb0IsZ0JBQWtCO0FBQUEsZ0JBQWhCcEcsVUFBZ0IsUUFBaEJBLFVBQWdCOztBQUNwQ2loQyxtQkFBT3huQyxJQUFQLHlCQUFrQ3VHLFVBQWxDO0FBQ0QsV0FGRDtBQUdELFNBSkQsTUFJTztBQUNMaWhDLGlCQUFPeG5DLElBQVAseUJBQWtDMnhCLFlBQVlwckIsVUFBOUM7QUFDRDtBQUNGLE9BUkQ7O0FBVUEsYUFBT2loQyxNQUFQO0FBQ0Q7Ozs7RUFqSjZCekIsa0I7O0FBb0poQzs7Ozs7O0FBSUFxcUIsa0JBQWtCN29ELHVCQUFsQixHQUE0Q3NxRCxrQ0FBNUM7O0FBRUE7Ozs7O0FBS0F6QixrQkFBa0I1b0QsaUJBQWxCLEdBQXNDbXFELG9DQUF0Qzs7QUFFQTs7Ozs7O0FBTUF2QixrQkFBa0Izb0QsdUJBQWxCLEdBQTRDcXFELDBDQUE1Qzs7QUFFQTs7Ozs7QUFLQTFCLGtCQUFrQjdwRCxVQUFsQixHQUErQixXQUEvQjs7QUFFQTs7Ozs7QUFLQTZwRCxrQkFBa0Ixb0QsUUFBbEIsR0FBNkIsaUNBQTdCOztBQUVBOzs7OztBQUtBMG9ELGtCQUFrQnpvRCxXQUFsQixHQUFnQyw0QkFBaEM7O0FBRUE7Ozs7Ozs7QUFPQXlvRCxrQkFBa0J4b0QsY0FBbEIsR0FBbUMsRUFBbkM7O0FBSUE7Ozs7QUFJQXdvRCxrQkFBa0JyQixrQkFBbEIsR0FBdUMsQ0FBQyxXQUFELENBQXZDOztrQkFFZXFCLGlCOzs7Ozs7Ozs7Ozs7Ozs7OztBQzFOZjs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OzsrZUFuQkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztJQW1CcUJ1QiwwQjs7O0FBQ25CLHdDQUFzQjtBQUFBOztBQUFBOztBQUFBLHNDQUFOeHJELElBQU07QUFBTkEsVUFBTTtBQUFBOztBQUFBLG1MQUNYQSxJQURXOztBQUdwQixVQUFLckYsUUFBTCxDQUNFLGNBREYsRUFFRSxtQkFGRixFQUdFLGVBSEY7O0FBTUEsVUFBS0MsS0FBTCxHQUFhLEVBQUUwNEMsT0FBTyxJQUFULEVBQWI7QUFDQSxVQUFLc1ksT0FBTCxHQUFlLE1BQUt0eEQsV0FBTCxDQUFpQm14RCxTQUFqQixDQUEyQixNQUFLenNELEtBQUwsQ0FBVzRCLE9BQXRDLENBQWY7O0FBRUEsVUFBS29LLE9BQUwsdUJBQ0d6UyxtQkFBVXNNLE1BQVYsQ0FBaUJ1dUMsdUJBRHBCLEVBQzhDLE1BQUt5WSxhQURuRDs7QUFJQSxVQUFLQyxtQkFBTCxDQUF5QixDQUFDLE1BQUtwbkQsY0FBTCxDQUFvQixpQ0FBcEIsQ0FBMUI7QUFoQm9CO0FBaUJyQjs7QUFFRDs7QUFFQTs7Ozs7Ozs7Ozs7QUFvQ0E7O0FBRUE7Ozs7OztnREFNNkJpZ0MsUSxFQUFVQyxRLEVBQVU7QUFDL0MsYUFBT0QsU0FBUzJPLEtBQVQsS0FBbUIxTyxTQUFTME8sS0FBbkM7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7Ozs7c0NBS21CcHpCLFEsRUFBVTtBQUMzQixVQUFNcVMscUJBQXFCLEtBQUs3dEIsY0FBTCxDQUFvQixXQUFwQixDQUEzQjtBQUQyQixVQUVuQnZELE1BRm1CLEdBRVIsS0FBS2IsT0FGRyxDQUVuQmEsTUFGbUI7O0FBRzNCK2UsaUJBQVdBLFdBQVdqcEIsS0FBS2krQixFQUFoQixHQUFxQixHQUFoQztBQUNBL3pCLGFBQU93ZixXQUFQLENBQW1CVCxRQUFuQjtBQUNBL2UsYUFBT3N1QixjQUFQLENBQXNCOEMsbUJBQW1CKzNCLGNBQW5CLENBQWtDcHFDLFFBQWxDLENBQXRCOztBQUVBL2UsYUFBT21MLE1BQVA7QUFDQSxXQUFLWCxjQUFMLENBQW9CLEVBQUV1VSxrQkFBRixFQUFwQjtBQUNEOztBQUVEOzs7Ozs7OztrREFLK0I7QUFBQSxVQUNyQi9lLE1BRHFCLEdBQ1YsS0FBS2IsT0FESyxDQUNyQmEsTUFEcUI7O0FBRTdCLFVBQU0rZSxXQUFXL2UsT0FBT3NmLFdBQVAsRUFBakI7O0FBRUEsVUFBTTNULG1CQUFtQjNMLE9BQU80TCxtQkFBUCxDQUEyQixLQUEzQixDQUF6Qjs7QUFFQSxhQUFPLElBQUluVixnQkFBSixDQUNMWCxLQUFLMlMsR0FBTCxDQUFTa0QsaUJBQWlCeFEsQ0FBakIsR0FBcUJyRixLQUFLc3pELEdBQUwsQ0FBU3JxQyxRQUFULENBQTlCLElBQW9EanBCLEtBQUsyUyxHQUFMLENBQVNrRCxpQkFBaUJ2USxDQUFqQixHQUFxQnRGLEtBQUt1ekQsR0FBTCxDQUFTdHFDLFFBQVQsQ0FBOUIsQ0FEL0MsRUFFTGpwQixLQUFLMlMsR0FBTCxDQUFTa0QsaUJBQWlCeFEsQ0FBakIsR0FBcUJyRixLQUFLdXpELEdBQUwsQ0FBU3RxQyxRQUFULENBQTlCLElBQW9EanBCLEtBQUsyUyxHQUFMLENBQVNrRCxpQkFBaUJ2USxDQUFqQixHQUFxQnRGLEtBQUtzekQsR0FBTCxDQUFTcnFDLFFBQVQsQ0FBOUIsQ0FGL0MsQ0FBUDtBQUlEOztBQUVEOzs7Ozs7Ozs2Q0FLMEI7QUFDeEIsVUFBTXFTLHFCQUFxQixLQUFLN3RCLGNBQUwsQ0FBb0IsV0FBcEIsQ0FBM0I7QUFDQSxVQUFNNHVDLFFBQVEsS0FBSzV1QyxjQUFMLENBQW9CLE9BQXBCLENBQWQ7QUFDQSxVQUFJLENBQUM0dUMsS0FBRCxJQUFVLENBQUNBLE1BQU14MEIsVUFBckIsRUFBaUM7QUFDL0IsZUFBTyxDQUFQO0FBQ0Q7O0FBRUQsVUFBTWtDLFFBQVEsS0FBS3RjLGNBQUwsQ0FBb0IsT0FBcEIsQ0FBZDtBQUNBLFVBQU11YyxNQUFNLEtBQUt2YyxjQUFMLENBQW9CLEtBQXBCLENBQVo7O0FBRUEsVUFBTWtELE9BQU9xWixJQUFJcmtCLEtBQUosR0FBWU8sUUFBWixDQUFxQjZqQixLQUFyQixDQUFiO0FBQ0EsVUFBTTRhLHNCQUFzQnJKLG1CQUFtQjlULGtCQUFuQixDQUFzQyxLQUF0QyxFQUN6QmhELFFBRHlCLENBQ2hCN1QsSUFEZ0IsQ0FBNUI7QUFFQSxhQUFPMHJDLE1BQU14MEIsVUFBTixDQUFpQnhpQixDQUFqQixHQUFxQnMvQixvQkFBb0J0L0IsQ0FBaEQ7QUFDRDs7QUFFRDs7Ozs7Ozt1Q0FJb0I7QUFDbEIsVUFBTXl2RCxlQUFlLEVBQXJCOztBQUVBLFVBQU1DLHVCQUF1QixLQUFLQyx3QkFBTCxFQUE3QjtBQUNBLFVBQUlELG9CQUFKLEVBQTBCO0FBQ3hCRCxxQkFBYWx5RCxJQUFiLENBQWtCbXlELG9CQUFsQjtBQUNEOztBQUVELFVBQU1FLHlCQUF5QixLQUFLQywwQkFBTCxFQUEvQjtBQUNBLFVBQUlELHNCQUFKLEVBQTRCO0FBQzFCSCxxQkFBYWx5RCxJQUFiLENBQWtCcXlELHNCQUFsQjtBQUNEOztBQUVELGFBQU9ILFlBQVA7QUFDRDs7QUFFRDs7Ozs7OzsrQ0FJNEI7QUFBQSxVQUNsQjVxRCxNQURrQixHQUNQLEtBQUtiLE9BREUsQ0FDbEJhLE1BRGtCOztBQUUxQixVQUFNb3hCLHFCQUFxQixLQUFLN3RCLGNBQUwsQ0FBb0IsV0FBcEIsQ0FBM0I7QUFDQSxVQUFNMGxELDBCQUEwQixLQUFLMWxELGNBQUwsQ0FBb0IseUJBQXBCLENBQWhDO0FBQ0EsVUFBTXdsRCxrQ0FBa0MsS0FBS3hsRCxjQUFMLENBQW9CLGlDQUFwQixDQUF4QztBQUNBLFVBQUksQ0FBQzZ0QixtQkFBbUJnM0IsWUFBbkIsQ0FBZ0NhLHVCQUFoQyxDQUFMLEVBQStEO0FBQzdELGVBQU87QUFDTC8rQyxxQkFBV2tuQixrQkFETjtBQUVMM3hCLG1CQUFTd3BELHVCQUZKO0FBR0xnQyxvQkFBVWxDLCtCQUhMO0FBSUxyRSxnQkFBTSxjQUFDeDZDLFNBQUQsRUFBWTBnQyxVQUFaLEVBQTJCO0FBQy9CNXFDLG1CQUFPbTRCLGtCQUFQLENBQTBCanVCLFNBQTFCLEVBQXFDMGdDLFVBQXJDO0FBQ0Q7QUFOSSxTQUFQO0FBUUQ7QUFDRjs7QUFFRDs7Ozs7OztpREFJOEI7QUFBQSxVQUNwQjVxQyxNQURvQixHQUNULEtBQUtiLE9BREksQ0FDcEJhLE1BRG9COztBQUU1QixVQUFNb2YsdUJBQXVCLEtBQUs3YixjQUFMLENBQW9CLHNCQUFwQixDQUE3QjtBQUNBLFVBQU11bUQsNEJBQTRCLEtBQUt2bUQsY0FBTCxDQUFvQiwyQkFBcEIsQ0FBbEM7QUFDQSxVQUFNeWxELG9DQUFvQyxLQUFLemxELGNBQUwsQ0FBb0IsbUNBQXBCLENBQTFDO0FBQ0EsVUFBSSxDQUFDNmIscUJBQXFCZ3BDLFlBQXJCLENBQWtDMEIseUJBQWxDLENBQUwsRUFBbUU7QUFDakUsZUFBTztBQUNMNS9DLHFCQUFXa1Ysb0JBRE47QUFFTDNmLG1CQUFTcXFELHlCQUZKO0FBR0xtQixvQkFBVWpDLGlDQUhMO0FBSUx0RSxnQkFBTSxjQUFDeDZDLFNBQUQsRUFBWTBnQyxVQUFaLEVBQTJCO0FBQy9CLGdCQUFJMWdDLFVBQVVvVixXQUFWLE9BQTRCc3JCLFdBQVc3ckIsUUFBM0MsRUFBcUQ7QUFDbkQvZSxxQkFBT2tyRCxlQUFQLENBQXVCdGdCLFdBQVc3ckIsUUFBWCxHQUFzQjdVLFVBQVVvVixXQUFWLEVBQTdDO0FBQ0Q7O0FBRUQsZ0JBQU1QLFdBQVc2ckIsV0FBVzdyQixRQUE1QjtBQUNBLGdCQUFNb3NDLGNBQWNwc0MsYUFBYSxFQUFiLElBQW1CQSxhQUFhLEdBQXBEO0FBQ0EsZ0JBQUk3VSxVQUFVZ0IsaUJBQVYsT0FBa0MwL0IsV0FBVzNyQixjQUFqRCxFQUFpRTtBQUMvRGpmLHFCQUFPb3JELGFBQVAsQ0FBcUJELGNBQWMsWUFBZCxHQUE2QixVQUFsRDtBQUNELGFBRkQsTUFFTyxJQUFJamhELFVBQVVjLG1CQUFWLE9BQW9DNC9CLFdBQVc1ckIsZ0JBQW5ELEVBQXFFO0FBQzFFaGYscUJBQU9vckQsYUFBUCxDQUFxQkQsY0FBYyxVQUFkLEdBQTJCLFlBQWhEO0FBQ0Q7QUFDRjtBQWhCSSxTQUFQO0FBa0JEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7b0NBSWlCO0FBQ2YsVUFBTWhaLFFBQVEsS0FBSzV1QyxjQUFMLENBQW9CLE9BQXBCLENBQWQ7QUFDQSxXQUFLOG5ELFlBQUwsQ0FBa0JsWixLQUFsQjtBQUNEOztBQUVEOzs7Ozs7OztpQ0FLY24zQyxDLEVBQUc7QUFBQSxVQUNQZ0YsTUFETyxHQUNJLEtBQUtiLE9BRFQsQ0FDUGEsTUFETzs7O0FBR2YsVUFBTW15QyxRQUFRLEtBQUs1dUMsY0FBTCxDQUFvQixPQUFwQixDQUFkO0FBQ0EsVUFBTTZ0QixxQkFBcUIsS0FBSzd0QixjQUFMLENBQW9CLFdBQXBCLENBQTNCO0FBQ0EsVUFBTTZiLHVCQUF1QixLQUFLN2IsY0FBTCxDQUFvQixzQkFBcEIsQ0FBN0I7O0FBRUEsVUFBTXdiLFdBQVcvZSxPQUFPc2YsV0FBUCxFQUFqQjtBQUNBLFVBQUlPLFFBQVEsS0FBS3RjLGNBQUwsQ0FBb0IsT0FBcEIsRUFBNkI5SCxLQUE3QixFQUFaO0FBQ0EsVUFBSXFrQixNQUFNLEtBQUt2YyxjQUFMLENBQW9CLEtBQXBCLEVBQTJCOUgsS0FBM0IsRUFBVjtBQUNBLFVBQUksQ0FBQzAyQyxVQUFVLElBQVYsSUFBbUJ0eUIsTUFBTWtjLE1BQU4sQ0FBYSxDQUFiLEVBQWdCLENBQWhCLEtBQXNCamMsSUFBSWljLE1BQUosQ0FBVyxDQUFYLEVBQWMsQ0FBZCxDQUExQyxLQUFnRWhkLGFBQWEsQ0FBakYsRUFBb0Y7QUFDbEYvZSxlQUFPb0ssVUFBUCxDQUFrQmsrQyxNQUFsQixDQUF5QmwzQixrQkFBekI7QUFDRCxPQUZELE1BRU87QUFDTDtBQUNBLFlBQUlrSixlQUFlLEtBQUtneEIsc0JBQUwsRUFBbkI7O0FBRUEsWUFBTTdyRCxVQUFVO0FBQ2RzZiw0QkFEYztBQUVkYyxzQkFGYztBQUdkQyxrQkFIYztBQUlkd2Esb0NBSmM7QUFLZC92QixtQkFBUztBQUxLLFNBQWhCOztBQVFBLFlBQU0yK0MsYUFBYTkzQixtQkFBbUIrM0IsY0FBbkIsQ0FBa0NwcUMsUUFBbEMsQ0FBbkI7QUFDQSxZQUFNMUIsa0JBQWtCK1QsbUJBQW1COVQsa0JBQW5CLENBQXNDLEtBQXRDLENBQXhCO0FBQ0EsWUFBTThyQyxNQUFNdHpELEtBQUtzekQsR0FBTCxDQUFTLENBQUNycUMsUUFBVixDQUFaO0FBQ0EsWUFBTXNxQyxNQUFNdnpELEtBQUt1ekQsR0FBTCxDQUFTLENBQUN0cUMsUUFBVixDQUFaOztBQUVBLFlBQU11cUMsbUJBQW1CeHBDLElBQUlya0IsS0FBSixHQUFZTyxRQUFaLENBQXFCNmpCLEtBQXJCLEVBQTRCaFUsTUFBNUIsQ0FBbUMsQ0FBbkMsQ0FBekI7QUFDQSxZQUFNMDlDLGlCQUFpQjFwQyxNQUFNcGtCLEtBQU4sR0FDcEIyTSxHQURvQixDQUNoQmtoRCxnQkFEZ0IsRUFFcEJodkMsUUFGb0IsQ0FFWCtDLGVBRlcsQ0FBdkI7O0FBSUEsWUFBTW1zQywyQkFBMkJELGVBQzlCdnRELFFBRDhCLENBQ3JCcWhCLGdCQUFnQjVoQixLQUFoQixHQUF3QjZlLFFBQXhCLENBQWlDLEdBQWpDLENBRHFCLENBQWpDOztBQUdBO0FBQ0EsWUFBTW12Qyw4QkFBOEIsSUFBSWh6RCxnQkFBSixDQUNsQyt5RCx5QkFBeUJydUQsQ0FBekIsR0FBNkJpdUQsR0FBN0IsR0FBbUNJLHlCQUF5QnB1RCxDQUF6QixHQUE2Qml1RCxHQUQ5QixFQUVsQ0cseUJBQXlCcnVELENBQXpCLEdBQTZCa3VELEdBQTdCLEdBQW1DRyx5QkFBeUJwdUQsQ0FBekIsR0FBNkJndUQsR0FGOUIsRUFHbEN2OUMsTUFIa0MsQ0FHM0JxOUMsVUFIMkIsQ0FBcEM7O0FBS0EsWUFBTVEsb0JBQW9CcnNDLGdCQUFnQjVoQixLQUFoQixHQUF3QjZlLFFBQXhCLENBQWlDLEdBQWpDLEVBQ3ZCbFMsR0FEdUIsQ0FDbkJxaEQsMkJBRG1CLENBQTFCOztBQUdBLFlBQU1FLG9CQUFvQkQsa0JBQWtCanVELEtBQWxCLEdBQTBCb1EsTUFBMUIsQ0FBaUN3UixlQUFqQyxDQUExQjs7QUFFQTVkLGdCQUFRb2dCLEtBQVIsR0FBZ0I4cEMsa0JBQWtCbHVELEtBQWxCLEdBQTBCTyxRQUExQixDQUFtQ3N0RCxpQkFBaUI3dEQsS0FBakIsR0FBeUJvUSxNQUF6QixDQUFnQ3E5QyxVQUFoQyxDQUFuQyxDQUFoQjtBQUNBenBELGdCQUFRcWdCLEdBQVIsR0FBYzZwQyxrQkFBa0JsdUQsS0FBbEIsR0FBMEIyTSxHQUExQixDQUE4QmtoRCxpQkFBaUI3dEQsS0FBakIsR0FBeUJvUSxNQUF6QixDQUFnQ3E5QyxVQUFoQyxDQUE5QixDQUFkOztBQUVBbHBELGVBQU9tNEIsa0JBQVAsQ0FBMEIvRyxrQkFBMUIsRUFBOEMzeEIsT0FBOUM7QUFDQTJ4QiwyQkFBbUIveEIsR0FBbkIsQ0FBdUJJLE9BQXZCO0FBQ0Q7O0FBRUQsVUFBSTJmLHFCQUFxQkUsV0FBckIsT0FBdUMsQ0FBdkMsSUFDQSxDQUFDRixxQkFBcUJsVSxpQkFBckIsRUFERCxJQUVBLENBQUNrVSxxQkFBcUJwVSxtQkFBckIsRUFGTCxFQUVpRDtBQUMvQ2hMLGVBQU9vSyxVQUFQLENBQWtCaytDLE1BQWxCLENBQXlCbHBDLG9CQUF6QjtBQUNEOztBQUVEO0FBQ0FwZixhQUFPZ3FELFVBQVAsQ0FBa0IsS0FBbEI7QUFDQWhxRCxhQUFPd2YsV0FBUCxDQUFtQixDQUFuQjtBQUNBeGYsYUFBT3N1QixjQUFQLENBQXNCLENBQXRCOztBQUVBO0FBQ0EsVUFBTXM4QixlQUFlLEtBQUtXLGdCQUFMLEVBQXJCO0FBQ0EsVUFBSVgsYUFBYS9rRCxNQUFqQixFQUF5QjtBQUFBLDZCQUNRLEtBQUtoSSxLQUFMLENBQVc0QixPQURuQjtBQUFBLFlBQ2pCb2hDLFNBRGlCLGtCQUNqQkEsU0FEaUI7QUFBQSxZQUNOdWdCLFNBRE0sa0JBQ05BLFNBRE07OztBQUd2QixZQUFJLENBQUN2Z0IsU0FBRCxJQUFjLENBQUN1Z0IsU0FBbkIsRUFBOEI7QUFDNUJwaEQsaUJBQU9pckIsT0FBUCxDQUFlN2lCLEdBQWYsQ0FBbUJ3aUQsWUFBbkI7QUFDRDtBQUNGOztBQUVEO0FBQ0E1cUQsYUFBT3lyQixRQUFQLENBQWdCKy9CLE1BQWhCLENBQXVCLE1BQXZCLEVBQStCLE1BQS9CO0FBQ0F4ckQsYUFBT29yQixJQUFQLENBQVkvckIsR0FBWixDQUFnQixNQUFoQjs7QUFFQSwySkFBbUJyRSxDQUFuQjtBQUNEOztBQUVEOztBQUVBOzs7Ozs7OzswQ0FLK0M7QUFBQSxVQUExQnl3RCxpQkFBMEIsdUVBQU4sSUFBTTs7QUFDN0MsVUFBTXZoRCxZQUFZLEtBQUszRyxjQUFMLENBQW9CLFdBQXBCLENBQWxCO0FBQ0EsVUFBSW1vRCxnQkFBZ0IsSUFBcEI7QUFDQSxVQUFNdEIsU0FBU2owRCxrQkFBU2lMLEtBQVQsQ0FBZXFqQixPQUFmLENBQXVCLEtBQUtnbUMsT0FBNUIsQ0FBZjs7QUFFQTtBQUNBLFVBQU1rQixpQkFBaUJ6aEQsVUFBVSt4QixNQUFqQztBQUNBLFVBQUkwdkIsY0FBSixFQUFvQjtBQUNsQixZQUFNQyxpQkFBaUJ4QixPQUFPemtELE1BQVAsQ0FBYyxVQUFDd3NDLEtBQUQ7QUFBQSxpQkFBV0EsVUFBVXdaLGNBQXJCO0FBQUEsU0FBZCxDQUF2QjtBQUNBRCx3QkFBZ0JFLGVBQWUsQ0FBZixDQUFoQjtBQUNEOztBQUVEO0FBQ0EsVUFBSSxDQUFDRixhQUFMLEVBQW9CO0FBQ2xCLFlBQU1HLGlCQUFpQnpCLE9BQU96a0QsTUFBUCxDQUFjLFVBQUN3c0MsS0FBRDtBQUFBLGlCQUFXQSxNQUFNQyxRQUFqQjtBQUFBLFNBQWQsQ0FBdkI7QUFDQXNaLHdCQUFnQkcsZUFBZXJ0QyxHQUFmLEVBQWhCO0FBQ0Q7O0FBRUQ7QUFDQSxVQUFJLENBQUNrdEMsYUFBTCxFQUFvQjtBQUNsQkEsd0JBQWdCdEIsT0FBTyxDQUFQLENBQWhCO0FBQ0Q7O0FBRUQsYUFBTyxLQUFLaUIsWUFBTCxDQUFrQkssYUFBbEIsRUFBaUNELGlCQUFqQyxFQUFvRCxLQUFwRCxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7aUNBT2N0WixLLEVBQWdEO0FBQUEsVUFBekNzWixpQkFBeUMsdUVBQXJCLElBQXFCO0FBQUEsVUFBZjV4RCxNQUFlLHVFQUFOLElBQU07O0FBQzVELFVBQU1xUSxZQUFZLEtBQUszRyxjQUFMLENBQW9CLFdBQXBCLENBQWxCO0FBQ0EsVUFBSWtvRCxxQkFBcUJ0WixLQUF6QixFQUFnQztBQUM5QixhQUFLMlosMEJBQUwsQ0FBZ0MzWixLQUFoQyxFQUF1Q3Q0QyxNQUF2QztBQUNEO0FBQ0RxUSxnQkFBVSt4QixNQUFWLEdBQW1Ca1csS0FBbkI7O0FBRUEsVUFBTTRaLGlCQUFpQjtBQUNyQjVaO0FBRHFCLE9BQXZCO0FBUDRELFVBVXBEbnlDLE1BVm9ELEdBVXpDLEtBQUtiLE9BVm9DLENBVXBEYSxNQVZvRDs7QUFXNUQsVUFBSSxDQUFDbXlDLEtBQUwsRUFBWTtBQUNWbnlDLGVBQU9ncUQsVUFBUCxDQUFrQixLQUFsQjtBQUNBaHFELGVBQU93ZixXQUFQLENBQW1CLENBQW5CO0FBQ0F4ZixlQUFPc3VCLGNBQVAsQ0FBc0IsQ0FBdEI7O0FBRUF5OUIsdUJBQWVodEMsUUFBZixHQUEwQixDQUExQjtBQUNBZ3RDLHVCQUFlbHNDLEtBQWYsR0FBdUIsSUFBSXBwQixnQkFBSixDQUFZLENBQVosRUFBZSxDQUFmLENBQXZCO0FBQ0FzMUQsdUJBQWVqc0MsR0FBZixHQUFxQixJQUFJcnBCLGdCQUFKLENBQVksQ0FBWixFQUFlLENBQWYsQ0FBckI7QUFDRCxPQVJELE1BUU87QUFDTHVKLGVBQU9ncUQsVUFBUCxDQUFrQixLQUFLem1ELGNBQUwsQ0FBb0IsZUFBcEIsQ0FBbEI7QUFDRDtBQUNEdkQsYUFBT21MLE1BQVA7QUFDQSxXQUFLWCxjQUFMLENBQW9CdWhELGNBQXBCLEVBQW9DbHlELE1BQXBDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztzREFNeUU7QUFBQSxVQUEzQ3M0QyxLQUEyQyxTQUEzQ0EsS0FBMkM7QUFBQSxVQUFwQ2xqQyxJQUFvQyxTQUFwQ0EsSUFBb0M7QUFBQSxVQUE5QjBPLFVBQThCLFNBQTlCQSxVQUE4QjtBQUFBLFVBQWhCOWpCLE1BQWdCLHVFQUFQLEtBQU87QUFBQSxVQUMvRG1HLE1BRCtELEdBQ3BELEtBQUtiLE9BRCtDLENBQy9EYSxNQUQrRDs7QUFFdkUsVUFBSTZmLFFBQVEsSUFBSXBwQixnQkFBSixFQUFaO0FBQ0EsVUFBSXFwQixNQUFNLElBQUlycEIsZ0JBQUosRUFBVjs7QUFFQSxVQUFJa25CLGNBQWMsQ0FBQ3cwQixLQUFuQixFQUEwQjtBQUN4QkEsZ0JBQVF4MEIsV0FBV3hpQixDQUFYLEdBQWV3aUIsV0FBV3ZpQixDQUFsQztBQUNEOztBQUVELFVBQUkrMkMsVUFBVSxHQUFkLEVBQW1CO0FBQ2pCdHlCLGdCQUFRLElBQUlwcEIsZ0JBQUosQ0FBWSxDQUFaLEVBQWUsQ0FBZixDQUFSO0FBQ0FxcEIsY0FBTSxJQUFJcnBCLGdCQUFKLENBQVksQ0FBWixFQUFlLENBQWYsQ0FBTjtBQUNELE9BSEQsTUFHTztBQUNMLFlBQU1rVixtQkFBbUIzTCxPQUFPNEwsbUJBQVAsRUFBekI7QUFDQSxZQUFNb2dELGNBQWNyZ0QsaUJBQWlCeFEsQ0FBakIsR0FBcUJ3USxpQkFBaUJ2USxDQUExRDtBQUNBLFlBQUk0d0QsZUFBZTdaLEtBQW5CLEVBQTBCO0FBQ3hCLGNBQU1uMUMsU0FBUyxJQUFJMk8saUJBQWlCdlEsQ0FBckIsSUFBMEJ1USxpQkFBaUJ4USxDQUFqQixHQUFxQmczQyxLQUEvQyxDQUFmO0FBQ0F0eUIsZ0JBQU14Z0IsR0FBTixDQUFVLENBQVYsRUFBYSxDQUFDLE1BQU1yQyxNQUFQLElBQWlCLENBQTlCO0FBQ0E4aUIsY0FBSXpnQixHQUFKLENBQVEsR0FBUixFQUFhLElBQUl3Z0IsTUFBTXprQixDQUF2QjtBQUNELFNBSkQsTUFJTztBQUNMLGNBQU1pQyxRQUFRLElBQUlzTyxpQkFBaUJ4USxDQUFyQixJQUEwQmczQyxRQUFReG1DLGlCQUFpQnZRLENBQW5ELENBQWQ7QUFDQXlrQixnQkFBTXhnQixHQUFOLENBQVUsQ0FBQyxJQUFJaEMsS0FBTCxJQUFjLENBQXhCLEVBQTJCLENBQTNCO0FBQ0F5aUIsY0FBSXpnQixHQUFKLENBQVEsSUFBSXdnQixNQUFNMWtCLENBQWxCLEVBQXFCLEdBQXJCO0FBQ0Q7QUFDRjs7QUFFRCxXQUFLcVAsY0FBTCxDQUFvQixFQUFFcVYsWUFBRixFQUFTQyxRQUFULEVBQXBCLEVBQW9Dam1CLE1BQXBDO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7NENBSXlCO0FBQ3ZCLFVBQU1rbEIsV0FBVyxLQUFLeGIsY0FBTCxDQUFvQixVQUFwQixJQUFrQyxHQUFsQyxHQUF3Q3pOLEtBQUtpK0IsRUFBOUQ7QUFDQSxVQUFJLENBQUMsS0FBS3h3QixjQUFMLENBQW9CLE9BQXBCLENBQUwsRUFBbUMsT0FBTyxJQUFQO0FBQ25DLGFBQVEsZ0NBQUMsZ0NBQUQ7QUFDTixlQUFPd2IsUUFERDtBQUVOLGtCQUFVLENBQUMsRUFGTDtBQUdOLHVCQUhNO0FBSU4sa0JBQVUsRUFKSjtBQUtOLG1CQUFVLE1BTEo7QUFNTixlQUFPLEtBQUszQyxFQUFMLENBQVEsK0JBQVIsQ0FORDtBQU9OLGtCQUFVLEtBQUs2dkMsaUJBUFQsR0FBUjtBQVFEOztBQUVEOzs7Ozs7Ozt1Q0FLb0I7QUFBQTs7QUFDbEIsVUFBSXJpQyxRQUFRLEVBQVo7QUFDQSxVQUFNQyxXQUFXLFNBQVhBLFFBQVcsQ0FBQ3NvQixLQUFELEVBQVc7QUFDMUIsZUFBUTtBQUFBO0FBQUE7QUFDTixpQkFBSSxRQURFO0FBRU4saUJBQUtBLE1BQU1sekMsVUFGTDtBQUdOLCtCQUFpQmt6QyxNQUFNbHpDLFVBSGpCO0FBSU47QUFBQTtBQUFBLGNBQUssV0FBVSxhQUFmO0FBQ0U7QUFBQTtBQUFBLGdCQUFLLEtBQUksdUJBQVQ7QUFDRSwyQkFBVyxPQUFLc0UsY0FBTCxDQUFvQixPQUFwQixNQUFpQzR1QyxLQUFqQyxHQUF5QyxXQUF6QyxHQUF1RCxJQURwRTtBQUVFLHlCQUFTLE9BQUtrWixZQUFMLENBQWtCeDBELElBQWxCLENBQXVCLE1BQXZCLEVBQTZCczdDLEtBQTdCLENBRlg7QUFHRSx1REFBSyxLQUFJLFFBQVQsRUFBa0IsS0FBSyxPQUFLMTVCLGFBQUwseUJBQXlDMDVCLE1BQU1sekMsVUFBL0MsV0FBaUUsSUFBakUsQ0FBdkIsR0FIRjtBQUlFO0FBQUE7QUFBQSxrQkFBSyxLQUFJLFNBQVQ7QUFBb0IsdUJBQUttZCxFQUFMLDRCQUFpQysxQixNQUFNbHpDLFVBQXZDLEtBQXdEa3pDLE1BQU1wc0M7QUFBbEY7QUFKRjtBQURGO0FBSk0sU0FBUjtBQWFELE9BZEQ7O0FBZ0JBLFdBQUswa0QsT0FBTCxDQUFhcGxELE9BQWIsQ0FBcUIsVUFBQzZtRCxZQUFELEVBQWtCO0FBQ3JDLFlBQUk5cUQsTUFBTTZvQixPQUFOLENBQWNpaUMsWUFBZCxDQUFKLEVBQWlDO0FBQy9CLGNBQU01OEMsUUFBUTQ4QyxZQUFkOztBQUVBLGNBQUloaUMsYUFBYSxFQUFqQjtBQUNBNWEsZ0JBQU1qSyxPQUFOLENBQWMsVUFBQzhzQyxLQUFELEVBQVc7QUFDdkJqb0IsdUJBQVd4eEIsSUFBWCxDQUFnQm14QixTQUFTc29CLEtBQVQsQ0FBaEI7QUFDRCxXQUZEOztBQUlBLGNBQUlqb0IsV0FBV3JrQixNQUFmLEVBQXVCO0FBQ3JCK2pCLGtCQUFNbHhCLElBQU4sQ0FBV3d4QixVQUFYO0FBQ0Q7QUFDRixTQVhELE1BV087QUFDTCxjQUFNaW9CLFFBQVErWixZQUFkO0FBQ0F0aUMsZ0JBQU1seEIsSUFBTixDQUFXbXhCLFNBQVNzb0IsS0FBVCxDQUFYO0FBQ0Q7QUFDRixPQWhCRDs7QUFrQkEsVUFBSS9uQixhQUFhLEVBQWpCO0FBQ0FSLFlBQU12a0IsT0FBTixDQUFjLFVBQUNnbEIsV0FBRCxFQUFpQjtBQUM3QkQscUJBQWFBLFdBQVdoa0IsTUFBWCxDQUFrQmlrQixXQUFsQixDQUFiO0FBQ0EsWUFBSWpwQixNQUFNNm9CLE9BQU4sQ0FBY0ksV0FBZCxLQUE4QkEsZ0JBQWdCVCxNQUFNQSxNQUFNL2pCLE1BQU4sR0FBZSxDQUFyQixDQUFsRCxFQUEyRTtBQUN6RXVrQixxQkFBVzF4QixJQUFYLENBQWdCLHdDQUFJLEtBQUksYUFBUixHQUFoQjtBQUNEO0FBQ0YsT0FMRDs7QUFPQSxVQUFNeXpELGtCQUFtQjtBQUFBO0FBQUE7QUFDdkIsZUFBSSxRQURtQjtBQUV2Qiw2QkFBZ0IsTUFGTztBQUd2QixlQUFJLGFBSG1CO0FBSXZCO0FBQUE7QUFBQSxZQUFLLFdBQVUsYUFBZjtBQUNFO0FBQUE7QUFBQSxjQUFLLEtBQUksdUJBQVQ7QUFDRSx5QkFBVyxDQUFDLEtBQUs1b0QsY0FBTCxDQUFvQixPQUFwQixDQUFELEdBQWdDLFdBQWhDLEdBQThDLElBRDNEO0FBRUUsdUJBQVMsS0FBSzhuRCxZQUFMLENBQWtCeDBELElBQWxCLENBQXVCLElBQXZCLEVBQTZCLElBQTdCLENBRlg7QUFHRSxxREFBSyxLQUFJLFFBQVQsRUFBa0IsS0FBSyxLQUFLNGhCLGFBQUwsd0NBQTBELElBQTFELENBQXZCLEdBSEY7QUFJRTtBQUFBO0FBQUEsZ0JBQUssS0FBSSxTQUFUO0FBQW9CLG1CQUFLMkQsRUFBTDtBQUFwQjtBQUpGO0FBREY7QUFKdUIsT0FBekI7O0FBNUNrQixVQTBEVjNjLE9BMURVLEdBMERFLEtBQUtOLE9BMURQLENBMERWTSxPQTFEVTs7O0FBNERsQixhQUFPQSxRQUFRTyxNQUFSLENBQWU2Z0MsU0FBZixHQUNIelcsVUFERyxHQUVILENBQUMraEMsZUFBRCxFQUFrQix3Q0FBSSxLQUFJLGFBQVIsR0FBbEIsRUFBNEMvbEQsTUFBNUMsQ0FBbURna0IsVUFBbkQsQ0FGSjtBQUdEOztBQUVEOzs7Ozs7O3FDQUlrQjtBQUNoQixVQUFNRSxZQUFZLEtBQUtDLGdCQUFMLEVBQWxCOztBQUVBLGFBQ0U7QUFBQTtBQUFBLFVBQUssS0FBSSxlQUFUO0FBQ0U7QUFBQyxzQ0FBRDtBQUFBO0FBQ0U7QUFBQTtBQUFBLGNBQUksS0FBSSxTQUFSO0FBQ0dEO0FBREg7QUFERjtBQURGLE9BREY7QUFTRDs7OzhCQTFkaUI3cUIsTyxFQUFTO0FBQUEsVUFDbkIycUQsTUFEbUIsR0FDd0IzcUQsT0FEeEIsQ0FDbkIycUQsTUFEbUI7QUFBQSxVQUNYZ0MsYUFEVyxHQUN3QjNzRCxPQUR4QixDQUNYMnNELGFBRFc7QUFBQSxVQUNJQyxlQURKLEdBQ3dCNXNELE9BRHhCLENBQ0k0c0QsZUFESjs7QUFFekJqQyxlQUFTQSxVQUFVLEVBQW5COztBQUVBLFVBQUlrQyx5QkFBSjtBQUNBQSx5QkFBbUJsMUQsbUJBQVVrTixRQUFWLENBQW1CNHRDLGdCQUF0QztBQUNBLFVBQUlrYSxhQUFKLEVBQW1CO0FBQ2pCRSwyQkFBbUJsQyxNQUFuQjtBQUNELE9BRkQsTUFFTztBQUNMa0MsMkJBQW1CQSxpQkFBaUJsbUQsTUFBakIsQ0FBd0Jna0QsTUFBeEIsQ0FBbkI7QUFDRDs7QUFFRCxVQUFJaUMsbUJBQW1CQSxnQkFBZ0J4bUQsTUFBdkMsRUFBK0M7QUFDN0MsWUFBSTBtRCxhQUFhLFNBQWJBLFVBQWEsQ0FBQ2x1QixJQUFELEVBQVU7QUFDekIsY0FBSWo5QixNQUFNNm9CLE9BQU4sQ0FBY29VLElBQWQsQ0FBSixFQUF5QjtBQUN2QixtQkFBT0EsS0FBS3I0QixHQUFMLENBQVN1bUQsVUFBVCxFQUNKNW1ELE1BREksQ0FDRztBQUFBLHFCQUFLZ04sQ0FBTDtBQUFBLGFBREgsQ0FBUDtBQUVELFdBSEQsTUFHTztBQUNMLGdCQUFJMDVDLGdCQUFnQnZ6RCxPQUFoQixDQUF3QnVsQyxLQUFLcC9CLFVBQTdCLE1BQTZDLENBQUMsQ0FBbEQsRUFBcUQ7QUFDbkQscUJBQU8sSUFBUDtBQUNELGFBRkQsTUFFTztBQUNMLHFCQUFPby9CLElBQVA7QUFDRDtBQUNGO0FBQ0YsU0FYRDtBQVlBaXVCLDJCQUFtQkEsaUJBQWlCdG1ELEdBQWpCLENBQXFCdW1ELFVBQXJCLEVBQWlDNW1ELE1BQWpDLENBQXdDO0FBQUEsaUJBQUtnTixDQUFMO0FBQUEsU0FBeEMsQ0FBbkI7QUFDRDs7QUFFRCxhQUFPMjVDLGdCQUFQO0FBQ0Q7Ozs7RUF4RHFEMXRELDJCOztrQkFBbkN5ckQsMEI7OztBQXdmckJBLDJCQUEyQjFyRCxZQUEzQixHQUEwQ0MsNEJBQWtCRCxZQUE1RCxDOzs7Ozs7Ozs7Ozs7Ozs7QUM3ZkE7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFsQkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWtCQSxJQUFNNnRELGlCQUFpQixJQUFJLzFELGdCQUFKLENBQVksRUFBWixFQUFnQixFQUFoQixDQUF2Qjs7SUFFcUIrekQsZ0M7OztBQUNuQiw4Q0FBc0I7QUFBQTs7QUFBQTs7QUFBQSxzQ0FBTjNyRCxJQUFNO0FBQU5BLFVBQU07QUFBQTs7QUFBQSwrTEFDWEEsSUFEVzs7QUFHcEIsVUFBS3ZGLGdCQUFMLEdBQXdCLElBQXhCO0FBQ0EsVUFBS0UsUUFBTCxDQUNFLG9CQURGLEVBRUUsZUFGRjs7QUFLQSxVQUFLQyxLQUFMLEdBQWE7QUFDWGtrQixrQkFBWSxNQUFLcGEsY0FBTCxDQUFvQixtQkFBcEI7QUFERCxLQUFiO0FBVG9CO0FBWXJCOztBQUVEOzs7Ozs7O2dDQUdhO0FBQ1gsVUFBSW5OLGVBQU00USxPQUFOLENBQWM0Z0IsT0FBZCxDQUFzQixFQUF0QixDQUFKLEVBQStCO0FBQUEsWUFDckI1bkIsTUFEcUIsR0FDVixLQUFLYixPQURLLENBQ3JCYSxNQURxQjtBQUFBLFlBRXJCNkMsU0FGcUIsR0FFUCxLQUFLdEYsSUFGRSxDQUVyQnNGLFNBRnFCOzs7QUFJN0IsWUFBTTRJLG1CQUFtQnpMLE9BQU8wTCxtQkFBUCxDQUEyQixLQUEzQixDQUF6QjtBQUNBLFlBQU1xYyxhQUFhdGMsaUJBQWlCclEsQ0FBcEM7QUFDQXlILGtCQUFVOUYsS0FBVixDQUFnQkMsTUFBaEIsR0FBNEIrcUIsVUFBNUI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7O3lDQUlzQjBiLFEsRUFBVTtBQUM5QixVQUFJQSxhQUFhLEtBQUtsZ0MsY0FBTCxDQUFvQixPQUFwQixDQUFqQixFQUErQztBQUM3QyxhQUFLa3BELGlCQUFMO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozt3Q0FJcUI7QUFDbkIsVUFBTXZpRCxZQUFZLEtBQUszRyxjQUFMLENBQW9CLFdBQXBCLENBQWxCO0FBQ0EsVUFBTTR1QyxRQUFRLEtBQUs1dUMsY0FBTCxDQUFvQixPQUFwQixLQUFnQyxFQUFFNHVDLE9BQU8sR0FBVCxFQUE5Qzs7QUFFQSxVQUFJeDBCLG1CQUFKO0FBQ0EsVUFBSXcwQixNQUFNeDBCLFVBQVYsRUFBc0I7QUFDcEJBLHFCQUFhdzBCLE1BQU14MEIsVUFBTixDQUFpQmxpQixLQUFqQixFQUFiO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsWUFBTTRoQixrQkFBa0JuVCxVQUFVb1Qsa0JBQVYsQ0FBNkIsS0FBN0IsQ0FBeEI7QUFDQSxZQUFNdUMsUUFBUSxLQUFLdGMsY0FBTCxDQUFvQixPQUFwQixDQUFkO0FBQ0EsWUFBTXVjLE1BQU0sS0FBS3ZjLGNBQUwsQ0FBb0IsS0FBcEIsQ0FBWjtBQUNBLFlBQU1tcEQsZ0JBQWdCNXNDLElBQUlya0IsS0FBSixHQUFZTyxRQUFaLENBQXFCNmpCLEtBQXJCLENBQXRCO0FBQ0FsQyxxQkFBYSt1QyxjQUFjcHlDLFFBQWQsQ0FBdUIrQyxlQUF2QixFQUF3Q3BMLEtBQXhDLEVBQWI7QUFDRDs7QUFFRCxXQUFLbFgsUUFBTCxDQUFjLEVBQUU0aUIsc0JBQUYsRUFBZDtBQUNEOztBQUVEOztBQUVBOzs7Ozs7O3lDQUlzQjtBQUNwQixVQUFNa0MsUUFBUSxLQUFLdGMsY0FBTCxDQUFvQixPQUFwQixDQUFkO0FBQ0EsVUFBTXVjLE1BQU0sS0FBS3ZjLGNBQUwsQ0FBb0IsS0FBcEIsQ0FBWjs7QUFFQSxXQUFLb3BELGNBQUwsR0FBc0I7QUFDcEI5c0MsZUFBT0EsTUFBTXBrQixLQUFOLEVBRGE7QUFFcEJxa0IsYUFBS0EsSUFBSXJrQixLQUFKLEVBRmU7QUFHcEJnTCxjQUFNcVosSUFBSXJrQixLQUFKLEdBQVlPLFFBQVosQ0FBcUI2akIsS0FBckI7QUFIYyxPQUF0QjtBQUtEOztBQUVEOzs7Ozs7OztrQ0FLZW5GLE0sRUFBUTtBQUFBLFVBQ2IxYSxNQURhLEdBQ0YsS0FBS2IsT0FESCxDQUNiYSxNQURhO0FBQUEsMkJBRUcsS0FBSzJzRCxjQUZSO0FBQUEsVUFFYjlzQyxLQUZhLGtCQUViQSxLQUZhO0FBQUEsVUFFTnBaLElBRk0sa0JBRU5BLElBRk07O0FBR3JCLFVBQU1rRixtQkFBbUIzTCxPQUFPNEwsbUJBQVAsRUFBekI7QUFDQSxVQUFNZ2hELHNCQUFzQmx5QyxPQUFPamYsS0FBUCxHQUFlb1EsTUFBZixDQUFzQkYsZ0JBQXRCLENBQTVCOztBQUVBLFVBQU1raEQsV0FBVyxJQUFJcDJELGdCQUFKLENBQVksQ0FBWixFQUFlLENBQWYsQ0FBakI7QUFDQSxVQUFNcTJELFdBQVcsSUFBSXIyRCxnQkFBSixDQUFZLENBQVosRUFBZSxDQUFmLEVBQ2R1RixRQURjLENBQ0x5SyxJQURLLENBQWpCOztBQUdBLFVBQU1takQsV0FBVy9wQyxNQUFNcGtCLEtBQU4sR0FDZDJNLEdBRGMsQ0FDVndrRCxtQkFEVSxFQUVkbjhCLEtBRmMsQ0FFUm84QixRQUZRLEVBRUVDLFFBRkYsQ0FBakI7QUFHQSxVQUFNakQsU0FBU0QsU0FBU251RCxLQUFULEdBQ1oyTSxHQURZLENBQ1IzQixJQURRLENBQWY7O0FBR0EsV0FBSytELGNBQUwsQ0FBb0IsRUFBRXFWLE9BQU8rcEMsUUFBVCxFQUFtQjlwQyxLQUFLK3BDLE1BQXhCLEVBQXBCO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7O3FDQUtrQnYwQixVLEVBQVk7QUFDNUIsV0FBS3kzQixrQkFBTCxHQUEwQnozQixVQUExQjs7QUFFQSxXQUFLcTNCLGNBQUwsR0FBc0I7QUFDcEI5c0MsZUFBTyxLQUFLdGMsY0FBTCxDQUFvQixPQUFwQixFQUE2QjlILEtBQTdCLEVBRGE7QUFFcEJxa0IsYUFBSyxLQUFLdmMsY0FBTCxDQUFvQixLQUFwQixFQUEyQjlILEtBQTNCO0FBRmUsT0FBdEI7QUFJRDs7QUFFRDs7Ozs7Ozs7O2dDQU1hNjVCLFUsRUFBWTVhLE0sRUFBUTtBQUFBLFVBQ3ZCMWEsTUFEdUIsR0FDWixLQUFLYixPQURPLENBQ3ZCYSxNQUR1Qjs7QUFFL0IsVUFBTTJMLG1CQUFtQjNMLE9BQU80TCxtQkFBUCxFQUF6Qjs7QUFGK0Isa0JBR0gsS0FBS3JJLGNBQUwsQ0FBb0IsT0FBcEIsS0FBZ0MsRUFBRTR1QyxPQUFPLEdBQVQsRUFIN0I7QUFBQSxVQUd6QkEsS0FIeUIsU0FHekJBLEtBSHlCO0FBQUEsVUFHbEJ4MEIsVUFIa0IsU0FHbEJBLFVBSGtCOztBQUkvQixVQUFJQSxjQUFjLENBQUN3MEIsS0FBbkIsRUFBMEI7QUFDeEJBLGdCQUFReDBCLFdBQVd4aUIsQ0FBWCxHQUFld2lCLFdBQVd2aUIsQ0FBbEM7QUFDRDs7QUFFRCxVQUFNbXRDLFVBQVUsS0FBS29rQixjQUFMLENBQW9CN3NDLEdBQXBCLENBQXdCcmtCLEtBQXhCLEdBQ2JPLFFBRGEsQ0FDSixLQUFLMndELGNBQUwsQ0FBb0I5c0MsS0FEaEIsRUFFYnZGLFFBRmEsQ0FFSjNPLGdCQUZJLENBQWhCOztBQUlBO0FBQ0EsVUFBSXFoRCxnQkFBSjtBQUNBLFVBQUkxM0IsZUFBZSxPQUFuQixFQUE0QjtBQUMxQmlULGdCQUFRdnNDLFFBQVIsQ0FBaUIwZSxNQUFqQjtBQUNBc3lDLGtCQUFVLEtBQUtMLGNBQUwsQ0FBb0I3c0MsR0FBcEIsQ0FBd0Jya0IsS0FBeEIsR0FDUDZlLFFBRE8sQ0FDRTNPLGdCQURGLENBQVY7QUFFRCxPQUpELE1BSU8sSUFBSTJwQixlQUFlLEtBQW5CLEVBQTBCO0FBQy9CaVQsZ0JBQVFuZ0MsR0FBUixDQUFZc1MsTUFBWjtBQUNBc3lDLGtCQUFVLElBQUl2MkQsZ0JBQUosQ0FBWSxDQUFaLEVBQWUsQ0FBZixFQUNQdUYsUUFETyxDQUNFLEtBQUsyd0QsY0FBTCxDQUFvQjlzQyxLQUR0QixFQUVQdkYsUUFGTyxDQUVFM08sZ0JBRkYsQ0FBVjtBQUdEOztBQUVELFVBQUlzaEQsc0JBQXNCdGhELGdCQUExQjtBQUNBLFVBQUksT0FBT3dtQyxLQUFQLEtBQWlCLFdBQWpCLElBQWdDQSxVQUFVLEdBQTlDLEVBQW1EO0FBQ2pELFlBQUlBLFFBQVF4bUMsaUJBQWlCeFEsQ0FBakIsR0FBcUJ3USxpQkFBaUJ2USxDQUFsRCxFQUFxRDtBQUNuRDZ4RCxnQ0FBc0IsSUFBSXgyRCxnQkFBSixDQUFZa1YsaUJBQWlCeFEsQ0FBN0IsRUFBZ0N3USxpQkFBaUJ4USxDQUFqQixHQUFxQmczQyxLQUFyRCxDQUF0QjtBQUNELFNBRkQsTUFFTztBQUNMOGEsZ0NBQXNCLElBQUl4MkQsZ0JBQUosQ0FBWWtWLGlCQUFpQnZRLENBQWpCLEdBQXFCKzJDLEtBQWpDLEVBQXdDeG1DLGlCQUFpQnZRLENBQXpELENBQXRCO0FBQ0Q7QUFDRjs7QUFFRG10QyxjQUFRcHRDLENBQVIsR0FBWXJGLEtBQUsyRyxHQUFMLENBQVMzRyxLQUFLMEcsR0FBTCxDQUFTMUcsS0FBSzJHLEdBQUwsQ0FBUyt2RCxlQUFlcnhELENBQXhCLEVBQTJCOHhELG9CQUFvQjl4RCxDQUEvQyxDQUFULEVBQTREb3RDLFFBQVFwdEMsQ0FBcEUsQ0FBVCxFQUFpRjZ4RCxRQUFRN3hELENBQXpGLENBQVo7QUFDQSxVQUFJZzNDLFVBQVUsR0FBZCxFQUFtQjtBQUNqQjVKLGdCQUFRbnRDLENBQVIsR0FBWW10QyxRQUFRcHRDLENBQVIsR0FBWWczQyxLQUF4QjtBQUNEO0FBQ0Q1SixjQUFRbnRDLENBQVIsR0FBWXRGLEtBQUsyRyxHQUFMLENBQVMzRyxLQUFLMEcsR0FBTCxDQUFTMUcsS0FBSzJHLEdBQUwsQ0FBUyt2RCxlQUFlcHhELENBQXhCLEVBQTJCNnhELG9CQUFvQjd4RCxDQUEvQyxDQUFULEVBQTREbXRDLFFBQVFudEMsQ0FBcEUsQ0FBVCxFQUFpRjR4RCxRQUFRNXhELENBQXpGLENBQVo7QUFDQSxVQUFJKzJDLFVBQVUsR0FBZCxFQUFtQjtBQUNqQjVKLGdCQUFRcHRDLENBQVIsR0FBWW90QyxRQUFRbnRDLENBQVIsR0FBWSsyQyxLQUF4QjtBQUNEOztBQUVELFVBQUk3YyxlQUFlLE9BQW5CLEVBQTRCO0FBQzFCLFlBQU1zMEIsV0FBVyxLQUFLK0MsY0FBTCxDQUFvQjdzQyxHQUFwQixDQUF3QnJrQixLQUF4QixHQUNkTyxRQURjLENBRWJ1c0MsUUFDRzlzQyxLQURILEdBRUdvUSxNQUZILENBRVVGLGdCQUZWLENBRmEsQ0FBakI7QUFNQSxhQUFLbkIsY0FBTCxDQUFvQixFQUFFcVYsT0FBTytwQyxRQUFULEVBQXBCLEVBQXlDLEtBQXpDO0FBQ0EsYUFBSzZDLGlCQUFMO0FBQ0QsT0FURCxNQVNPLElBQUluM0IsZUFBZSxLQUFuQixFQUEwQjtBQUMvQixZQUFNdTBCLFNBQVMsS0FBSzhDLGNBQUwsQ0FBb0I5c0MsS0FBcEIsQ0FBMEJwa0IsS0FBMUIsR0FDWjJNLEdBRFksQ0FFWG1nQyxRQUNHOXNDLEtBREgsR0FFR29RLE1BRkgsQ0FFVUYsZ0JBRlYsQ0FGVyxDQUFmO0FBTUEsYUFBS25CLGNBQUwsQ0FBb0IsRUFBRXNWLEtBQUsrcEMsTUFBUCxFQUFwQixFQUFxQyxLQUFyQztBQUNBLGFBQUs0QyxpQkFBTDtBQUNEO0FBQ0Y7O0FBRUQ7O0FBRUE7Ozs7Ozs7MkNBSXdCO0FBQUEsVUFDZHpzRCxNQURjLEdBQ0gsS0FBS2IsT0FERixDQUNkYSxNQURjOztBQUV0QixVQUFNNmYsUUFBUSxLQUFLdGMsY0FBTCxDQUFvQixPQUFwQixDQUFkO0FBQ0EsVUFBTXVjLE1BQU0sS0FBS3ZjLGNBQUwsQ0FBb0IsS0FBcEIsQ0FBWjs7QUFFQSxhQUFPdWMsSUFBSXJrQixLQUFKLEdBQ0pPLFFBREksQ0FDSzZqQixLQURMLEVBRUp2RixRQUZJLENBRUt0YSxPQUFPc2Qsa0JBQVAsQ0FBMEIsS0FBMUIsQ0FGTCxFQUdKL1UsS0FISSxFQUFQO0FBSUQ7O0FBRUQ7O0FBRUE7Ozs7Ozs7OztxQ0FNa0I7QUFBQSxVQUNSdkksTUFEUSxHQUNHLEtBQUtiLE9BRFIsQ0FDUmEsTUFEUTs7QUFFaEIsVUFBTTJMLG1CQUFtQjNMLE9BQU80TCxtQkFBUCxFQUF6QjtBQUNBLFVBQU1ILG1CQUFtQnpMLE9BQU8wTCxtQkFBUCxFQUF6Qjs7QUFFQSxVQUFNbVUsUUFBUSxLQUFLdGMsY0FBTCxDQUFvQixPQUFwQixFQUE2QjlILEtBQTdCLEdBQXFDNmUsUUFBckMsQ0FBOEMzTyxnQkFBOUMsRUFBZ0VzRyxLQUFoRSxFQUFkO0FBQ0EsVUFBTTZOLE1BQU0sS0FBS3ZjLGNBQUwsQ0FBb0IsS0FBcEIsRUFBMkI5SCxLQUEzQixHQUFtQzZlLFFBQW5DLENBQTRDM08sZ0JBQTVDLEVBQThEdWhELElBQTlELEVBQVo7QUFDQSxVQUFNem1ELE9BQU9xWixJQUFJcmtCLEtBQUosR0FBWU8sUUFBWixDQUFxQjZqQixLQUFyQixDQUFiOztBQUVBLFVBQU1uRixTQUFTalAsaUJBQWlCaFEsS0FBakIsR0FDWk8sUUFEWSxDQUNIMlAsZ0JBREcsRUFFWkUsTUFGWSxDQUVMLENBRkssRUFHWm9HLEtBSFksRUFBZjs7QUFLQSxVQUFNa2YsVUFBVW54QixPQUFPbXRELFVBQVAsRUFBaEI7QUFDQXR0QyxZQUFNelgsR0FBTixDQUFVc1MsTUFBVixFQUNHdFMsR0FESCxDQUNPLENBRFAsRUFDVStvQixRQUFRLENBQVIsQ0FEVjs7QUFHQSxhQUFPO0FBQ0xpOEIsaUJBQVMsS0FBS0Msb0JBQUwsQ0FBMEJ4dEMsTUFBTTFrQixDQUFoQyxFQUFtQzBrQixNQUFNemtCLENBQXpDLENBREo7QUFFTGt5RCxtQkFBVyxLQUFLRCxvQkFBTCxDQUEwQjVtRCxLQUFLdEwsQ0FBL0IsRUFBa0Mwa0IsTUFBTXprQixDQUF4QyxDQUZOO0FBR0xteUQsb0JBQVksS0FBS0Ysb0JBQUwsQ0FBMEJ4dEMsTUFBTTFrQixDQUFoQyxFQUFtQ3NMLEtBQUtyTCxDQUF4QyxDQUhQO0FBSUxveUQsZ0JBQVEsS0FBS0gsb0JBQUwsQ0FBMEI1bUQsS0FBS3RMLENBQS9CLEVBQWtDc0wsS0FBS3JMLENBQXZDO0FBSkgsT0FBUDtBQU1EOztBQUVEOzs7Ozs7Ozs7O3lDQU9zQkQsQyxFQUFHQyxDLEVBQUc7QUFDMUI7QUFDQSxhQUFPO0FBQ0xpQyxlQUFPdkgsS0FBSzBHLEdBQUwsQ0FBUyxDQUFULEVBQVlyQixDQUFaLENBREY7QUFFTDZCLGdCQUFRbEgsS0FBSzBHLEdBQUwsQ0FBUyxDQUFULEVBQVlwQixDQUFaO0FBRkgsT0FBUDtBQUlEOztBQUVEOzs7Ozs7O29DQUlpQjtBQUNmLFVBQU0rMkMsUUFBUSxLQUFLNXVDLGNBQUwsQ0FBb0IsT0FBcEIsQ0FBZDtBQURlLFVBRVBvYSxVQUZPLEdBRVEsS0FBS2xrQixLQUZiLENBRVBra0IsVUFGTzs7O0FBSWYsVUFBSTRsQyxzQkFBSjtBQUNBLFVBQUlwUixLQUFKLEVBQVc7QUFDVCxZQUFNc2IsYUFBYSxLQUFLQyxjQUFMLEVBQW5CO0FBQ0FuSyx3QkFBaUI7QUFBQTtBQUFBLFlBQUssS0FBSSw0QkFBVDtBQUNmO0FBQUE7QUFBQSxjQUFLLEtBQUksT0FBVDtBQUNFO0FBQUE7QUFBQSxnQkFBSyxLQUFJLGVBQVQsRUFBeUIsT0FBT2tLLFdBQVdMLE9BQTNDO0FBQUE7QUFBQSxhQURGO0FBRUU7QUFBQTtBQUFBLGdCQUFLLEtBQUksZUFBVCxFQUF5QixPQUFPSyxXQUFXSCxTQUEzQztBQUFBO0FBQUEsYUFGRjtBQUdFLHFEQUFLLEtBQUksZUFBVDtBQUhGLFdBRGU7QUFNZjtBQUFBO0FBQUEsY0FBSyxLQUFJLE9BQVQ7QUFDRTtBQUFBO0FBQUEsZ0JBQUssS0FBSSxlQUFULEVBQXlCLE9BQU9HLFdBQVdGLFVBQTNDO0FBQUE7QUFBQSxhQURGO0FBRUU7QUFBQywwQ0FBRDtBQUFBO0FBQ0UseUJBQVMsS0FBS0ksa0JBRGhCO0FBRUUsd0JBQVEsS0FBS0MsYUFGZjtBQUdFO0FBQUE7QUFBQSxrQkFBSyxLQUFJLG1CQUFULEVBQTZCLE9BQU9ILFdBQVdELE1BQS9DO0FBQ0U7QUFBQyw4Q0FBRDtBQUFBO0FBQ0UsNkJBQVMsS0FBS3ZrRCxnQkFBTCxDQUFzQnBTLElBQXRCLENBQTJCLElBQTNCLEVBQWlDLE9BQWpDLENBRFg7QUFFRSw0QkFBUSxLQUFLcVMsV0FBTCxDQUFpQnJTLElBQWpCLENBQXNCLElBQXRCLEVBQTRCLE9BQTVCLENBRlY7QUFHRTtBQUFBO0FBQUEsc0JBQUssS0FBSSwwQkFBVDtBQUNFLDZEQUFLLEtBQUksUUFBVCxFQUFrQixLQUFLLEtBQUs0aEIsYUFBTCxDQUFtQix5Q0FBbkIsRUFBOEQsSUFBOUQsQ0FBdkI7QUFERjtBQUhGLGlCQURGO0FBUUU7QUFBQTtBQUFBLG9CQUFLLEtBQUksY0FBVDtBQUE0QmtGLDZCQUFXeGlCLENBQXZDLFNBQTRDd2lCLFdBQVd2aUI7QUFBdkQsaUJBUkY7QUFTRTtBQUFDLDhDQUFEO0FBQUE7QUFDRSw2QkFBUyxLQUFLNk4sZ0JBQUwsQ0FBc0JwUyxJQUF0QixDQUEyQixJQUEzQixFQUFpQyxLQUFqQyxDQURYO0FBRUUsNEJBQVEsS0FBS3FTLFdBQUwsQ0FBaUJyUyxJQUFqQixDQUFzQixJQUF0QixFQUE0QixLQUE1QixDQUZWO0FBR0U7QUFBQTtBQUFBLHNCQUFLLEtBQUksOEJBQVQ7QUFDRSw2REFBSyxLQUFJLFFBQVQsRUFBa0IsS0FBSyxLQUFLNGhCLGFBQUwsQ0FBbUIseUNBQW5CLEVBQThELElBQTlELENBQXZCO0FBREY7QUFIRjtBQVRGO0FBSEYsYUFGRjtBQXVCRTtBQUFBO0FBQUEsZ0JBQUssS0FBSSxlQUFUO0FBQUE7QUFBQTtBQXZCRixXQU5lO0FBK0JmO0FBQUE7QUFBQSxjQUFLLEtBQUksT0FBVDtBQUNFO0FBQUE7QUFBQSxnQkFBSyxLQUFJLGVBQVQ7QUFBQTtBQUFBLGFBREY7QUFFRTtBQUFBO0FBQUEsZ0JBQUssS0FBSSxlQUFUO0FBQUE7QUFBQSxhQUZGO0FBR0U7QUFBQTtBQUFBLGdCQUFLLEtBQUksZUFBVDtBQUFBO0FBQUE7QUFIRjtBQS9CZSxTQUFqQjtBQXFDRCxPQXZDRCxNQXVDTztBQUNMOHFDLHdCQUFpQjtBQUFBO0FBQUEsWUFBSyxLQUFJLDRCQUFUO0FBQ2Y7QUFBQTtBQUFBLGNBQUssS0FBSSxjQUFUO0FBQTRCNWxDLHVCQUFXeGlCLENBQXZDLFNBQTRDd2lCLFdBQVd2aUI7QUFBdkQ7QUFEZSxTQUFqQjtBQUdEOztBQUVELGFBQVE7QUFBQTtBQUFBLFVBQUssS0FBSSxxQ0FBVCxFQUErQyxLQUFJLFdBQW5EO0FBQ0xtb0Q7QUFESyxPQUFSO0FBR0Q7Ozs7RUF2VDJENWdELGlDOztrQkFBekM2bkQsZ0M7OztBQTBUckJBLGlDQUFpQzdyRCxZQUFqQyxHQUFnRGdFLGtDQUF3QmhFLFlBQXhFLEM7Ozs7Ozs7Ozs7Ozs7OztBQ2hVQTs7QUFDQTs7Ozs7Ozs7Ozs7OytlQWpCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBaUJxQjRyRCx3Qjs7Ozs7Ozs7Ozs7O0FBQ25COzs7OzttQ0FLZ0J2d0QsUyxFQUFXO0FBQ3pCLFVBQUkwM0IsZ0JBQUo7QUFDQSxVQUFJMTNCLGNBQWMsSUFBbEIsRUFBd0I7QUFDdEIwM0Isa0JBQVUsRUFBVjtBQUNELE9BRkQsTUFFTyxJQUFJMTNCLGNBQWMsS0FBbEIsRUFBeUI7QUFDOUIwM0Isa0JBQVUsQ0FBQyxFQUFYO0FBQ0Q7O0FBTndCLFVBUWpCMXhCLE1BUmlCLEdBUU4sS0FBS2IsT0FSQyxDQVFqQmEsTUFSaUI7O0FBU3pCLFVBQU1rSyxZQUFZLEtBQUszRyxjQUFMLENBQW9CLHNCQUFwQixDQUFsQjtBQUNBLFVBQU1zcUQsY0FBYyxDQUFDM2pELFVBQVVvVixXQUFWLEtBQTBCb1MsT0FBM0IsSUFBc0MsR0FBMUQ7O0FBRUF4bkIsZ0JBQVU3SyxHQUFWLENBQWMsRUFBRTBmLFVBQVU4dUMsV0FBWixFQUFkOztBQUVBLFVBQUlwcUIsV0FBVztBQUNieW1CLDZCQUFxQjJEO0FBRFIsT0FBZjs7QUFJQSxVQUFNMWIsUUFBUSxLQUFLNXVDLGNBQUwsQ0FBb0IsT0FBcEIsQ0FBZDtBQUNBLFVBQUk0dUMsU0FBUyxDQUFDQSxNQUFNeDBCLFVBQXBCLEVBQWdDO0FBQzlCLFlBQU1rQyxRQUFRLEtBQUt0YyxjQUFMLENBQW9CLE9BQXBCLENBQWQ7QUFDQSxZQUFNdWMsTUFBTSxLQUFLdmMsY0FBTCxDQUFvQixLQUFwQixDQUFaO0FBQ0EsWUFBTXVxRCxZQUFZanVDLE1BQU1wa0IsS0FBTixFQUFsQjtBQUNBLFlBQUl6QixjQUFjLElBQWxCLEVBQXdCO0FBQ3RCNmxCLGdCQUFNeGdCLEdBQU4sQ0FBVSxNQUFNeWdCLElBQUkxa0IsQ0FBcEIsRUFBdUIweUQsVUFBVTN5RCxDQUFqQztBQUNBMmtCLGNBQUl6Z0IsR0FBSixDQUFRLE1BQU15dUQsVUFBVTF5RCxDQUF4QixFQUEyQjBrQixJQUFJM2tCLENBQS9CO0FBQ0QsU0FIRCxNQUdPLElBQUluQixjQUFjLEtBQWxCLEVBQXlCO0FBQzlCNmxCLGdCQUFNeGdCLEdBQU4sQ0FBVXl1RCxVQUFVMXlELENBQXBCLEVBQXVCLE1BQU0wa0IsSUFBSTNrQixDQUFqQztBQUNBMmtCLGNBQUl6Z0IsR0FBSixDQUFReWdCLElBQUkxa0IsQ0FBWixFQUFlLE1BQU0weUQsVUFBVTN5RCxDQUEvQjtBQUNEO0FBQ0Rzb0MsaUJBQVM1akIsS0FBVCxHQUFpQkEsS0FBakI7QUFDQTRqQixpQkFBUzNqQixHQUFULEdBQWVBLEdBQWY7QUFDRDs7QUFFRCxVQUFJcXlCLFNBQVNBLE1BQU14MEIsVUFBbkIsRUFBK0I7QUFDN0IsYUFBS25DLFVBQUwsQ0FBZ0Jwa0IsbUJBQVVzTSxNQUFWLENBQWlCdXVDLHVCQUFqQztBQUNEOztBQUVELFdBQUt6bkMsY0FBTCxDQUFvQmk1QixRQUFwQjs7QUFFQXpqQyxhQUFPa3JELGVBQVAsQ0FBdUJ4NUIsT0FBdkI7QUFDQTF4QixhQUFPb3JCLElBQVAsQ0FBWS9yQixHQUFaLENBQWdCLE1BQWhCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7aUNBSWNyRixTLEVBQVc7QUFBQTs7QUFBQSxVQUNmZ0csTUFEZSxHQUNKLEtBQUtiLE9BREQsQ0FDZmEsTUFEZTs7QUFFdkIsVUFBTWtLLFlBQVksS0FBSzNHLGNBQUwsQ0FBb0Isc0JBQXBCLENBQWxCOztBQUVBLFVBQU13cUQsVUFBVSxDQUFDLEtBQUt4cUQsY0FBTCxVQUEyQnZKLFNBQTNCLENBQWpCO0FBQ0EsVUFBTTZ6RCxjQUFjLEtBQUt0cUQsY0FBTCxDQUFvQixVQUFwQixJQUFrQyxDQUFDLENBQXZEO0FBQ0EsV0FBS2lILGNBQUwsa0VBQ1V4USxTQURWLEVBQ3dCK3pELE9BRHhCLGdEQUVZRixXQUZaO0FBSUE3dEQsYUFBT3dmLFdBQVAsQ0FBbUJxdUMsV0FBbkI7QUFDQTNqRCxnQkFBVXFWLElBQVYsQ0FBZXZsQixTQUFmOztBQUVBLFVBQU02bEIsUUFBUSxLQUFLdGMsY0FBTCxDQUFvQixPQUFwQixDQUFkO0FBQ0EsVUFBTXVjLE1BQU0sS0FBS3ZjLGNBQUwsQ0FBb0IsS0FBcEIsQ0FBWjtBQUNBLFVBQU15cUQsV0FBV251QyxNQUFNcGtCLEtBQU4sRUFBakI7QUFDQSxVQUFJekIsY0FBYyxZQUFsQixFQUFnQztBQUM5QjZsQixjQUFNeGdCLEdBQU4sQ0FBVSxNQUFNeWdCLElBQUkza0IsQ0FBcEIsRUFBdUIwa0IsTUFBTXprQixDQUE3QjtBQUNBMGtCLFlBQUl6Z0IsR0FBSixDQUFRLE1BQU0ydUQsU0FBUzd5RCxDQUF2QixFQUEwQjJrQixJQUFJMWtCLENBQTlCO0FBQ0QsT0FIRCxNQUdPLElBQUlwQixjQUFjLFVBQWxCLEVBQThCO0FBQ25DNmxCLGNBQU14Z0IsR0FBTixDQUFVd2dCLE1BQU0xa0IsQ0FBaEIsRUFBbUIsTUFBTTJrQixJQUFJMWtCLENBQTdCO0FBQ0Ewa0IsWUFBSXpnQixHQUFKLENBQVF5Z0IsSUFBSTNrQixDQUFaLEVBQWUsTUFBTTZ5RCxTQUFTNXlELENBQTlCO0FBQ0Q7O0FBRUQsV0FBS29QLGNBQUwsQ0FBb0IsRUFBRXFWLFlBQUYsRUFBU0MsUUFBVCxFQUFwQjs7QUFFQTlmLGFBQU9vckQsYUFBUCxDQUFxQnB4RCxTQUFyQjtBQUNBZ0csYUFBT21MLE1BQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7O2dEQU02QnE0QixRLEVBQVVDLFEsRUFBVTtBQUMvQyxhQUFPLEtBQVA7QUFDRDs7QUFFRDs7Ozs7OztvQ0FJaUI7QUFDZixhQUFRO0FBQUE7QUFBQSxVQUFLLFdBQVUsV0FBZjtBQUNOO0FBQUE7QUFBQSxZQUFLLEtBQUksZUFBVCxFQUF5QixTQUFTLEtBQUt3cUIsWUFBTCxDQUFrQnAzRCxJQUFsQixDQUF1QixJQUF2QixFQUE2QixVQUE3QixDQUFsQztBQUNFLG1EQUFLLEtBQUksUUFBVCxFQUFrQixLQUFLLEtBQUs0aEIsYUFBTCxDQUFtQiwrQkFBbkIsRUFBb0QsSUFBcEQsQ0FBdkI7QUFERixTQURNO0FBSU47QUFBQTtBQUFBLFlBQUssS0FBSSxlQUFULEVBQXlCLFNBQVMsS0FBS3cxQyxZQUFMLENBQWtCcDNELElBQWxCLENBQXVCLElBQXZCLEVBQTZCLFlBQTdCLENBQWxDO0FBQ0UsbURBQUssS0FBSSxRQUFULEVBQWtCLEtBQUssS0FBSzRoQixhQUFMLENBQW1CLCtCQUFuQixFQUFvRCxJQUFwRCxDQUF2QjtBQURGLFNBSk07QUFPTixpREFBSyxLQUFJLFNBQVQsR0FQTTtBQVFOO0FBQUE7QUFBQSxZQUFLLEtBQUksZUFBVCxFQUF5QixTQUFTLEtBQUt5MUMsY0FBTCxDQUFvQnIzRCxJQUFwQixDQUF5QixJQUF6QixFQUErQixLQUEvQixDQUFsQztBQUNFLG1EQUFLLEtBQUksUUFBVCxFQUFrQixLQUFLLEtBQUs0aEIsYUFBTCxDQUFtQixtQ0FBbkIsRUFBd0QsSUFBeEQsQ0FBdkI7QUFERixTQVJNO0FBV047QUFBQTtBQUFBLFlBQUssS0FBSSxlQUFULEVBQXlCLFNBQVMsS0FBS3kxQyxjQUFMLENBQW9CcjNELElBQXBCLENBQXlCLElBQXpCLEVBQStCLElBQS9CLENBQWxDO0FBQ0UsbURBQUssS0FBSSxRQUFULEVBQWtCLEtBQUssS0FBSzRoQixhQUFMLENBQW1CLGtDQUFuQixFQUF1RCxJQUF2RCxDQUF2QjtBQURGO0FBWE0sT0FBUjtBQWVEOzs7O0VBbEhtRG5SLHlCOztrQkFBakNpakQsd0I7OztBQXFIckJBLHlCQUF5QjVyRCxZQUF6QixHQUF3QzJJLDBCQUFnQjNJLFlBQXhELEM7Ozs7Ozs7Ozs7Ozs7OztBQ3pIQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBbEJBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBbUJBOzs7Ozs7SUFNTXd2RCxlOzs7Ozs7Ozs7Ozs7QUFDSjs7Ozs7Ozs0QkFPZ0J4aEQsVyxFQUFhO0FBQUEsVUFDbkIzTSxNQURtQixHQUNSLEtBQUtiLE9BREcsQ0FDbkJhLE1BRG1COztBQUUzQixVQUFNeUsseUJBQXlCekssT0FBT29LLFVBQVAsQ0FBa0IrVSxNQUFsQixDQUF5QixRQUF6QixDQUEvQjtBQUNBLFVBQU1qVixZQUFZbEssT0FBT29LLFVBQVAsQ0FBa0JDLFdBQWxCLENBQThCLFFBQTlCLENBQWxCO0FBQ0EsVUFBTUssaUJBQWlCUixVQUFVaXJCLGdCQUFWLENBQTJCLENBQUMsWUFBRCxFQUFlLFFBQWYsRUFBeUIsV0FBekIsQ0FBM0IsQ0FBdkI7O0FBRUEsV0FBSzNxQixjQUFMLENBQW9CLEVBQUVOLG9CQUFGLEVBQWFPLDhDQUFiLEVBQXFDQyw4QkFBckMsRUFBcEI7QUFDRDs7QUFFRDs7Ozs7Ozs7OzZCQU1pQjtBQUNmLFVBQU1BLGlCQUFpQixLQUFLbkgsY0FBTCxDQUFvQixnQkFBcEIsQ0FBdkI7QUFDQSxVQUFNNnFELG9CQUFvQixLQUFLbEcsVUFBTCxDQUFnQm1HLFNBQWhCLEdBQTRCbDFELFdBQXREO0FBQ0EsVUFBTW0xRCwyQkFBMkI1akQsZUFBZS9FLE1BQWYsQ0FBc0J4TSxXQUF2RDs7QUFFQSxVQUFJa2dCLGlCQUFKO0FBQ0EsVUFBSWkxQyx5QkFBeUJydkQsVUFBekIsS0FBd0MsUUFBNUMsRUFBc0Q7QUFDcERvYSxtQkFBVzNPLGVBQWUvRSxNQUFmLENBQXNCd3VCLFFBQXRCLEVBQVg7QUFDRDtBQUNELFVBQU16VixZQUFZLEtBQUt3cEMsVUFBTCxDQUFnQjl5QixZQUFoQixFQUFsQjtBQUNBLFVBQUksS0FBSzh5QixVQUFMLENBQWdCdDVDLGFBQWhCLE9BQW9DbEUsZUFBZXpMLFVBQW5ELElBQ0Z5ZixjQUFjaFUsZUFBZWdVLFNBRC9CLEVBQzBDO0FBQUEsWUFDaEMxZSxNQURnQyxHQUNyQixLQUFLYixPQURnQixDQUNoQ2EsTUFEZ0M7O0FBRXhDQSxlQUFPaXJCLE9BQVAsQ0FBZTdpQixHQUFmLENBQW1CLEtBQUs4L0MsVUFBeEIsRUFDRTtBQUNFanBELHNCQUFZeUwsZUFBZXpMLFVBRDdCO0FBRUV5ZjtBQUZGLFNBREYsRUFLRSxLQUFLbmIsY0FBTCxDQUFvQix3QkFBcEIsQ0FMRixFQU1FLFlBQU07QUFDSixjQUFNMkcsWUFBWWxLLE9BQU9vSyxVQUFQLENBQWtCQyxXQUFsQixDQUE4QixRQUE5QixDQUFsQjtBQUNBLGNBQUlpa0QseUJBQXlCcnZELFVBQXpCLEtBQXdDLFFBQTVDLEVBQXNEO0FBQ3BEaUwsc0JBQVVxa0QsU0FBVixDQUFvQixJQUFJRCx3QkFBSixDQUE2QixFQUFFeDhDLE9BQU91SCxRQUFULEVBQTdCLENBQXBCO0FBQ0QsV0FGRCxNQUVPO0FBQ0xuUCxzQkFBVXFrRCxTQUFWLENBQW9CLElBQUlELHdCQUFKLEVBQXBCO0FBQ0Q7QUFDRixTQWJIO0FBY0Q7O0FBRUQsVUFBSUYsa0JBQWtCSSxVQUF0QixFQUFrQztBQUFBLFlBQ3hCeHVELE9BRHdCLEdBQ2IsS0FBS2IsT0FEUSxDQUN4QmEsTUFEd0I7O0FBRWhDQSxnQkFBT29LLFVBQVAsQ0FBa0JrK0MsTUFBbEIsQ0FBeUIsS0FBS0osVUFBOUI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7Z0NBTW9CbG9ELE0sRUFBUTtBQUMxQixhQUFPQSxPQUFPeXVCLGFBQVAsQ0FBcUIsUUFBckIsS0FDTHp1QixPQUFPK25ELGFBQVAsQ0FBcUIsS0FBSzlvRCxVQUExQixDQURGO0FBRUQ7O0FBRUQ7Ozs7Ozs7O3FDQUt5QmUsTSxFQUFRO0FBQy9CLFVBQU1QLFVBQVVPLE9BQU9vM0IsVUFBUCxFQUFoQjtBQUNBLFVBQU1xM0IsZ0JBQWdCdDRELGtCQUFTeUwsUUFBVCxDQUNwQm5DLFFBQVFPLE1BQVIsQ0FBZXMzQixlQUFmLENBQStCM3hCLE1BRFgsRUFFcEIsS0FBS3JGLGNBRmUsQ0FBdEI7QUFJQSxVQUFNb3VELGdCQUFnQixJQUFJaDJDLHVCQUFKLENBQWtCMVksT0FBTzBoQixLQUFQLEVBQWxCLEVBQWtDK3NDLGFBQWxDLENBQXRCOztBQUVBLFVBQUl2dUIsU0FBUyxFQUFiO0FBQ0EsVUFBTTE3QixhQUFha3FELGNBQWNDLGFBQWQsRUFBbkI7QUFDQW5xRCxpQkFBV2EsT0FBWCxDQUFtQixVQUFDSyxRQUFELEVBQWM7QUFDL0J3NkIsZUFBT3huQyxJQUFQLGtDQUEyQ2dOLFNBQVN6RyxVQUFwRDtBQUNBLFlBQU0rYSxVQUFVMDBDLGNBQWNFLHFCQUFkLENBQW9DbHBELFNBQVN6RyxVQUE3QyxDQUFoQjtBQUNBK2EsZ0JBQVEzVSxPQUFSLENBQWdCLFVBQUNNLE1BQUQsRUFBWTtBQUMxQnU2QixpQkFBT3huQyxJQUFQLHVCQUFnQ2lOLE9BQU8xRyxVQUF2QztBQUNBLGNBQUkwRyxPQUFPMFQsUUFBWCxFQUFxQjtBQUNuQjZtQixtQkFBT3huQyxJQUFQLENBQVksQ0FBQ2lOLE9BQU8wVCxRQUFSLEVBQWtCLEtBQWxCLEVBQXlCLEtBQXpCLENBQVo7QUFDRDtBQUNGLFNBTEQ7QUFNRCxPQVREOztBQVdBLGFBQU82bUIsTUFBUDtBQUNEOzs7O0VBaEcyQnpCLGtCOztBQW1HOUI7Ozs7Ozs7QUFLQTB2QixnQkFBZ0JqdUQsaUJBQWhCLEdBQW9DMnVELGlDQUFwQzs7QUFFQTs7Ozs7QUFLQVYsZ0JBQWdCbHZELFVBQWhCLEdBQTZCLFFBQTdCOztBQUVBOzs7OztBQUtBa3ZELGdCQUFnQi90RCxRQUFoQixHQUEyQiwrQkFBM0I7O0FBRUE7Ozs7O0FBS0ErdEQsZ0JBQWdCOXRELFdBQWhCLEdBQThCLHlCQUE5Qjs7QUFFQTs7Ozs7OztBQU9BOHRELGdCQUFnQjd0RCxjQUFoQixHQUFpQztBQUMvQmtFLGNBQVksRUFEbUI7QUFFL0JDLHFCQUFtQixLQUZZO0FBRy9CcVYsb0JBQWtCLElBSGE7QUFJL0JnMUMsa0JBQWdCOztBQUdsQjs7OztBQVBpQyxDQUFqQyxDQVdBWCxnQkFBZ0IxRyxrQkFBaEIsR0FBcUMsQ0FBQyxRQUFELENBQXJDOztrQkFFZTBHLGU7Ozs7Ozs7Ozs7Ozs7OztBQzdKZjs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7K2VBckJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFxQlFyMUMsTyxHQUFZdmlCLGFBQUkrUyxVQUFKLENBQWV1UCxlLENBQTNCQyxPOztJQUVhaTJDLHVCOzs7QUFDbkIscUNBQXNCO0FBQUE7O0FBQUE7O0FBQUEsc0NBQU5sd0QsSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEsNktBQ1hBLElBRFc7O0FBR3BCLFVBQUtyRixRQUFMLENBQ0UsY0FERixFQUVFLHFCQUZGLEVBR0Usc0JBSEYsRUFJRSxtQkFKRjtBQU1BLFVBQUswdUQsVUFBTCxHQUFrQixNQUFLM2tELGNBQUwsQ0FBb0IsV0FBcEIsQ0FBbEI7O0FBRUEsVUFBS3NHLE9BQUwsdUJBQ0d6UyxtQkFBVXNNLE1BQVYsQ0FBaUJvRyxpQkFEcEIsRUFDd0MsTUFBS0MsbUJBRDdDOztBQUlBLFVBQUtpbEQsa0JBQUw7O0FBRUEsVUFBS3YxRCxLQUFMLEdBQWE7QUFDWGlNLGdCQUFVLE1BQUtnZCxjQUFMLENBQW9CdXNDLHVCQUFwQixDQUE0QyxLQUE1QztBQURDLEtBQWI7QUFqQm9CO0FBb0JyQjs7QUFFRDs7QUFFQTs7Ozs7Ozs7eUNBSXNCO0FBQ3BCLFdBQUt2c0MsY0FBTCxHQUFzQixJQUFJaEssdUJBQUosQ0FBa0IsS0FBS3ZaLE9BQUwsQ0FBYTRFLEVBQS9CLEVBQW1DLEtBQUtsRyxLQUFMLENBQVc0QixPQUE5QyxDQUF0QjtBQUNEOztBQUVEOztBQUVBOzs7Ozs7Ozt5Q0FLc0JpQyxLLEVBQU87QUFDM0IsV0FBS3dtRCxVQUFMLENBQWdCZ0gsWUFBaEIsQ0FBNkJ4dEQsUUFBUSxHQUFyQzs7QUFEMkIsVUFHbkIxQixNQUhtQixHQUdSLEtBQUtiLE9BSEcsQ0FHbkJhLE1BSG1COztBQUkzQkEsYUFBT21MLE1BQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7c0NBS21CekYsUSxFQUFVO0FBQUE7O0FBQzNCLFdBQUszSyxRQUFMLENBQWMsRUFBRTJLLFVBQVVBLFFBQVosRUFBZCxFQUFzQyxZQUFNO0FBQzFDLGVBQUtuSSxJQUFMLENBQVVpcUIsU0FBVixDQUFvQjN0QixNQUFwQjtBQUNELE9BRkQ7QUFHRDs7QUFFRDs7Ozs7Ozs7d0NBS3FCcVEsUyxFQUFXO0FBQzlCO0FBQ0E7QUFDQSxVQUFJQSxjQUFjLEtBQUtnK0MsVUFBdkIsRUFBbUM7QUFDakMsYUFBSzFrRCxXQUFMO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7O2lDQU1jdkUsVSxFQUFZakUsQyxFQUFHO0FBQUE7O0FBQzNCLFdBQUswbkIsY0FBTCxDQUFvQkMsK0JBQXBCLENBQW9EMWpCLFVBQXBELEVBQ0crRixJQURILENBQ1Esa0JBQVU7QUFDZCxlQUFLa2pELFVBQUwsQ0FBZ0I3b0QsR0FBaEIsQ0FBb0I7QUFDbEJzRyx3QkFEa0I7QUFFbEIxRyxnQ0FGa0I7QUFHbEJ5ZixxQkFBVztBQUhPLFNBQXBCOztBQURjLFlBT04xZSxNQVBNLEdBT0ssT0FBS2IsT0FQVixDQU9OYSxNQVBNOztBQVFkQSxlQUFPbUwsTUFBUDtBQUNBLGVBQUszSCxXQUFMO0FBQ0QsT0FYSDtBQVlEOztBQUVEOztBQUVBOzs7Ozs7OzRDQUl5QjtBQUN2QixVQUFNMnJELGdCQUFnQixLQUFLakgsVUFBTCxDQUFnQm1HLFNBQWhCLEVBQXRCO0FBQ0EsVUFBSWMsY0FBY1gsVUFBbEIsRUFBOEIsT0FBTyxJQUFQOztBQUU5QixVQUFNOXZDLFlBQVksS0FBS3dwQyxVQUFMLENBQWdCOXlCLFlBQWhCLEVBQWxCO0FBQ0EsYUFBUSxnQ0FBQyxnQ0FBRDtBQUNOLGtCQUFVLENBREo7QUFFTixrQkFBVSxHQUZKO0FBR04sZUFBTzFXLFlBQVksR0FIYjtBQUlOLG1CQUFVLEdBSko7QUFLTiw2QkFBb0IsR0FMZDtBQU1OLGVBQU8sS0FBS3RDLEVBQUwsQ0FBUSw2QkFBUixDQU5EO0FBT04sa0JBQVUsS0FBS25hLG9CQVBULEdBQVI7QUFRRDs7QUFFRDs7Ozs7Ozs7dUNBS29CO0FBQUE7O0FBQ2xCLFVBQU1tdEQsMEJBQTBCLEtBQUtsSCxVQUFMLENBQWdCdDVDLGFBQWhCLEVBQWhDO0FBQ0EsVUFBTW9MLFVBQVUsS0FBSzBJLGNBQUwsQ0FBb0Jrc0MscUJBQXBCLENBQTBDLEtBQUtuMUQsS0FBTCxDQUFXaU0sUUFBWCxDQUFvQnpHLFVBQTlELENBQWhCOztBQUVBLGFBQU8sQ0FBQzZaLFFBQVFDLGNBQVQsRUFBeUIzUyxNQUF6QixDQUFnQzRULE9BQWhDLEVBQXlDaFUsR0FBekMsQ0FBNkMsVUFBQ0wsTUFBRCxFQUFZO0FBQUEsWUFDdEQxRyxVQURzRCxHQUN2QzBHLE1BRHVDLENBQ3REMUcsVUFEc0Q7O0FBRTlELGVBQVE7QUFBQTtBQUFBO0FBQ04saUJBQUksUUFERTtBQUVOLGlCQUFLQSxVQUZDO0FBR04scUJBQVMsT0FBSzZxQixZQUFMLENBQWtCanpCLElBQWxCLENBQXVCLE1BQXZCLEVBQTZCb0ksVUFBN0IsQ0FISDtBQUlOO0FBQUE7QUFBQSxjQUFLLFdBQVUsYUFBZjtBQUNFO0FBQUE7QUFBQTtBQUNFLHFCQUFJLDZCQUROO0FBRUUsdURBQUssS0FBSSxRQUFULEVBQWtCLEtBQUssT0FBS3daLGFBQUwsdUJBQXVDeFosVUFBdkMsV0FBeUQsSUFBekQsQ0FBdkIsR0FGRjtBQUdFO0FBQUE7QUFBQSxrQkFBSyxLQUFJLGdCQUFULEVBQTBCLFdBQVlBLGVBQWVtd0QsdUJBQWhCLEdBQTJDLFdBQTNDLEdBQXlELElBQTlGO0FBQ0U7QUFBQTtBQUFBLG9CQUFLLEtBQUksU0FBVDtBQUNFLHlCQUFLaHpDLEVBQUwseUJBQThCelcsT0FBTzFHLFVBQXJDLEtBQ0EwRyxPQUFPSTtBQUZUO0FBREY7QUFIRjtBQURGO0FBSk0sU0FBUjtBQWlCRCxPQW5CTSxDQUFQO0FBb0JEOztBQUVEOzs7Ozs7Ozs4Q0FLMkI7QUFBQTs7QUFDekIsVUFBTXZCLGFBQWEsS0FBS2tlLGNBQUwsQ0FBb0Jpc0MsYUFBcEIsRUFBbkI7QUFDQSxVQUFNVSwwQkFDSixDQUFDLEtBQUt4eEQsS0FBTCxDQUFXNEIsT0FBWCxDQUFtQnF2RCxjQUFwQixJQUNBdHFELFdBQVdxQixNQUFYLEdBQW9CLENBRnRCO0FBR0EsVUFBSSxDQUFDd3BELHVCQUFMLEVBQThCO0FBQzVCLGVBQU8sSUFBUDtBQUNEOztBQUVELFVBQU1DLGdCQUFnQjlxRCxXQUFXd0IsR0FBWCxDQUFlLFVBQUNWLENBQUQsRUFBTztBQUMxQyxlQUFPO0FBQ0xyRyxzQkFBWXFHLEVBQUVyRyxVQURUO0FBRUxvL0IsZ0JBQU0vNEIsQ0FGRDtBQUdMdEQsaUJBQU8sT0FBS29hLEVBQUwseUJBQThCOVcsRUFBRXJHLFVBQWhDLEtBQWlEcUcsRUFBRVMsV0FIckQ7QUFJTHlTLGdCQUFNLE9BQUtDLGFBQUwsa0NBQWtEblQsRUFBRXJHLFVBQXBELFdBQXNFLElBQXRFO0FBSkQsU0FBUDtBQU1ELE9BUHFCLENBQXRCOztBQVNBLFVBQU1zd0QsbUJBQW1CO0FBQ3ZCdHdELG9CQUFZLEtBQUt4RixLQUFMLENBQVdpTSxRQUFYLENBQW9CekcsVUFEVDtBQUV2Qm8vQixjQUFNLEtBQUs1a0MsS0FBTCxDQUFXaU0sUUFGTTtBQUd2QjFELGVBQU8sS0FBS29hLEVBQUwseUJBQThCLEtBQUszaUIsS0FBTCxDQUFXaU0sUUFBWCxDQUFvQnpHLFVBQWxELEtBQW1FLEtBQUt4RixLQUFMLENBQVdpTSxRQUFYLENBQW9CSyxXQUh2RTtBQUl2QnlTLGNBQU0sS0FBS0MsYUFBTCxrQ0FBa0QsS0FBS2hmLEtBQUwsQ0FBV2lNLFFBQVgsQ0FBb0J6RyxVQUF0RSxXQUF3RixJQUF4RjtBQUppQixPQUF6Qjs7QUFPQSxhQUFRO0FBQUE7QUFBQSxVQUFLLEtBQUksMkJBQVQ7QUFDTix3Q0FBQyxtQ0FBRDtBQUNFLGlCQUFPcXdELGFBRFQ7QUFFRSx3QkFBY0MsZ0JBRmhCO0FBR0Usb0JBQVUsS0FBS0MsaUJBSGpCO0FBRE0sT0FBUjtBQU1EOztBQUVEOzs7Ozs7O3FDQUlrQjtBQUNoQixVQUFNbGxDLFlBQVksS0FBS0MsZ0JBQUwsRUFBbEI7QUFDQSxVQUFNa2xDLG1CQUFtQixLQUFLQyx1QkFBTCxFQUF6Qjs7QUFFQSxhQUFPLENBQ0xELGdCQURLLEVBRUo7QUFBQTtBQUFBLFVBQUssS0FBSSxlQUFUO0FBQ0M7QUFBQyxzQ0FBRDtBQUFBLFlBQW9CLEtBQUksV0FBeEI7QUFDRTtBQUFBO0FBQUEsY0FBSSxLQUFJLFNBQVI7QUFDR25sQztBQURIO0FBREY7QUFERCxPQUZJLENBQVA7QUFVRDs7OztFQXhNa0QxckIsMkI7O2tCQUFoQ213RCx1Qjs7O0FBMk1yQkEsd0JBQXdCcHdELFlBQXhCLEdBQXVDQyw0QkFBa0JELFlBQXpELEM7Ozs7Ozs7Ozs7Ozs7OztBQ3BOQTs7Ozs7OytlQWhCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBZ0JxQmd4RCxnQzs7Ozs7Ozs7Ozs7O0FBQ25COztBQUVBOzs7OztpQ0FLY3R4QixJLEVBQU07QUFDbEIsV0FBS3hnQyxLQUFMLENBQVc4RCxRQUFYLElBQ0UsS0FBSzlELEtBQUwsQ0FBVzhELFFBQVgsQ0FBb0IwOEIsS0FBS0EsSUFBekIsQ0FERjtBQUVEOztBQUVEOztBQUVBOzs7Ozs7Ozt1Q0FLb0I7QUFBQTs7QUFDbEIsYUFBTyxLQUFLeGdDLEtBQUwsQ0FBVytyQixLQUFYLENBQ0o1akIsR0FESSxDQUNBLFVBQUNxNEIsSUFBRCxFQUFVO0FBQ2IsWUFBTWtjLFNBQVNsYyxLQUFLcC9CLFVBQUwsS0FBb0IsT0FBS3BCLEtBQUwsQ0FBVyt6QixZQUFYLENBQXdCM3lCLFVBQTNEO0FBQ0EsZUFBTztBQUFBO0FBQUE7QUFDTCxpQkFBSSxTQURDO0FBRUwsdUJBQVdzN0MsU0FBUyxZQUFULEdBQXdCLEVBRjlCO0FBR0wscUJBQVMsT0FBS3p3QixZQUFMLENBQWtCanpCLElBQWxCLENBQXVCLE1BQXZCLEVBQTZCd25DLElBQTdCLENBSEo7QUFJTCxtREFBSyxLQUFJLFFBQVQsRUFBa0IsS0FBS0EsS0FBSzdsQixJQUE1QixHQUpLO0FBS0w7QUFBQTtBQUFBLGNBQUssS0FBSSxTQUFUO0FBQW9CNmxCLGlCQUFLcjhCO0FBQXpCO0FBTEssU0FBUDtBQU9ELE9BVkksQ0FBUDtBQVdEOztBQUVEOzs7Ozs7O29DQUlpQjtBQUNmLGFBQVE7QUFBQTtBQUFBLFVBQUssS0FBSSxnQ0FBVDtBQUNOO0FBQUE7QUFBQSxZQUFJLEtBQUksU0FBUjtBQUNHLGVBQUt1b0IsZ0JBQUw7QUFESDtBQURNLE9BQVI7QUFLRDs7OztFQTVDMkRyekIsc0I7O2tCQUF6Q3k0RCxnQzs7O0FBK0NyQkEsaUNBQWlDaHhELFlBQWpDLEdBQWdEekgsdUJBQWN5SCxZQUE5RCxDOzs7Ozs7Ozs7Ozs7Ozs7QUNsREE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQWpCQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWtCQTs7Ozs7O0lBTU1peEQsYTs7Ozs7Ozs7Ozs7O0FBQ0o7Ozs7OztnQ0FNb0I1dkQsTSxFQUFRO0FBQzFCLGFBQU9BLE9BQU95dUIsYUFBUCxDQUFxQixPQUFyQixNQUNKenVCLE9BQU8rbkQsYUFBUCxDQUFxQixjQUFyQixLQUNEL25ELE9BQU8rbkQsYUFBUCxDQUFxQixnQkFBckIsQ0FGSyxDQUFQO0FBR0Q7O0FBRUQ7Ozs7Ozs7Ozs2QkFNaUI7QUFBQSxVQUNQL25ELE1BRE8sR0FDSSxLQUFLYixPQURULENBQ1BhLE1BRE87O0FBRWZBLGFBQU95ckIsUUFBUCxDQUFnQisvQixNQUFoQixDQUF1QixNQUF2QixFQUErQixNQUEvQjs7QUFFQSxVQUFNOWdELGlCQUFpQixLQUFLbkgsY0FBTCxDQUFvQixnQkFBcEIsQ0FBdkI7QUFDQSxVQUFNc3NELG1CQUFtQixLQUFLdHNELGNBQUwsQ0FBb0Isa0JBQXBCLENBQXpCO0FBQ0EsVUFBTTJHLFlBQVksS0FBSzNHLGNBQUwsQ0FBb0IsV0FBcEIsQ0FBbEI7O0FBRUEsVUFBSyxDQUFDMkcsU0FBRCxJQUFjMmxELGdCQUFmLElBQ0QzbEQsYUFBYTJsRCxnQkFBYixJQUFpQzNsRCxVQUFVL1EsV0FBVixLQUEwQjAyRCxpQkFBaUIxMkQsV0FEL0UsRUFDNkY7QUFDM0Y2RyxlQUFPaXJCLE9BQVAsQ0FBZTdpQixHQUFmLENBQW1CeW5ELGdCQUFuQixFQUNFbmxELGNBREYsRUFFRSxJQUZGO0FBR0Q7O0FBRUQsVUFBSVIsYUFBYSxDQUFDMmxELGdCQUFsQixFQUFvQztBQUNsQzd2RCxlQUFPaXJCLE9BQVAsQ0FBZTdpQixHQUFmLENBQW1COEIsU0FBbkIsRUFDRSxFQURGLEVBRUUsS0FGRjtBQUdEOztBQUVELFVBQUlBLGFBQWEybEQsZ0JBQWIsSUFBaUMzbEQsVUFBVS9RLFdBQVYsS0FBMEIwMkQsaUJBQWlCMTJELFdBQWhGLEVBQTZGO0FBQzNGNkcsZUFBT2lyQixPQUFQLENBQWU3aUIsR0FBZixDQUFtQixDQUFDO0FBQ2xCOEIscUJBQVcybEQsZ0JBRE87QUFFbEJwd0QsbUJBQVNpTCxjQUZTO0FBR2xCdWdELG9CQUFVO0FBSFEsU0FBRCxFQUloQjtBQUNEL2dELDhCQURDO0FBRUR6SyxtQkFBUyxFQUZSO0FBR0R3ckQsb0JBQVU7QUFIVCxTQUpnQixDQUFuQjtBQVNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7NEJBT2dCdCtDLFcsRUFBYTtBQUFBLFVBQ25CM00sTUFEbUIsR0FDUixLQUFLYixPQURHLENBQ25CYSxNQURtQjs7QUFFM0IsVUFBTWtLLFlBQVlsSyxPQUFPb0ssVUFBUCxDQUFrQmhMLEdBQWxCLENBQXNCLGdCQUF0QixLQUEyQ1ksT0FBT29LLFVBQVAsQ0FBa0JoTCxHQUFsQixDQUFzQixjQUF0QixDQUE3RDs7QUFFQSxVQUFJc0wsaUJBQWlCLEVBQXJCO0FBQ0EsVUFBSVIsU0FBSixFQUFlO0FBQ2JRLHlCQUFpQlIsVUFBVWlyQixnQkFBVixFQUFqQjtBQUNBLGVBQU96cUIsZUFBZUgsT0FBdEI7QUFDRDs7QUFFRCxXQUFLQyxjQUFMLENBQW9CO0FBQ2xCTiw0QkFEa0I7QUFFbEIybEQsMEJBQWtCM2xELFNBRkE7QUFHbEJPLGdDQUF3QixDQUFDLENBQUNQLFNBSFI7QUFJbEJRLHNDQUprQjtBQUtsQjJTLHlCQUFpQnJkLE9BQU80TCxtQkFBUDtBQUxDLE9BQXBCO0FBT0Q7O0FBRUQ7Ozs7Ozs7O3FDQUt5QjVMLE0sRUFBUTtBQUMvQixVQUFJa2dDLFNBQVMsRUFBYjtBQUNBLFVBQUlsZ0MsT0FBTytuRCxhQUFQLENBQXFCLGNBQXJCLENBQUosRUFBMEM7QUFDeEM3bkIsZUFBT3huQyxJQUFQLENBQVksMkJBQVo7QUFDRDtBQUNELFVBQUlzSCxPQUFPK25ELGFBQVAsQ0FBcUIsZ0JBQXJCLENBQUosRUFBNEM7QUFDMUM3bkIsZUFBT3huQyxJQUFQLENBQVksNkJBQVo7QUFDRDs7QUFFRCxhQUFPd25DLE1BQVA7QUFDRDs7OztFQTlGeUJ6QixrQjs7QUFpRzVCOzs7Ozs7O0FBS0FteEIsY0FBYzF2RCxpQkFBZCxHQUFrQzR2RCxnQ0FBbEM7O0FBRUE7Ozs7OztBQU1BRixjQUFjenZELHVCQUFkLEdBQXdDNHZELHNDQUF4Qzs7QUFFQTs7Ozs7QUFLQUgsY0FBYzN3RCxVQUFkLEdBQTJCLE9BQTNCOztBQUVBOzs7OztBQUtBMndELGNBQWN4dkQsUUFBZCxHQUF5Qiw2QkFBekI7O0FBRUE7Ozs7O0FBS0F3dkQsY0FBY3Z2RCxXQUFkLEdBQTRCLHdCQUE1Qjs7QUFFQTs7OztBQUlBdXZELGNBQWN0dkQsY0FBZCxHQUErQixFQUEvQjs7QUFJQTs7OztBQUlBc3ZELGNBQWNuSSxrQkFBZCxHQUFtQyxDQUFDLGNBQUQsRUFBaUIsZ0JBQWpCLEVBQW1DLGNBQW5DLEVBQW1ELE1BQW5ELENBQW5DOztrQkFFZW1JLGE7Ozs7Ozs7Ozs7Ozs7OztBQzVKZjs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OzsrZUFuQkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQW1CQSxJQUFNM0gsUUFBUSxDQUNaLEVBQUUrSCxVQUFVLGNBQVosRUFBNEJDLFVBQVUsUUFBdEMsRUFBZ0Q1dkQsYUFBYSwyQkFBN0QsRUFEWSxFQUVaLEVBQUUydkQsVUFBVSxnQkFBWixFQUE4QkMsVUFBVSxVQUF4QyxFQUFvRDV2RCxhQUFhLDZCQUFqRSxFQUZZLENBQWQ7O0lBS3FCeXZELHNCOzs7QUFDbkIsb0NBQXNCO0FBQUE7O0FBQUE7O0FBQUEsc0NBQU5qeEQsSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEsMktBQ1hBLElBRFc7O0FBRXBCLFVBQUtyRixRQUFMLENBQ0UscUJBREYsRUFFRSxxQkFGRjtBQUlBLFVBQUswMkQsaUJBQUwsR0FBeUIsSUFBekI7O0FBRUEsVUFBS3JtRCxPQUFMLHVCQUNHelMsbUJBQVVzTSxNQUFWLENBQWlCc0csaUJBRHBCLEVBQ3dDLE1BQUtDLG1CQUQ3QztBQVJvQjtBQVdyQjs7QUFFRDs7QUFFQTs7Ozs7Ozs7O3dDQUtxQnZJLEssRUFBTztBQUMxQixVQUFNd0ksWUFBWSxLQUFLM0csY0FBTCxDQUFvQixXQUFwQixDQUFsQjtBQUNBLFVBQU04WixrQkFBa0IsS0FBSzlaLGNBQUwsQ0FBb0IsaUJBQXBCLENBQXhCO0FBQ0EyRyxnQkFBVWltRCxhQUFWLENBQXdCenVELFFBQVEyYixnQkFBZ0I1Z0IsR0FBaEIsRUFBaEM7O0FBSDBCLFVBS2xCdUQsTUFMa0IsR0FLUCxLQUFLYixPQUxFLENBS2xCYSxNQUxrQjs7QUFNMUJBLGFBQU9tTCxNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OzttQ0FNZ0I2a0QsUSxFQUFVaDFELEMsRUFBRztBQUFBLFVBQ25CZ0YsTUFEbUIsR0FDUixLQUFLYixPQURHLENBQ25CYSxNQURtQjs7QUFFM0IsVUFBTW93RCxvQkFBb0IsS0FBSzdzRCxjQUFMLENBQW9CLFdBQXBCLENBQTFCO0FBQ0EsVUFBSTZzRCxpQkFBSixFQUF1QjtBQUNyQixhQUFLRixpQkFBTCxHQUF5QkUsaUJBQXpCO0FBQ0Fwd0QsZUFBT29LLFVBQVAsQ0FBa0JrK0MsTUFBbEIsQ0FBeUI4SCxpQkFBekI7QUFDRDs7QUFFRCxVQUFJam1ELGVBQWUsSUFBbkI7QUFDQSxVQUFJNmxELFFBQUosRUFBYztBQUNaN2xELHVCQUFlbkssT0FBT29LLFVBQVAsQ0FBa0JDLFdBQWxCLENBQThCMmxELFFBQTlCLENBQWY7QUFDRDs7QUFFRCxXQUFLeGxELGNBQUwsQ0FBb0IsRUFBRU4sV0FBV0MsWUFBYixFQUFwQjtBQUNBbkssYUFBT21MLE1BQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7d0NBS3FCakIsUyxFQUFXO0FBQzlCLFVBQU1tbUQsbUJBQW1CLEtBQUs5c0QsY0FBTCxDQUFvQixXQUFwQixDQUF6QjtBQUNBLFVBQUksQ0FBQzhzRCxnQkFBRCxJQUFxQm5tRCxjQUFjbW1ELGdCQUFuQyxJQUF1RG5tRCxjQUFjLEtBQUtnbUQsaUJBQTlFLEVBQWlHO0FBQ2pHLFVBQUksS0FBS2x4RCxrQkFBVCxFQUE2Qjs7QUFIQyxVQUt0QmdCLE1BTHNCLEdBS1gsS0FBS2IsT0FMTSxDQUt0QmEsTUFMc0I7O0FBTTlCLFVBQU1mLGFBQWFveEQsaUJBQWlCbDNELFdBQWpCLENBQTZCOEYsVUFBaEQ7QUFDQSxVQUFNa0wsZUFBZW5LLE9BQU9vSyxVQUFQLENBQWtCQyxXQUFsQixDQUE4QnBMLFVBQTlCLENBQXJCOztBQUVBLFdBQUt1TCxjQUFMLENBQW9CO0FBQ2xCTixtQkFBV0MsWUFETztBQUVsQk0sZ0NBQXdCLEtBRk47QUFHbEJDLHdCQUFnQjtBQUhFLE9BQXBCO0FBS0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7NENBSXlCO0FBQ3ZCLFVBQU00bEQsaUJBQWlCLEtBQUsvc0QsY0FBTCxDQUFvQixXQUFwQixDQUF2QjtBQUNBLFVBQUksQ0FBQytzRCxjQUFMLEVBQXFCLE9BQU8sSUFBUDs7QUFFckIsVUFBTWp6QyxrQkFBa0IsS0FBSzlaLGNBQUwsQ0FBb0IsaUJBQXBCLENBQXhCO0FBQ0EsVUFBTWd0RCxlQUFlbHpDLGdCQUFnQjVnQixHQUFoQixFQUFyQjtBQUNBLFVBQU1pRixRQUFRNHVELGVBQWVFLGFBQWYsS0FBaUNELFlBQS9DO0FBQ0EsYUFBUSxnQ0FBQyxnQ0FBRDtBQUNOLGtCQUFVLENBREo7QUFFTixrQkFBVXo2RCxLQUFLMkcsR0FBTCxDQUFTLEdBQVQsRUFBYzNHLEtBQUt5UyxLQUFMLENBQVdnb0QsZUFBZSxHQUExQixDQUFkLENBRko7QUFHTixtQkFBVSxJQUhKO0FBSU4sbUJBQVcsS0FKTDtBQUtOLGVBQU8sS0FBS24wQyxFQUFMLENBQVEsNkJBQVIsQ0FMRDtBQU1OLGtCQUFVLEtBQUtxMEMsbUJBTlQ7QUFPTixlQUFPL3VELEtBUEQsR0FBUjtBQVFEOztBQUVEOzs7Ozs7Ozt1Q0FLb0I7QUFBQTs7QUFDbEIsVUFBTTR1RCxpQkFBaUIsS0FBSy9zRCxjQUFMLENBQW9CLFdBQXBCLENBQXZCOztBQURrQixVQUdWdkQsTUFIVSxHQUdDLEtBQUtiLE9BSE4sQ0FHVmEsTUFIVTs7QUFJbEIsVUFBTTB3RCxjQUFlO0FBQUE7QUFBQTtBQUNuQixlQUFJLFFBRGU7QUFFbkIsZUFBSSxNQUZlO0FBR25CO0FBQUE7QUFBQSxZQUFLLFdBQVUsYUFBZjtBQUNFO0FBQUE7QUFBQTtBQUNFLG1CQUFJLHVCQUROO0FBRUUseUJBQVcsQ0FBQ0osY0FBRCxHQUFrQixXQUFsQixHQUFnQyxJQUY3QztBQUdFLHVCQUFTLEtBQUtuMEMsY0FBTCxDQUFvQnRsQixJQUFwQixDQUF5QixJQUF6QixFQUErQixJQUEvQixDQUhYO0FBSUUscURBQUssS0FBSSxRQUFULEVBQWtCLEtBQUssS0FBSzRoQixhQUFMLENBQW1CLHlCQUFuQixFQUE4QyxJQUE5QyxDQUF2QixHQUpGO0FBS0U7QUFBQTtBQUFBLGdCQUFLLEtBQUksU0FBVDtBQUFvQixtQkFBSzJELEVBQUwsQ0FBUSx5QkFBUjtBQUFwQjtBQUxGO0FBREY7QUFIbUIsT0FBckI7O0FBY0EsYUFBTyxDQUFDczBDLFdBQUQsRUFBY3RxRCxNQUFkLENBQXFCNmhELE1BQ3pCdGlELE1BRHlCLENBQ2xCO0FBQUEsWUFBR3FxRCxRQUFILFNBQUdBLFFBQUg7QUFBQSxlQUFrQmh3RCxPQUFPK25ELGFBQVAsQ0FBcUJpSSxRQUFyQixDQUFsQjtBQUFBLE9BRGtCLEVBRXpCaHFELEdBRnlCLENBRXJCLGlCQUF5QztBQUFBLFlBQXRDZ3FELFFBQXNDLFNBQXRDQSxRQUFzQztBQUFBLFlBQTVCQyxRQUE0QixTQUE1QkEsUUFBNEI7QUFBQSxZQUFsQjV2RCxXQUFrQixTQUFsQkEsV0FBa0I7O0FBQzVDLFlBQU1zd0QsV0FBV0wsa0JBQWtCQSxlQUFlbjNELFdBQWYsQ0FBMkI4RixVQUEzQixLQUEwQyt3RCxRQUE3RTtBQUNBLGVBQVE7QUFBQTtBQUFBO0FBQ04saUJBQUksUUFERTtBQUVOLCtCQUFpQkEsUUFGWDtBQUdOLGlCQUFLQSxRQUhDO0FBSU47QUFBQTtBQUFBLGNBQUssV0FBVSxhQUFmO0FBQ0U7QUFBQTtBQUFBO0FBQ0UscUJBQUksdUJBRE47QUFFRSwyQkFBV1csV0FBVyxXQUFYLEdBQXlCLElBRnRDO0FBR0UseUJBQVMsT0FBS3gwQyxjQUFMLENBQW9CdGxCLElBQXBCLENBQXlCLE1BQXpCLEVBQStCbTVELFFBQS9CLENBSFg7QUFJRSx1REFBSyxLQUFJLFFBQVQsRUFBa0IsS0FBSyxPQUFLdjNDLGFBQUwscUJBQXFDdzNDLFFBQXJDLFdBQXFELElBQXJELENBQXZCLEdBSkY7QUFLRTtBQUFBO0FBQUEsa0JBQUssS0FBSSxTQUFUO0FBQW9CLHVCQUFLN3pDLEVBQUwsQ0FBUS9iLFdBQVI7QUFBcEI7QUFMRjtBQURGO0FBSk0sU0FBUjtBQWNELE9BbEJ5QixDQUFyQixDQUFQO0FBbUJEOztBQUVEOzs7Ozs7O3FDQUlrQjtBQUNoQixVQUFNaXFCLFlBQVksS0FBS0MsZ0JBQUwsRUFBbEI7O0FBRUEsYUFBUTtBQUFBO0FBQUEsVUFBSyxLQUFJLGVBQVQ7QUFDTjtBQUFDLHNDQUFEO0FBQUE7QUFDRTtBQUFBO0FBQUEsY0FBSSxLQUFJLFNBQVI7QUFDR0Q7QUFESDtBQURGO0FBRE0sT0FBUjtBQU9EOzs7O0VBM0ppRDFyQiwyQjs7a0JBQS9Ca3hELHNCOzs7QUE4SnJCQSx1QkFBdUJueEQsWUFBdkIsR0FBc0NDLDRCQUFrQkQsWUFBeEQsQzs7Ozs7Ozs7Ozs7Ozs7O0FDeEtBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFuQkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztJQW1CcUJveEQsNEI7Ozs7Ozs7Ozs7OztBQUNuQjs7QUFFQTs7Ozs7OzZDQU0wQjdsRCxTLEVBQVc7QUFDbkMsVUFBSSxDQUFDQSxTQUFMLEVBQWdCLE9BQU8sSUFBUDs7QUFFaEIsY0FBUUEsVUFBVS9RLFdBQVYsQ0FBc0I4RixVQUE5QjtBQUNFLGFBQUssZ0JBQUw7QUFDRSxpQkFBTzJ4RCw0Q0FBUDtBQUNGLGFBQUssY0FBTDtBQUNFLGlCQUFPQyw0Q0FBUDtBQUpKO0FBTUQ7O0FBRUQ7Ozs7Ozs7b0NBSWlCO0FBQ2YsVUFBTTNtRCxZQUFZLEtBQUszRyxjQUFMLENBQW9CLFdBQXBCLENBQWxCO0FBQ0EsVUFBTWs3QixXQUFXLEtBQUtxeUIsd0JBQUwsQ0FBOEI1bUQsU0FBOUIsQ0FBakI7QUFDQSxVQUFJLENBQUN1MEIsUUFBTCxFQUFlLE9BQU8sNENBQVA7QUFDZixhQUFPLGdDQUFDLFFBQUQsRUFBYyxLQUFLNWdDLEtBQW5CLENBQVA7QUFDRDs7OztFQTdCdUQ4RSxpQzs7a0JBQXJDb3RELDRCOzs7QUFnQ3JCQSw2QkFBNkJweEQsWUFBN0IsR0FBNENnRSxrQ0FBd0JoRSxZQUFwRSxDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3JDQTs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7K2VBbEJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFrQnFCaXlELGtDOzs7QUFDbkIsZ0RBQXNCO0FBQUE7O0FBQUE7O0FBQUEsc0NBQU4veEQsSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEsbU1BQ1hBLElBRFc7O0FBR3BCLFVBQUtyRixRQUFMLENBQ0Usb0JBREYsRUFFRSxlQUZGLEVBR0Usa0JBSEYsRUFJRSxhQUpGLEVBS0UscUJBTEY7O0FBUUEsVUFBS0MsS0FBTCxHQUFhO0FBQ1hzM0Qsb0JBQWMsSUFBSXQ2RCxnQkFBSixFQURIO0FBRVh1NkQsc0JBQWdCLElBQUl2NkQsZ0JBQUosRUFGTDtBQUdYdzZELG9CQUFjLElBQUl4NkQsZ0JBQUo7QUFISCxLQUFiO0FBS0EsVUFBS3l4RCxVQUFMLEdBQWtCLE1BQUsza0QsY0FBTCxDQUFvQixXQUFwQixDQUFsQjs7QUFFQSxVQUFLc0csT0FBTCx1QkFDR3pTLG1CQUFVc00sTUFBVixDQUFpQm9HLGlCQURwQixFQUN3QyxNQUFLQyxtQkFEN0M7QUFsQm9CO0FBcUJyQjs7QUFFRDs7QUFFQTs7Ozs7Ozs7d0NBSXFCO0FBQ25CLFdBQUttbkQscUJBQUw7QUFDRDs7QUFFRDs7Ozs7Ozs7d0NBS3FCaG5ELFMsRUFBVztBQUM5QixVQUFJQSxjQUFjLEtBQUszRyxjQUFMLENBQW9CLFdBQXBCLENBQWxCLEVBQW9EO0FBQ3BELFdBQUsydEQscUJBQUw7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7Ozt5Q0FJc0J6dEIsUSxFQUFVO0FBQzlCLFVBQUlBLFNBQVN2NUIsU0FBYixFQUF3QjtBQUN0QixhQUFLZytDLFVBQUwsR0FBa0J6a0IsU0FBU3Y1QixTQUEzQjtBQUNBLFlBQUksS0FBS2crQyxVQUFMLENBQWdCL3VELFdBQWhCLENBQTRCOEYsVUFBNUIsS0FBMkMsZ0JBQS9DLEVBQWlFLEtBQUtpeUQscUJBQUw7QUFDbEU7QUFDRjs7QUFFRDs7Ozs7O3dDQUdxQjtBQUFBOztBQUNuQjs7QUFEbUIsVUFHWGx4RCxNQUhXLEdBR0EsS0FBS2IsT0FITCxDQUdYYSxNQUhXOztBQUluQkEsYUFBT29yQixJQUFQLENBQVkvckIsR0FBWixDQUFnQixNQUFoQixFQUF3QixZQUFNO0FBQzVCVyxlQUFPeXJCLFFBQVAsQ0FBZ0J3K0IsT0FBaEIsQ0FBd0IsTUFBeEIsRUFBZ0MsTUFBaEM7QUFDQSxlQUFLaUgscUJBQUw7QUFDRCxPQUhEO0FBSUQ7O0FBRUQ7O0FBRUE7Ozs7Ozs7eUNBSXNCO0FBQ3BCLFdBQUtDLGFBQUwsR0FBcUIsS0FBS2pKLFVBQUwsQ0FBZ0JrSixRQUFoQixFQUFyQjtBQUNBLFdBQUtDLFdBQUwsR0FBbUIsS0FBS25KLFVBQUwsQ0FBZ0JvSixNQUFoQixFQUFuQjtBQUNBLFdBQUtDLFlBQUwsR0FBb0IsS0FBS0YsV0FBTCxDQUFpQjUxRCxLQUFqQixHQUNqQk8sUUFEaUIsQ0FDUixLQUFLbTFELGFBREcsQ0FBcEI7QUFFRDs7QUFFRDs7Ozs7Ozs7a0NBS2V6MkMsTSxFQUFRO0FBQUEsVUFDYjFhLE1BRGEsR0FDRixLQUFLYixPQURILENBQ2JhLE1BRGE7OztBQUdyQixVQUFNMkwsbUJBQW1CM0wsT0FBTzRMLG1CQUFQLEVBQXpCO0FBQ0EsVUFBTTRsRCxpQkFBaUI5MkMsT0FBT2pmLEtBQVAsR0FDcEJvUSxNQURvQixDQUNiRixnQkFEYSxDQUF2Qjs7QUFHQSxVQUFNaStDLFdBQVcsS0FBS3VILGFBQUwsQ0FBbUIxMUQsS0FBbkIsR0FBMkIyTSxHQUEzQixDQUErQm9wRCxjQUEvQixFQUNkL2dDLEtBRGMsQ0FFYixJQUFJaDZCLGdCQUFKLENBQVksQ0FBWixFQUFlLENBQWYsQ0FGYSxFQUdiLElBQUlBLGdCQUFKLENBQVksQ0FBWixFQUFlLENBQWYsRUFBa0J1RixRQUFsQixDQUEyQixLQUFLdTFELFlBQWhDLENBSGEsQ0FBakI7QUFLQSxVQUFNMUgsU0FBU0QsU0FBU251RCxLQUFULEdBQWlCMk0sR0FBakIsQ0FBcUIsS0FBS21wRCxZQUExQixDQUFmOztBQUVBLFdBQUtySixVQUFMLENBQWdCN29ELEdBQWhCLENBQW9CO0FBQ2xCd2dCLGVBQU8rcEMsUUFEVztBQUVsQjlwQyxhQUFLK3BDO0FBRmEsT0FBcEI7O0FBS0E3cEQsYUFBT21MLE1BQVA7QUFDQSxXQUFLK2xELHFCQUFMO0FBQ0EsV0FBSzF0RCxXQUFMO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7cUNBSWtCeEksQyxFQUFHO0FBQ25CLFdBQUt5MkQsb0JBQUwsR0FBNEIsS0FBS2g0RCxLQUFMLENBQVd3M0QsWUFBWCxDQUF3QngxRCxLQUF4QixFQUE1QjtBQUNEOztBQUVEOzs7Ozs7OztnQ0FLYWlmLE0sRUFBUTtBQUFBLFVBQ1gxYSxNQURXLEdBQ0EsS0FBS2IsT0FETCxDQUNYYSxNQURXOztBQUVuQixVQUFNMkwsbUJBQW1CM0wsT0FBTzRMLG1CQUFQLEVBQXpCOztBQUVBLFVBQU04bEQsa0JBQWtCLEtBQUtELG9CQUFMLENBQTBCaDJELEtBQTFCLEdBQ3JCMk0sR0FEcUIsQ0FDakJzUyxNQURpQixFQUVyQitWLEtBRnFCLENBRWYsSUFBSWg2QixnQkFBSixDQUFZLENBQVosRUFBZSxDQUFmLENBRmUsRUFFSWtWLGdCQUZKLENBQXhCOztBQUlBLFVBQU1nbUQscUJBQXFCRCxnQkFBZ0JqMkQsS0FBaEIsR0FDeEJPLFFBRHdCLENBQ2YsS0FBS3ZDLEtBQUwsQ0FBV3MzRCxZQURJLENBQTNCOztBQUdBLFVBQU1seEMsUUFBUSxLQUFLcG1CLEtBQUwsQ0FBV3MzRCxZQUFYLENBQXdCdDFELEtBQXhCLEdBQ1gyTSxHQURXLENBQ1AsQ0FBQ3VwRCxtQkFBbUJ2MkQsQ0FEYixFQUNnQnUyRCxtQkFBbUJ4MkQsQ0FEbkMsRUFFWDBRLE1BRlcsQ0FFSkYsZ0JBRkksQ0FBZDtBQUdBLFVBQU1tVSxNQUFNLEtBQUtybUIsS0FBTCxDQUFXczNELFlBQVgsQ0FBd0J0MUQsS0FBeEIsR0FDVDJNLEdBRFMsQ0FDTHVwRCxtQkFBbUJ2MkQsQ0FEZCxFQUNpQixDQUFDdTJELG1CQUFtQngyRCxDQURyQyxFQUVUMFEsTUFGUyxDQUVGRixnQkFGRSxDQUFaO0FBR0EsVUFBTWxGLE9BQU9rckQsbUJBQW1CNXVDLEdBQW5CLEtBQTJCLENBQXhDOztBQUVBLFdBQUttbEMsVUFBTCxDQUFnQjdvRCxHQUFoQixDQUFvQjtBQUNsQndnQixvQkFEa0I7QUFFbEJDLGdCQUZrQjtBQUdsQnJaLGNBQU1BLE9BQU9rRixpQkFBaUJsUCxHQUFqQixFQUhLO0FBSWxCczlCLHNCQUFjdHpCLE9BQU9rRixpQkFBaUJsUCxHQUFqQjtBQUpILE9BQXBCO0FBTUEsV0FBSzFCLFFBQUwsQ0FBYztBQUNaazJELHNCQUFjUyxlQURGO0FBRVpWLHdCQUFnQixJQUFJdjZELGdCQUFKLENBQVksS0FBS2dELEtBQUwsQ0FBV3UzRCxjQUFYLENBQTBCNzFELENBQXRDLEVBQXlDc0wsSUFBekM7QUFGSixPQUFkO0FBSUF6RyxhQUFPbUwsTUFBUDtBQUNEOztBQUVEOztBQUVBOzs7Ozs7OztvQ0FLaUI7QUFDZixVQUFNeW1ELE9BQU8sS0FBS240RCxLQUFMLENBQVd3M0QsWUFBWCxDQUF3QngxRCxLQUF4QixHQUNWTyxRQURVLENBQ0QsS0FBS3ZDLEtBQUwsQ0FBV3MzRCxZQURWLENBQWI7QUFFQSxVQUFJci9CLFVBQVU1N0IsS0FBSys3RCxLQUFMLENBQVdELEtBQUt6MkQsQ0FBaEIsRUFBbUJ5MkQsS0FBS3gyRCxDQUF4QixLQUE4QixNQUFNdEYsS0FBS2krQixFQUF6QyxDQUFkO0FBQ0EsVUFBTS9OLHdCQUFzQixDQUFDLENBQUMwTCxPQUFGLEVBQVdocEIsT0FBWCxDQUFtQixDQUFuQixDQUF0QixTQUFOOztBQUVBLGFBQU87QUFDTHJMLGVBQU8sS0FBSzVELEtBQUwsQ0FBV3UzRCxjQUFYLENBQTBCNzFELENBRDVCO0FBRUw2QixnQkFBUSxLQUFLdkQsS0FBTCxDQUFXdTNELGNBQVgsQ0FBMEI1MUQsQ0FGN0I7QUFHTFMsY0FBTSxLQUFLcEMsS0FBTCxDQUFXczNELFlBQVgsQ0FBd0I1MUQsQ0FIekI7QUFJTFcsYUFBSyxLQUFLckMsS0FBTCxDQUFXczNELFlBQVgsQ0FBd0IzMUQsQ0FKeEI7QUFLTDAyRCxvQkFBWSxLQUFLcjRELEtBQUwsQ0FBV3UzRCxjQUFYLENBQTBCNzFELENBQTFCLEdBQThCLENBQUMsR0FMdEM7QUFNTDQyRCxtQkFBVyxLQUFLdDRELEtBQUwsQ0FBV3UzRCxjQUFYLENBQTBCNTFELENBQTFCLEdBQThCLENBQUMsR0FOckM7QUFPTDRxQixtQkFBV0EsU0FQTjtBQVFMZ3NDLHNCQUFjaHNDLFNBUlQ7QUFTTGlzQyxxQkFBYWpzQyxTQVRSO0FBVUxrc0MseUJBQWlCbHNDO0FBVlosT0FBUDtBQVlEOztBQUVEOzs7Ozs7OztvQ0FLaUI7QUFDZixhQUFPO0FBQ0xucUIsY0FBTSxLQUFLcEMsS0FBTCxDQUFXdzNELFlBQVgsQ0FBd0I5MUQsQ0FEekI7QUFFTFcsYUFBSyxLQUFLckMsS0FBTCxDQUFXdzNELFlBQVgsQ0FBd0I3MUQ7QUFGeEIsT0FBUDtBQUlEOztBQUVEOztBQUVBOzs7Ozs7OzRDQUl5QjtBQUFBLFVBQ2Y0RSxNQURlLEdBQ0osS0FBS2IsT0FERCxDQUNmYSxNQURlOztBQUV2QixVQUFNMkwsbUJBQW1CM0wsT0FBTzRMLG1CQUFQLEVBQXpCOztBQUVBLFVBQU1pVSxRQUFRLEtBQUtxb0MsVUFBTCxDQUFnQmtKLFFBQWhCLEdBQTJCMzFELEtBQTNCLEdBQW1DNmUsUUFBbkMsQ0FBNEMzTyxnQkFBNUMsQ0FBZDtBQUNBLFVBQU1tVSxNQUFNLEtBQUtvb0MsVUFBTCxDQUFnQm9KLE1BQWhCLEdBQXlCNzFELEtBQXpCLEdBQWlDNmUsUUFBakMsQ0FBMEMzTyxnQkFBMUMsQ0FBWjtBQUNBLFVBQU1sRixPQUFPLEtBQUt5aEQsVUFBTCxDQUFnQmlLLE9BQWhCLEtBQTRCeG1ELGlCQUFpQmxQLEdBQWpCLEVBQXpDOztBQUVBLFVBQU1tMUQsT0FBTzl4QyxJQUFJcmtCLEtBQUosR0FBWU8sUUFBWixDQUFxQjZqQixLQUFyQixDQUFiO0FBQ0EsVUFBTXV5QyxTQUFTdnlDLE1BQU1wa0IsS0FBTixHQUNaMk0sR0FEWSxDQUNSd3BELEtBQUtuMkQsS0FBTCxHQUFhb1EsTUFBYixDQUFvQixDQUFwQixDQURRLENBQWY7O0FBR0EsVUFBTXdtRCxXQUFXLElBQUk1N0QsZ0JBQUosQ0FDZmtWLGlCQUFpQm9YLEdBQWpCLEtBQXlCLENBRFYsRUFFZnRjLElBRmUsQ0FBakI7O0FBS0EsVUFBTTZyRCxZQUFZVixLQUFLN3VDLEdBQUwsRUFBbEI7QUFDQSxVQUFNd3ZDLFNBQVNYLEtBQUtuMkQsS0FBTCxHQUFhb1EsTUFBYixDQUFvQnltRCxTQUFwQixFQUErQnptRCxNQUEvQixDQUFzQyxDQUF0QyxDQUFmOztBQUVBLFdBQUs5USxRQUFMLENBQWM7QUFDWmkyRCx3QkFBZ0JxQixRQURKO0FBRVp0QixzQkFBY3FCLE9BQU8zMkQsS0FBUCxFQUZGO0FBR1p3MUQsc0JBQWNtQixPQUFPMzJELEtBQVAsR0FDWDJNLEdBRFcsQ0FDUCxDQUFDM0IsSUFBRCxHQUFROHJELE9BQU9uM0QsQ0FEUixFQUNXcUwsT0FBTzhyRCxPQUFPcDNELENBRHpCO0FBSEYsT0FBZDtBQU1EOztBQUVEOzs7Ozs7Ozt5Q0FLc0I7QUFBQSxrQ0FDWSxLQUFLZ0UsT0FBTCxDQUFhYSxNQUFiLENBQW9CZ3lCLE1BQXBCLEdBQTZCaEIsU0FBN0IsR0FBeUNDLFNBQXpDLEVBRFo7QUFBQSxVQUNaOTFCLENBRFkseUJBQ1pBLENBRFk7QUFBQSxVQUNUQyxDQURTLHlCQUNUQSxDQURTO0FBQUEsVUFDTmlDLEtBRE0seUJBQ05BLEtBRE07QUFBQSxVQUNDTCxNQURELHlCQUNDQSxNQUREOztBQUVwQixhQUFPO0FBQ0xuQixjQUFNVixDQUREO0FBRUxXLGFBQUtWLENBRkE7QUFHTGlDLG9CQUhLO0FBSUxMO0FBSkssT0FBUDtBQU1EOztBQUVEOzs7Ozs7O29DQUlpQjtBQUNmLGFBQVE7QUFBQTtBQUFBLFVBQUssS0FBSSxxQ0FBVCxFQUErQyxLQUFJLFdBQW5ELEVBQStELE9BQU8sS0FBSzhPLGtCQUFMLEVBQXRFO0FBQ047QUFBQTtBQUFBLFlBQUssS0FBSSw4QkFBVDtBQUNFO0FBQUMsd0NBQUQ7QUFBQTtBQUNFLHVCQUFTLEtBQUs2aEQsa0JBRGhCO0FBRUUsc0JBQVEsS0FBS0MsYUFGZjtBQUdFLHFEQUFLLEtBQUksUUFBVCxFQUFrQixPQUFPLEtBQUs0RSxhQUFMLEVBQXpCO0FBSEYsV0FERjtBQU1FO0FBQUMsd0NBQUQ7QUFBQTtBQUNFLHVCQUFTLEtBQUt2cEQsZ0JBRGhCO0FBRUUsc0JBQVEsS0FBS0MsV0FGZjtBQUdFLHFEQUFLLEtBQUksZ0JBQVQsRUFBMEIsT0FBTyxLQUFLRSxhQUFMLEVBQWpDO0FBSEY7QUFORjtBQURNLE9BQVI7QUFjRDs7OztFQTFRNkR6RyxpQzs7a0JBQTNDaXVELGtDOzs7QUE2UXJCQSxtQ0FBbUNqeUQsWUFBbkMsR0FBa0RnRSxrQ0FBd0JoRSxZQUExRSxDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2pSQTs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7K2VBbEJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFrQnFCa3lELGtDOzs7QUFDbkIsZ0RBQXNCO0FBQUE7O0FBQUE7O0FBQUEsc0NBQU5oeUQsSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEsbU1BQ1hBLElBRFc7O0FBR3BCLFVBQUtyRixRQUFMLENBQ0Usb0JBREYsRUFFRSxlQUZGLEVBR0Usa0JBSEYsRUFJRSxhQUpGLEVBS0UscUJBTEY7O0FBUUEsVUFBS0MsS0FBTCxHQUFhO0FBQ1hzM0Qsb0JBQWMsSUFBSXQ2RCxnQkFBSixFQURIO0FBRVh1NkQsc0JBQWdCLElBQUl2NkQsZ0JBQUosRUFGTDtBQUdYdzZELG9CQUFjLElBQUl4NkQsZ0JBQUo7QUFISCxLQUFiO0FBS0EsVUFBS2c4RCxvQkFBTCxHQUE0QixLQUE1QjtBQUNBLFVBQUt2SyxVQUFMLEdBQWtCLE1BQUsza0QsY0FBTCxDQUFvQixXQUFwQixDQUFsQjs7QUFFQSxVQUFLc0csT0FBTCx1QkFDR3pTLG1CQUFVc00sTUFBVixDQUFpQm9HLGlCQURwQixFQUN3QyxNQUFLQyxtQkFEN0M7QUFuQm9CO0FBc0JyQjs7QUFFRDs7QUFFQTs7Ozs7Ozs7d0NBSXFCO0FBQ25CLFdBQUttbkQscUJBQUw7QUFDRDs7QUFFRDs7Ozs7Ozs7d0NBS3FCaG5ELFMsRUFBVztBQUM5QixVQUFJQSxjQUFjLEtBQUszRyxjQUFMLENBQW9CLFdBQXBCLENBQWxCLEVBQW9EO0FBQ3BELFdBQUtrdkQsb0JBQUwsR0FBNEIsS0FBNUI7QUFDQSxXQUFLdkIscUJBQUw7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7Ozt5Q0FJc0J6dEIsUSxFQUFVO0FBQzlCLFVBQUlBLFNBQVN2NUIsU0FBYixFQUF3QjtBQUN0QixhQUFLZytDLFVBQUwsR0FBa0J6a0IsU0FBU3Y1QixTQUEzQjtBQUNBLFlBQUksS0FBS2crQyxVQUFMLENBQWdCL3VELFdBQWhCLENBQTRCOEYsVUFBNUIsS0FBMkMsY0FBL0MsRUFBK0QsS0FBS2l5RCxxQkFBTDtBQUNoRTtBQUNGOztBQUVEOzs7Ozs7d0NBR3FCO0FBQUE7O0FBQ25CO0FBRG1CLFVBRVhseEQsTUFGVyxHQUVBLEtBQUtiLE9BRkwsQ0FFWGEsTUFGVzs7QUFHbkJBLGFBQU9vckIsSUFBUCxDQUFZL3JCLEdBQVosQ0FBZ0IsTUFBaEIsRUFBd0IsWUFBTTtBQUM1QlcsZUFBT3lyQixRQUFQLENBQWdCdytCLE9BQWhCLENBQXdCLE1BQXhCLEVBQWdDLE1BQWhDO0FBQ0EsZUFBS2lILHFCQUFMO0FBQ0QsT0FIRDtBQUlEOztBQUVEOztBQUVBOzs7Ozs7O3lDQUlzQjtBQUNwQixXQUFLMTFELGdCQUFMLEdBQXdCLEtBQUswc0QsVUFBTCxDQUFnQjd0QyxXQUFoQixFQUF4QjtBQUNBLFdBQUtvM0Msb0JBQUwsR0FBNEIsS0FBS2g0RCxLQUFMLENBQVd3M0QsWUFBWCxDQUF3QngxRCxLQUF4QixFQUE1QjtBQUNEOztBQUVEOzs7Ozs7OztrQ0FLZWlmLE0sRUFBUTtBQUFBLFVBQ2IxYSxNQURhLEdBQ0YsS0FBS2IsT0FESCxDQUNiYSxNQURhOzs7QUFHckIsVUFBTTJMLG1CQUFtQjNMLE9BQU80TCxtQkFBUCxFQUF6QjtBQUNBLFVBQU00bEQsaUJBQWlCOTJDLE9BQU9qZixLQUFQLEdBQWVvUSxNQUFmLENBQXNCRixnQkFBdEIsQ0FBdkI7QUFDQSxVQUFNZ1AsY0FBYyxLQUFLbmYsZ0JBQUwsQ0FDakJDLEtBRGlCLEdBRWpCMk0sR0FGaUIsQ0FFYm9wRCxjQUZhLENBQXBCOztBQUlBLFVBQU1FLGtCQUFrQixLQUFLRCxvQkFBTCxDQUEwQmgyRCxLQUExQixHQUNyQjJNLEdBRHFCLENBQ2pCc1MsTUFEaUIsQ0FBeEI7O0FBR0EsV0FBS3d0QyxVQUFMLENBQWdCN29ELEdBQWhCLENBQW9CO0FBQ2xCMEksa0JBQVU0UztBQURRLE9BQXBCOztBQUlBLFdBQUtsaEIsS0FBTCxDQUFXdzNELFlBQVgsR0FBMEJTLGVBQTFCOztBQUVBMXhELGFBQU9tTCxNQUFQO0FBQ0EsV0FBSytsRCxxQkFBTDtBQUNEOztBQUVEOztBQUVBOzs7Ozs7O3FDQUlrQmwyRCxDLEVBQUc7QUFDbkIsV0FBS3kzRCxvQkFBTCxHQUE0QixJQUE1QjtBQUNBLFdBQUtoQixvQkFBTCxHQUE0QixLQUFLaDRELEtBQUwsQ0FBV3czRCxZQUFYLENBQXdCeDFELEtBQXhCLEVBQTVCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O2dDQUthaWYsTSxFQUFRO0FBQUEsVUFDWDFhLE1BRFcsR0FDQSxLQUFLYixPQURMLENBQ1hhLE1BRFc7O0FBRW5CLFVBQU0yTCxtQkFBbUIzTCxPQUFPNEwsbUJBQVAsRUFBekI7O0FBRUEsVUFBTThsRCxrQkFBa0IsS0FBS0Qsb0JBQUwsQ0FBMEJoMkQsS0FBMUIsR0FDckIyTSxHQURxQixDQUNqQnNTLE1BRGlCLEVBRXJCK1YsS0FGcUIsQ0FFZixJQUFJaDZCLGdCQUFKLENBQVksQ0FBWixFQUFlLENBQWYsQ0FGZSxFQUVJa1YsZ0JBRkosQ0FBeEI7O0FBSUEsVUFBTTVELFdBQVcsS0FBS21nRCxVQUFMLENBQWdCN3RDLFdBQWhCLEdBQThCNWUsS0FBOUIsR0FDZDZlLFFBRGMsQ0FDTDNPLGdCQURLLENBQWpCOztBQUdBLFVBQU1vVSxTQUFTMnhDLGdCQUNaajJELEtBRFksR0FFWk8sUUFGWSxDQUVIK0wsUUFGRyxFQUdaVSxHQUhZLEdBSVpzYSxHQUpZLEVBQWY7QUFLQSxVQUFNRixpQkFBaUI5QyxTQUFTLENBQWhDOztBQUVBLFdBQUtobEIsUUFBTCxDQUFjO0FBQ1prMkQsc0JBQWNTLGVBREY7QUFFWlYsd0JBQWdCLElBQUl2NkQsZ0JBQUosQ0FDZHNwQixTQUFTLENBREssRUFFZEEsU0FBUyxDQUZLO0FBRkosT0FBZDtBQU9BLFdBQUttb0MsVUFBTCxDQUFnQjdvRCxHQUFoQixDQUFvQjtBQUNsQjBnQixnQkFBUUEsU0FBU3BVLGlCQUFpQmxQLEdBQWpCLEVBREM7QUFFbEJvbUIsd0JBQWdCQSxpQkFBaUJsWCxpQkFBaUJsUCxHQUFqQjtBQUZmLE9BQXBCOztBQUtBdUQsYUFBT21MLE1BQVA7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7Ozs7b0NBS2lCO0FBQ2YsYUFBTztBQUNMOU4sZUFBTyxLQUFLNUQsS0FBTCxDQUFXdTNELGNBQVgsQ0FBMEI3MUQsQ0FENUI7QUFFTDZCLGdCQUFRLEtBQUt2RCxLQUFMLENBQVd1M0QsY0FBWCxDQUEwQjUxRCxDQUY3QjtBQUdMUyxjQUFNLEtBQUtwQyxLQUFMLENBQVdzM0QsWUFBWCxDQUF3QjUxRCxDQUh6QjtBQUlMVyxhQUFLLEtBQUtyQyxLQUFMLENBQVdzM0QsWUFBWCxDQUF3QjMxRCxDQUp4QjtBQUtMMDJELG9CQUFZLEtBQUtyNEQsS0FBTCxDQUFXdTNELGNBQVgsQ0FBMEI3MUQsQ0FBMUIsR0FBOEIsQ0FBQyxHQUx0QztBQU1MNDJELG1CQUFXLEtBQUt0NEQsS0FBTCxDQUFXdTNELGNBQVgsQ0FBMEI1MUQsQ0FBMUIsR0FBOEIsQ0FBQztBQU5yQyxPQUFQO0FBUUQ7O0FBRUQ7Ozs7Ozs7O29DQUtpQjtBQUNmLGFBQU87QUFDTFMsY0FBTSxLQUFLcEMsS0FBTCxDQUFXdzNELFlBQVgsQ0FBd0I5MUQsQ0FEekI7QUFFTFcsYUFBSyxLQUFLckMsS0FBTCxDQUFXdzNELFlBQVgsQ0FBd0I3MUQ7QUFGeEIsT0FBUDtBQUlEOztBQUVEOztBQUVBOzs7Ozs7OzRDQUl5QjtBQUFBLFVBQ2Y0RSxNQURlLEdBQ0osS0FBS2IsT0FERCxDQUNmYSxNQURlOzs7QUFHdkIsVUFBTTJMLG1CQUFtQjNMLE9BQU80TCxtQkFBUCxFQUF6QjtBQUNBLFVBQU03RCxXQUFXLEtBQUttZ0QsVUFBTCxDQUFnQjd0QyxXQUFoQixHQUE4QjVlLEtBQTlCLEdBQ2Q2ZSxRQURjLENBQ0wzTyxnQkFESyxDQUFqQjs7QUFHQSxVQUFNb1UsU0FBUyxLQUFLbW9DLFVBQUwsQ0FBZ0J3SyxTQUFoQixLQUE4Qi9tRCxpQkFBaUJsUCxHQUFqQixFQUE3QztBQUNBLFVBQU1rMkQsV0FBVzV5QyxTQUFTLENBQTFCO0FBQ0EsVUFBTXN5QyxXQUFXLElBQUk1N0QsZ0JBQUosQ0FBWWs4RCxRQUFaLEVBQXNCQSxRQUF0QixDQUFqQjs7QUFFQSxVQUFJbHZCLFdBQVc7QUFDYnV0Qix3QkFBZ0JxQixRQURIO0FBRWJ0QixzQkFBY2hwRDtBQUZELE9BQWY7O0FBS0EsVUFBSSxDQUFDLEtBQUswcUQsb0JBQVYsRUFBZ0M7QUFDOUJodkIsaUJBQVN3dEIsWUFBVCxHQUF3QmxwRCxTQUFTdE0sS0FBVCxHQUNyQjJNLEdBRHFCLENBQ2pCMlgsTUFEaUIsRUFDVCxDQURTLENBQXhCO0FBRUQ7O0FBRUQsV0FBS2hsQixRQUFMLENBQWMwb0MsUUFBZDtBQUNEOztBQUVEOzs7Ozs7Ozt5Q0FLc0I7QUFBQSxVQUNaempDLE1BRFksR0FDRCxLQUFLYixPQURKLENBQ1phLE1BRFk7O0FBQUEsa0NBRVlBLE9BQU9neUIsTUFBUCxHQUFnQmhCLFNBQWhCLEdBQTRCQyxTQUE1QixFQUZaO0FBQUEsVUFFWjkxQixDQUZZLHlCQUVaQSxDQUZZO0FBQUEsVUFFVEMsQ0FGUyx5QkFFVEEsQ0FGUztBQUFBLFVBRU5pQyxLQUZNLHlCQUVOQSxLQUZNO0FBQUEsVUFFQ0wsTUFGRCx5QkFFQ0EsTUFGRDs7QUFHcEIsYUFBTztBQUNMbkIsY0FBTVYsQ0FERDtBQUVMVyxhQUFLVixDQUZBO0FBR0xpQyxvQkFISztBQUlMTDtBQUpLLE9BQVA7QUFNRDs7QUFFRDs7Ozs7OztvQ0FJaUI7QUFDZixhQUFRO0FBQUE7QUFBQSxVQUFLLEtBQUkscUNBQVQsRUFBK0MsS0FBSSxXQUFuRCxFQUErRCxPQUFPLEtBQUs4TyxrQkFBTCxFQUF0RTtBQUNOO0FBQUE7QUFBQSxZQUFLLEtBQUksOEJBQVQ7QUFDRTtBQUFDLHdDQUFEO0FBQUE7QUFDRSx1QkFBUyxLQUFLNmhELGtCQURoQjtBQUVFLHNCQUFRLEtBQUtDLGFBRmY7QUFHRSxxREFBSyxLQUFJLFFBQVQsRUFBa0IsT0FBTyxLQUFLNEUsYUFBTCxFQUF6QjtBQUhGLFdBREY7QUFNRTtBQUFDLHdDQUFEO0FBQUE7QUFDRSx1QkFBUyxLQUFLdnBELGdCQURoQjtBQUVFLHNCQUFRLEtBQUtDLFdBRmY7QUFHRSxxREFBSyxLQUFJLGdCQUFULEVBQTBCLE9BQU8sS0FBS0UsYUFBTCxFQUFqQztBQUhGO0FBTkY7QUFETSxPQUFSO0FBY0Q7Ozs7RUE3UDZEekcsaUM7O2tCQUEzQ2t1RCxrQzs7O0FBZ1FyQkEsbUNBQW1DbHlELFlBQW5DLEdBQWtEZ0Usa0NBQXdCaEUsWUFBMUUsQzs7Ozs7Ozs7Ozs7Ozs7O0FDclFBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFsQkE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7NEJBa0J1Q3BJLGFBQUkrUyxVQUFKLENBQWVDLGU7SUFBOUNDLGEseUJBQUFBLGE7SUFBZUUsVyx5QkFBQUEsVzs7QUFFdkI7Ozs7Ozs7SUFNTWtwRCxlOzs7Ozs7Ozs7Ozs7QUFDSjs7Ozs7OzZCQU1pQjtBQUFBLFVBQ1A1eUQsTUFETyxHQUNJLEtBQUtiLE9BRFQsQ0FDUGEsTUFETzs7QUFFZixVQUFNa0ssWUFBWSxLQUFLM0csY0FBTCxDQUFvQixXQUFwQixDQUFsQjs7QUFFQSxVQUFJLENBQUMsS0FBS0EsY0FBTCxDQUFvQixhQUFwQixDQUFMLEVBQXlDO0FBQ3ZDdkQsZUFBT2lyQixPQUFQLENBQWU3aUIsR0FBZixDQUNFOEIsU0FERixFQUVFLEtBQUszRyxjQUFMLENBQW9CLGdCQUFwQixDQUZGLEVBR0UsS0FBS0EsY0FBTCxDQUFvQix3QkFBcEIsQ0FIRjtBQUtEOztBQUVEdkQsYUFBT29yQixJQUFQLENBQVlrcUIsT0FBWjtBQUNBdDFDLGFBQU95ckIsUUFBUCxDQUFnQisvQixNQUFoQixDQUF1QixNQUF2QixFQUErQixNQUEvQjtBQUNBeHJELGFBQU9tTCxNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7NEJBT2dCd0IsVyxFQUFhO0FBQUEsVUFDbkIzTSxNQURtQixHQUNSLEtBQUtiLE9BREcsQ0FDbkJhLE1BRG1COztBQUUzQixVQUFNeUsseUJBQXlCekssT0FBT29LLFVBQVAsQ0FBa0IrVSxNQUFsQixDQUF5QixRQUF6QixDQUEvQjtBQUNBLFVBQU1qVixZQUFZbEssT0FBT29LLFVBQVAsQ0FBa0JDLFdBQWxCLENBQThCLFFBQTlCLENBQWxCO0FBQ0EsVUFBTUMsVUFBVUosVUFBVVMsVUFBVixFQUFoQjtBQUNBLFVBQU1wRixXQUFXMkUsVUFBVTJvRCxnQkFBVixDQUEyQnJwRCxhQUEzQixDQUFqQjtBQUNBLFVBQU1rQixpQkFBaUJSLFVBQVVpckIsZ0JBQVYsRUFBdkI7O0FBRUFuMUIsYUFBT29yQixJQUFQLENBQVk0cEIsSUFBWjtBQUNBaDFDLGFBQU9vckIsSUFBUCxDQUFZL3JCLEdBQVosQ0FBZ0IsTUFBaEI7QUFDQVcsYUFBT3lyQixRQUFQLENBQWdCdytCLE9BQWhCLENBQXdCLE1BQXhCLEVBQWdDLE1BQWhDOztBQUVBLFdBQUt6L0MsY0FBTCxDQUFvQjtBQUNsQkMsc0RBRGtCLEVBQ01QLG9CQUROLEVBQ2lCSSxnQkFEakIsRUFDMEIvRSxrQkFEMUIsRUFDb0NtRjtBQURwQyxPQUFwQjtBQUdEOztBQUVEOzs7Ozs7Ozs7Ozs7b0NBU3dCM0MsUSxFQUFVL0gsTSxFQUFRO0FBQ3hDLFVBQUksQ0FBQ0EsT0FBT29LLFVBQVAsQ0FBa0IrVSxNQUFsQixDQUF5QixRQUF6QixDQUFMLEVBQXlDLE9BQU8sS0FBUDs7QUFFekMsVUFBTWpWLFlBQVlsSyxPQUFPb0ssVUFBUCxDQUFrQkMsV0FBbEIsQ0FBOEIsUUFBOUIsQ0FBbEI7QUFDQSxVQUFJQyxVQUFVSixVQUFVNG9ELG9CQUFWLENBQStCL3FELFFBQS9CLEVBQXlDL0gsT0FBTyt1QiwwQkFBUCxFQUF6QyxFQUNYcHBCLE1BRFcsQ0FDSixVQUFDSCxDQUFEO0FBQUEsZUFBTyxFQUFFQSxhQUFha0UsV0FBZixDQUFQO0FBQUEsT0FESSxDQUFkOztBQUdBLFVBQUlZLFFBQVF6RSxNQUFSLElBQWtCeUUsUUFBUSxDQUFSLGFBQXNCZCxhQUE1QyxFQUEyRDtBQUN6RCxlQUFPLEVBQUVsRyxnQkFBZ0JnSCxRQUFRLENBQVIsQ0FBbEIsRUFBUDtBQUNELE9BRkQsTUFFTztBQUNMLGVBQU8sS0FBUDtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7Z0NBT29CdEssTSxFQUFRO0FBQzFCLGFBQU9BLE9BQU95dUIsYUFBUCxDQUFxQixTQUFyQixLQUNMenVCLE9BQU8rbkQsYUFBUCxDQUFxQixTQUFyQixDQURGO0FBRUQ7Ozs7RUFqRjJCdHBCLGtCOztBQW9GOUI7Ozs7Ozs7QUFLQW0wQixnQkFBZ0IxeUQsaUJBQWhCLEdBQW9DNnlELGtDQUFwQzs7QUFFQTs7Ozs7O0FBTUFILGdCQUFnQnp5RCx1QkFBaEIsR0FBMEM2eUQsd0NBQTFDOztBQUVBOzs7OztBQUtBSixnQkFBZ0IzekQsVUFBaEIsR0FBNkIsU0FBN0I7O0FBRUE7Ozs7O0FBS0EyekQsZ0JBQWdCeHlELFFBQWhCLEdBQTJCLCtCQUEzQjs7QUFFQTs7Ozs7QUFLQXd5RCxnQkFBZ0J2eUQsV0FBaEIsR0FBOEIsMEJBQTlCOztBQUVBOzs7Ozs7OztBQVFBdXlELGdCQUFnQnR5RCxjQUFoQixHQUFpQztBQUMvQmtFLGNBQVksSUFEbUI7QUFFL0JDLHFCQUFtQixLQUZZO0FBRy9CZ0IscUJBQW1CLElBSFk7QUFJL0J3dEQsWUFBVSxLQUpxQjtBQUsvQm5FLGtCQUFnQixLQUxlO0FBTS9Cb0UsY0FBWSxJQU5tQjtBQU8vQkMsZ0JBQWMsRUFQaUI7QUFRL0JDLHlCQUF1QixDQVJRO0FBUy9CeGxDLHFCQUFtQjs7QUFHckI7Ozs7QUFaaUMsQ0FBakMsQ0FnQkFnbEMsZ0JBQWdCbkwsa0JBQWhCLEdBQXFDLENBQUMsUUFBRCxDQUFyQzs7QUFFQW1MLGdCQUFnQlMsZ0JBQWhCLEdBQW1DNTBCLG1CQUFTNDBCLGdCQUE1Qzs7a0JBRWVULGU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvSmY7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7K2VBdEJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFzQnFCVSxnQzs7O0FBQ25CLDhDQUFzQjtBQUFBOztBQUFBOztBQUFBLHNDQUFOejBELElBQU07QUFBTkEsVUFBTTtBQUFBOztBQUFBLCtMQUNYQSxJQURXOztBQUdwQixVQUFLckYsUUFBTCxDQUNFLHNCQURGLEVBRUUsc0JBRkYsRUFHRSxtQkFIRixFQUlFLHNCQUpGO0FBTUEsVUFBS3FRLE9BQUwsdUJBQ0d6UyxtQkFBVXNNLE1BQVYsQ0FBaUJtdUMsbUJBRHBCLEVBQzBDLE1BQUswaEIsb0JBRC9DOztBQUlBLFVBQUtyTCxVQUFMLEdBQWtCLE1BQUsza0QsY0FBTCxDQUFvQixXQUFwQixDQUFsQjtBQUNBLFVBQUtpd0QsUUFBTCxHQUFnQixNQUFLandELGNBQUwsQ0FBb0IsU0FBcEIsQ0FBaEI7QUFDQSxVQUFLa3dELFNBQUwsR0FBaUIsTUFBS2x3RCxjQUFMLENBQW9CLFVBQXBCLENBQWpCOztBQUVBLFVBQUttd0QsbUJBQUw7O0FBRUEsVUFBS2o2RCxLQUFMLEdBQWE7QUFDWGlNLGdCQUFVLE1BQUttYyxlQUFMLENBQXFCOHhDLFdBQXJCLENBQWlDLEtBQWpDO0FBREMsS0FBYjtBQW5Cb0I7QUFzQnJCOztBQUVEOztBQUVBOzs7Ozs7Ozs7eUNBS3NCQyxhLEVBQWU7QUFBQSxVQUMzQjFwRCxTQUQyQixHQUNKMHBELGFBREksQ0FDM0IxcEQsU0FEMkI7QUFBQSxVQUNoQnpLLE9BRGdCLEdBQ0ptMEQsYUFESSxDQUNoQm4wRCxPQURnQjs7QUFFbkMsVUFBSXlLLGNBQWMsS0FBSzNHLGNBQUwsQ0FBb0IsV0FBcEIsQ0FBbEIsRUFBb0Q7O0FBRmpCLFVBSTNCK0csT0FKMkIsR0FJZjdLLE9BSmUsQ0FJM0I2SyxPQUoyQjs7QUFLbkMsVUFBSUEsUUFBUXhSLE9BQVIsQ0FBZ0IsS0FBS3lLLGNBQUwsQ0FBb0IsZ0JBQXBCLENBQWhCLE1BQTJELENBQUMsQ0FBaEUsRUFBbUU7QUFDakU7QUFDQSxhQUFLaUgsY0FBTCxDQUFvQixFQUFFcXBELGFBQWEsSUFBZixFQUFwQixFQUEyQyxLQUEzQztBQUNBLGFBQUtoMkQsS0FBTCxDQUFXeUIsZ0JBQVgsQ0FBNEIsTUFBNUI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7OztzQ0FLbUJvRyxRLEVBQVU7QUFBQTs7QUFDM0IsV0FBSzNLLFFBQUwsQ0FBYyxFQUFFMkssVUFBVUEsUUFBWixFQUFkLEVBQXNDLFlBQU07QUFDMUMsZUFBS25JLElBQUwsQ0FBVWlxQixTQUFWLENBQW9CM3RCLE1BQXBCO0FBQ0QsT0FGRDtBQUdEOztBQUVEOztBQUVBOzs7Ozs7d0NBR3FCO0FBQ25COztBQUVBLFVBQUksS0FBS2dFLEtBQUwsQ0FBVzRCLE9BQVgsQ0FBbUJxMEQsZ0JBQXZCLEVBQXlDO0FBQ3ZDLGFBQUtDLHFCQUFMO0FBQ0Q7O0FBTGtCLFVBT1gvekQsTUFQVyxHQU9BLEtBQUtiLE9BUEwsQ0FPWGEsTUFQVzs7QUFRbkJBLGFBQU9vckIsSUFBUCxDQUFZL3JCLEdBQVosQ0FBZ0IsTUFBaEIsRUFBd0IsWUFBTTtBQUM1QlcsZUFBT3lyQixRQUFQLENBQWdCdytCLE9BQWhCLENBQXdCLE1BQXhCLEVBQWdDLE1BQWhDO0FBQ0QsT0FGRDtBQUdEOztBQUVEOztBQUVBOzs7Ozs7OzRDQUl5QjtBQUFBOztBQUN2QjtBQUNBLFVBQUlqUixlQUFlLElBQW5CO0FBQ0EsVUFBSWdiLGNBQWN4b0QsV0FBVyxZQUFNO0FBQ2pDd3RDLHVCQUFlNWdELHVCQUFhc3dCLFFBQWIsQ0FBc0J1d0IsY0FBdEIsQ0FBcUMsT0FBSzc4QixFQUFMLENBQVEsMkJBQVIsQ0FBckMsQ0FBZjtBQUNELE9BRmlCLEVBRWYsR0FGZSxDQUFsQjs7QUFJQTtBQUNBO0FBQ0EsVUFBTTYzQyxjQUFjLFNBQWRBLFdBQWMsR0FBTTtBQUN4QixZQUFJRCxXQUFKLEVBQWlCO0FBQ2Y3c0IsdUJBQWE2c0IsV0FBYjtBQUNBQSx3QkFBYyxJQUFkO0FBQ0Q7QUFDRCxZQUFJaGIsWUFBSixFQUFrQkEsYUFBYWh3QixLQUFiO0FBQ2xCLGVBQUtrckMsV0FBTCxHQUFtQixJQUFuQjtBQUNELE9BUEQ7O0FBU0EsV0FBS3J5QyxlQUFMLENBQ0dzeUMsWUFESCxDQUNnQixLQUFLdDJELEtBQUwsQ0FBVzRCLE9BQVgsQ0FBbUJxMEQsZ0JBRG5DLEVBRUc5dUQsSUFGSCxDQUVRLFVBQUNDLE1BQUQsRUFBWTtBQUNoQmd2RDtBQUNBLGVBQUt6d0QsV0FBTCxDQUFpQixZQUFNO0FBQ3JCLGlCQUFLakcsSUFBTCxDQUFVaXFCLFNBQVYsQ0FBb0IzdEIsTUFBcEI7QUFDRCxTQUZEO0FBR0QsT0FQSCxFQVFHc2pCLEtBUkgsQ0FRUyxVQUFDbmlCLENBQUQsRUFBTztBQUNaaTVEO0FBQ0EsWUFBTWpYLGFBQWE1a0QsdUJBQWFzd0IsUUFBYixDQUFzQk8sWUFBdEIsQ0FDakIsT0FBSzdNLEVBQUwsQ0FBUSwyQ0FBUixDQURpQixFQUVqQnBoQixFQUFFbXVCLE9BRmUsQ0FBbkI7QUFJQTZ6QixtQkFBV3JrRCxFQUFYLENBQWMsT0FBZCxFQUF1QixZQUFNO0FBQUUsaUJBQUtrRixLQUFMLENBQVdvL0MsTUFBWDtBQUFxQixTQUFwRDtBQUNELE9BZkg7QUFnQkQ7O0FBRUQ7O0FBRUE7Ozs7Ozs7MkNBSXdCO0FBQUE7O0FBQUEsVUFDZG1YLGNBRGMsR0FDSyxLQUFLMzZELEtBRFYsQ0FDZDI2RCxjQURjOztBQUV0QixVQUFNdGlELFFBQVEsSUFBSW5iLE9BQU9vYixLQUFYLEVBQWQ7QUFGc0IsVUFHZG5MLFNBSGMsR0FHQXd0RCxlQUFlMXRELE1BSGYsQ0FHZEUsU0FIYzs7QUFJdEJrTCxZQUFNNVYsZ0JBQU4sQ0FBdUIsTUFBdkIsRUFBK0IsWUFBTTtBQUNuQyxZQUFJLENBQUMsT0FBS3pDLEtBQUwsQ0FBVzQ2RCxjQUFaLElBQ0EsT0FBSzU2RCxLQUFMLENBQVcyNkQsY0FBWCxLQUE4QkEsY0FEbEMsRUFDa0Q7QUFDaEQ7QUFDRDs7QUFFRCxZQUFJLE9BQU94dEQsVUFBVXZKLEtBQWpCLEtBQTJCLFdBQTNCLElBQ0EsT0FBT3VKLFVBQVU1SixNQUFqQixLQUE0QixXQURoQyxFQUM2QztBQUMzQzhVLGdCQUFNelUsS0FBTixHQUFjdUosVUFBVXZKLEtBQXhCO0FBQ0F5VSxnQkFBTTlVLE1BQU4sR0FBZTRKLFVBQVU1SixNQUF6QjtBQUNEOztBQUVELFlBQU1nWCxTQUFTLE9BQUt6VyxJQUFMLENBQVUrMkQsYUFBekI7QUFDQXRnRCxlQUFPM1csS0FBUCxHQUFlMlcsT0FBT3haLFdBQXRCO0FBQ0F3WixlQUFPaFgsTUFBUCxHQUFnQmdYLE9BQU9uWixZQUF2Qjs7QUFFQSxZQUFNc0UsVUFBVTZVLE9BQU9sQixVQUFQLENBQWtCLElBQWxCLENBQWhCO0FBQ0EsWUFBTWtwQixRQUFRbG1DLEtBQUsyRyxHQUFMLENBQVN1WCxPQUFPM1csS0FBUCxHQUFleVUsTUFBTXpVLEtBQTlCLEVBQXFDMlcsT0FBT2hYLE1BQVAsR0FBZ0I4VSxNQUFNOVUsTUFBM0QsQ0FBZDtBQUNBLFlBQU11M0QsV0FBVyxJQUFJOTlELGdCQUFKLENBQVlxYixNQUFNelUsS0FBbEIsRUFBeUJ5VSxNQUFNOVUsTUFBL0IsRUFDZHNkLFFBRGMsQ0FDTDBoQixLQURLLENBQWpCO0FBRUEsWUFBTXc0QixlQUFlLElBQUkvOUQsZ0JBQUosQ0FBWXVkLE9BQU8zVyxLQUFuQixFQUEwQjJXLE9BQU9oWCxNQUFqQyxFQUNsQjZPLE1BRGtCLENBQ1gsQ0FEVyxFQUVsQjdQLFFBRmtCLENBRVR1NEQsU0FBUzk0RCxLQUFULEdBQWlCb1EsTUFBakIsQ0FBd0IsQ0FBeEIsQ0FGUyxDQUFyQjs7QUFJQTFNLGdCQUFRbTFCLFNBQVIsQ0FBa0J4aUIsS0FBbEIsRUFDRSxDQURGLEVBQ0ssQ0FETCxFQUVFQSxNQUFNelUsS0FGUixFQUVleVUsTUFBTTlVLE1BRnJCLEVBR0V3M0QsYUFBYXI1RCxDQUhmLEVBR2tCcTVELGFBQWFwNUQsQ0FIL0IsRUFJRW01RCxTQUFTcDVELENBSlgsRUFJY281RCxTQUFTbjVELENBSnZCO0FBS0QsT0E3QkQ7O0FBK0JBLFVBQU1xNUQsc0JBQXNCLEtBQUtoOEMsYUFBTCxDQUFtQjNVLHlCQUFlaWUsZ0JBQWYsQ0FBZ0NxeUMsY0FBaEMsRUFBZ0QsTUFBaEQsQ0FBbkIsQ0FBNUI7QUFDQXRpRCxZQUFNa0YsV0FBTixHQUFvQixLQUFLN1gsT0FBTCxDQUFhYSxNQUFiLENBQW9CeWlCLGNBQXBCLEVBQXBCO0FBQ0EzUSxZQUFNSSxHQUFOLEdBQVl1aUQsbUJBQVo7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7OzswQ0FJdUI7QUFDckIsV0FBSzV5QyxlQUFMLEdBQXVCLElBQUkvZCx3QkFBSixDQUFtQixLQUFLM0UsT0FBTCxDQUFhNEUsRUFBaEMsRUFBb0MsS0FBS2xHLEtBQUwsQ0FBVzRCLE9BQS9DLENBQXZCO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7O2lDQUtjekUsQyxFQUFHO0FBQ2YsV0FBS2dFLGtCQUFMLEdBQTBCLElBQTFCO0FBQ0EsV0FBS25CLEtBQUwsQ0FBV3lCLGdCQUFYLENBQTRCLE1BQTVCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O29DQUtpQnNHLE8sRUFBUztBQUFBOztBQUFBLFVBQ2hCZ0IsU0FEZ0IsR0FDRmhCLFFBQVFjLE1BRE4sQ0FDaEJFLFNBRGdCOztBQUV4QixVQUFNaEMsTUFBTWQseUJBQWVpZSxnQkFBZixDQUFnQ25jLE9BQWhDLEVBQXlDLE1BQXpDLENBQVo7QUFDQSxVQUFNNnVELHNCQUFzQixLQUFLaDhDLGFBQUwsQ0FBbUI3VCxHQUFuQixDQUE1QjtBQUNBLFVBQU1rTixRQUFRLElBQUluYixPQUFPb2IsS0FBWCxFQUFkOztBQUVBLFVBQUlpbkMscUJBQUo7QUFDQSxVQUFJZ2IsY0FBY3hvRCxXQUFXLFlBQU07QUFDakN3dEMsdUJBQWU1Z0QsdUJBQWFzd0IsUUFBYixDQUFzQnV3QixjQUF0QixDQUFxQyxPQUFLNzhCLEVBQUwsQ0FBUSwyQkFBUixDQUFyQyxDQUFmO0FBQ0QsT0FGaUIsRUFFZixHQUZlLENBQWxCOztBQUlBdEssWUFBTTVWLGdCQUFOLENBQXVCLE1BQXZCLEVBQStCLFlBQU07QUFDbkMsWUFBSTg4QyxZQUFKLEVBQWtCQSxhQUFhaHdCLEtBQWI7QUFDbEIsWUFBSWdyQyxXQUFKLEVBQWlCO0FBQ2Y3c0IsdUJBQWE2c0IsV0FBYjtBQUNBQSx3QkFBYyxJQUFkO0FBQ0Q7O0FBRUQsWUFBSSxPQUFPcHRELFVBQVV2SixLQUFqQixLQUEyQixXQUEzQixJQUNBLE9BQU91SixVQUFVNUosTUFBakIsS0FBNEIsV0FEaEMsRUFDNkM7QUFDM0M4VSxnQkFBTXpVLEtBQU4sR0FBY3VKLFVBQVV2SixLQUF4QjtBQUNBeVUsZ0JBQU05VSxNQUFOLEdBQWU0SixVQUFVNUosTUFBekI7QUFDRDs7QUFYa0MsWUFhM0JnRCxNQWIyQixHQWFoQixPQUFLYixPQWJXLENBYTNCYSxNQWIyQjs7O0FBZW5DLFlBQU1nOEIsUUFBUSxPQUFLMDRCLDZCQUFMLENBQW1DOXVELE9BQW5DLEVBQTRDa00sS0FBNUMsQ0FBZDtBQUNBLFlBQU03RixTQUFTLE9BQUtpOEMsVUFBTCxDQUFnQjFsQyxhQUFoQixDQUE4QjtBQUMzQ3ZqQixzQkFBWTJHLFFBQVEzRyxVQUR1QjtBQUUzQzZTLHNCQUYyQztBQUczQy9KLG9CQUFVLElBQUl0UixnQkFBSixDQUFZLEdBQVosRUFBaUIsR0FBakIsQ0FIaUM7QUFJM0NrbkIsc0JBQVksSUFBSWxuQixnQkFBSixDQUFZcWIsTUFBTXpVLEtBQWxCLEVBQXlCeVUsTUFBTTlVLE1BQS9CLEVBQXVDc2QsUUFBdkMsQ0FBZ0QwaEIsS0FBaEQsQ0FKK0I7QUFLM0NqZCxvQkFBVSxDQUxpQztBQU0zQzZPLDZCQUFtQixPQUFLL3ZCLEtBQUwsQ0FBVzRCLE9BQVgsQ0FBbUJtdUI7QUFOSyxTQUE5QixDQUFmO0FBUUEsZUFBS3M2QixVQUFMLENBQWdCeU0sU0FBaEIsQ0FBMEIxb0QsTUFBMUI7QUFDQSxlQUFLd25ELFNBQUwsQ0FBZS82RCxJQUFmLENBQW9CdVQsTUFBcEI7O0FBRUFqTSxlQUFPbUwsTUFBUCxDQUFjLFlBQU07QUFDbEI7QUFDQSxpQkFBS1gsY0FBTCxDQUFvQjtBQUNsQmxILDRCQUFnQjJJLE1BREU7QUFFbEIzQixxQkFBUyxPQUFLa3BELFFBRkk7QUFHbEJqdUQsc0JBQVUsT0FBS2t1RDtBQUhHLFdBQXBCO0FBS0QsU0FQRDtBQVFELE9BbkNEOztBQXFDQTNoRCxZQUFNNVYsZ0JBQU4sQ0FBdUIsT0FBdkIsRUFBZ0MsWUFBTTtBQUNwQyxZQUFJODhDLFlBQUosRUFBa0JBLGFBQWFod0IsS0FBYjtBQUNsQixZQUFJZ3JDLFdBQUosRUFBaUI7QUFDZjdzQix1QkFBYTZzQixXQUFiO0FBQ0FBLHdCQUFjLElBQWQ7QUFDRDs7QUFFRDU3RCwrQkFBYXN3QixRQUFiLENBQXNCTyxZQUF0QixDQUNFLE9BQUs3TSxFQUFMLENBQVEsa0NBQVIsQ0FERixFQUVFLE9BQUtBLEVBQUwsQ0FBUSxpQ0FBUixFQUEyQyxFQUFFeUIsTUFBTS9MLE1BQU1JLEdBQWQsRUFBM0MsQ0FGRjtBQUlELE9BWEQ7O0FBYUFKLFlBQU1rRixXQUFOLEdBQW9CLEtBQUs3WCxPQUFMLENBQWFhLE1BQWIsQ0FBb0J5aUIsY0FBcEIsRUFBcEI7QUFDQTNRLFlBQU1JLEdBQU4sR0FBWXVpRCxtQkFBWjtBQUNEOztBQUVEOzs7Ozs7Ozs7O2tEQU8rQjd1RCxPLEVBQVNrTSxLLEVBQU87QUFDN0MsVUFBTTVILFlBQVksS0FBSzNHLGNBQUwsQ0FBb0IsV0FBcEIsQ0FBbEI7QUFDQSxVQUFNOFosa0JBQWtCblQsVUFBVW9ULGtCQUFWLENBQTZCLEtBQTdCLENBQXhCO0FBQ0EsVUFBTW9wQyxrQkFBa0IsSUFBSWp3RCxnQkFBSixDQUFZcWIsTUFBTXpVLEtBQWxCLEVBQXlCeVUsTUFBTTlVLE1BQS9CLENBQXhCOztBQUVBLFVBQU00M0Qsb0JBQW9CeitELGtCQUFTMCtELGlCQUFULENBQTJCbk8sZUFBM0IsRUFBNENycEMsZ0JBQWdCNWhCLEtBQWhCLEdBQXdCNmUsUUFBeEIsQ0FBaUMsR0FBakMsQ0FBNUMsQ0FBMUI7QUFDQSxhQUFPczZDLGtCQUFrQno1RCxDQUFsQixHQUFzQnVyRCxnQkFBZ0J2ckQsQ0FBN0M7QUFDRDs7QUFFRDs7Ozs7Ozs7O3lDQU1zQjI1RCxXLEVBQWE5NUQsQyxFQUFHO0FBQUE7O0FBQ3BDLFdBQUtELFFBQUwsQ0FBYztBQUNaczVELHdCQUFnQixJQURKO0FBRVpELHdCQUFnQlUsV0FGSjtBQUdaQywrQkFBdUIvNUQsRUFBRWc2RDtBQUhiLE9BQWQsRUFJRyxZQUFNO0FBQ1AsZUFBS0Msb0JBQUw7QUFDQSxlQUFLQyxzQkFBTDtBQUNELE9BUEQ7QUFRRDs7QUFFRDs7Ozs7Ozs7NkNBSzBCO0FBQ3hCLFVBQU05dUIsS0FBSyxLQUFLM3NDLEtBQUwsQ0FBV3M3RCxxQkFBdEI7QUFDQSxVQUFNNXdDLFNBQVMsS0FBSzVtQixJQUFMLENBQVVDLElBQXpCO0FBQ0EsVUFBTTlCLGVBQWUwcUMsR0FBR3pxQyxxQkFBSCxFQUFyQjtBQUNBLFVBQU13NUQscUJBQXFCaHhDLE9BQU94b0IscUJBQVAsRUFBM0I7O0FBRUEsV0FBS1osUUFBTCxDQUFjO0FBQ1pxNkQseUJBQWlCMTVELGFBQWFHLElBQWIsR0FBb0JzNUQsbUJBQW1CdDVEO0FBRDVDLE9BQWQ7QUFHRDs7QUFFRDs7Ozs7OzsyQ0FJd0I7QUFDdEIsV0FBS2QsUUFBTCxDQUFjO0FBQ1pzNUQsd0JBQWdCLEtBREo7QUFFWkQsd0JBQWdCO0FBRkosT0FBZDtBQUlEOztBQUVEOztBQUVBOzs7Ozs7Ozt1Q0FLb0I7QUFBQTs7QUFBQSwyQkFDOEIsS0FBS3YyRCxLQUFMLENBQVc0QixPQUR6QztBQUFBLFVBQ1ZxMEQsZ0JBRFUsa0JBQ1ZBLGdCQURVO0FBQUEsVUFDUXJ2RCxpQkFEUixrQkFDUUEsaUJBRFI7O0FBRWxCLFVBQUlxdkQsb0JBQW9CcnZELGlCQUFwQixJQUF5QyxDQUFDLEtBQUt5dkQsV0FBbkQsRUFBZ0U7QUFDOUQ7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQsVUFBTTN1RCxXQUFXLEtBQUtzYyxlQUFMLENBQXFCd3pDLHNCQUFyQixDQUE0QyxLQUFLNTdELEtBQUwsQ0FBV2lNLFFBQVgsQ0FBb0J6RyxVQUFoRSxDQUFqQjtBQUNBLGFBQU9zRyxTQUFTUyxHQUFULENBQWEsVUFBQ0osT0FBRCxFQUFVMlcsQ0FBVixFQUFnQjtBQUFBLFlBQzFCOWMsT0FEMEIsR0FDZCxPQUFLNUIsS0FEUyxDQUMxQjRCLE9BRDBCOzs7QUFHbEMsWUFBTTYxRCxhQUFhNzFELFFBQVF3ekQsUUFBUixHQUNmO0FBQ0FzQyx3QkFBYyxPQUFLQyxvQkFBTCxDQUEwQjMrRCxJQUExQixDQUErQixNQUEvQixFQUFxQytPLE9BQXJDLENBRGQ7QUFFQTZ2RCx3QkFBYyxPQUFLQztBQUZuQixTQURlLEdBS2YsSUFMSjs7QUFPQSxlQUFRLGdDQUFDLDhCQUFEO0FBQ04sbUJBQVM5dkQsT0FESDtBQUVOLG1CQUFTLE9BQUsrdkQsZUFBTCxDQUFxQjkrRCxJQUFyQixDQUEwQixNQUExQixFQUFnQytPLE9BQWhDO0FBRkgsV0FHRjB2RCxVQUhFLEVBQVI7QUFJRCxPQWRNLENBQVA7QUFlRDs7QUFFRDs7Ozs7Ozs7cUNBS2tCO0FBQ2hCLFVBQU1qQixpQkFBaUIsS0FBS3gyRCxLQUFMLENBQVc0QixPQUFYLENBQW1Cd3pELFFBQW5CLElBQ3JCLEtBQUt4NUQsS0FBTCxDQUFXNDZELGNBRGI7O0FBR0EsVUFBTXQzRCxRQUFRO0FBQ1psQixjQUFNLEtBQUtwQyxLQUFMLENBQVcyN0Q7QUFETCxPQUFkOztBQUlBLGFBQU9mLGlCQUNGO0FBQUE7QUFBQSxVQUFLLEtBQUksZ0JBQVQ7QUFDRDtBQUFBO0FBQUEsWUFBSyxLQUFJLGdDQUFUO0FBQ0UsbUJBQU90M0QsS0FEVDtBQUVFLHNEQUFRLEtBQUksVUFBWixFQUF1QixLQUFJLGVBQTNCO0FBRkY7QUFEQyxPQURFLEdBT0gsSUFQSjtBQVFEOztBQUVEOzs7Ozs7Ozs4Q0FLMkI7QUFBQTs7QUFBQSw0QkFDdUIsS0FBS2MsS0FBTCxDQUFXNEIsT0FEbEM7QUFBQSxVQUNqQnEwRCxnQkFEaUIsbUJBQ2pCQSxnQkFEaUI7QUFBQSxVQUNDcnZELGlCQURELG1CQUNDQSxpQkFERDs7QUFFekIsVUFBSXF2RCxvQkFBb0JydkQsaUJBQXBCLElBQXlDLENBQUMsS0FBS3l2RCxXQUFuRCxFQUFnRTtBQUM5RDtBQUNBO0FBQ0E7QUFDRDs7QUFFRCxVQUFNMXZELGFBQWEsS0FBS3FkLGVBQUwsQ0FBcUI4c0MsYUFBckIsQ0FBbUMsSUFBbkMsQ0FBbkI7QUFDQSxVQUFNVSwwQkFDSixDQUFDLEtBQUt4eEQsS0FBTCxDQUFXNEIsT0FBWCxDQUFtQnF2RCxjQUFwQixJQUNBdHFELFdBQVdxQixNQUFYLEdBQW9CLENBRnRCO0FBR0EsVUFBSSxDQUFDd3BELHVCQUFMLEVBQThCO0FBQzVCLGVBQU8sSUFBUDtBQUNEOztBQUVELFVBQU1DLGdCQUFnQjlxRCxXQUFXd0IsR0FBWCxDQUFlLFVBQUNWLENBQUQsRUFBTztBQUMxQyxlQUFPO0FBQ0xyRyxzQkFBWXFHLEVBQUVyRyxVQURUO0FBRUxvL0IsZ0JBQU0vNEIsQ0FGRDtBQUdMdEQsaUJBQU8sT0FBS29hLEVBQUwsMEJBQStCOVcsRUFBRXJHLFVBQWpDLEtBQWtEcUcsRUFBRVMsV0FIdEQ7QUFJTHlTLGdCQUFNLE9BQUtDLGFBQUwsbUNBQW1EblQsRUFBRXJHLFVBQXJELFdBQXVFLElBQXZFO0FBSkQsU0FBUDtBQU1ELE9BUHFCLENBQXRCO0FBaEJ5QixVQXdCUDIyRCxlQXhCTyxHQXdCYSxLQUFLbjhELEtBeEJsQixDQXdCakJpTSxRQXhCaUI7O0FBeUJ6QixVQUFNbXdELHVCQUF1QjtBQUMzQjUyRCxvQkFBWTIyRCxnQkFBZ0IzMkQsVUFERDtBQUUzQm8vQixjQUFNdTNCLGVBRnFCO0FBRzNCNXpELGVBQU8sS0FBS29hLEVBQUwsMEJBQStCdzVDLGdCQUFnQjMyRCxVQUEvQyxLQUFnRTIyRCxnQkFBZ0I3dkQsV0FINUQ7QUFJM0J5UyxjQUFNLEtBQUtDLGFBQUwsbUNBQW1EbTlDLGdCQUFnQjMyRCxVQUFuRSxXQUFxRixJQUFyRjtBQUpxQixPQUE3Qjs7QUFPQSxhQUFRO0FBQUE7QUFBQSxVQUFLLEtBQUksMkJBQVQ7QUFDTix3Q0FBQyxtQ0FBRDtBQUNFLGlCQUFPcXdELGFBRFQ7QUFFRSx3QkFBY3VHLG9CQUZoQjtBQUdFLG9CQUFVLEtBQUtyRyxpQkFIakI7QUFETSxPQUFSO0FBTUQ7O0FBRUQ7Ozs7Ozs7cUNBSWtCO0FBQ2hCLFVBQU1sbEMsWUFBWSxLQUFLQyxnQkFBTCxFQUFsQjtBQUNBLFVBQU11ckMsVUFBVSxLQUFLQyxjQUFMLEVBQWhCO0FBQ0EsVUFBTXRHLG1CQUFtQixLQUFLQyx1QkFBTCxFQUF6Qjs7QUFFQSxhQUFPLENBQUNvRyxPQUFELEVBQ0xyRyxnQkFESyxFQUVKO0FBQUE7QUFBQSxVQUFLLEtBQUksZUFBVDtBQUNDO0FBQUMsc0NBQUQ7QUFBQSxZQUFvQixLQUFJLFdBQXhCO0FBQ0U7QUFBQTtBQUFBLGNBQUksS0FBSSxTQUFSO0FBQ0dubEM7QUFESDtBQURGO0FBREQsT0FGSSxDQUFQO0FBU0Q7Ozs7RUFoYjJEMXJCLDJCOztrQkFBekMwMEQsZ0M7OztBQW1ickJBLGlDQUFpQzMwRCxZQUFqQyxHQUFnREMsNEJBQWtCRCxZQUFsRSxDOzs7Ozs7Ozs7Ozs7Ozs7QUMzYkE7O0FBQ0E7Ozs7Ozs7Ozs7K2VBakJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFpQnFCMjBELGdDOzs7QUFDbkIsOENBQXNCO0FBQUE7O0FBQUE7O0FBQUEsc0NBQU56MEQsSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEsK0xBQ1hBLElBRFc7O0FBR3BCLFVBQUtwRixLQUFMLEdBQWE7QUFDWG1NLGVBQVMsTUFBSy9ILEtBQUwsQ0FBVytIO0FBRFQsS0FBYjtBQUhvQjtBQU1yQjs7QUFFRDs7Ozs7Ozt3Q0FHcUI7QUFDbkIsV0FBS293RCxjQUFMO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OENBSTJCeDdDLFMsRUFBVztBQUFBOztBQUNwQyxVQUFJLEtBQUszYyxLQUFMLENBQVcrSCxPQUFYLEtBQXVCNFUsVUFBVTVVLE9BQXJDLEVBQThDO0FBQzVDLGFBQUs3SyxRQUFMLENBQWMsRUFBRTZLLFNBQVM0VSxVQUFVNVUsT0FBckIsRUFBZCxFQUE4QyxZQUFNO0FBQ2xELGlCQUFLb3dELGNBQUw7QUFDRCxTQUZEO0FBR0Q7QUFDRjs7QUFFRDs7Ozs7OztxQ0FJa0I7QUFBQSxVQUNSaDJELE1BRFEsR0FDRyxLQUFLYixPQURSLENBQ1JhLE1BRFE7O0FBRWhCLFVBQU0reEIsTUFBTS94QixPQUFPZ3lCLE1BQVAsRUFBWjs7QUFGZ0IsVUFJUnBzQixPQUpRLEdBSUksS0FBSy9ILEtBSlQsQ0FJUitILE9BSlE7QUFBQSxVQU1SaUIsVUFOUSxHQU1PakIsUUFBUWMsTUFOZixDQU1SRyxVQU5ROztBQU9oQixVQUFNakMsTUFBTWQseUJBQWVpZSxnQkFBZixDQUFnQ25jLE9BQWhDLEVBQXlDLE9BQXpDLENBQVo7QUFDQSxVQUFNNnVELHNCQUFzQixLQUFLaDhDLGFBQUwsQ0FBbUI3VCxHQUFuQixDQUE1QjtBQUNBLFVBQU1vUCxTQUFTLEtBQUt6VyxJQUFMLGFBQW9CcUksUUFBUXFKLElBQTVCLENBQWY7O0FBRUEsVUFBTThlLGFBQWFnRSxJQUFJRSxhQUFKLEVBQW5CO0FBQ0FqZSxhQUFPM1csS0FBUCxHQUFlMlcsT0FBT3haLFdBQVAsR0FBcUJ1ekIsVUFBcEM7QUFDQS9aLGFBQU9oWCxNQUFQLEdBQWdCZ1gsT0FBT25aLFlBQVAsR0FBc0JrekIsVUFBdEM7O0FBRUEvWixhQUFPalgsS0FBUCxDQUFhTSxLQUFiLEdBQXdCMlcsT0FBT3haLFdBQS9CO0FBQ0F3WixhQUFPalgsS0FBUCxDQUFhQyxNQUFiLEdBQXlCZ1gsT0FBT25aLFlBQWhDOztBQUVBLFVBQU1zRSxVQUFVNlUsT0FBT2xCLFVBQVAsQ0FBa0IsSUFBbEIsQ0FBaEI7QUFDQSxVQUFNaEIsUUFBUSxJQUFJbmIsT0FBT29iLEtBQVgsRUFBZDtBQUNBRCxZQUFNNVYsZ0JBQU4sQ0FBdUIsTUFBdkIsRUFBK0IsWUFBTTtBQUNuQyxZQUFJLE9BQU8ySyxXQUFXeEosS0FBbEIsS0FBNEIsV0FBNUIsSUFDQSxPQUFPd0osV0FBVzdKLE1BQWxCLEtBQTZCLFdBRDdCLElBRUEsQ0FBQzVHLGVBQU00USxPQUFOLENBQWNDLFlBQWQsRUFGTCxFQUVtQztBQUNqQzZLLGdCQUFNelUsS0FBTixHQUFjd0osV0FBV3hKLEtBQXpCO0FBQ0F5VSxnQkFBTTlVLE1BQU4sR0FBZTZKLFdBQVc3SixNQUExQjtBQUNEOztBQUVELFlBQU1nL0IsUUFBUWxtQyxLQUFLMkcsR0FBTCxDQUFTdVgsT0FBTzNXLEtBQVAsR0FBZXlVLE1BQU16VSxLQUE5QixFQUFxQzJXLE9BQU9oWCxNQUFQLEdBQWdCOFUsTUFBTTlVLE1BQTNELENBQWQ7QUFDQSxZQUFNdTNELFdBQVcsSUFBSTk5RCxnQkFBSixDQUFZcWIsTUFBTXpVLEtBQWxCLEVBQXlCeVUsTUFBTTlVLE1BQS9CLEVBQ2RzZCxRQURjLENBQ0wwaEIsS0FESyxDQUFqQjtBQUVBLFlBQU13NEIsZUFBZSxJQUFJLzlELGdCQUFKLENBQVl1ZCxPQUFPM1csS0FBbkIsRUFBMEIyVyxPQUFPaFgsTUFBakMsRUFDbEI2TyxNQURrQixDQUNYLENBRFcsRUFFbEI3UCxRQUZrQixDQUVUdTRELFNBQVM5NEQsS0FBVCxHQUFpQm9RLE1BQWpCLENBQXdCLENBQXhCLENBRlMsQ0FBckI7O0FBSUExTSxnQkFBUW0xQixTQUFSLENBQWtCeGlCLEtBQWxCLEVBQ0UsQ0FERixFQUNLLENBREwsRUFFRUEsTUFBTXpVLEtBRlIsRUFFZXlVLE1BQU05VSxNQUZyQixFQUdFdzNELGFBQWFyNUQsQ0FIZixFQUdrQnE1RCxhQUFhcDVELENBSC9CLEVBSUVtNUQsU0FBU3A1RCxDQUpYLEVBSWNvNUQsU0FBU241RCxDQUp2QjtBQUtELE9BcEJEO0FBcUJBMFcsWUFBTWtGLFdBQU4sR0FBb0IsS0FBSzdYLE9BQUwsQ0FBYWEsTUFBYixDQUFvQnlpQixjQUFwQixFQUFwQjtBQUNBM1EsWUFBTUksR0FBTixHQUFZdWlELG1CQUFaO0FBQ0Q7O0FBRUQ7Ozs7Ozs7b0NBSWlCO0FBQ2YsYUFBUTtBQUFBO0FBQUE7QUFDTixlQUFJLDZCQURFO0FBRU4sZUFBSyxLQUFLNTJELEtBQUwsQ0FBVytILE9BQVgsQ0FBbUJxSixJQUZsQjtBQUdOLG1CQUFTLEtBQUtwUixLQUFMLENBQVdrTyxPQUhkO0FBSU4sd0JBQWMsS0FBS2xPLEtBQUwsQ0FBVzAzRCxZQUpuQjtBQUtOLHdCQUFjLEtBQUsxM0QsS0FBTCxDQUFXNDNELFlBTG5CO0FBTU4sb0RBQVEsS0FBSSxVQUFaLEVBQXVCLGlCQUFlLEtBQUs1M0QsS0FBTCxDQUFXK0gsT0FBWCxDQUFtQnFKLElBQXpEO0FBTk0sT0FBUjtBQVFEOzs7O0VBMUYyRC9YLHNCOztrQkFBekNvOEQsZ0M7Ozs7Ozs7Ozs7Ozs7OztBQ0pyQjs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQWpCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztJQWlCcUJOLDhCOzs7Ozs7Ozs7Ozs7QUFDbkI7Ozs7OzZDQUswQjtBQUN4QixVQUFJLENBQUMsS0FBS3p2RCxjQUFMLENBQW9CLGdCQUFwQixDQUFMLEVBQTRDOztBQUU1QyxhQUFRLGdDQUFDLHlDQUFEO0FBQ04sZ0JBQVEsS0FBSzB5RCxhQURQO0FBRU4sdUJBQWUsS0FBS0Msb0JBRmQ7QUFHTixrQkFBVSxLQUFLcHBELGVBSFQsR0FBUjtBQUlEOzs7O0VBYnlEbkQsd0M7O2tCQUF2Q3FwRCw4Qjs7O0FBZ0JyQkEsK0JBQStCcjBELFlBQS9CLEdBQThDZ0wseUNBQStCaEwsWUFBN0UsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuQkE7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFsQkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztJQWtCcUJ3TixpQjs7O0FBQ25CLCtCQUFzQjtBQUFBOztBQUFBOztBQUFBLHNDQUFOdE4sSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEsaUtBQ1hBLElBRFc7O0FBR3BCLFVBQUtyRixRQUFMLENBQ0UsZUFERixFQUVFLG9CQUZGLEVBR0UsbUJBSEYsRUFJRSxpQkFKRixFQUtFLHdCQUxGLEVBTUUsbUJBTkYsRUFPRSx1QkFQRixFQVFFLDBCQVJGLEVBU0UscUJBVEYsRUFVRSx5QkFWRixFQVdFLFNBWEY7O0FBY0EsVUFBS0MsS0FBTCxHQUFhO0FBQ1gwOEQsZ0JBQVUsS0FEQztBQUVYbitELFlBQU0sTUFBSzZGLEtBQUwsQ0FBV29PLE1BQVgsQ0FBa0JtcUQsT0FBbEI7QUFGSyxLQUFiO0FBakJvQjtBQXFCckI7O0FBRUQ7O0FBRUE7Ozs7Ozs7OzhDQUkyQjU3QyxTLEVBQVc7QUFDcEMsc0pBQWdDQSxTQUFoQztBQUNBLFVBQUlBLFVBQVV2TyxNQUFWLEtBQXFCLEtBQUtwTyxLQUFMLENBQVdvTyxNQUFwQyxFQUE0QztBQUMxQyxhQUFLMU8sSUFBTCxDQUFVODRELFFBQVYsQ0FBbUJDLElBQW5CO0FBQ0EsYUFBS3Y3RCxRQUFMLENBQWM7QUFDWi9DLGdCQUFNd2lCLFVBQVV2TyxNQUFWLENBQWlCbXFELE9BQWpCLEVBRE07QUFFWkQsb0JBQVU7QUFGRSxTQUFkO0FBSUQ7QUFDRjs7QUFFRDs7Ozs7Ozs7a0NBS2VuN0QsQyxFQUFHO0FBQUEsVUFDUmlSLE1BRFEsR0FDRyxLQUFLcE8sS0FEUixDQUNSb08sTUFEUTs7QUFFaEJBLGFBQU9zcUQsT0FBUCxDQUFldjdELEVBQUUrN0MsTUFBRixDQUFTcjFDLEtBQXhCO0FBQ0EsV0FBSzNHLFFBQUwsQ0FBYyxFQUFFL0MsTUFBTWdELEVBQUUrN0MsTUFBRixDQUFTcjFDLEtBQWpCLEVBQWQ7QUFDRDs7QUFFRDs7Ozs7Ozs7eUNBS3NCO0FBQ3BCLFdBQUs4MEQsYUFBTDtBQUNEOztBQUVEOzs7Ozs7b0NBR2lCO0FBQUE7O0FBQUEsVUFDUHZxRCxNQURPLEdBQ0ksS0FBS3BPLEtBRFQsQ0FDUG9PLE1BRE87QUFBQSxVQUVQak0sTUFGTyxHQUVJLEtBQUtiLE9BRlQsQ0FFUGEsTUFGTzs7O0FBSWZpTSxhQUFPd3FELFVBQVAsQ0FBa0IsS0FBbEI7O0FBRUEsVUFBSSxDQUFDeHFELE9BQU95cUQsT0FBWixFQUFxQjtBQUNuQnpxRCxlQUFPc3FELE9BQVAsQ0FBZSxFQUFmO0FBQ0EsYUFBS2g1RCxJQUFMLENBQVU4NEQsUUFBVixDQUFtQjMwRCxLQUFuQixHQUEyQixFQUEzQjtBQUNBdUssZUFBT3lxRCxPQUFQLEdBQWlCLElBQWpCO0FBQ0EsYUFBSzM3RCxRQUFMLENBQWMsRUFBRS9DLE1BQU0sRUFBUixFQUFkO0FBQ0Q7QUFDRCxXQUFLK0MsUUFBTCxDQUFjLEVBQUVvN0QsVUFBVSxJQUFaLEVBQWQsRUFBa0MsWUFBTTtBQUN0QyxlQUFLNTRELElBQUwsQ0FBVTg0RCxRQUFWLENBQW1CeGIsS0FBbkI7QUFDQSxlQUFLdDlDLElBQUwsQ0FBVTg0RCxRQUFWLENBQW1CNXdCLE1BQW5CO0FBQ0QsT0FIRDs7QUFLQXpsQyxhQUFPbUwsTUFBUDtBQUNEOztBQUVEOzs7Ozs7b0NBR2lCO0FBQUEsVUFDUGMsTUFETyxHQUNJLEtBQUtwTyxLQURULENBQ1BvTyxNQURPO0FBQUEsVUFFUGpNLE1BRk8sR0FFSSxLQUFLYixPQUZULENBRVBhLE1BRk87OztBQUlmaU0sYUFBT3dxRCxVQUFQLENBQWtCLElBQWxCO0FBQ0F6MkQsYUFBT21MLE1BQVA7QUFDQSxXQUFLcFEsUUFBTCxDQUFjLEVBQUVvN0QsVUFBVSxLQUFaLEVBQWQ7QUFDRDs7QUFFRDs7Ozs7Ozs7c0NBS21CbjdELEMsRUFBRztBQUNwQixXQUFLMjdELHFCQUFMLEdBQTZCdmdFLGVBQU1tRixnQkFBTixDQUF1QlAsQ0FBdkIsQ0FBN0I7QUFDQSxXQUFLNDdELFdBQUwsR0FBbUIsbUJBQW5CO0FBQ0Q7O0FBRUQ7Ozs7Ozs7c0NBSW1CO0FBQ2pCO0FBQ0EsVUFBSSxzQkFBUSxLQUFLQSxXQUFiLElBQTRCLEdBQWhDLEVBQXFDO0FBQ25DO0FBQ0EsWUFBSSxPQUFPLEtBQUtDLFVBQVosS0FBMkIsV0FBM0IsSUFDQSxzQkFBUSxLQUFLQSxVQUFiLElBQTJCLEdBRC9CLEVBQ29DO0FBQ2xDO0FBQ0EsZUFBS0Msa0JBQUw7QUFDRDtBQUNELGFBQUtELFVBQUwsR0FBa0IsbUJBQWxCO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQTs7Ozs7Ozs7OzZDQU0wQjl1RCxRLEVBQVUvTSxDLEVBQUc7QUFDckMsV0FBSys3RCxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsV0FBS3Y3RCxnQkFBTCxHQUF3QixLQUFLdzdELHdCQUFMLEVBQXhCOztBQUVBLFdBQUtuNUQsS0FBTCxDQUFXNGMsV0FBWCxJQUEwQixLQUFLNWMsS0FBTCxDQUFXNGMsV0FBWCxFQUExQjtBQUNEOztBQUVEOzs7Ozs7Ozs7d0NBTXFCQyxNLEVBQVExZixDLEVBQUc7QUFBQSxVQUN0QmlSLE1BRHNCLEdBQ1gsS0FBS3BPLEtBRE0sQ0FDdEJvTyxNQURzQjtBQUFBLFVBRXRCak0sTUFGc0IsR0FFWCxLQUFLYixPQUZNLENBRXRCYSxNQUZzQjs7O0FBSTlCLFVBQU1pM0QsaUJBQWlCLEtBQUtDLDBCQUFMLEVBQXZCO0FBQ0EsVUFBTXhGLGtCQUFrQixLQUFLbDJELGdCQUFMLENBQ3JCQyxLQURxQixHQUVyQjJNLEdBRnFCLENBRWpCc1MsTUFGaUIsQ0FBeEI7O0FBSUE7QUFDQSxVQUFNeThDLHlCQUF5QnpGLGdCQUM1QmoyRCxLQUQ0QixHQUU1Qk8sUUFGNEIsQ0FFbkJpN0QsY0FGbUIsQ0FBL0I7O0FBSUEsVUFBTUcsY0FBY25yRCxPQUFPMlIsYUFBUCxDQUFxQjVkLE9BQU9neUIsTUFBUCxFQUFyQixFQUFzQ2h5QixPQUFPNEwsbUJBQVAsRUFBdEMsQ0FBcEI7QUFDQSxVQUFNeXJELFVBQVV2aEUsS0FBSys3RCxLQUFMLENBQ2RzRix1QkFBdUIvN0QsQ0FBdkIsR0FBMkIsQ0FEYixFQUVkKzdELHVCQUF1Qmg4RCxDQUF2QixHQUEyQixDQUZiLElBR1pyRixLQUFLKzdELEtBQUwsQ0FBV3VGLFlBQVloOEQsQ0FBWixHQUFnQixDQUEzQixFQUE4Qmc4RCxZQUFZajhELENBQVosR0FBZ0IsQ0FBOUMsQ0FISjs7QUFLQThRLGFBQU91VCxXQUFQLENBQW1CNjNDLE9BQW5CO0FBQ0FyM0QsYUFBT21MLE1BQVA7QUFDQSxXQUFLM0gsV0FBTDtBQUNEOztBQUVEOzs7Ozs7Ozs0Q0FLeUJ4SSxDLEVBQUc7QUFDMUIsV0FBSzZDLEtBQUwsQ0FBV2dkLFVBQVgsSUFBeUIsS0FBS2hkLEtBQUwsQ0FBV2dkLFVBQVgsRUFBekI7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7Ozs7OzJDQU13QjlTLFEsRUFBVS9NLEMsRUFBRztBQUNuQyxXQUFLUSxnQkFBTCxHQUF3QixLQUFLODdELHNCQUFMLEVBQXhCOztBQUVBLFdBQUt6NUQsS0FBTCxDQUFXNGMsV0FBWCxJQUEwQixLQUFLNWMsS0FBTCxDQUFXNGMsV0FBWCxFQUExQjtBQUNEOztBQUVEOzs7Ozs7Ozs7c0NBTW1CQyxNLEVBQVExZixDLEVBQUc7QUFBQSxVQUNwQmlSLE1BRG9CLEdBQ1QsS0FBS3BPLEtBREksQ0FDcEJvTyxNQURvQjs7QUFFNUIsVUFBTXNyRCxlQUFldHJELE9BQU9xVCxXQUFQLEVBQXJCOztBQUY0QixVQUlwQnRmLE1BSm9CLEdBSVQsS0FBS2IsT0FKSSxDQUlwQmEsTUFKb0I7O0FBSzVCLFVBQU0yTCxtQkFBbUIzTCxPQUFPNEwsbUJBQVAsRUFBekI7O0FBRUEsVUFBTXc5QyxNQUFNdHpELEtBQUtzekQsR0FBTCxDQUFTbU8sWUFBVCxDQUFaO0FBQ0EsVUFBTWxPLE1BQU12ekQsS0FBS3V6RCxHQUFMLENBQVNrTyxZQUFULENBQVo7O0FBRUEsVUFBTTdGLGtCQUFrQixLQUFLbDJELGdCQUFMLENBQXNCQyxLQUF0QixHQUNyQjJNLEdBRHFCLENBQ2pCc1MsTUFEaUIsQ0FBeEI7QUFFQSxVQUFNM1MsV0FBVyxLQUFLbXZELDBCQUFMLEVBQWpCO0FBQ0EsVUFBTU0scUJBQXFCOUYsZ0JBQWdCajJELEtBQWhCLEdBQ3hCTyxRQUR3QixDQUNmK0wsUUFEZSxDQUEzQjs7QUFHQSxVQUFNMHZELGNBQWMzaEUsS0FBSzBHLEdBQUwsQ0FDbEIsQ0FBQ2c3RCxtQkFBbUJyOEQsQ0FBbkIsR0FBdUJpdUQsR0FBdkIsR0FBNkJvTyxtQkFBbUJwOEQsQ0FBbkIsR0FBdUJpdUQsR0FBckQsSUFBNEQxOUMsaUJBQWlCeFEsQ0FBN0UsR0FBaUYsQ0FEL0QsRUFFbEIsR0FGa0IsQ0FBcEI7QUFJQThRLGFBQU95ckQsV0FBUCxDQUFtQkQsV0FBbkI7QUFDQXozRCxhQUFPbUwsTUFBUDtBQUNEOztBQUVEOzs7Ozs7OzswQ0FLdUJuUSxDLEVBQUc7QUFDeEIsV0FBSzZDLEtBQUwsQ0FBV2dkLFVBQVgsSUFBeUIsS0FBS2hkLEtBQUwsQ0FBV2dkLFVBQVgsRUFBekI7QUFDRDs7QUFFRDs7Ozs7Ozs4QkFJVztBQUNULFdBQUs4OEMsYUFBTDtBQUNEOztBQUVEOztBQUVBOzs7Ozs7Ozs0Q0FLeUI7QUFDdkIsVUFBTTV2RCxXQUFXLEtBQUtpdkQsd0JBQUwsRUFBakI7QUFDQSxhQUFPO0FBQ0xuN0QsY0FBTWtNLFNBQVM1TSxDQURWO0FBRUxXLGFBQUtpTSxTQUFTM007QUFGVCxPQUFQO0FBSUQ7O0FBRUQ7Ozs7Ozs7OzBDQUt1QjtBQUNyQixVQUFNMk0sV0FBVyxLQUFLdXZELHNCQUFMLEVBQWpCO0FBQ0EsYUFBTztBQUNMejdELGNBQU1rTSxTQUFTNU0sQ0FEVjtBQUVMVyxhQUFLaU0sU0FBUzNNO0FBRlQsT0FBUDtBQUlEOztBQUVEOzs7Ozs7OztvQ0FLaUI7QUFBQSxVQUNQNEUsTUFETyxHQUNJLEtBQUtiLE9BRFQsQ0FDUGEsTUFETztBQUFBLFVBRVBpTSxNQUZPLEdBRUksS0FBS3BPLEtBRlQsQ0FFUG9PLE1BRk87O0FBR2YsVUFBTThsQixNQUFNL3hCLE9BQU9neUIsTUFBUCxFQUFaO0FBQ0EsVUFBTXJtQixtQkFBbUIzTCxPQUFPNEwsbUJBQVAsRUFBekI7QUFDQSxVQUFNN08sUUFBUWtQLE9BQU8yckQsV0FBUCxDQUFtQjdsQyxHQUFuQixFQUF3QnBtQixnQkFBeEIsQ0FBZDs7QUFFQSxVQUFNc3JELGlCQUFpQixLQUFLQywwQkFBTCxFQUF2QjtBQUNBLFVBQU1FLGNBQWNuckQsT0FBTzJSLGFBQVAsQ0FBcUJtVSxHQUFyQixFQUEwQnBtQixnQkFBMUIsQ0FBcEI7QUFDQTVPLFlBQU1DLE1BQU4sR0FBZWxILEtBQUsyRyxHQUFMLENBQVMyNkQsWUFBWWg4RCxDQUFyQixFQUF3QnVRLGlCQUFpQnZRLENBQWpCLEdBQXFCNjdELGVBQWU3N0QsQ0FBNUQsQ0FBZjtBQUNBLFVBQUksQ0FBQyxLQUFLM0IsS0FBTCxDQUFXMDhELFFBQWhCLEVBQTBCO0FBQ3hCcDVELGNBQU1tQixPQUFOLEdBQWdCLE1BQWhCO0FBQ0Q7QUFDRCxhQUFPbkIsS0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs2Q0FLMEI7QUFBQSxVQUNoQmlELE1BRGdCLEdBQ0wsS0FBS2IsT0FEQSxDQUNoQmEsTUFEZ0I7QUFBQSxVQUVoQmlNLE1BRmdCLEdBRUwsS0FBS3BPLEtBRkEsQ0FFaEJvTyxNQUZnQjs7O0FBSXhCLFVBQU1OLG1CQUFtQjNMLE9BQU80TCxtQkFBUCxFQUF6QjtBQUNBLFVBQU13ckQsY0FBY25yRCxPQUFPMlIsYUFBUCxDQUFxQjVkLE9BQU9neUIsTUFBUCxFQUFyQixFQUFzQ3JtQixnQkFBdEMsQ0FBcEI7O0FBRUEsVUFBTTVELFdBQVdrRSxPQUFPb08sV0FBUCxHQUNkNWUsS0FEYyxHQUVkNmUsUUFGYyxDQUVMM08sZ0JBRkssQ0FBakI7O0FBSUEsVUFBTStsQixVQUFVemxCLE9BQU9xVCxXQUFQLEtBQXVCLEdBQXZCLEdBQTZCeHBCLEtBQUtpK0IsRUFBbEQ7QUFDQSxVQUFNL04seUJBQXVCMEwsUUFBUWhwQixPQUFSLENBQWdCLENBQWhCLENBQXZCLFNBQU47QUFDQSxVQUFNbXZELGtCQUFrQixTQUF4Qjs7QUFFQSxVQUFNeDZELFFBQVErNUQsWUFBWWo4RCxDQUExQjtBQUNBLFVBQU02QixTQUFTbzZELFlBQVloOEQsQ0FBM0I7O0FBRUEsYUFBTztBQUNMaUMsZUFBT0EsS0FERjtBQUVMTCxnQkFBUUEsTUFGSDtBQUdMbkIsY0FBTWtNLFNBQVM1TSxDQUFULEdBQWFrQyxRQUFRLEdBSHRCO0FBSUx2QixhQUFLaU0sU0FBUzNNLENBQVQsR0FBYTRCLFNBQVMsR0FKdEI7QUFLTDgwRCxvQkFBWSxDQUxQO0FBTUxDLG1CQUFXLENBTk47QUFPTC9yQyxtQkFBV0EsU0FQTjtBQVFMZ3NDLHNCQUFjaHNDLFNBUlQ7QUFTTGlzQyxxQkFBYWpzQyxTQVRSO0FBVUxrc0MseUJBQWlCbHNDLFNBVlo7QUFXTDZ4Qyx5QkFBaUJBLGVBWFo7QUFZTEMsNEJBQW9CRCxlQVpmO0FBYUxFLDJCQUFtQkYsZUFiZDtBQWNMRywrQkFBdUJIO0FBZGxCLE9BQVA7QUFnQkQ7O0FBRUQ7O0FBRUE7Ozs7Ozs7OytDQUs0QjtBQUFBLFVBQ2xCNXJELE1BRGtCLEdBQ1AsS0FBS3BPLEtBREUsQ0FDbEJvTyxNQURrQjtBQUFBLFVBRWxCak0sTUFGa0IsR0FFUCxLQUFLYixPQUZFLENBRWxCYSxNQUZrQjs7O0FBSTFCLFVBQU1xcEQsTUFBTXZ6RCxLQUFLdXpELEdBQUwsQ0FBU3A5QyxPQUFPcVQsV0FBUCxFQUFULENBQVo7QUFDQSxVQUFNOHBDLE1BQU10ekQsS0FBS3N6RCxHQUFMLENBQVNuOUMsT0FBT3FULFdBQVAsRUFBVCxDQUFaOztBQUVBLFVBQU0zVCxtQkFBbUIzTCxPQUFPNEwsbUJBQVAsRUFBekI7QUFDQSxVQUFNd3JELGNBQWNuckQsT0FBTzJSLGFBQVAsQ0FBcUI1ZCxPQUFPZ3lCLE1BQVAsRUFBckIsRUFBc0NybUIsZ0JBQXRDLENBQXBCO0FBQ0EsVUFBTXNzRCxpQkFBaUJiLFlBQVkzN0QsS0FBWixHQUFvQm9RLE1BQXBCLENBQTJCLENBQTNCLENBQXZCOztBQUVBLFVBQU05RCxXQUFXa0UsT0FBT29PLFdBQVAsR0FDZDVlLEtBRGMsR0FFZDZlLFFBRmMsQ0FFTDNPLGdCQUZLLEVBR2R2RCxHQUhjLENBSWI2dkQsZUFBZTk4RCxDQUFmLEdBQW1CaXVELEdBQW5CLEdBQXlCNk8sZUFBZTc4RCxDQUFmLEdBQW1CaXVELEdBSi9CLEVBS2I0TyxlQUFlOThELENBQWYsR0FBbUJrdUQsR0FBbkIsR0FBeUI0TyxlQUFlNzhELENBQWYsR0FBbUJndUQsR0FML0IsQ0FBakI7QUFPQSxhQUFPcmhELFFBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7NkNBSzBCO0FBQUEsVUFDaEJrRSxNQURnQixHQUNMLEtBQUtwTyxLQURBLENBQ2hCb08sTUFEZ0I7QUFBQSxVQUVoQmpNLE1BRmdCLEdBRUwsS0FBS2IsT0FGQSxDQUVoQmEsTUFGZ0I7OztBQUl4QixVQUFNcXBELE1BQU12ekQsS0FBS3V6RCxHQUFMLENBQVNwOUMsT0FBT3FULFdBQVAsRUFBVCxDQUFaO0FBQ0EsVUFBTThwQyxNQUFNdHpELEtBQUtzekQsR0FBTCxDQUFTbjlDLE9BQU9xVCxXQUFQLEVBQVQsQ0FBWjs7QUFFQSxVQUFNM1QsbUJBQW1CM0wsT0FBTzRMLG1CQUFQLEVBQXpCO0FBQ0EsVUFBTXdyRCxjQUFjbnJELE9BQU8yUixhQUFQLENBQXFCNWQsT0FBT2d5QixNQUFQLEVBQXJCLEVBQXNDcm1CLGdCQUF0QyxDQUFwQjtBQUNBLFVBQU1zc0QsaUJBQWlCYixZQUFZMzdELEtBQVosR0FBb0JvUSxNQUFwQixDQUEyQixDQUEzQixDQUF2QjtBQUNBLFVBQU05RCxXQUFXa0UsT0FBT29PLFdBQVAsR0FDZDVlLEtBRGMsR0FFZDZlLFFBRmMsQ0FFTDNPLGdCQUZLLEVBR2R2RCxHQUhjLENBSWI2dkQsZUFBZTk4RCxDQUFmLEdBQW1CaXVELEdBQW5CLEdBQXlCNk8sZUFBZTc4RCxDQUFmLEdBQW1CaXVELEdBSi9CLEVBS2I0TyxlQUFlOThELENBQWYsR0FBbUJrdUQsR0FBbkIsR0FBeUI0TyxlQUFlNzhELENBQWYsR0FBbUJndUQsR0FML0IsQ0FBakI7QUFPQSxhQUFPcmhELFFBQVA7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7Ozs7bUNBS2dCO0FBQ2QsVUFBSW13RCxRQUFRLEVBQVo7QUFDQSxVQUFJLEtBQUtyNkQsS0FBTCxDQUFXdTBDLFFBQVgsSUFBdUIsQ0FBQyxLQUFLMzRDLEtBQUwsQ0FBVzA4RCxRQUF2QyxFQUFpRDtBQUMvQytCLGdCQUFRLENBQ0w7QUFBQyxzQ0FBRDtBQUFBO0FBQ0MscUJBQVMsS0FBS0Msd0JBRGY7QUFFQyxvQkFBUSxLQUFLQyxtQkFGZDtBQUdDLG9CQUFRLEtBQUtDLHVCQUhkO0FBSUM7QUFBQTtBQUFBLGNBQUssS0FBSSx5QkFBVCxFQUFtQyxPQUFPLEtBQUtDLHFCQUFMLEVBQTFDO0FBQ0UscURBQUssS0FBSSxpQkFBVCxFQUEyQixLQUFLLEtBQUs3L0MsYUFBTCxDQUFtQiwyQkFBbkIsRUFBZ0QsSUFBaEQsQ0FBaEM7QUFERjtBQUpELFNBREssRUFTTDtBQUFDLHNDQUFEO0FBQUE7QUFDQyxxQkFBUyxLQUFLOC9DLHNCQURmO0FBRUMsb0JBQVEsS0FBS0MsaUJBRmQ7QUFHQyxvQkFBUSxLQUFLQyxxQkFIZDtBQUlDO0FBQUE7QUFBQSxjQUFLLEtBQUkseUJBQVQsRUFBbUMsT0FBTyxLQUFLQyxtQkFBTCxFQUExQztBQUNFLHFEQUFLLEtBQUksUUFBVCxFQUFrQixLQUFLLEtBQUtqZ0QsYUFBTCxDQUFtQix1Q0FBbkIsRUFBNEQsSUFBNUQsQ0FBdkI7QUFERjtBQUpELFNBVEssQ0FBUjtBQWtCRDtBQUNELGFBQU95L0MsS0FBUDtBQUNEOztBQUVEOzs7Ozs7OztrQ0FLZTtBQUNiLFVBQU1TLHFCQUFxQixLQUFLQyxzQkFBTCxFQUEzQjtBQUNBLFVBQU1DLFdBQVk7QUFDaEIsYUFBSSxXQURZO0FBRWhCLGFBQUksVUFGWTtBQUdoQixlQUFPLEtBQUtDLGFBQUwsRUFIUztBQUloQixlQUFPLEtBQUtyL0QsS0FBTCxDQUFXekIsSUFKRjtBQUtoQixrQkFBVSxDQUFDLEtBQUt5QixLQUFMLENBQVcwOEQsUUFMTjtBQU1oQixnQkFBUSxLQUFLbGIsT0FORztBQU9oQixrQkFBVSxLQUFLOGQsYUFQQyxHQUFsQjs7QUFTQSxhQUFRO0FBQUE7QUFBQSxVQUFLLFdBQVUsUUFBZjtBQUNOO0FBQUE7QUFBQSxZQUFLLEtBQUksYUFBVCxFQUF1QixPQUFPSixrQkFBOUI7QUFDR0U7QUFESDtBQURNLE9BQVI7QUFLRDs7QUFFRDs7Ozs7Ozs7NkNBSzBCO0FBQ3hCLFVBQUlHLDRCQUE0QixFQUFoQztBQUNBLFVBQUksS0FBS243RCxLQUFMLENBQVd1MEMsUUFBZixFQUF5QjtBQUN2QjRtQixrQ0FBMEJ0Z0UsSUFBMUIsQ0FBK0IsYUFBL0I7QUFDRDtBQUNELFVBQUksS0FBS2UsS0FBTCxDQUFXMDhELFFBQWYsRUFBeUI7QUFDdkI2QyxrQ0FBMEJ0Z0UsSUFBMUIsQ0FBK0IsYUFBL0I7QUFDRDtBQUNEc2dFLGtDQUE0QkEsMEJBQTBCenVCLElBQTFCLENBQStCLEdBQS9CLENBQTVCO0FBQ0EsVUFBTTB1QixlQUFlLEtBQUtMLHNCQUFMLEVBQXJCOztBQUVBLGFBQVE7QUFBQTtBQUFBLFVBQUssV0FBVSxRQUFmO0FBQ047QUFBQyxzQ0FBRDtBQUFBO0FBQ0UscUJBQVMsS0FBS00sZ0JBRGhCO0FBRUUsb0JBQVEsS0FBS0MsZUFGZjtBQUdFLG9CQUFRLEtBQUtDLFdBSGY7QUFJRSxzQkFBVSxDQUFDLEtBQUt2N0QsS0FBTCxDQUFXdTBDLFFBQVosSUFBeUIsS0FBS3YwQyxLQUFMLENBQVd1MEMsUUFBWCxJQUF1QixLQUFLMzRDLEtBQUwsQ0FBVzA4RCxRQUp2RTtBQUtFLG1EQUFLLEtBQUksbUJBQVQ7QUFDRSwyQkFBZSxLQUFLVyxrQkFEdEI7QUFFRSwwQkFBYyxLQUFLdUMsaUJBRnJCO0FBR0Usd0JBQVksS0FBS0MsZUFIbkI7QUFJRSxtQkFBT0wsWUFKVDtBQUtFLHVCQUFXRCx5QkFMYjtBQUxGO0FBRE0sT0FBUjtBQWNEOztBQUVEOzs7Ozs7O29DQUlpQjtBQUNmLGFBQVE7QUFBQTtBQUFBLFVBQUssV0FBVSx5QkFBZjtBQUNOO0FBQUE7QUFBQSxZQUFLLEtBQUkscUJBQVQ7QUFDRyxlQUFLTyxXQUFMLEVBREg7QUFFRyxlQUFLQyxzQkFBTCxFQUZIO0FBR0csZUFBS0MsWUFBTDtBQUhIO0FBRE0sT0FBUjtBQU9EOzs7O0VBamU0Q3IvQyx1Qjs7a0JBQTFCak8saUI7OztBQW9lckJBLGtCQUFrQnhOLFlBQWxCLEdBQWlDeWIsd0JBQWN6YixZQUEvQyxDOzs7Ozs7Ozs7Ozs7Ozs7QUN4ZUE7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFsQkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztJQWtCcUJ5TixvQjs7O0FBQ25CLGtDQUFzQjtBQUFBOztBQUFBOztBQUFBLHNDQUFOdk4sSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEsdUtBQ1hBLElBRFc7O0FBR3BCLFVBQUtyRixRQUFMLENBQ0Usd0JBREYsRUFFRSxtQkFGRixFQUdFLHVCQUhGO0FBS0EsVUFBS2tnRSxHQUFMLEdBQVd2akUsa0JBQVNpaUQsT0FBVCxFQUFYO0FBUm9CO0FBU3JCOztBQUVEOztBQUVBOzs7Ozs7Ozs7OztxQ0FPa0J1aEIsSSxFQUFNNXhELFEsRUFBVS9NLEMsRUFBRztBQUFBLFVBQzNCaVIsTUFEMkIsR0FDaEIsS0FBS3BPLEtBRFcsQ0FDM0JvTyxNQUQyQjs7QUFFbkMsY0FBUTB0RCxJQUFSO0FBQ0UsYUFBSyxRQUFMO0FBQ0UsZUFBS24rRCxnQkFBTCxHQUF3QixLQUFLbytELDBCQUFMLEVBQXhCO0FBQ0E7QUFDRixhQUFLLEtBQUw7QUFDRSxlQUFLcCtELGdCQUFMLEdBQXdCLEtBQUtxK0QsdUJBQUwsRUFBeEI7QUFDQTtBQU5KOztBQVNBLFdBQUtDLGtCQUFMLEdBQTBCN3RELE9BQU8yUixhQUFQLEdBQXVCbmlCLEtBQXZCLEVBQTFCOztBQUVBLFdBQUtvQyxLQUFMLENBQVc0YyxXQUFYLElBQTBCLEtBQUs1YyxLQUFMLENBQVc0YyxXQUFYLEVBQTFCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Z0NBT2FrL0MsSSxFQUFNai9DLE0sRUFBUTFmLEMsRUFBRztBQUFBLFVBQ3BCaVIsTUFEb0IsR0FDVCxLQUFLcE8sS0FESSxDQUNwQm9PLE1BRG9CO0FBQUEsVUFFcEJqTSxNQUZvQixHQUVULEtBQUtiLE9BRkksQ0FFcEJhLE1BRm9COzs7QUFJNUIsVUFBTSs1RCxrQkFBa0IsS0FBSzdDLDBCQUFMLEVBQXhCO0FBQ0EsVUFBTXhGLGtCQUFrQixLQUFLbDJELGdCQUFMLENBQ3JCQyxLQURxQixHQUVyQjJNLEdBRnFCLENBRWpCc1MsTUFGaUIsQ0FBeEI7O0FBSUE7QUFDQSxVQUFNeThDLHlCQUF5QnpGLGdCQUM1QmoyRCxLQUQ0QixHQUU1Qk8sUUFGNEIsQ0FFbkIrOUQsZUFGbUIsQ0FBL0I7O0FBSUEsVUFBTUMsZ0NBQWdDLEtBQUt4K0QsZ0JBQUwsQ0FDbkNDLEtBRG1DLEdBRW5DTyxRQUZtQyxDQUUxQis5RCxlQUYwQixDQUF0Qzs7QUFJQSxVQUFJLEtBQUtsOEQsS0FBTCxDQUFXNEIsT0FBWCxDQUFtQnl6RCxVQUF2QixFQUFtQztBQUNqQyxZQUFNK0UsaUJBQWlCLEtBQUtnQyxxQkFBTCxHQUNwQnB1RCxNQURvQixDQUNiLENBRGEsRUFFcEJwRCxHQUZvQixFQUF2Qjs7QUFJQSxZQUFNeXhELDRCQUE0QixLQUFLMStELGdCQUFMLENBQy9CQyxLQUQrQixHQUUvQk8sUUFGK0IsQ0FFdEIrOUQsZUFGc0IsQ0FBbEM7O0FBSUEsWUFBSTFDLGdCQUFKOztBQUVBLGdCQUFRc0MsSUFBUjtBQUNFLGVBQUssUUFBTDtBQUNFdEMsc0JBQVV2aEUsS0FBSys3RCxLQUFMLENBQ1JzRix1QkFBdUIvN0QsQ0FEZixFQUVSKzdELHVCQUF1Qmg4RCxDQUZmLElBR05yRixLQUFLKzdELEtBQUwsQ0FBV29HLGVBQWU3OEQsQ0FBMUIsRUFBNkI2OEQsZUFBZTk4RCxDQUE1QyxDQUhKO0FBSUE7QUFDRixlQUFLLEtBQUw7QUFDRWs4RCxzQkFBVXZoRSxLQUFLKzdELEtBQUwsQ0FDUnNGLHVCQUF1Qi83RCxDQURmLEVBRVIrN0QsdUJBQXVCaDhELENBRmYsSUFHTnJGLEtBQUsrN0QsS0FBTCxDQUFXLENBQUNvRyxlQUFlNzhELENBQTNCLEVBQThCLENBQUM2OEQsZUFBZTk4RCxDQUE5QyxDQUhKO0FBSUE7QUFaSjs7QUFlQSxZQUFNZy9ELGdCQUFnQixLQUFLTCxrQkFBTCxDQUNuQnIrRCxLQURtQixHQUVuQjZlLFFBRm1CLENBR2xCNjhDLHVCQUF1QnAwQyxHQUF2QixLQUErQm0zQywwQkFBMEJuM0MsR0FBMUIsRUFIYixDQUF0Qjs7QUExQmlDLDZCQWdDZSxLQUFLbGxCLEtBQUwsQ0FBVzRCLE9BaEMxQjtBQUFBLFlBZ0N6QjB6RCxZQWhDeUIsa0JBZ0N6QkEsWUFoQ3lCO0FBQUEsWUFnQ1hDLHFCQWhDVyxrQkFnQ1hBLHFCQWhDVzs7QUFpQ2pDLFlBQU0xaEMsVUFBVTU3QixLQUFLeVMsS0FBTCxDQUFXOHVELFVBQVUsR0FBVixHQUFnQnZoRSxLQUFLaStCLEVBQWhDLENBQWhCO0FBQ0EsWUFBTXFtQyxXQUFXdGtFLEtBQUt5UyxLQUFMLENBQVdtcEIsVUFBVXloQyxZQUFyQixJQUFxQ0EsWUFBdEQ7QUFDQSxZQUFNa0gsWUFBWTNvQyxVQUFVMG9DLFFBQTVCO0FBQ0EsWUFBSXRrRSxLQUFLMlMsR0FBTCxDQUFTNHhELFNBQVQsSUFBc0JqSCxxQkFBMUIsRUFBaUQ7QUFDL0NpRSxvQkFBVStDLFdBQVd0a0UsS0FBS2krQixFQUFoQixHQUFxQixHQUEvQjtBQUNEOztBQUVEOW5CLGVBQU81TSxHQUFQLENBQVc7QUFDVHNlLHNCQUFZdzhDLGFBREg7QUFFVHA3QyxvQkFBVXM0QztBQUZELFNBQVg7QUFJRCxPQTVDRCxNQTRDTztBQUNMLFlBQU1qc0MsT0FBTyxLQUFLanNCLE9BQUwsQ0FBYWEsTUFBYixDQUFvQm9yQixJQUFwQixDQUF5QmhzQixHQUF6QixFQUFiO0FBQ0EsWUFBTTJmLFdBQVc5UyxPQUFPcVQsV0FBUCxFQUFqQjtBQUNBLFlBQU04cEMsTUFBTXR6RCxLQUFLc3pELEdBQUwsQ0FBU3JxQyxXQUFXLENBQUMsQ0FBckIsQ0FBWjtBQUNBLFlBQU1zcUMsTUFBTXZ6RCxLQUFLdXpELEdBQUwsQ0FBU3RxQyxXQUFXLENBQUMsQ0FBckIsQ0FBWjs7QUFFQSxZQUFNdTdDLHdCQUF3QixJQUFJN2pFLGdCQUFKLENBQzVCMGdFLHVCQUF1Qmg4RCxDQUF2QixHQUEyQml1RCxHQUEzQixHQUFpQytOLHVCQUF1Qi83RCxDQUF2QixHQUEyQml1RCxHQURoQyxFQUU1QjhOLHVCQUF1Qmg4RCxDQUF2QixHQUEyQmt1RCxHQUEzQixHQUFpQzhOLHVCQUF1Qi83RCxDQUF2QixHQUEyQmd1RCxHQUZoQyxDQUE5Qjs7QUFLQSxZQUFNbVIsZ0NBQWdDLElBQUk5akUsZ0JBQUosQ0FDcEN1akUsOEJBQThCNytELENBQTlCLEdBQWtDaXVELEdBQWxDLEdBQXdDNFEsOEJBQThCNStELENBQTlCLEdBQWtDaXVELEdBRHRDLEVBRXBDMlEsOEJBQThCNytELENBQTlCLEdBQWtDa3VELEdBQWxDLEdBQXdDMlEsOEJBQThCNStELENBQTlCLEdBQWtDZ3VELEdBRnRDLENBQXRDOztBQUtBLFlBQUlvUiw2QkFBSjs7QUFFQSxnQkFBUWIsSUFBUjtBQUNFLGVBQUssUUFBTDtBQUNFYSxtQ0FBdUJGLHNCQUFzQjcrRCxLQUF0QixHQUNwQk8sUUFEb0IsQ0FDWHUrRCw2QkFEVyxDQUF2QjtBQUVBO0FBQ0YsZUFBSyxLQUFMO0FBQ0VDLG1DQUF1QkQsOEJBQThCOStELEtBQTlCLEdBQ3BCTyxRQURvQixDQUNYcytELHFCQURXLENBQXZCO0FBRUE7QUFSSjs7QUFXQSxZQUFNSCxpQkFBZ0IsS0FBS0wsa0JBQUwsQ0FBd0JyK0QsS0FBeEIsR0FDbkIyTSxHQURtQixDQUNmb3lELHFCQUFxQi8rRCxLQUFyQixHQUE2Qm9RLE1BQTdCLENBQW9DdWYsSUFBcEMsRUFBMEM5USxRQUExQyxDQUFtRCxDQUFuRCxDQURlLENBQXRCOztBQUdBck8sZUFBTzVNLEdBQVAsQ0FBVztBQUNUc2Usc0JBQVl3OEM7QUFESCxTQUFYO0FBR0Q7QUFDRG42RCxhQUFPbUwsTUFBUDtBQUNEOztBQUVEOzs7Ozs7O3NDQUltQjtBQUNqQixXQUFLdE4sS0FBTCxDQUFXZ2QsVUFBWCxJQUF5QixLQUFLaGQsS0FBTCxDQUFXZ2QsVUFBWCxFQUF6QjtBQUNEOztBQUVEOzs7Ozs7Ozs7MkNBTXdCOVMsUSxFQUFVL00sQyxFQUFHO0FBQ25DLFdBQUtRLGdCQUFMLEdBQXdCLEtBQUtpL0Qsc0JBQUwsRUFBeEI7QUFDQSxXQUFLNThELEtBQUwsQ0FBVzRjLFdBQVgsSUFBMEIsS0FBSzVjLEtBQUwsQ0FBVzRjLFdBQVgsRUFBMUI7QUFDRDs7QUFFRDs7Ozs7Ozs0Q0FJeUI7QUFDdkIsV0FBSzVjLEtBQUwsQ0FBV2dkLFVBQVgsSUFBeUIsS0FBS2hkLEtBQUwsQ0FBV2dkLFVBQVgsRUFBekI7QUFDRDs7QUFFRDs7Ozs7Ozs7O3NDQU1tQkgsTSxFQUFRMWYsQyxFQUFHO0FBQUEsVUFDcEJpUixNQURvQixHQUNULEtBQUtwTyxLQURJLENBQ3BCb08sTUFEb0I7QUFBQSxVQUVwQmpNLE1BRm9CLEdBRVQsS0FBS2IsT0FGSSxDQUVwQmEsTUFGb0I7O0FBRzVCLFVBQU0rNUQsa0JBQWtCLEtBQUs3QywwQkFBTCxFQUF4QjtBQUNBLFVBQU14RixrQkFBa0IsS0FBS2wyRCxnQkFBTCxDQUNyQkMsS0FEcUIsR0FFckIyTSxHQUZxQixDQUVqQnNTLE1BRmlCLENBQXhCOztBQUlBLFVBQU11OUMsaUJBQWlCLEtBQUtnQyxxQkFBTCxHQUNwQnB1RCxNQURvQixDQUNiLENBRGEsQ0FBdkI7O0FBR0E7QUFDQSxVQUFNc3JELHlCQUF5QnpGLGdCQUM1QmoyRCxLQUQ0QixHQUU1Qk8sUUFGNEIsQ0FFbkIrOUQsZUFGbUIsQ0FBL0I7O0FBSUEsVUFBSTFDLGdCQUFKO0FBQ0FBLGdCQUFVdmhFLEtBQUsrN0QsS0FBTCxDQUNSc0YsdUJBQXVCLzdELENBRGYsRUFFUis3RCx1QkFBdUJoOEQsQ0FGZixJQUdOckYsS0FBSys3RCxLQUFMLENBQVcsQ0FBQ29HLGVBQWU3OEQsQ0FBM0IsRUFBOEI2OEQsZUFBZTk4RCxDQUE3QyxDQUhKOztBQUtBOFEsYUFBTzVNLEdBQVAsQ0FBVztBQUNUMGYsa0JBQVVzNEM7QUFERCxPQUFYOztBQUlBcjNELGFBQU9tTCxNQUFQO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7OzhDQUsyQjtBQUN6QixVQUFNOGxELGVBQWUsS0FBSzJJLDBCQUFMLEVBQXJCOztBQUVBLGFBQU87QUFDTC85RCxjQUFNbzFELGFBQWE5MUQsQ0FEZDtBQUVMVyxhQUFLbTFELGFBQWE3MUQ7QUFGYixPQUFQO0FBSUQ7O0FBRUQ7Ozs7Ozs7OzJDQUt3QjtBQUN0QixVQUFNNjFELGVBQWUsS0FBSzRJLHVCQUFMLEVBQXJCOztBQUVBLGFBQU87QUFDTGgrRCxjQUFNbzFELGFBQWE5MUQsQ0FEZDtBQUVMVyxhQUFLbTFELGFBQWE3MUQ7QUFGYixPQUFQO0FBSUQ7O0FBRUQ7Ozs7Ozs7OzBDQUt1QjtBQUNyQixVQUFNNjFELGVBQWUsS0FBS3dKLHNCQUFMLEVBQXJCOztBQUVBLGFBQU87QUFDTDUrRCxjQUFNbzFELGFBQWE5MUQsQ0FEZDtBQUVMVyxhQUFLbTFELGFBQWE3MUQ7QUFGYixPQUFQO0FBSUQ7O0FBRUQ7Ozs7Ozs7O3VDQUtvQjtBQUFBLFVBQ1Y2USxNQURVLEdBQ0MsS0FBS3BPLEtBRE4sQ0FDVm9PLE1BRFU7OztBQUdsQixVQUFNeXVELHNCQUFzQixLQUFLVCxxQkFBTCxHQUN6Qnh4RCxHQUR5QixFQUE1QjtBQUVBLFVBQU13dUQsaUJBQWlCLEtBQUtDLDBCQUFMLEdBQ3BCbDdELFFBRG9CLENBQ1gwK0Qsb0JBQW9Cai9ELEtBQXBCLEdBQTRCb1EsTUFBNUIsQ0FBbUMsQ0FBbkMsQ0FEVyxDQUF2Qjs7QUFHQSxVQUFNNmxCLFVBQVV6bEIsT0FBT3FULFdBQVAsS0FBdUIsR0FBdkIsR0FBNkJ4cEIsS0FBS2krQixFQUFsRDtBQUNBLFVBQUkvTix3QkFBc0IwTCxRQUFRaHBCLE9BQVIsQ0FBZ0IsQ0FBaEIsQ0FBdEIsU0FBSjs7QUFFQSxVQUFNaXlELG1CQUFtQjF1RCxPQUFPMlIsYUFBUCxFQUF6Qjs7QUFFQSxVQUFJcUIsaUJBQWlCaFQsT0FBT2YsaUJBQVAsRUFBckI7QUFDQSxVQUFJeXZELGlCQUFpQnYvRCxDQUFqQixHQUFxQixDQUF6QixFQUE0QjZqQixpQkFBaUIsQ0FBQ0EsY0FBbEI7QUFDNUIsVUFBSUEsY0FBSixFQUFvQjtBQUNsQitHLHFCQUFhLGFBQWI7QUFDRDs7QUFFRCxVQUFJaEgsbUJBQW1CL1MsT0FBT2pCLG1CQUFQLEVBQXZCO0FBQ0EsVUFBSTJ2RCxpQkFBaUJ4L0QsQ0FBakIsR0FBcUIsQ0FBekIsRUFBNEI2akIsbUJBQW1CLENBQUNBLGdCQUFwQjtBQUM1QixVQUFJQSxnQkFBSixFQUFzQjtBQUNwQmdILHFCQUFhLGFBQWI7QUFDRDs7QUFFRCxhQUFPO0FBQ0xscUIsYUFBS203RCxlQUFlNzdELENBRGY7QUFFTFMsY0FBTW83RCxlQUFlOTdELENBRmhCO0FBR0xrQyxlQUFPcTlELG9CQUFvQnYvRCxDQUh0QjtBQUlMNkIsZ0JBQVEwOUQsb0JBQW9CdC9ELENBSnZCO0FBS0w4MkQseUJBQWlCbHNDLFNBTFo7QUFNTGlzQyxxQkFBYWpzQyxTQU5SO0FBT0xnc0Msc0JBQWNoc0MsU0FQVDtBQVFMNDBDLG9CQUFZNTBDO0FBUlAsT0FBUDtBQVVEOztBQUVEOztBQUVBOzs7Ozs7Ozs7NENBTXlCO0FBQUEsVUFDZi9aLE1BRGUsR0FDSixLQUFLcE8sS0FERCxDQUNmb08sTUFEZTtBQUFBLFVBRWZqTSxNQUZlLEdBRUosS0FBS2IsT0FGRCxDQUVmYSxNQUZlOzs7QUFJdkIsYUFBT2lNLE9BQU8yUixhQUFQLEdBQ0puaUIsS0FESSxHQUVKNmUsUUFGSSxDQUVLdGEsT0FBT29yQixJQUFQLENBQVloc0IsR0FBWixFQUZMLENBQVA7QUFHRDs7QUFFRDs7Ozs7Ozs7NkNBSzBCO0FBQUEsVUFDaEI2TSxNQURnQixHQUNMLEtBQUtwTyxLQURBLENBQ2hCb08sTUFEZ0I7O0FBRXhCLFVBQU04dEQsa0JBQWtCLEtBQUs3QywwQkFBTCxFQUF4QjtBQUNBLFVBQU0yRCxrQkFBa0I1dUQsT0FBT3FULFdBQVAsRUFBeEI7O0FBRUE7QUFDQSxVQUFNK3BDLE1BQU12ekQsS0FBS3V6RCxHQUFMLENBQVN3UixtQkFBbUIsQ0FBNUIsQ0FBWjtBQUNBLFVBQU16UixNQUFNdHpELEtBQUtzekQsR0FBTCxDQUFTeVIsbUJBQW1CLENBQTVCLENBQVo7O0FBRUE7QUFDQSxVQUFNNUMsaUJBQWlCLEtBQUtnQyxxQkFBTCxHQUNwQnB1RCxNQURvQixDQUNiLENBRGEsQ0FBdkI7O0FBR0E7QUFDQSxhQUFPa3VELGdCQUFnQnQrRCxLQUFoQixHQUNKMk0sR0FESSxDQUVINnZELGVBQWU5OEQsQ0FBZixHQUFtQml1RCxHQUFuQixHQUF5QjZPLGVBQWU3OEQsQ0FBZixHQUFtQml1RCxHQUZ6QyxFQUdINE8sZUFBZTk4RCxDQUFmLEdBQW1Ca3VELEdBQW5CLEdBQXlCNE8sZUFBZTc4RCxDQUFmLEdBQW1CZ3VELEdBSHpDLENBQVA7QUFLRDs7QUFFRDs7Ozs7Ozs7aURBSzhCO0FBQUEsVUFDcEJuOUMsTUFEb0IsR0FDVCxLQUFLcE8sS0FESSxDQUNwQm9PLE1BRG9COztBQUU1QixVQUFNOHRELGtCQUFrQixLQUFLN0MsMEJBQUwsRUFBeEI7QUFDQSxVQUFNMkQsa0JBQWtCNXVELE9BQU9xVCxXQUFQLEVBQXhCOztBQUVBO0FBQ0EsVUFBTStwQyxNQUFNdnpELEtBQUt1ekQsR0FBTCxDQUFTd1IsbUJBQW1CLENBQTVCLENBQVo7QUFDQSxVQUFNelIsTUFBTXR6RCxLQUFLc3pELEdBQUwsQ0FBU3lSLG1CQUFtQixDQUE1QixDQUFaOztBQUVBO0FBQ0EsVUFBTTVDLGlCQUFpQixLQUFLZ0MscUJBQUwsR0FDcEJwdUQsTUFEb0IsQ0FDYixDQURhLENBQXZCOztBQUdBO0FBQ0EsYUFBT2t1RCxnQkFBZ0J0K0QsS0FBaEIsR0FDSjJNLEdBREksQ0FFSDZ2RCxlQUFlOThELENBQWYsR0FBbUJpdUQsR0FBbkIsR0FBeUI2TyxlQUFlNzhELENBQWYsR0FBbUJpdUQsR0FGekMsRUFHSDRPLGVBQWU5OEQsQ0FBZixHQUFtQmt1RCxHQUFuQixHQUF5QjRPLGVBQWU3OEQsQ0FBZixHQUFtQmd1RCxHQUh6QyxDQUFQO0FBS0Q7O0FBRUQ7Ozs7Ozs7OzhDQUsyQjtBQUFBLFVBQ2pCbjlDLE1BRGlCLEdBQ04sS0FBS3BPLEtBREMsQ0FDakJvTyxNQURpQjs7QUFFekIsVUFBTTh0RCxrQkFBa0IsS0FBSzdDLDBCQUFMLEVBQXhCO0FBQ0EsVUFBTTJELGtCQUFrQjV1RCxPQUFPcVQsV0FBUCxFQUF4Qjs7QUFFQTtBQUNBLFVBQU0rcEMsTUFBTXZ6RCxLQUFLdXpELEdBQUwsQ0FBU3dSLG1CQUFtQixDQUE1QixDQUFaO0FBQ0EsVUFBTXpSLE1BQU10ekQsS0FBS3N6RCxHQUFMLENBQVN5UixtQkFBbUIsQ0FBNUIsQ0FBWjs7QUFFQTtBQUNBLFVBQU01QyxpQkFBaUIsS0FBS2dDLHFCQUFMLENBQTJCaHVELE1BQTNCLEVBQ3BCSixNQURvQixDQUNiLENBRGEsQ0FBdkI7O0FBR0E7QUFDQSxhQUFPa3VELGdCQUFnQnQrRCxLQUFoQixHQUNKTyxRQURJLENBRUhpOEQsZUFBZTk4RCxDQUFmLEdBQW1CaXVELEdBQW5CLEdBQXlCNk8sZUFBZTc4RCxDQUFmLEdBQW1CaXVELEdBRnpDLEVBR0g0TyxlQUFlOThELENBQWYsR0FBbUJrdUQsR0FBbkIsR0FBeUI0TyxlQUFlNzhELENBQWYsR0FBbUJndUQsR0FIekMsQ0FBUDtBQUtEOztBQUVEOztBQUVBOzs7Ozs7OzttQ0FLZ0I7QUFDZCxVQUFJOE8sUUFBUSxFQUFaO0FBQ0EsVUFBSSxLQUFLcjZELEtBQUwsQ0FBV3UwQyxRQUFmLEVBQXlCO0FBQ3ZCOGxCLGdCQUFRLENBQ0w7QUFBQyxzQ0FBRDtBQUFBO0FBQ0MscUJBQVMsS0FBS2p2RCxnQkFBTCxDQUFzQnBTLElBQXRCLENBQTJCLElBQTNCLEVBQWlDLFFBQWpDLENBRFY7QUFFQyxvQkFBUSxLQUFLc1MsZUFBTCxDQUFxQnRTLElBQXJCLENBQTBCLElBQTFCLEVBQWdDLFFBQWhDLENBRlQ7QUFHQyxvQkFBUSxLQUFLcVMsV0FBTCxDQUFpQnJTLElBQWpCLENBQXNCLElBQXRCLEVBQTRCLFFBQTVCLENBSFQ7QUFJQztBQUFBO0FBQUEsY0FBSyxLQUFJLGdCQUFULEVBQTBCLE9BQU8sS0FBS2lrRSx1QkFBTCxFQUFqQztBQUNFLHFEQUFLLEtBQUksUUFBVCxFQUFrQixLQUFLLEtBQUtyaUQsYUFBTCxDQUFtQix5Q0FBbkIsRUFBOEQsSUFBOUQsQ0FBdkI7QUFERjtBQUpELFNBREssRUFTTDtBQUFDLHNDQUFEO0FBQUE7QUFDQyxxQkFBUyxLQUFLeFAsZ0JBQUwsQ0FBc0JwUyxJQUF0QixDQUEyQixJQUEzQixFQUFpQyxLQUFqQyxDQURWO0FBRUMsb0JBQVEsS0FBS3NTLGVBQUwsQ0FBcUJ0UyxJQUFyQixDQUEwQixJQUExQixFQUFnQyxLQUFoQyxDQUZUO0FBR0Msb0JBQVEsS0FBS3FTLFdBQUwsQ0FBaUJyUyxJQUFqQixDQUFzQixJQUF0QixFQUE0QixLQUE1QixDQUhUO0FBSUM7QUFBQTtBQUFBLGNBQUssS0FBSSxnQkFBVCxFQUEwQixPQUFPLEtBQUtra0Usb0JBQUwsRUFBakM7QUFDRSxxREFBSyxLQUFJLFFBQVQsRUFBa0IsS0FBSyxLQUFLdGlELGFBQUwsQ0FBbUIseUNBQW5CLEVBQThELElBQTlELENBQXZCO0FBREY7QUFKRCxTQVRLLENBQVI7O0FBbUJBLFlBQUksQ0FBQyxLQUFLNWEsS0FBTCxDQUFXNEIsT0FBWCxDQUFtQnl6RCxVQUF4QixFQUFvQztBQUNsQ2dGLGdCQUFNeC9ELElBQU4sQ0FDRztBQUFDLHdDQUFEO0FBQUE7QUFDQyx1QkFBUyxLQUFLc2lFLHNCQURmO0FBRUMsc0JBQVEsS0FBS0MscUJBRmQ7QUFHQyxzQkFBUSxLQUFLQyxpQkFIZDtBQUlDO0FBQUE7QUFBQSxnQkFBSyxLQUFJLGdCQUFULEVBQTBCLE9BQU8sS0FBS0MsbUJBQUwsRUFBakM7QUFDRSx1REFBSyxLQUFJLFFBQVQsRUFBa0IsS0FBSyxLQUFLMWlELGFBQUwsQ0FBbUIsMkJBQW5CLEVBQWdELElBQWhELENBQXZCO0FBREY7QUFKRCxXQURIO0FBVUQ7QUFDRjtBQUNELGFBQU95L0MsS0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozt1Q0FLb0I7QUFDbEIsVUFBSSxLQUFLcjZELEtBQUwsQ0FBV3FPLFdBQWYsRUFBNEIsT0FBTyxJQUFQO0FBRFYsVUFFVkQsTUFGVSxHQUVDLEtBQUtwTyxLQUZOLENBRVZvTyxNQUZVOztBQUdsQixVQUFNK1YsY0FBYy9WLE9BQU84cEIsY0FBUCxFQUFwQjtBQUNBLFVBQU1FLGFBQWFqVSxZQUFZa1UsYUFBWixFQUFuQjtBQUNBLFVBQU1DLGFBQWFuVSxZQUFZb1UsYUFBWixFQUFuQjtBQUNBLFVBQU1DLFdBQVdyVSxZQUFZc1UsV0FBWixFQUFqQjs7QUFFQSxVQUFNOGtDLDZDQUN5QixLQUFLMUIsR0FEOUIsa0dBR29DempDLFVBSHBDLDhEQUlvQ0EsVUFKcEMsOERBS29DQSxVQUxwQyxpR0FPdUNFLFVBUHZDLHlGQVNnQ0UsUUFUaEMsd0JBU3dELEVBQUUsTUFBTUEsUUFBUixJQUFvQixHQVQ1RSwyREFVZ0NBLFFBVmhDLHdCQVV3RCxFQUFFLE1BQU1BLFFBQVIsSUFBb0IsR0FWNUUsMkRBV2dDQSxRQVhoQyx3QkFXd0QsRUFBRSxNQUFNQSxRQUFSLElBQW9CLEdBWDVFLDREQUFOOztBQWdCQTtBQUNBO0FBQ0E7QUFDQSxhQUFRO0FBQUE7QUFBQSxVQUFLLE9BQU0sR0FBWCxFQUFlLFFBQU8sR0FBdEIsRUFBMEIsK0JBQTRCLE1BQXRELEVBQTZELElBQUcsS0FBaEU7QUFDTGwvQiwwQkFBUzhjLGFBQVQsQ0FBdUIsTUFBdkIsRUFBK0I7QUFDOUJVLGVBQUs3ZSxLQUFLa2dCLE1BQUwsRUFEeUI7QUFFOUJxbEQsbUNBQXlCO0FBQ3ZCN2Usb0JBQVE0ZTtBQURlO0FBRkssU0FBL0I7QUFESyxPQUFSO0FBUUQ7O0FBRUQ7Ozs7Ozs7OzZDQUswQjtBQUN4QixVQUFJcEMsNEJBQTRCLEVBQWhDO0FBQ0EsVUFBSSxLQUFLbjdELEtBQUwsQ0FBV3UwQyxRQUFmLEVBQXlCO0FBQ3ZCNG1CLGtDQUEwQnRnRSxJQUExQixDQUErQixhQUEvQjtBQUNEO0FBQ0RzZ0Usa0NBQTRCQSwwQkFBMEJ6dUIsSUFBMUIsQ0FBK0IsR0FBL0IsQ0FBNUI7O0FBRUEsVUFBTTB1QixlQUFlLEtBQUtxQyxnQkFBTCxFQUFyQjtBQUNBLGFBQVE7QUFBQTtBQUFBLFVBQUssV0FBVSxRQUFmO0FBQ047QUFBQyxzQ0FBRDtBQUFBO0FBQ0UscUJBQVMsS0FBS3BDLGdCQURoQjtBQUVFLG9CQUFRLEtBQUtDLGVBRmY7QUFHRSxvQkFBUSxLQUFLQyxXQUhmO0FBSUUsc0JBQVUsQ0FBQyxLQUFLdjdELEtBQUwsQ0FBV3UwQyxRQUp4QjtBQUtFLG1EQUFLLEtBQUksbUJBQVQ7QUFDRSwyQkFBZSxLQUFLMGtCLGtCQUR0QjtBQUVFLDBCQUFjLEtBQUt1QyxpQkFGckI7QUFHRSx3QkFBWSxLQUFLQyxlQUhuQjtBQUlFLG1CQUFPTCxZQUpUO0FBS0UsdUJBQVdELHlCQUxiO0FBTEY7QUFETSxPQUFSO0FBY0Q7O0FBRUQ7Ozs7Ozs7O2tDQUtlO0FBQ2IsVUFBSSxLQUFLbjdELEtBQUwsQ0FBV3FPLFdBQWYsRUFBNEIsT0FBTyxJQUFQOztBQURmLFVBR0xELE1BSEssR0FHTSxLQUFLcE8sS0FIWCxDQUdMb08sTUFISzs7QUFJYixVQUFNc3ZELGVBQWUsS0FBS0QsZ0JBQUwsRUFBckI7O0FBRUEsVUFBTUUsVUFBVTdrRSxPQUFPOGtFLFFBQVAsQ0FBZ0IxVixJQUFoQixDQUFxQjdnRCxPQUFyQixDQUE2QnZPLE9BQU84a0UsUUFBUCxDQUFnQkMsSUFBN0MsRUFBbUQsRUFBbkQsQ0FBaEI7QUFDQSxVQUFNQyxvQkFBb0IsRUFBRWgyRCxrQkFBZ0I2MUQsT0FBaEIsdUJBQXlDLEtBQUs5QixHQUE5QyxjQUFGLEVBQTFCOztBQUVBLFVBQU1rQyxXQUFXLEVBQUV2K0QsT0FBT2srRCxhQUFhbCtELEtBQXRCLEVBQTZCTCxRQUFRdStELGFBQWF2K0QsTUFBbEQsRUFBakI7QUFDQSxhQUFRO0FBQUE7QUFBQSxVQUFLLFdBQVUsV0FBZjtBQUNOO0FBQUE7QUFBQSxZQUFLLEtBQUksYUFBVCxFQUF1QixPQUFPdStELFlBQTlCO0FBQ0U7QUFBQTtBQUFBLGNBQUssT0FBTzU1QyxTQUFTNDVDLGFBQWFsK0QsS0FBdEIsQ0FBWixFQUEwQyxRQUFRc2tCLFNBQVM0NUMsYUFBYXYrRCxNQUF0QixDQUFsRCxFQUFpRiwrQkFBNEIsTUFBN0csRUFBb0gsSUFBRyxLQUF2SCxFQUE2SCxPQUFPNCtELFFBQXBJLEVBQThJLHFCQUFvQixNQUFsSztBQUNHemtFLDhCQUFTOGMsYUFBVCxDQUF1QixPQUF2QixFQUFnQztBQUMvQjRuRCx5QkFBVzV2RCxPQUFPa29CLFFBQVAsR0FBa0JqaUIsR0FERTtBQUUvQjdVLHFCQUFPaytELGFBQWFsK0QsS0FGVztBQUcvQkwsc0JBQVF1K0QsYUFBYXYrRCxNQUhVO0FBSS9CRCxxQkFBTzQrRCxpQkFKd0I7QUFLL0JHLG1DQUFxQjtBQUxVLGFBQWhDO0FBREg7QUFERjtBQURNLE9BQVI7QUFhRDs7QUFFRDs7Ozs7OztvQ0FJaUI7QUFDZixhQUFRO0FBQUE7QUFBQSxVQUFLLFdBQVUseUJBQWY7QUFDTjtBQUFBO0FBQUEsWUFBSyxLQUFJLHFCQUFUO0FBQ0csZUFBS0MsZ0JBQUwsRUFESDtBQUVHLGVBQUt4QyxXQUFMLEVBRkg7QUFHRyxlQUFLQyxzQkFBTCxFQUhIO0FBSUcsZUFBS0MsWUFBTDtBQUpIO0FBRE0sT0FBUjtBQVFEOzs7O0VBbmlCK0NyL0MsdUI7O2tCQUE3QmhPLG9COzs7QUFzaUJyQkEscUJBQXFCek4sWUFBckIsR0FBb0N5Yix3QkFBY3piLFlBQWxELEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMWlCQTs7QUFDQTs7Ozs7Ozs7OzsrZUFqQkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztJQWlCcUIwTixrQjs7Ozs7Ozs7Ozs7O0FBQ25COztBQUVBOzs7d0NBR3FCO0FBQ25CO0FBQ0EsVUFBSSxLQUFLeE8sS0FBTCxDQUFXcU8sV0FBZixFQUE0QjtBQUM1QixVQUFNOEgsU0FBUyxLQUFLblcsS0FBTCxDQUFXb08sTUFBWCxDQUFrQmlqQixTQUFsQixFQUFmO0FBQ0EsV0FBSzhzQyxhQUFMLENBQW1CaG9ELE1BQW5CO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OENBSTJCd0csUyxFQUFXO0FBQ3BDLFVBQUksS0FBSzNjLEtBQUwsQ0FBV3FPLFdBQWYsRUFBNEI7QUFDNUIsVUFBSXNPLFVBQVV2TyxNQUFWLEtBQXFCLEtBQUtwTyxLQUFMLENBQVdvTyxNQUFwQyxFQUE0QztBQUMxQyxZQUFNK0gsU0FBUyxLQUFLblcsS0FBTCxDQUFXb08sTUFBWCxDQUFrQmlqQixTQUFsQixFQUFmO0FBQ0FsYixlQUFPMEMsVUFBUCxDQUFrQkMsV0FBbEIsQ0FBOEIzQyxNQUE5QjtBQUNBLFlBQU1pb0QsWUFBWXpoRCxVQUFVdk8sTUFBVixDQUFpQmlqQixTQUFqQixFQUFsQjtBQUNBLGFBQUs4c0MsYUFBTCxDQUFtQkMsU0FBbkI7QUFDRDtBQUNGOztBQUVEOztBQUVBOzs7Ozs7O2tDQUllO0FBQ2IsYUFBTyxLQUFLMTRELGNBQUwsQ0FBb0IsT0FBcEIsTUFBaUMsS0FBSzFGLEtBQUwsQ0FBV29PLE1BQW5EO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7O2tDQUtlK0gsTSxFQUFRO0FBQUEsVUFDYmhVLE1BRGEsR0FDRixLQUFLYixPQURILENBQ2JhLE1BRGE7O0FBRXJCLFVBQU0yTCxtQkFBbUIzTCxPQUFPNEwsbUJBQVAsRUFBekI7QUFDQW9JLGFBQU9qWCxLQUFQLENBQWFNLEtBQWIsR0FBcUJzTyxpQkFBaUJ4USxDQUFqQixHQUFxQixJQUExQztBQUNBNlksYUFBT2pYLEtBQVAsQ0FBYUMsTUFBYixHQUFzQjJPLGlCQUFpQnZRLENBQWpCLEdBQXFCLElBQTNDO0FBQ0EsV0FBS21DLElBQUwsQ0FBVXVnQixLQUFWLENBQWdCckgsV0FBaEIsQ0FBNEJ6QyxNQUE1QjtBQUNEOztBQUVEOzs7Ozs7O29DQUlpQjtBQUNmLFVBQUksS0FBS25XLEtBQUwsQ0FBV3FPLFdBQWYsRUFBNEIsT0FBTyxJQUFQOztBQUU1QixVQUFNZ3dELGlCQUFpQixLQUFLQyxXQUFMLEtBQXFCLGFBQXJCLEdBQXFDLElBQTVEO0FBQ0EsYUFBUTtBQUFBO0FBQUEsVUFBSyxXQUFVLHlCQUFmO0FBQ047QUFBQTtBQUFBLFlBQUssS0FBSSw0QkFBVCxFQUFzQyxLQUFJLFdBQTFDO0FBQ0U7QUFDRSxpQkFBSSxVQUROO0FBRUUsdUJBQVdELGNBRmI7QUFHRSxpQkFBSSxPQUhOO0FBREY7QUFETSxPQUFSO0FBUUQ7Ozs7RUFwRTZDOWhELHVCOztrQkFBM0IvTixrQjs7O0FBdUVyQkEsbUJBQW1CMU4sWUFBbkIsR0FBa0N5Yix3QkFBY3piLFlBQWhELEM7Ozs7Ozs7Ozs7Ozs7OztBQzFFQTs7Ozs7OytlQWhCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBZ0JxQnk5RCwrQjs7Ozs7Ozs7Ozs7O0FBQ25COztBQUVBOzs7Ozs7aUNBTWNwaUUsUyxFQUFXZ0IsQyxFQUFHO0FBQzFCQSxRQUFFeUYsY0FBRjtBQUNBekYsUUFBRTBGLGVBQUY7O0FBRUEsV0FBSzdDLEtBQUwsQ0FBV3crRCxNQUFYLElBQXFCLEtBQUt4K0QsS0FBTCxDQUFXdytELE1BQVgsQ0FBa0JyaUUsU0FBbEIsQ0FBckI7QUFDRDs7QUFFRDs7Ozs7Ozs7d0NBS3FCZ0IsQyxFQUFHO0FBQ3RCQSxRQUFFeUYsY0FBRjtBQUNBekYsUUFBRTBGLGVBQUY7O0FBRUEsV0FBSzdDLEtBQUwsQ0FBV3krRCxhQUFYLElBQTRCLEtBQUt6K0QsS0FBTCxDQUFXeStELGFBQVgsRUFBNUI7QUFDRDs7QUFFRDs7Ozs7Ozs7bUNBS2dCdGhFLEMsRUFBRztBQUNqQkEsUUFBRXlGLGNBQUY7QUFDQXpGLFFBQUUwRixlQUFGOztBQUVBLFdBQUs3QyxLQUFMLENBQVcwK0QsUUFBWCxJQUF1QixLQUFLMStELEtBQUwsQ0FBVzArRCxRQUFYLEVBQXZCO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7bUNBSWdCO0FBQ2QsYUFBTyxDQUNKO0FBQUE7QUFBQSxVQUFLLEtBQUksU0FBVCxFQUFtQixTQUFTLEtBQUt0TyxZQUFMLENBQWtCcDNELElBQWxCLENBQXVCLElBQXZCLEVBQTZCLEdBQTdCLENBQTVCO0FBQ0MsaURBQUssS0FBSSxRQUFULEVBQWtCLEtBQUssS0FBSzRoQixhQUFMLENBQW1CLDZCQUFuQixFQUFrRCxJQUFsRCxDQUF2QjtBQURELE9BREksRUFJSjtBQUFBO0FBQUEsVUFBSyxLQUFJLFNBQVQsRUFBbUIsU0FBUyxLQUFLdzFDLFlBQUwsQ0FBa0JwM0QsSUFBbEIsQ0FBdUIsSUFBdkIsRUFBNkIsR0FBN0IsQ0FBNUI7QUFDQyxpREFBSyxLQUFJLFFBQVQsRUFBa0IsS0FBSyxLQUFLNGhCLGFBQUwsQ0FBbUIsNkJBQW5CLEVBQWtELElBQWxELENBQXZCO0FBREQsT0FKSSxFQU9KO0FBQUE7QUFBQSxVQUFLLEtBQUksU0FBVCxFQUFtQixTQUFTLEtBQUsrakQsbUJBQUwsQ0FBeUIzbEUsSUFBekIsQ0FBOEIsSUFBOUIsQ0FBNUI7QUFDQyxpREFBSyxLQUFJLFFBQVQsRUFBa0IsS0FBSyxLQUFLNGhCLGFBQUwsQ0FBbUIsb0NBQW5CLEVBQXlELElBQXpELENBQXZCO0FBREQsT0FQSSxFQVVKLHlDQUFLLEtBQUksY0FBVCxHQVZJLEVBV0o7QUFBQTtBQUFBLFVBQUssS0FBSSxTQUFULEVBQW1CLFNBQVMsS0FBS2drRCxjQUFMLENBQW9CNWxFLElBQXBCLENBQXlCLElBQXpCLENBQTVCO0FBQ0MsaURBQUssS0FBSSxRQUFULEVBQWtCLEtBQUssS0FBSzRoQixhQUFMLENBQW1CLDZCQUFuQixFQUFrRCxJQUFsRCxDQUF2QjtBQURELE9BWEksQ0FBUDtBQWVEOztBQUVEOzs7Ozs7O29DQUlpQjtBQUNmLGFBQVE7QUFBQTtBQUFBO0FBQ04sZUFBSSwyQkFERTtBQUVMLGFBQUtpa0QsWUFBTDtBQUZLLE9BQVI7QUFJRDs7OztFQXpFMER4bEUsc0I7O2tCQUF4Q2tsRSwrQjs7O0FBNEVyQkEsZ0NBQWdDejlELFlBQWhDLEdBQStDekgsdUJBQWN5SCxZQUE3RCxDOzs7Ozs7Ozs7Ozs7Ozs7QUMvRUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBbkJBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OzRCQW1Cb0NwSSxhQUFJK1MsVUFBSixDQUFlQyxlO0lBQTNDRSxVLHlCQUFBQSxVO0lBQVlDLFcseUJBQUFBLFc7QUFDcEI7Ozs7Ozs7SUFNTWl6RCxZOzs7Ozs7Ozs7Ozs7QUFDSjs7O3VDQUdvQjtBQUNsQixVQUFNcjVELGlCQUFpQixLQUFLQyxjQUFMLENBQW9CLGdCQUFwQixDQUF2Qjs7QUFFQSxVQUFJLENBQUNELGNBQUwsRUFBcUI7QUFDbkI7QUFDRDs7QUFFRCxXQUFLczVELGtCQUFMLENBQXdCLE1BQXhCLEVBQWdDdDVELGVBQWU2eEIsZ0JBQWYsQ0FBZ0MsQ0FDOUQsT0FEOEQsRUFFOUQsaUJBRjhELEVBRzlELGtCQUg4RCxFQUk5RCxZQUo4RCxFQUs5RCxXQUw4RCxFQU05RCxnQkFOOEQsRUFPOUQsWUFQOEQsRUFROUQsWUFSOEQsRUFTOUQsV0FUOEQsQ0FBaEMsQ0FBaEM7QUFXRDs7QUFFRDs7Ozs7Ozs7NkJBS2lCO0FBQUEsVUFDUG4xQixNQURPLEdBQ0ksS0FBS2IsT0FEVCxDQUNQYSxNQURPOztBQUVmLFVBQU1rSyxZQUFZLEtBQUszRyxjQUFMLENBQW9CLFdBQXBCLENBQWxCOztBQUVBLFdBQUtzNUQsZ0JBQUw7O0FBRUEsVUFBSSxDQUFDLEtBQUt0NUQsY0FBTCxDQUFvQixhQUFwQixDQUFMLEVBQXlDO0FBQ3ZDdkQsZUFBT2lyQixPQUFQLENBQWU3aUIsR0FBZixDQUNFOEIsU0FERixFQUVFLEtBQUszRyxjQUFMLENBQW9CLGdCQUFwQixDQUZGLEVBR0UsS0FBS0EsY0FBTCxDQUFvQix3QkFBcEIsQ0FIRjtBQUtEO0FBQ0R2RCxhQUFPb3JCLElBQVAsQ0FBWWtxQixPQUFaO0FBQ0F0MUMsYUFBT3lyQixRQUFQLENBQWdCKy9CLE1BQWhCLENBQXVCLE1BQXZCLEVBQStCLE1BQS9CO0FBQ0F4ckQsYUFBT21MLE1BQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs0QkFPZ0J3QixXLEVBQWFsTixPLEVBQVM7QUFBQSxxQkFDYixLQUFLTixPQURRO0FBQUEsVUFDNUJhLE1BRDRCLFlBQzVCQSxNQUQ0QjtBQUFBLFVBQ3BCK0QsRUFEb0IsWUFDcEJBLEVBRG9COztBQUVwQyxVQUFNMEcseUJBQXlCekssT0FBT29LLFVBQVAsQ0FBa0IrVSxNQUFsQixDQUF5QixRQUF6QixDQUEvQjtBQUNBLFVBQU1qVixZQUFZbEssT0FBT29LLFVBQVAsQ0FBa0JDLFdBQWxCLENBQThCLFFBQTlCLENBQWxCO0FBQ0EsVUFBTUMsVUFBVUosVUFBVVMsVUFBVixFQUFoQjtBQUNBLFVBQU1ELGlCQUFpQlIsVUFBVWlyQixnQkFBVixFQUF2Qjs7QUFFQSxVQUFNNkgsY0FBYyxJQUFJNXZCLHFCQUFKLENBQWdCckosRUFBaEIsRUFBb0J0RSxPQUFwQixDQUFwQjtBQUNBLFVBQU1xOUQsdUJBQXVCOS9CLFlBQVlQLG1CQUFaLEVBQTdCOztBQUVBLFdBQUtqeUIsY0FBTCxDQUFvQjtBQUNsQkMsc0RBRGtCO0FBRWxCUCw0QkFGa0I7QUFHbEJJLHdCQUhrQjtBQUlsQkksc0NBSmtCO0FBS2xCc3lCLGdDQUxrQjtBQU1sQjgvQixrREFOa0I7QUFPbEJwdkQsZUFBT3N2QixZQUFZTSxRQUFaO0FBUFcsT0FBcEI7O0FBVUF0OUIsYUFBT29yQixJQUFQLENBQVk0cEIsSUFBWjtBQUNBaDFDLGFBQU9tTCxNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7O29DQVF3QnBELFEsRUFBVS9ILE0sRUFBUTtBQUN4QyxVQUFJLENBQUNBLE9BQU9vSyxVQUFQLENBQWtCK1UsTUFBbEIsQ0FBeUIsUUFBekIsQ0FBTCxFQUF5QyxPQUFPLEtBQVA7O0FBRXpDLFVBQU1qVixZQUFZbEssT0FBT29LLFVBQVAsQ0FBa0JDLFdBQWxCLENBQThCLFFBQTlCLENBQWxCO0FBQ0EsVUFBSUMsVUFBVUosVUFBVTRvRCxvQkFBVixDQUErQi9xRCxRQUEvQixFQUF5Qy9ILE9BQU8rdUIsMEJBQVAsRUFBekMsRUFDWHBwQixNQURXLENBQ0osVUFBQ0gsQ0FBRDtBQUFBLGVBQU8sRUFBRUEsYUFBYWtFLFdBQWYsQ0FBUDtBQUFBLE9BREksQ0FBZDs7QUFHQSxVQUFJWSxRQUFRekUsTUFBUixJQUFrQnlFLFFBQVEsQ0FBUixhQUFzQmIsVUFBNUMsRUFBd0Q7QUFDdEQsZUFBTyxFQUFFbkcsZ0JBQWdCZ0gsUUFBUSxDQUFSLENBQWxCLEVBQVA7QUFDRCxPQUZELE1BRU87QUFDTCxlQUFPLEtBQVA7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7Z0NBTW9CdEssTSxFQUFRO0FBQzFCLGFBQU9BLE9BQU95dUIsYUFBUCxDQUFxQixNQUFyQixLQUNMenVCLE9BQU8rbkQsYUFBUCxDQUFxQixNQUFyQixDQURGO0FBRUQ7O0FBRUQ7Ozs7Ozs7O3FDQUt5Qi9uRCxNLEVBQVE7QUFDL0IsYUFBTyxDQUNMLDhCQURLLEVBRUwsK0JBRkssRUFHTCxnQ0FISyxFQUlMLHlCQUpLLEVBS0wsd0JBTEssQ0FBUDtBQU9EOzs7O0VBNUh3QnkrQixrQjs7QUErSDNCOzs7Ozs7O0FBS0FrK0IsYUFBYXo4RCxpQkFBYixHQUFpQzY4RCwrQkFBakM7O0FBRUE7Ozs7OztBQU1BSixhQUFheDhELHVCQUFiLEdBQXVDNjhELHFDQUF2Qzs7QUFFQTs7Ozs7QUFLQUwsYUFBYTE5RCxVQUFiLEdBQTBCLE1BQTFCOztBQUVBOzs7OztBQUtBMDlELGFBQWF2OEQsUUFBYixHQUF3Qiw0QkFBeEI7O0FBRUE7Ozs7O0FBS0F1OEQsYUFBYXQ4RCxXQUFiLEdBQTJCLHVCQUEzQjs7QUFFQTs7Ozs7OztBQU9BczhELGFBQWFyOEQsY0FBYixHQUE4QjtBQUM1Qm9OLFNBQU8sRUFEcUI7QUFFNUJDLGdCQUFjLEtBRmM7QUFHNUJDLHVCQUFxQjs7QUFHdkI7Ozs7QUFOOEIsQ0FBOUIsQ0FVQSt1RCxhQUFhbFYsa0JBQWIsR0FBa0MsQ0FBQyxRQUFELENBQWxDOztrQkFFZWtWLFk7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbE1mOztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBakJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0lBaUJxQkssMkI7OztBQUNuQix5Q0FBc0I7QUFBQTs7QUFBQTs7QUFBQSxzQ0FBTm4rRCxJQUFNO0FBQU5BLFVBQU07QUFBQTs7QUFBQSxxTEFDWEEsSUFEVzs7QUFHcEIsVUFBS3JGLFFBQUwsQ0FBYyxhQUFkO0FBSG9CO0FBSXJCOztBQUVEOztBQUVBOzs7Ozs7OztrQ0FJZTtBQUNiLFVBQU15UyxTQUFTLEtBQUsxSSxjQUFMLENBQW9CLGdCQUFwQixDQUFmO0FBQ0EsVUFBSTBJLFVBQVVBLE9BQU9tcUQsT0FBUCxPQUFxQixFQUFuQyxFQUF1QztBQUNyQ25xRCxlQUFPc3FELE9BQVAsQ0FBZSxLQUFLbjZDLEVBQUwsQ0FBUSxvQ0FBUixDQUFmO0FBQ0FuUSxlQUFPeXFELE9BQVAsR0FBaUIsS0FBakI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7O3NDQUltQjtBQUNqQjtBQUNBLFdBQUs3NEQsS0FBTCxDQUFXeUIsZ0JBQVgsQ0FBNEIsTUFBNUI7QUFDRDs7QUFFRDs7Ozs7OztrQ0FJZTtBQUNiLFVBQU0yTSxTQUFTLEtBQUsxSSxjQUFMLENBQW9CLGdCQUFwQixDQUFmO0FBQ0EsV0FBS2hHLElBQUwsYUFBb0IwTyxPQUFPYyxLQUFQLEVBQXBCLEVBQXNDeXBELGFBQXRDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OzZDQUswQjtBQUN4QixVQUFJLENBQUMsS0FBS2p6RCxjQUFMLENBQW9CLGdCQUFwQixDQUFMLEVBQTRDOztBQUU1QyxhQUFRLGdDQUFDLHNDQUFEO0FBQ04sdUJBQWUsS0FBSzJ5RCxvQkFEZDtBQUVOLGtCQUFVLEtBQUtwcEQsZUFGVDtBQUdOLGdCQUFRLEtBQUttd0QsV0FIUCxHQUFSO0FBSUQ7Ozs7RUFuRHNEdHpELHdDOztrQkFBcENxekQsMkI7OztBQXNEckJBLDRCQUE0QnIrRCxZQUE1QixHQUEyQ2dMLHlDQUErQmhMLFlBQTFFLEM7Ozs7Ozs7Ozs7Ozs7OztBQ3pEQTs7Ozs7OytlQWhCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBZ0JxQnUrRCw0Qjs7Ozs7Ozs7Ozs7O0FBQ25COztBQUVBOzs7OztpQ0FLY2xpRSxDLEVBQUc7QUFDZkEsUUFBRXlGLGNBQUY7QUFDQXpGLFFBQUUwRixlQUFGOztBQUVBLFdBQUs3QyxLQUFMLENBQVdzL0QsTUFBWCxJQUFxQixLQUFLdC9ELEtBQUwsQ0FBV3MvRCxNQUFYLEVBQXJCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O3dDQUtxQm5pRSxDLEVBQUc7QUFDdEJBLFFBQUV5RixjQUFGO0FBQ0F6RixRQUFFMEYsZUFBRjs7QUFFQSxXQUFLN0MsS0FBTCxDQUFXeStELGFBQVgsSUFBNEIsS0FBS3orRCxLQUFMLENBQVd5K0QsYUFBWCxFQUE1QjtBQUNEOztBQUVEOzs7Ozs7OzttQ0FLZ0J0aEUsQyxFQUFHO0FBQ2pCQSxRQUFFeUYsY0FBRjtBQUNBekYsUUFBRTBGLGVBQUY7O0FBRUEsV0FBSzdDLEtBQUwsQ0FBVzArRCxRQUFYLElBQXVCLEtBQUsxK0QsS0FBTCxDQUFXMCtELFFBQVgsRUFBdkI7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7OzttQ0FJZ0I7QUFDZCxVQUFJM3lDLFFBQVEsQ0FDVDtBQUFBO0FBQUEsVUFBSyxLQUFJLFNBQVQsRUFBbUIsU0FBUyxLQUFLNHlDLG1CQUFMLENBQXlCM2xFLElBQXpCLENBQThCLElBQTlCLENBQTVCO0FBQ0MsaURBQUssS0FBSSxRQUFULEVBQWtCLEtBQUssS0FBSzRoQixhQUFMLENBQW1CLG9DQUFuQixFQUF5RCxJQUF6RCxDQUF2QjtBQURELE9BRFMsQ0FBWjs7QUFNQSxVQUFJcmlCLGVBQU1tdkMsYUFBTixFQUFKLEVBQTJCO0FBQ3pCM2IsZ0JBQVFBLE1BQU14akIsTUFBTixDQUFhLENBQ2xCLHlDQUFLLEtBQUksY0FBVCxHQURrQixFQUVsQjtBQUFBO0FBQUEsWUFBSyxLQUFJLFNBQVQsRUFBbUIsU0FBUyxLQUFLZzNELFlBQUwsQ0FBa0J2bUUsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBNUI7QUFDQyxtREFBSyxLQUFJLFFBQVQsRUFBa0IsS0FBSyxLQUFLNGhCLGFBQUwsQ0FBbUIsMkJBQW5CLEVBQWdELElBQWhELENBQXZCO0FBREQsU0FGa0IsQ0FBYixDQUFSO0FBTUQ7O0FBRURtUixjQUFRQSxNQUFNeGpCLE1BQU4sQ0FBYSxDQUNsQix5Q0FBSyxLQUFJLGNBQVQsR0FEa0IsRUFFbEI7QUFBQTtBQUFBLFVBQUssS0FBSSxTQUFULEVBQW1CLFNBQVMsS0FBS3EyRCxjQUFMLENBQW9CNWxFLElBQXBCLENBQXlCLElBQXpCLENBQTVCO0FBQ0MsaURBQUssS0FBSSxRQUFULEVBQWtCLEtBQUssS0FBSzRoQixhQUFMLENBQW1CLDZCQUFuQixFQUFrRCxJQUFsRCxDQUF2QjtBQURELE9BRmtCLENBQWIsQ0FBUjs7QUFPQSxhQUFPbVIsS0FBUDtBQUNEOztBQUVEOzs7Ozs7O29DQUlpQjtBQUNmLGFBQVE7QUFBQTtBQUFBO0FBQ04sZUFBSSwyQkFERTtBQUVMLGFBQUs4eUMsWUFBTDtBQUZLLE9BQVI7QUFJRDs7OztFQWhGdUR4bEUsc0I7O2tCQUFyQ2dtRSw0Qjs7O0FBbUZyQkEsNkJBQTZCditELFlBQTdCLEdBQTRDekgsdUJBQWN5SCxZQUExRCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckZBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7K2VBdkJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUF1QkEsSUFBTTArRCxhQUFhLENBQ2pCLE1BRGlCLEVBRWpCLFFBRmlCLEVBR2pCLE9BSGlCLENBQW5COztJQUtxQk4scUI7OztBQUNuQixtQ0FBc0I7QUFBQTs7QUFBQTs7QUFBQSxzQ0FBTmwrRCxJQUFNO0FBQU5BLFVBQU07QUFBQTs7QUFBQSx5S0FDWEEsSUFEVzs7QUFHcEIsVUFBS3JGLFFBQUwsQ0FDRSxtQkFERixFQUVFLGVBRkYsRUFHRSxtQkFIRixFQUlFLHFCQUpGLEVBS0UsMEJBTEYsRUFNRSwwQkFORixFQU9FLHNCQVBGO0FBU0EsVUFBS3FRLE9BQUwsdUJBQ0d6UyxtQkFBVXNNLE1BQVYsQ0FBaUJtdUMsbUJBRHBCLEVBQzBDLE1BQUswaEIsb0JBRC9DO0FBR0EsVUFBS3JMLFVBQUwsR0FBa0IsTUFBSzNrRCxjQUFMLENBQW9CLFdBQXBCLENBQWxCO0FBQ0EsVUFBS3U3QixXQUFMLEdBQW1CLE1BQUszL0IsT0FBTCxDQUFhNEUsRUFBYixDQUFnQnk0QixhQUFoQixFQUFuQjtBQUNBLFVBQUtzQyxXQUFMLENBQWlCdGIsUUFBakIsQ0FBMEIsTUFBS2pnQixjQUFMLENBQW9CLE9BQXBCLENBQTFCOztBQUVBLFVBQUs5SixLQUFMLEdBQWEsRUFBRWl0QixNQUFNLElBQVIsRUFBY1csU0FBUyxJQUF2QixFQUFiOztBQW5Cb0IsUUFxQlpybkIsTUFyQlksR0FxQkQsTUFBS2IsT0FyQkosQ0FxQlphLE1BckJZOztBQXNCcEJBLFdBQU9tTCxNQUFQOztBQUVBLFVBQUtrQyxNQUFMLEdBQWMsTUFBSzlKLGNBQUwsQ0FBb0IsT0FBcEIsQ0FBZDtBQXhCb0I7QUF5QnJCOztBQUVEOztBQUVBOzs7Ozs7O3dDQUdxQjtBQUFBOztBQUNuQjs7QUFEbUIsVUFHWHZELE1BSFcsR0FHQSxLQUFLYixPQUhMLENBR1hhLE1BSFc7O0FBSW5CQSxhQUFPb3JCLElBQVAsQ0FBWS9yQixHQUFaLENBQWdCLE1BQWhCLEVBQXdCLFlBQU07QUFDNUJXLGVBQU95ckIsUUFBUCxDQUFnQncrQixPQUFoQixDQUF3QixNQUF4QixFQUFnQyxNQUFoQztBQUNELE9BRkQ7O0FBSUEsVUFBTXFULGNBQWMsU0FBZEEsV0FBYyxHQUFNO0FBQ3hCLGVBQUtDLFdBQUw7QUFDQSxlQUFLeGlFLFFBQUwsQ0FBYyxFQUFFc3NCLFNBQVMsS0FBWCxFQUFkO0FBQ0QsT0FIRDs7QUFLQSxVQUFJLEtBQUt5WCxXQUFMLENBQWlCMCtCLFdBQWpCLEVBQUosRUFBb0M7QUFDbEMsYUFBS0MsVUFBTCxHQUNHejRELElBREgsQ0FDUXM0RCxZQUFZem1FLElBQVosQ0FBaUIsSUFBakIsQ0FEUjtBQUVELE9BSEQsTUFHTztBQUNMeW1FO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7aUNBS2M7QUFBQTs7QUFDWixVQUFNdGtCLGVBQWU1Z0QsdUJBQWFzd0IsUUFBYixDQUFzQnV3QixjQUF0QixDQUFxQyxLQUFLNzhCLEVBQUwsQ0FBUSwyQkFBUixDQUFyQyxDQUFyQjtBQUNBLGFBQU8sS0FBSzBpQixXQUFMLENBQWlCLzVCLElBQWpCLEdBQ0pDLElBREksQ0FDQyxZQUFNO0FBQ1ZnMEMscUJBQWFod0IsS0FBYjtBQUNELE9BSEksRUFJSjdMLEtBSkksQ0FJRSxVQUFDbmlCLENBQUQsRUFBTztBQUNaZytDLHFCQUFhaHdCLEtBQWI7QUFDQTV3QiwrQkFBYXN3QixRQUFiLENBQXNCNDRCLGNBQXRCLENBQ0UsT0FBS2xsQyxFQUFMLENBQVEscUNBQVIsQ0FERixFQUVFLE9BQUtBLEVBQUwsQ0FBUSxvQ0FBUixDQUZGO0FBSUQsT0FWSSxDQUFQO0FBV0Q7O0FBRUQ7Ozs7Ozs7a0NBSWU7QUFBQSxVQUNMcGMsTUFESyxHQUNNLEtBQUtiLE9BRFgsQ0FDTGEsTUFESzs7QUFFYixVQUFNc0QsaUJBQWlCLEtBQUtDLGNBQUwsQ0FBb0IsZ0JBQXBCLENBQXZCO0FBQ0EsVUFBTTJHLFlBQVksS0FBSzNHLGNBQUwsQ0FBb0IsV0FBcEIsQ0FBbEI7QUFDQSxVQUFNeTVCLGNBQWMsS0FBS3o1QixjQUFMLENBQW9CLGFBQXBCLENBQXBCOztBQUVBO0FBQ0EsVUFBTWpELGlCQUFpQixLQUFLbzlELGtCQUFMLENBQXdCLE1BQXhCLENBQXZCOztBQUVBLFVBQU1aLHVCQUF1Qng4RCxpQkFDekIsS0FBS2lELGNBQUwsQ0FBb0Isc0JBQXBCLENBRHlCLEdBRXpCeTVCLFlBQVlQLG1CQUFaLEVBRko7O0FBSUEsVUFBTTl3QixtQkFBbUIzTCxPQUFPNEwsbUJBQVAsRUFBekI7QUFDQSxVQUFJLENBQUN0SSxjQUFMLEVBQXFCO0FBQ25CLFlBQU15dUIsTUFBTS94QixPQUFPZ3lCLE1BQVAsRUFBWjtBQUNBLFlBQU0vRixXQUFXOEYsSUFBSTdGLFdBQUosRUFBakI7O0FBRUEsWUFBTXl4QyxpQkFBaUIxeEMsU0FBUzJ4QyxpQkFBVCxFQUF2QjtBQUNBLFlBQU01bEUsT0FBT2tTLFVBQVV5WixVQUFWO0FBQ1hsRSwwQkFBZ0JxOUMscUJBQXFCbHVELGFBQXJCLEVBREw7QUFFWDVXLGdCQUFNLEtBQUtva0IsRUFBTCxDQUFRLG9DQUFSLENBRks7QUFHWHJVLG9CQUFVLElBQUl0UixnQkFBSixDQUFZLEdBQVosRUFBaUIsR0FBakIsQ0FIQztBQUlYb25FLGlCQUFPLElBQUlwbkUsZ0JBQUosQ0FBWSxHQUFaLEVBQWlCLEdBQWpCLENBSkk7QUFLWGtwQixvQkFBVSxHQUxDO0FBTVhtK0MscUJBQVdILGlCQUFpQkEsaUJBQWlCaHlELGlCQUFpQnZRLENBQW5ELEdBQXVELENBTnZEO0FBT1g0bkIsb0JBQVUsSUFQQztBQVFYaFYsc0JBQVk4dUQscUJBQXFCcjVDLE9BQXJCLEdBQStCL0csYUFBL0IsRUFSRDtBQVNYa0gsc0JBQVlrNUMscUJBQXFCajVDLGFBQXJCLEVBVEQ7QUFVWHNPLHFCQUFXMnFDLHFCQUFxQmlCLFlBQXJCLEVBVkE7QUFXWDc2QyxxQkFBVztBQVhBLFdBWVA1aUIsa0JBQWtCLEVBWlgsRUFBYjtBQWNBNEosa0JBQVV5cUQsU0FBVixDQUFvQjM4RCxJQUFwQjtBQUNBLGFBQUt3UyxjQUFMLENBQW9CLEVBQUVsSCxnQkFBZ0J0TCxJQUFsQixFQUFwQjtBQUNBZ0ksZUFBT21MLE1BQVA7QUFDRDtBQUNGOztBQUVEOztBQUVBOzs7Ozs7Ozt5Q0FLc0J5b0QsYSxFQUFlO0FBQUEsVUFDM0IxcEQsU0FEMkIsR0FDSjBwRCxhQURJLENBQzNCMXBELFNBRDJCO0FBQUEsVUFDaEJ6SyxPQURnQixHQUNKbTBELGFBREksQ0FDaEJuMEQsT0FEZ0I7O0FBRW5DLFVBQUl5SyxjQUFjLEtBQUszRyxjQUFMLENBQW9CLFdBQXBCLENBQWxCLEVBQW9EOztBQUZqQixVQUkzQitHLE9BSjJCLEdBSWY3SyxPQUplLENBSTNCNkssT0FKMkI7O0FBS25DLFVBQUlBLFFBQVF4UixPQUFSLENBQWdCLEtBQUt5SyxjQUFMLENBQW9CLGdCQUFwQixDQUFoQixNQUEyRCxDQUFDLENBQWhFLEVBQW1FO0FBQ2pFO0FBQ0EsYUFBS2lILGNBQUwsQ0FBb0IsRUFBRXFwRCxhQUFhLElBQWYsRUFBcEIsRUFBMkMsS0FBM0M7QUFDQSxhQUFLaDJELEtBQUwsQ0FBV3lCLGdCQUFYLENBQTRCLE1BQTVCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7aUNBS2N0RSxDLEVBQUc7QUFBQSxVQUNQZ0YsTUFETyxHQUNJLEtBQUtiLE9BRFQsQ0FDUGEsTUFETzs7QUFFZixXQUFLNjhELGdCQUFMO0FBQ0E3OEQsYUFBT21MLE1BQVA7QUFDQSxXQUFLbk0sa0JBQUwsR0FBMEIsSUFBMUI7QUFDQSxXQUFLbkIsS0FBTCxDQUFXeUIsZ0JBQVgsQ0FBNEIsTUFBNUI7QUFDRDs7QUFFRDs7Ozs7O3VDQUdvQjtBQUNsQixVQUFNZ0UsaUJBQWlCLEtBQUtDLGNBQUwsQ0FBb0IsZ0JBQXBCLENBQXZCOztBQUVBLFVBQUksQ0FBQ0QsY0FBTCxFQUFxQjtBQUNuQjtBQUNEOztBQUVELFdBQUtzNUQsa0JBQUwsQ0FBd0IsTUFBeEIsRUFBZ0N0NUQsZUFBZTZ4QixnQkFBZixDQUFnQyxDQUM5RCxPQUQ4RCxFQUU5RCxpQkFGOEQsRUFHOUQsa0JBSDhELEVBSTlELFlBSjhELEVBSzlELFdBTDhELEVBTTlELGdCQU44RCxFQU85RCxZQVA4RCxFQVE5RCxZQVI4RCxFQVM5RCxXQVQ4RCxDQUFoQyxDQUFoQztBQVdEOztBQUVEOzs7Ozs7O3lDQUlzQnNPLFEsRUFBVTtBQUM5QixVQUFJLG9CQUFvQkEsUUFBeEIsRUFBa0M7QUFDaEMsYUFBS2pnQyxXQUFMO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7c0NBS21Cd2YsUSxFQUFVO0FBQUEsVUFDcEJoakIsTUFEb0IsR0FDVixLQUFLYixPQURLLENBQ3BCYSxNQURvQjs7QUFFM0IsVUFBTTJMLG1CQUFtQixLQUFLeE0sT0FBTCxDQUFhYSxNQUFiLENBQW9CNEwsbUJBQXBCLEVBQXpCO0FBQ0EsVUFBTW95RCxlQUFlLEtBQUt6NkQsY0FBTCxDQUFvQixnQkFBcEIsQ0FBckI7QUFDQXk2RCxtQkFBYUMsV0FBYixDQUF5Qmo3QyxXQUFXclgsaUJBQWlCdlEsQ0FBckQ7QUFDQSxXQUFLb0ksV0FBTDtBQUNBeEQsYUFBT21MLE1BQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7a0NBS2UrQyxTLEVBQVc7QUFBQSxVQUNoQmxPLE1BRGdCLEdBQ0wsS0FBS2IsT0FEQSxDQUNoQmEsTUFEZ0I7O0FBRXhCLFVBQU1nK0QsZUFBZSxLQUFLejZELGNBQUwsQ0FBb0IsZ0JBQXBCLENBQXJCO0FBQ0F5NkQsbUJBQWF6dkQsYUFBYixDQUEyQkwsVUFBVXVWLE9BQVYsR0FBb0IvRyxhQUFwQixFQUEzQjtBQUNBc2hELG1CQUFhRSxhQUFiLENBQTJCaHdELFVBQVUyVixhQUFWLEVBQTNCO0FBQ0FtNkMsbUJBQWFHLFlBQWIsQ0FBMEJqd0QsVUFBVTZ2RCxZQUFWLEVBQTFCO0FBQ0FDLG1CQUFhSSxpQkFBYixDQUErQmx3RCxVQUFVVSxhQUFWLEVBQS9CO0FBQ0EsV0FBS3BMLFdBQUw7QUFDQXhELGFBQU9tTCxNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O3NDQUttQm5RLEMsRUFBRztBQUFBLFVBQ1pnRixNQURZLEdBQ0QsS0FBS2IsT0FESixDQUNaYSxNQURZOztBQUVwQixVQUFNZytELGVBQWUsS0FBS3o2RCxjQUFMLENBQW9CLGdCQUFwQixDQUFyQjtBQUNBLFVBQU0yZixZQUFZODZDLGFBQWFLLFlBQWIsRUFBbEI7O0FBRUEsVUFBTUMsZUFBZWpCLFdBQVd2a0UsT0FBWCxDQUFtQm9xQixTQUFuQixDQUFyQjtBQUNBLFVBQU1xN0MsWUFBWSxDQUFDRCxlQUFlLENBQWhCLElBQXFCakIsV0FBV3gzRCxNQUFsRDtBQUNBLFVBQU0yNEQsZUFBZW5CLFdBQVdrQixTQUFYLENBQXJCOztBQUVBUCxtQkFBYVMsWUFBYixDQUEwQkQsWUFBMUI7QUFDQSxXQUFLbnpELGlCQUFMO0FBQ0FyTCxhQUFPbUwsTUFBUDtBQUNEOztBQUVEOzs7Ozs7Ozt3Q0FLcUJuUSxDLEVBQUc7QUFBQSxVQUNkZ0YsTUFEYyxHQUNILEtBQUtiLE9BREYsQ0FDZGEsTUFEYzs7QUFFdEIsVUFBTWtLLFlBQVksS0FBSzNHLGNBQUwsQ0FBb0IsV0FBcEIsQ0FBbEI7QUFDQTJHLGdCQUFVa0IsaUJBQVYsQ0FBNEIsS0FBSzdILGNBQUwsQ0FBb0IsZ0JBQXBCLENBQTVCO0FBQ0EsV0FBSzhILGlCQUFMO0FBQ0FyTCxhQUFPbUwsTUFBUDtBQUNEOztBQUVEOzs7Ozs7Ozs2Q0FLMEJnRSxLLEVBQU87QUFBQSxVQUN2Qm5QLE1BRHVCLEdBQ1osS0FBS2IsT0FETyxDQUN2QmEsTUFEdUI7O0FBRS9CLFVBQU1nK0QsZUFBZSxLQUFLejZELGNBQUwsQ0FBb0IsZ0JBQXBCLENBQXJCO0FBQ0F5NkQsbUJBQWFVLFFBQWIsQ0FBc0J2dkQsS0FBdEI7QUFDQW5QLGFBQU9tTCxNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OzZDQUswQmdFLEssRUFBTztBQUFBLFVBQ3ZCblAsTUFEdUIsR0FDWixLQUFLYixPQURPLENBQ3ZCYSxNQUR1Qjs7QUFFL0IsVUFBTWcrRCxlQUFlLEtBQUt6NkQsY0FBTCxDQUFvQixnQkFBcEIsQ0FBckI7QUFDQXk2RCxtQkFBYVcsa0JBQWIsQ0FBZ0N4dkQsS0FBaEM7QUFDQW5QLGFBQU9tTCxNQUFQO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7O2tDQUtldWIsSSxFQUFNO0FBQ25CLFVBQUlBLFNBQVMsS0FBS2p0QixLQUFMLENBQVdpdEIsSUFBeEIsRUFBOEJBLE9BQU8sSUFBUDs7QUFFOUIsV0FBSzNyQixRQUFMLENBQWMsRUFBRTJyQixVQUFGLEVBQWQ7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7Ozs0Q0FJeUI7QUFDdkIsY0FBUSxLQUFLanRCLEtBQUwsQ0FBV2l0QixJQUFuQjtBQUNFLGFBQUssTUFBTDtBQUNFLGlCQUFPLEtBQUtrNEMsNkJBQUwsRUFBUDtBQUNGLGFBQUssTUFBTDtBQUNFLGlCQUFPLEtBQUtDLCtCQUFMLEVBQVA7QUFDRjtBQUNFLGlCQUFPLElBQVA7QUFOSjtBQVFEOztBQUVEOztBQUVBOzs7Ozs7OztvREFLaUM7QUFDL0IsVUFBTWIsZUFBZSxLQUFLejZELGNBQUwsQ0FBb0IsZ0JBQXBCLENBQXJCO0FBQ0EsVUFBSSxDQUFDeTZELFlBQUwsRUFBbUI7O0FBRlksVUFJdkJoK0QsTUFKdUIsR0FJWixLQUFLYixPQUpPLENBSXZCYSxNQUp1Qjs7QUFLL0IsVUFBTTJMLG1CQUFtQjNMLE9BQU80TCxtQkFBUCxFQUF6Qjs7QUFFQSxVQUFNa3pELGNBQWNocEUsS0FBS3lTLEtBQUwsQ0FBV29ELGlCQUFpQnZRLENBQTVCLENBQXBCO0FBQ0EsVUFBTTRuQixXQUFXbHRCLEtBQUt5UyxLQUFMLENBQVd5MUQsYUFBYWUsV0FBYixLQUE2QnB6RCxpQkFBaUJ2USxDQUF6RCxDQUFqQjtBQUNBLGFBQVEsZ0NBQUMsZ0NBQUQ7QUFDTixlQUFPNG5CLFFBREQ7QUFFTixrQkFBVXJYLGlCQUFpQnZRLENBQWpCLEdBQXFCLElBRnpCO0FBR04sa0JBQVUwakUsV0FISjtBQUlOLGVBQU8sS0FBSzFpRCxFQUFMLENBQVEsd0JBQVIsQ0FKRDtBQUtOLGtCQUFVLEtBQUs0aUQsaUJBTFQsR0FBUjtBQU1EOztBQUVEOzs7Ozs7OztzQ0FLbUI7QUFDakIsVUFBTWhCLGVBQWUsS0FBS3o2RCxjQUFMLENBQW9CLGdCQUFwQixDQUFyQjtBQUNBLFVBQUksQ0FBQ3k2RCxZQUFMLEVBQW1COztBQUVuQixVQUFNcnlELG1CQUFtQixLQUFLeE0sT0FBTCxDQUFhYSxNQUFiLENBQW9CNEwsbUJBQXBCLEVBQXpCOztBQUVBLFVBQU1vWCxXQUFXZzdDLGFBQWFlLFdBQWIsRUFBakI7QUFDQSxVQUFNN2lELFlBQVksS0FBS3ppQixLQUFMLENBQVdpdEIsSUFBWCxLQUFvQixNQUFwQixHQUE2QixXQUE3QixHQUEyQyxJQUE3RDs7QUFFQSxhQUFRO0FBQUE7QUFBQTtBQUNOLGVBQUksUUFERTtBQUVOLGVBQUksTUFGRTtBQUdOO0FBQUE7QUFBQSxZQUFLLFdBQVUsYUFBZjtBQUNFO0FBQUE7QUFBQTtBQUNFLG1CQUFJLHVCQUROO0FBRUUseUJBQVd4SyxTQUZiO0FBR0UsaUNBQWdCLFVBSGxCO0FBSUUsdUJBQVMsS0FBSytpRCxhQUFMLENBQW1CcG9FLElBQW5CLENBQXdCLElBQXhCLEVBQThCLE1BQTlCLENBSlg7QUFLRTtBQUFBO0FBQUEsZ0JBQUssS0FBSSxtQkFBVDtBQUE4QmYsbUJBQUt5UyxLQUFMLENBQVd5YSxXQUFXclgsaUJBQWlCdlEsQ0FBdkM7QUFBOUIsYUFMRjtBQU1FO0FBQUE7QUFBQSxnQkFBSyxLQUFJLFNBQVQ7QUFBb0IsbUJBQUtnaEIsRUFBTCxDQUFRLHdCQUFSO0FBQXBCO0FBTkY7QUFERjtBQUhNLE9BQVI7QUFjRDs7QUFFRDs7QUFFQTs7Ozs7Ozs7c0RBS21DO0FBQ2pDLFVBQU00aEQsZUFBZSxLQUFLejZELGNBQUwsQ0FBb0IsZ0JBQXBCLENBQXJCO0FBQ0EsVUFBSSxDQUFDeTZELFlBQUwsRUFBbUI7O0FBRW5CLGFBQVEsZ0NBQUMsdUJBQUQ7QUFDTixvQkFBWUEsYUFBYXRoRCxhQUFiLEVBRE47QUFFTixvQkFBWXNoRCxhQUFhbjZDLGFBQWIsRUFGTjtBQUdOLG1CQUFXbTZDLGFBQWFELFlBQWIsRUFITDtBQUlOLGVBQU8sS0FBSzF3RCxNQUpOO0FBS04sa0JBQVUsS0FBSzZ4RCxhQUxULEdBQVI7QUFNRDs7QUFFRDs7Ozs7Ozs7c0NBS21CO0FBQ2pCLFVBQU1sQixlQUFlLEtBQUt6NkQsY0FBTCxDQUFvQixnQkFBcEIsQ0FBckI7QUFDQSxVQUFJLENBQUN5NkQsWUFBTCxFQUFtQjs7QUFFbkIsVUFBTTloRCxZQUFZLEtBQUt6aUIsS0FBTCxDQUFXaXRCLElBQVgsS0FBb0IsTUFBcEIsR0FBNkIsV0FBN0IsR0FBMkMsSUFBN0Q7QUFDQSxhQUFRO0FBQUE7QUFBQTtBQUNOLGVBQUksUUFERTtBQUVOLGVBQUksTUFGRTtBQUdOO0FBQUE7QUFBQSxZQUFLLFdBQVUsYUFBZjtBQUNFO0FBQUE7QUFBQTtBQUNFLG1CQUFJLHVCQUROO0FBRUUseUJBQVd4SyxTQUZiO0FBR0UsaUNBQWdCLE1BSGxCO0FBSUUsdUJBQVMsS0FBSytpRCxhQUFMLENBQW1CcG9FLElBQW5CLENBQXdCLElBQXhCLEVBQThCLE1BQTlCLENBSlg7QUFLRSw0Q0FBQyw4QkFBRDtBQUNFLDBCQUFZbW5FLGFBQWF0aEQsYUFBYixFQURkO0FBRUUsMEJBQVlzaEQsYUFBYW42QyxhQUFiLEVBRmQ7QUFHRSx5QkFBV202QyxhQUFhRCxZQUFiLEVBSGIsR0FMRjtBQVNFO0FBQUE7QUFBQSxnQkFBSyxLQUFJLFNBQVQ7QUFBb0IsbUJBQUszaEQsRUFBTCxDQUFRLHdCQUFSO0FBQXBCO0FBVEY7QUFERjtBQUhNLE9BQVI7QUFpQkQ7O0FBRUQ7O0FBRUE7Ozs7Ozs7OzJDQUt3QjtBQUN0QixVQUFNNGhELGVBQWUsS0FBS3o2RCxjQUFMLENBQW9CLGdCQUFwQixDQUFyQjtBQUNBLFVBQUksQ0FBQ3k2RCxZQUFMLEVBQW1COztBQUVuQixVQUFNOTZDLFlBQVk4NkMsYUFBYUssWUFBYixFQUFsQjs7QUFFQSxhQUFRO0FBQUE7QUFBQTtBQUNOLGVBQUksUUFERTtBQUVOLGVBQUksV0FGRTtBQUdOO0FBQUE7QUFBQSxZQUFLLFdBQVUsYUFBZjtBQUNFO0FBQUE7QUFBQTtBQUNFLG1CQUFJLHVCQUROO0FBRUUsdUJBQVMsS0FBS2MsaUJBRmhCO0FBR0UsaUNBQWdCLFdBSGxCO0FBSUUscURBQUssS0FBSSxRQUFULEVBQWtCLEtBQUssS0FBSzFtRCxhQUFMLDBCQUEwQ3lLLFNBQTFDLFdBQTJELElBQTNELENBQXZCLEdBSkY7QUFLRTtBQUFBO0FBQUEsZ0JBQUssS0FBSSxTQUFUO0FBQW9CLG1CQUFLOUcsRUFBTCxDQUFRLDZCQUFSO0FBQXBCO0FBTEY7QUFERjtBQUhNLE9BQVI7QUFhRDs7QUFFRDs7Ozs7Ozs7NkNBSzBCO0FBQ3hCLGFBQVE7QUFBQTtBQUFBO0FBQ04sZUFBSSxRQURFO0FBRU4sZUFBSSxhQUZFO0FBR047QUFBQTtBQUFBLFlBQUssV0FBVSxhQUFmO0FBQ0U7QUFBQTtBQUFBO0FBQ0UsbUJBQUksdUJBRE47QUFFRSx1QkFBUyxLQUFLb2dELG1CQUZoQjtBQUdFLHFEQUFLLEtBQUksUUFBVCxFQUFrQixLQUFLLEtBQUsvakQsYUFBTCxDQUFtQixvQ0FBbkIsRUFBeUQsSUFBekQsQ0FBdkIsR0FIRjtBQUlFO0FBQUE7QUFBQSxnQkFBSyxLQUFJLFNBQVQ7QUFBb0IsbUJBQUsyRCxFQUFMLENBQVEsK0JBQVI7QUFBcEI7QUFKRjtBQURGO0FBSE0sT0FBUjtBQVlEOztBQUVEOzs7Ozs7O3FDQUlrQjtBQUNoQixVQUFJLEtBQUszaUIsS0FBTCxDQUFXNHRCLE9BQWYsRUFBd0IsT0FBTyw0Q0FBUDs7QUFFeEIsVUFBTWlELFlBQVksQ0FDaEIsS0FBSzgwQyxlQUFMLEVBRGdCLEVBRWhCLEtBQUtDLGVBQUwsRUFGZ0IsRUFHaEIsS0FBS0Msb0JBQUwsRUFIZ0IsQ0FBbEI7O0FBTUEsVUFBTXRCLGVBQWUsS0FBS3o2RCxjQUFMLENBQW9CLGdCQUFwQixDQUFyQjs7QUFFQSxVQUFNZzhELGtCQUFrQnZCLGFBQWF3QixRQUFiLEdBQXdCL2pFLEtBQXhCLEVBQXhCO0FBQ0EsVUFBTTBuQixrQkFBa0I2NkMsYUFBYXlCLGtCQUFiLEdBQWtDaGtFLEtBQWxDLEVBQXhCOztBQUVBLGFBQU8sQ0FDSjtBQUFBO0FBQUEsVUFBSyxLQUFJLGVBQVQ7QUFDQztBQUFDLHNDQUFEO0FBQUEsWUFBb0IsS0FBSSxXQUF4QjtBQUNFO0FBQUE7QUFBQSxjQUFJLEtBQUksU0FBUjtBQUNHNnVCO0FBREg7QUFERjtBQURELE9BREksRUFRSjtBQUFBO0FBQUEsVUFBSyxLQUFJLHNCQUFUO0FBQ0Msd0NBQUMsOEJBQUQ7QUFDRSx3QkFBY2kxQyxlQURoQjtBQUVFLGlCQUFPLEtBQUtuakQsRUFBTCxDQUFRLDhCQUFSLENBRlQ7QUFHRSxvQkFBVSxLQUFLc2pELHdCQUhqQjtBQURELE9BUkksRUFjSjtBQUFBO0FBQUEsVUFBSyxLQUFJLHNCQUFUO0FBQ0Msd0NBQUMsOEJBQUQ7QUFDRSx3QkFBY3Y4QyxlQURoQjtBQUVFLGlCQUFPLEtBQUsvRyxFQUFMLENBQVEsOEJBQVIsQ0FGVDtBQUdFLG9CQUFVLEtBQUt1akQsd0JBSGpCO0FBREQsT0FkSSxDQUFQO0FBcUJEOzs7O0VBdmVnRC9nRSwyQjs7a0JBQTlCbStELHFCOzs7QUEwZXJCQSxzQkFBc0JwK0QsWUFBdEIsR0FBcUNDLDRCQUFrQkQsWUFBdkQsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4ZkE7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQW5CQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBbUJxQmloRSwyQjs7O0FBQ25CLHlDQUFzQjtBQUFBOztBQUFBOztBQUFBLHNDQUFOL2dFLElBQU07QUFBTkEsVUFBTTtBQUFBOztBQUFBLHFMQUNYQSxJQURXOztBQUdwQixVQUFLa2MsTUFBTCxHQUFjLE1BQUtsZCxLQUFMLENBQVdtZCxZQUFYLENBQXdCdmYsS0FBeEIsRUFBZDtBQUNBLFFBQU1va0UsU0FBUyxNQUFLOWtELE1BQUwsQ0FBWStrRCxLQUFaLEVBQWY7QUFDQSxRQUFNQyxJQUFJRixPQUFPLENBQVAsQ0FBVjtBQUNBLFFBQU1yNkQsSUFBSXE2RCxPQUFPLENBQVAsQ0FBVjtBQUNBLFFBQU05MUIsSUFBSTgxQixPQUFPLENBQVAsQ0FBVjtBQUNBLFVBQUtHLElBQUwsR0FBWSxFQUFFRCxJQUFGLEVBQUt2NkQsSUFBTCxFQUFRdWtDLElBQVIsRUFBWjs7QUFFQSxVQUFLdndDLFFBQUwsQ0FDRSxpQkFERixFQUVFLGdCQUZGLEVBR0Usa0JBSEY7QUFWb0I7QUFlckI7O0FBRUQ7O0FBRUE7Ozs7Ozs7d0NBR3FCO0FBQ25COztBQUVBeUMsZUFBU0MsZ0JBQVQsQ0FBMEIsT0FBMUIsRUFBbUMsS0FBSytqRSxnQkFBeEM7QUFDRDs7QUFFRDs7Ozs7OzJDQUd3QjtBQUN0Qjs7QUFFQWhrRSxlQUFTSSxtQkFBVCxDQUE2QixPQUE3QixFQUFzQyxLQUFLNGpFLGdCQUEzQztBQUNEOztBQUVEOztBQUVBOzs7Ozs7Ozs7cUNBTWtCamxFLEMsRUFBRztBQUNuQixXQUFLLElBQUk4RixVQUFVOUYsRUFBRSs3QyxNQUFyQixFQUE2QmoyQyxPQUE3QixFQUFzQ0EsVUFBVUEsUUFBUTRWLFVBQXhELEVBQW9FO0FBQ2xFLFlBQUk1VixZQUFZLEtBQUt2RCxJQUFMLENBQVVDLElBQTFCLEVBQWdDO0FBQzlCO0FBQ0Q7QUFDRjtBQUNELFdBQUtLLEtBQUwsQ0FBV3FpRSxPQUFYLElBQ0UsS0FBS3JpRSxLQUFMLENBQVdxaUUsT0FBWCxFQURGO0FBRUQ7O0FBRUQ7Ozs7Ozs7OztvQ0FNaUJsbEUsQyxFQUFHO0FBQ2xCQSxRQUFFMEYsZUFBRjtBQUNEOztBQUVEOzs7Ozs7OzttQ0FLZ0J5TyxLLEVBQU87QUFDckIsV0FBSzRMLE1BQUwsR0FBYzVMLEtBQWQ7QUFDQSxXQUFLdFIsS0FBTCxDQUFXOEQsUUFBWCxJQUF1QixLQUFLOUQsS0FBTCxDQUFXOEQsUUFBWCxDQUFvQndOLEtBQXBCLENBQXZCO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7b0NBSWlCO0FBQ2YsVUFBSWd4RCx1QkFBSjtBQUNBLFVBQUksS0FBS3RpRSxLQUFMLENBQVdvZSxLQUFYLEtBQXFCLEtBQXpCLEVBQWdDO0FBQzlCa2tELHlCQUFpQixnQ0FBQyx3QkFBRDtBQUNmLHdCQUFjLEtBQUtwbEQsTUFESjtBQUVmLG9CQUFVLEtBQUtxbEQ7QUFGQSxVQUFqQjtBQUlEOztBQUVELGFBQVE7QUFBQTtBQUFBLFVBQUssS0FBSSwyQkFBVCxFQUFxQyxTQUFTLEtBQUtDLGVBQW5ELEVBQW9FLEtBQUksTUFBeEU7QUFDTEYsc0JBREs7QUFFTjtBQUFBO0FBQUEsWUFBSyxLQUFJLFVBQVQ7QUFDRSwwQ0FBQyw2QkFBRDtBQUNFLDBCQUFjLEtBQUtwbEQsTUFEckI7QUFFRSxzQkFBVSxLQUFLcWxEO0FBRmpCLFlBREY7QUFLRSwwQ0FBQyxzQkFBRDtBQUNFLDBCQUFjLEtBQUtybEQsTUFEckI7QUFFRSxzQkFBVSxLQUFLcWxEO0FBRmpCO0FBTEY7QUFGTSxPQUFSO0FBYUQ7Ozs7RUF4R3NEbHBFLHNCOztrQkFBcEMwb0UsMkI7OztBQTJHckJBLDRCQUE0QmpoRSxZQUE1QixHQUEyQ3pILHVCQUFjeUgsWUFBekQsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoSEE7O0FBQ0E7Ozs7Ozs7Ozs7K2VBakJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFpQnFCMmhFLGM7OztBQUNuQiw0QkFBc0I7QUFBQTs7QUFBQTs7QUFBQSxzQ0FBTnpoRSxJQUFNO0FBQU5BLFVBQU07QUFBQTs7QUFBQSwySkFDWEEsSUFEVzs7QUFHcEIsVUFBS3JGLFFBQUwsQ0FDRSxhQURGLEVBRUUsa0JBRkY7O0FBS0EsVUFBS3VoQixNQUFMLEdBQWMsTUFBS2xkLEtBQUwsQ0FBV21kLFlBQVgsQ0FBd0J2ZixLQUF4QixFQUFkO0FBQ0EsVUFBSzJmLHlCQUFMLEdBQWlDaGxCLGVBQU1pbEIsOEJBQU4sRUFBakM7QUFUb0I7QUFVckI7O0FBRUQ7O0FBRUE7Ozs7Ozs7d0NBR3FCO0FBQ25CO0FBQ0EsV0FBS3lXLGFBQUw7QUFDRDs7QUFFRDs7Ozs7Ozs7MENBS3VCeXVDLFEsRUFBVTtBQUFBLFVBQ3ZCdmxELFlBRHVCLEdBQ051bEQsUUFETSxDQUN2QnZsRCxZQUR1Qjs7QUFFL0IsVUFBSUEsaUJBQWlCLEtBQUtELE1BQTFCLEVBQWtDO0FBQ2hDLGFBQUtBLE1BQUwsR0FBY0MsYUFBYXZmLEtBQWIsRUFBZDtBQUNBLGFBQUtxMkIsYUFBTDtBQUNBLGVBQU8sSUFBUDtBQUNEO0FBQ0QsYUFBTyxLQUFQO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7OztxQ0FNa0IvcEIsUSxFQUFVL00sQyxFQUFHO0FBQzdCLFVBQUlBLEVBQUUrN0MsTUFBRixLQUFhLEtBQUt4NUMsSUFBTCxDQUFVaWpFLElBQTNCLEVBQWlDO0FBQy9CLGFBQUtDLGFBQUwsR0FBcUIsS0FBSzFsRCxNQUFMLENBQVk3VSxDQUFqQztBQUNELE9BRkQsTUFFTztBQUNMLGFBQUt3NkQscUJBQUwsQ0FBMkIzNEQsUUFBM0I7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7Z0NBTWEyUyxNLEVBQVExZixDLEVBQUc7QUFDdEIsVUFBTWdaLFNBQVMsS0FBS3pXLElBQUwsQ0FBVXlXLE1BQXpCO0FBQ0EsVUFBTTJzRCxjQUFjM3NELE9BQU94WixXQUEzQjs7QUFFQSxVQUFNb21FLGNBQWNsbUQsT0FBT3ZmLENBQVAsR0FBV3dsRSxXQUEvQjtBQUNBLFdBQUtFLFNBQUwsQ0FBZSxLQUFLSixhQUFMLEdBQXFCRyxXQUFwQztBQUNEOztBQUVEOztBQUVBOzs7Ozs7OztvQ0FLaUI7QUFDZixhQUFPO0FBQ0wva0UsY0FBTSxDQUFDLEtBQUtrZixNQUFMLENBQVk3VSxDQUFaLEdBQWdCLEdBQWpCLEVBQXNCd0MsT0FBdEIsQ0FBOEIsQ0FBOUIsSUFBbUMsR0FEcEM7QUFFTDVNLGFBQUs7QUFGQSxPQUFQO0FBSUQ7O0FBRUQ7O0FBRUE7Ozs7Ozs7OzhCQUtXb0ssQyxFQUFHO0FBQ1osV0FBSzZVLE1BQUwsQ0FBWTdVLENBQVosR0FBZ0JBLENBQWhCO0FBQ0EsV0FBSzZVLE1BQUwsQ0FBWTdVLENBQVosR0FBZ0JwUSxLQUFLMkcsR0FBTCxDQUFTLENBQVQsRUFBWTNHLEtBQUswRyxHQUFMLENBQVMsQ0FBVCxFQUFZLEtBQUt1ZSxNQUFMLENBQVk3VSxDQUF4QixDQUFaLENBQWhCO0FBQ0EsV0FBSzFDLFdBQUw7QUFDQSxXQUFLM0YsS0FBTCxDQUFXOEQsUUFBWCxJQUF1QixLQUFLOUQsS0FBTCxDQUFXOEQsUUFBWCxDQUFvQixLQUFLb1osTUFBekIsQ0FBdkI7QUFDRDs7QUFFRDs7Ozs7Ozs7MENBS3VCaFQsUSxFQUFVO0FBQy9CLFVBQU1pTSxTQUFTLEtBQUt6VyxJQUFMLENBQVV5VyxNQUF6QjtBQUNBLFdBQUt5c0QsYUFBTCxHQUFxQjE0RCxTQUFTNU0sQ0FBVCxHQUFhNlksT0FBT3haLFdBQXpDO0FBQ0EsV0FBS3FtRSxTQUFMLENBQWUsS0FBS0osYUFBcEI7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7OztvQ0FJaUI7QUFDZixVQUFNenNELFNBQVMsS0FBS3pXLElBQUwsQ0FBVXlXLE1BQXpCO0FBQ0EsVUFBTTdVLFVBQVU2VSxPQUFPbEIsVUFBUCxDQUFrQixJQUFsQixDQUFoQjs7QUFFQWtCLGFBQU8zVyxLQUFQLEdBQWUyVyxPQUFPeFosV0FBdEI7QUFDQXdaLGFBQU9oWCxNQUFQLEdBQWdCZ1gsT0FBT25aLFlBQXZCOztBQUVBO0FBQ0EsVUFBTTRnQixVQUFVdGMsUUFBUXVjLGFBQVIsQ0FBc0IsS0FBS04seUJBQTNCLEVBQXNELFFBQXRELENBQWhCO0FBQ0FqYyxjQUFRd2MsU0FBUixHQUFvQkYsT0FBcEI7QUFDQXRjLGNBQVF5YyxRQUFSLENBQWlCLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCNUgsT0FBTzNXLEtBQTlCLEVBQXFDMlcsT0FBT2hYLE1BQTVDOztBQUVBO0FBQ0EsVUFBTThqRSxXQUFXM2hFLFFBQVE0aEUsb0JBQVIsQ0FBNkIsQ0FBN0IsRUFBZ0MsQ0FBaEMsRUFBbUMvc0QsT0FBTzNXLEtBQTFDLEVBQWlEMlcsT0FBT2hYLE1BQXhELENBQWpCO0FBQ0EsVUFBSW1TLFFBQVEsS0FBSzRMLE1BQUwsQ0FBWXRmLEtBQVosRUFBWjtBQUNBMFQsWUFBTWpKLENBQU4sR0FBVSxDQUFWO0FBQ0E0NkQsZUFBU0UsWUFBVCxDQUFzQixDQUF0QixFQUF5Qjd4RCxNQUFNME0sTUFBTixFQUF6QjtBQUNBaWxELGVBQVNFLFlBQVQsQ0FBc0IsQ0FBdEIsRUFBeUIsS0FBS2ptRCxNQUFMLENBQVlrbUQsS0FBWixFQUF6Qjs7QUFFQTtBQUNBOWhFLGNBQVF3YyxTQUFSLEdBQW9CbWxELFFBQXBCO0FBQ0EzaEUsY0FBUXljLFFBQVIsQ0FBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsRUFBdUI1SCxPQUFPM1csS0FBOUIsRUFBcUMyVyxPQUFPaFgsTUFBNUM7QUFDRDs7QUFFRDs7Ozs7OztvQ0FJaUI7QUFDZixhQUFRO0FBQUE7QUFBQSxVQUFLLEtBQUkseUJBQVQ7QUFDTjtBQUFDLHNDQUFEO0FBQUE7QUFDRSxxQkFBUyxLQUFLaU0sZ0JBRGhCO0FBRUUsb0JBQVEsS0FBS0MsV0FGZjtBQUdFO0FBQUE7QUFBQTtBQUNFLHdEQUFRLEtBQUksVUFBWixFQUF1QixLQUFJLFFBQTNCLEdBREY7QUFFRTtBQUNFLG1CQUFJLDhCQUROO0FBRUUsbUJBQUksTUFGTjtBQUdFLHFCQUFPLEtBQUtFLGFBQUwsRUFIVDtBQUZGO0FBSEY7QUFETSxPQUFSO0FBYUQ7Ozs7RUEzSnlDbFMsc0I7O2tCQUF2Qm9wRSxjOzs7QUE4SnJCQSxlQUFlM2hFLFlBQWYsR0FBOEJ6SCx1QkFBY3lILFlBQTVDLEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaktBOztBQUNBOzs7Ozs7Ozs7OytlQWpCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBaUJxQnVpRSxtQjs7O0FBQ25CLGlDQUFzQjtBQUFBOztBQUFBOztBQUFBLHNDQUFOcmlFLElBQU07QUFBTkEsVUFBTTtBQUFBOztBQUFBLHFLQUNYQSxJQURXOztBQUdwQixVQUFLckYsUUFBTCxDQUNFLGFBREYsRUFFRSxrQkFGRjs7QUFLQSxVQUFLdWhCLE1BQUwsR0FBYyxNQUFLbGQsS0FBTCxDQUFXbWQsWUFBWCxDQUF3QnZmLEtBQXhCLEVBQWQ7QUFDQSxRQUFNb2tFLFNBQVMsTUFBSzlrRCxNQUFMLENBQVkra0QsS0FBWixFQUFmO0FBQ0EsUUFBTUMsSUFBSUYsT0FBTyxDQUFQLENBQVY7QUFDQSxRQUFNcjZELElBQUlxNkQsT0FBTyxDQUFQLENBQVY7QUFDQSxRQUFNOTFCLElBQUk4MUIsT0FBTyxDQUFQLENBQVY7QUFDQSxVQUFLc0IsU0FBTCxHQUFpQixFQUFFcEIsSUFBRixFQUFLdjZELElBQUwsRUFBUXVrQyxJQUFSLEVBQWpCO0FBYm9CO0FBY3JCOztBQUVEOztBQUVBOzs7Ozs7O3dDQUdxQjtBQUNuQjtBQUNBLFdBQUtqWSxhQUFMO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OzBDQUt1Qnl1QyxRLEVBQVU7QUFBQSxVQUN2QnZsRCxZQUR1QixHQUNOdWxELFFBRE0sQ0FDdkJ2bEQsWUFEdUI7O0FBRS9CLFVBQUlBLGlCQUFpQixLQUFLRCxNQUExQixFQUFrQztBQUNoQyxhQUFLQSxNQUFMLEdBQWNDLGFBQWF2ZixLQUFiLEVBQWQ7QUFDQSxZQUFNb2tFLFNBQVMsS0FBSzlrRCxNQUFMLENBQVkra0QsS0FBWixFQUFmO0FBQ0EsWUFBTUMsSUFBSUYsT0FBTyxDQUFQLENBQVY7QUFDQSxZQUFNcjZELElBQUlxNkQsT0FBTyxDQUFQLENBQVY7QUFDQSxZQUFNOTFCLElBQUk4MUIsT0FBTyxDQUFQLENBQVY7QUFDQSxhQUFLc0IsU0FBTCxHQUFpQixFQUFFcEIsSUFBRixFQUFLdjZELElBQUwsRUFBUXVrQyxJQUFSLEVBQWpCO0FBQ0EsYUFBS2pZLGFBQUw7QUFDQSxlQUFPLElBQVA7QUFDRDtBQUNELGFBQU8sS0FBUDtBQUNEOztBQUVEOztBQUVBOzs7Ozs7Ozs7cUNBTWtCL3BCLFEsRUFBVS9NLEMsRUFBRztBQUM3QixVQUFJQSxFQUFFKzdDLE1BQUYsS0FBYSxLQUFLeDVDLElBQUwsQ0FBVWlqRSxJQUEzQixFQUFpQztBQUMvQixhQUFLWSxhQUFMLEdBQXFCLEtBQUtELFNBQUwsQ0FBZXAzQixDQUFwQztBQUNBLGFBQUtzM0Isa0JBQUwsR0FBMEIsS0FBS0YsU0FBTCxDQUFlMzdELENBQXpDO0FBQ0QsT0FIRCxNQUdPO0FBQ0wsYUFBSzg3RCxzQkFBTCxDQUE0QnY1RCxRQUE1QjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OztnQ0FNYTJTLE0sRUFBUTFmLEMsRUFBRztBQUFBLFVBQ2RnWixNQURjLEdBQ0gsS0FBS3pXLElBREYsQ0FDZHlXLE1BRGM7O0FBRXRCLFVBQU0yc0QsY0FBYzNzRCxPQUFPeFosV0FBM0I7QUFDQSxVQUFNK21FLGVBQWV2dEQsT0FBT25aLFlBQTVCOztBQUVBLFVBQU0ybUUsbUJBQW1COW1ELE9BQU92ZixDQUFQLEdBQVd3bEUsV0FBcEM7QUFDQSxVQUFNYyxjQUFjL21ELE9BQU90ZixDQUFQLEdBQVdtbUUsWUFBWCxHQUEwQixDQUFDLENBQS9DOztBQU5zQixVQVFoQnhCLENBUmdCLEdBUVYsS0FBS29CLFNBUkssQ0FRaEJwQixDQVJnQjs7QUFTdEIsV0FBSzJCLE9BQUwsQ0FDRTNCLENBREYsRUFFRSxLQUFLc0Isa0JBQUwsR0FBMEJHLGdCQUY1QixFQUdFLEtBQUtKLGFBQUwsR0FBcUJLLFdBSHZCO0FBS0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7O29DQUtpQjtBQUFBLHNCQUNFLEtBQUtOLFNBRFA7QUFBQSxVQUNQMzdELENBRE8sYUFDUEEsQ0FETztBQUFBLFVBQ0p1a0MsQ0FESSxhQUNKQSxDQURJOzs7QUFHZixhQUFPO0FBQ0xsdUMsY0FBTSxDQUFDMkosSUFBSSxHQUFMLEVBQVVrRCxPQUFWLENBQWtCLENBQWxCLElBQXVCLEdBRHhCO0FBRUw1TSxhQUFLLENBQUMsQ0FBQyxJQUFJaXVDLENBQUwsSUFBVSxHQUFYLEVBQWdCcmhDLE9BQWhCLENBQXdCLENBQXhCLElBQTZCO0FBRjdCLE9BQVA7QUFJRDs7QUFFRDs7QUFFQTs7Ozs7Ozs7Ozs0QkFPU3EzRCxDLEVBQUd2NkQsQyxFQUFHdWtDLEMsRUFBRztBQUNoQnZrQyxVQUFJMVAsS0FBSzBHLEdBQUwsQ0FBUyxJQUFULEVBQWUxRyxLQUFLMkcsR0FBTCxDQUFTK0ksQ0FBVCxFQUFZLElBQVosQ0FBZixDQUFKO0FBQ0F1a0MsVUFBSWowQyxLQUFLMEcsR0FBTCxDQUFTLElBQVQsRUFBZTFHLEtBQUsyRyxHQUFMLENBQVNzdEMsQ0FBVCxFQUFZLElBQVosQ0FBZixDQUFKO0FBQ0EsV0FBS2h2QixNQUFMLEdBQWNubEIsZUFBTStyRSxPQUFOLENBQWM1QixDQUFkLEVBQWlCdjZELENBQWpCLEVBQW9CdWtDLENBQXBCLEVBQXVCLEtBQUtodkIsTUFBTCxDQUFZN1UsQ0FBbkMsQ0FBZDtBQUNBLFdBQUtpN0QsU0FBTCxHQUFpQixFQUFFcEIsSUFBRixFQUFLdjZELElBQUwsRUFBUXVrQyxJQUFSLEVBQWpCOztBQUVBLFdBQUt2bUMsV0FBTDtBQUNBLFdBQUszRixLQUFMLENBQVc4RCxRQUFYLElBQXVCLEtBQUs5RCxLQUFMLENBQVc4RCxRQUFYLENBQW9CLEtBQUtvWixNQUF6QixDQUF2QjtBQUNEOztBQUVEOzs7Ozs7OzsyQ0FLd0JoVCxRLEVBQVU7QUFBQSxVQUN4QmlNLE1BRHdCLEdBQ2IsS0FBS3pXLElBRFEsQ0FDeEJ5VyxNQUR3Qjs7QUFFaEMsV0FBS3F0RCxrQkFBTCxHQUEwQnQ1RCxTQUFTNU0sQ0FBVCxHQUFhNlksT0FBT3haLFdBQTlDO0FBQ0EsV0FBSzRtRSxhQUFMLEdBQXFCLElBQUtyNUQsU0FBUzNNLENBQVQsR0FBYTRZLE9BQU9uWixZQUE5Qzs7QUFIZ0MsVUFLMUJrbEUsQ0FMMEIsR0FLcEIsS0FBS29CLFNBTGUsQ0FLMUJwQixDQUwwQjs7QUFNaEMsV0FBSzJCLE9BQUwsQ0FDRTNCLENBREYsRUFFRSxLQUFLc0Isa0JBRlAsRUFHRSxLQUFLRCxhQUhQO0FBS0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7b0NBSWlCO0FBQUEsVUFDUHB0RCxNQURPLEdBQ0ksS0FBS3pXLElBRFQsQ0FDUHlXLE1BRE87O0FBRWYsVUFBTTdVLFVBQVU2VSxPQUFPbEIsVUFBUCxDQUFrQixJQUFsQixDQUFoQjs7QUFFQWtCLGFBQU8zVyxLQUFQLEdBQWUyVyxPQUFPeFosV0FBdEI7QUFDQXdaLGFBQU9oWCxNQUFQLEdBQWdCZ1gsT0FBT25aLFlBQXZCOztBQUVBLFVBQUlxWixZQUFZL1UsUUFBUXlpRSxZQUFSLENBQXFCLENBQXJCLEVBQXdCLENBQXhCLEVBQTJCNXRELE9BQU8zVyxLQUFsQyxFQUF5QzJXLE9BQU9oWCxNQUFoRCxDQUFoQjs7QUFFQSxXQUFLLElBQUk1QixJQUFJLENBQWIsRUFBZ0JBLElBQUk0WSxPQUFPaFgsTUFBM0IsRUFBbUM1QixHQUFuQyxFQUF3QztBQUN0QyxZQUFNc0csUUFBUSxDQUFDc1MsT0FBT2hYLE1BQVAsR0FBZ0I1QixDQUFqQixJQUFzQjRZLE9BQU9oWCxNQUEzQztBQUNBLGFBQUssSUFBSTdCLElBQUksQ0FBYixFQUFnQkEsSUFBSTZZLE9BQU8zVyxLQUEzQixFQUFrQ2xDLEdBQWxDLEVBQXVDO0FBQ3JDLGNBQU1nN0IsYUFBYWg3QixJQUFJNlksT0FBTzNXLEtBQTlCO0FBQ0EsY0FBTThSLFFBQVF2WixlQUFNK3JFLE9BQU4sQ0FBYyxLQUFLUixTQUFMLENBQWVwQixDQUE3QixFQUFnQzVwQyxVQUFoQyxFQUE0Q3owQixLQUE1QyxDQUFkO0FBRnFDLGNBRzdCaVIsQ0FINkIsR0FHZHhELEtBSGMsQ0FHN0J3RCxDQUg2QjtBQUFBLGNBRzFCa3ZELENBSDBCLEdBR2QxeUQsS0FIYyxDQUcxQjB5RCxDQUgwQjtBQUFBLGNBR3ZCMTdELENBSHVCLEdBR2RnSixLQUhjLENBR3ZCaEosQ0FIdUI7QUFBQSxjQUdwQkQsQ0FIb0IsR0FHZGlKLEtBSGMsQ0FHcEJqSixDQUhvQjs7O0FBS3JDLGNBQU1yTixRQUFRLENBQUN1QyxJQUFJNFksT0FBTzNXLEtBQVgsR0FBbUJsQyxDQUFwQixJQUF5QixDQUF2Qzs7QUFFQStZLG9CQUFVaGMsSUFBVixDQUFlVyxLQUFmLElBQXdCOFosSUFBSSxHQUE1QjtBQUNBdUIsb0JBQVVoYyxJQUFWLENBQWVXLFFBQVEsQ0FBdkIsSUFBNEJncEUsSUFBSSxHQUFoQztBQUNBM3RELG9CQUFVaGMsSUFBVixDQUFlVyxRQUFRLENBQXZCLElBQTRCc04sSUFBSSxHQUFoQztBQUNBK04sb0JBQVVoYyxJQUFWLENBQWVXLFFBQVEsQ0FBdkIsSUFBNEJxTixJQUFJLEdBQWhDO0FBQ0Q7QUFDRjs7QUFFRC9HLGNBQVFpVixZQUFSLENBQXFCRixTQUFyQixFQUFnQyxDQUFoQyxFQUFtQyxDQUFuQztBQUNEOztBQUVEOzs7Ozs7O29DQUlpQjtBQUNmLGFBQVE7QUFBQTtBQUFBLFVBQUssS0FBSSw4QkFBVDtBQUNOO0FBQUMsc0NBQUQ7QUFBQTtBQUNFLHFCQUFTLEtBQUtqTCxnQkFEaEI7QUFFRSxvQkFBUSxLQUFLQyxXQUZmO0FBR0U7QUFBQTtBQUFBO0FBQ0Usd0RBQVEsS0FBSSxVQUFaLEVBQXVCLEtBQUksUUFBM0IsR0FERjtBQUVFO0FBQ0UsbUJBQUksOEJBRE47QUFFRSxtQkFBSSxNQUZOO0FBR0UscUJBQU8sS0FBS0UsYUFBTCxFQUhUO0FBRkY7QUFIRjtBQURNLE9BQVI7QUFhRDs7OztFQS9MOENsUyxzQjs7a0JBQTVCZ3FFLG1COzs7QUFrTXJCQSxvQkFBb0J2aUUsWUFBcEIsR0FBbUN6SCx1QkFBY3lILFlBQWpELEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDck1BOztBQUNBOzs7Ozs7Ozs7OytlQWpCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBaUJxQm1qRSxZOzs7QUFDbkIsMEJBQXNCO0FBQUE7O0FBQUE7O0FBQUEsc0NBQU5qakUsSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEsdUpBQ1hBLElBRFc7O0FBR3BCLFVBQUtyRixRQUFMLENBQ0UsYUFERixFQUVFLGtCQUZGOztBQUtBLFVBQUt1aEIsTUFBTCxHQUFjLE1BQUtsZCxLQUFMLENBQVdtZCxZQUFYLENBQXdCdmYsS0FBeEIsRUFBZDtBQUNBLFFBQU1va0UsU0FBUyxNQUFLOWtELE1BQUwsQ0FBWStrRCxLQUFaLEVBQWY7QUFDQSxRQUFNQyxJQUFJRixPQUFPLENBQVAsQ0FBVjtBQUNBLFFBQU1yNkQsSUFBSXE2RCxPQUFPLENBQVAsQ0FBVjtBQUNBLFFBQU05MUIsSUFBSTgxQixPQUFPLENBQVAsQ0FBVjtBQUNBLFVBQUtzQixTQUFMLEdBQWlCLEVBQUVwQixJQUFGLEVBQUt2NkQsSUFBTCxFQUFRdWtDLElBQVIsRUFBakI7O0FBRUEsVUFBS3R3QyxLQUFMLEdBQWE7QUFDWGlJLGFBQU8sTUFBSzdELEtBQUwsQ0FBV21kO0FBRFAsS0FBYjtBQWZvQjtBQWtCckI7O0FBRUQ7O0FBRUE7Ozs7Ozs7d0NBR3FCO0FBQ25CO0FBQ0EsV0FBSzhXLGFBQUw7QUFDRDs7QUFFRDs7Ozs7Ozs7MENBS3VCeXVDLFEsRUFBVTtBQUFBLFVBQ3ZCdmxELFlBRHVCLEdBQ051bEQsUUFETSxDQUN2QnZsRCxZQUR1Qjs7QUFFL0IsVUFBSUEsaUJBQWlCLEtBQUtELE1BQTFCLEVBQWtDO0FBQ2hDLGFBQUtBLE1BQUwsR0FBY0MsYUFBYXZmLEtBQWIsRUFBZDtBQUNBLFlBQU1va0UsU0FBUyxLQUFLOWtELE1BQUwsQ0FBWStrRCxLQUFaLEVBQWY7QUFDQSxZQUFNQyxJQUFJRixPQUFPLENBQVAsQ0FBVjtBQUNBLFlBQU1yNkQsSUFBSXE2RCxPQUFPLENBQVAsQ0FBVjtBQUNBLFlBQU05MUIsSUFBSTgxQixPQUFPLENBQVAsQ0FBVjtBQUNBLGFBQUtzQixTQUFMLEdBQWlCLEVBQUVwQixJQUFGLEVBQUt2NkQsSUFBTCxFQUFRdWtDLElBQVIsRUFBakI7QUFDQSxhQUFLalksYUFBTDtBQUNBLGVBQU8sSUFBUDtBQUNEO0FBQ0QsYUFBTyxLQUFQO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7OztxQ0FNa0IvcEIsUSxFQUFVL00sQyxFQUFHO0FBQzdCLFVBQUlBLEVBQUUrN0MsTUFBRixLQUFhLEtBQUt4NUMsSUFBTCxDQUFVaWpFLElBQTNCLEVBQWlDO0FBQy9CLGFBQUt1QixXQUFMLEdBQW1CLEtBQUtaLFNBQUwsQ0FBZXBCLENBQWxDO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsYUFBS2lDLHFCQUFMLENBQTJCajZELFFBQTNCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7O2dDQU1hMlMsTSxFQUFRMWYsQyxFQUFHO0FBQUEsVUFDZGdaLE1BRGMsR0FDSCxLQUFLelcsSUFERixDQUNkeVcsTUFEYzs7QUFFdEIsVUFBTXV0RCxlQUFldnRELE9BQU9uWixZQUE1Qjs7QUFFQSxVQUFNb25FLFlBQVl2bkQsT0FBT3RmLENBQVAsR0FBV21tRSxZQUE3QjtBQUNBLFdBQUtXLE9BQUwsQ0FBYSxLQUFLSCxXQUFMLEdBQW1CRSxTQUFoQztBQUNEOztBQUVEOztBQUVBOzs7Ozs7OztvQ0FLaUI7QUFDZixhQUFPO0FBQ0xwbUUsY0FBTSxLQUREO0FBRUxDLGFBQUssQ0FBQyxLQUFLcWxFLFNBQUwsQ0FBZXBCLENBQWYsR0FBbUIsR0FBcEIsRUFBeUJyM0QsT0FBekIsQ0FBaUMsQ0FBakMsSUFBc0M7QUFGdEMsT0FBUDtBQUlEOztBQUVEOztBQUVBOzs7Ozs7Ozs0QkFLU3EzRCxDLEVBQUc7QUFBQSxzQkFDSyxLQUFLb0IsU0FEVjtBQUFBLFVBQ0ozN0QsQ0FESSxhQUNKQSxDQURJO0FBQUEsVUFDRHVrQyxDQURDLGFBQ0RBLENBREM7O0FBRVZnMkIsVUFBSWpxRSxLQUFLMkcsR0FBTCxDQUFTLENBQVQsRUFBWTNHLEtBQUswRyxHQUFMLENBQVMsQ0FBVCxFQUFZdWpFLENBQVosQ0FBWixDQUFKO0FBQ0F2NkQsVUFBSTFQLEtBQUswRyxHQUFMLENBQVMsSUFBVCxFQUFlMUcsS0FBSzJHLEdBQUwsQ0FBUytJLENBQVQsRUFBWSxJQUFaLENBQWYsQ0FBSjtBQUNBdWtDLFVBQUlqMEMsS0FBSzBHLEdBQUwsQ0FBUyxJQUFULEVBQWUxRyxLQUFLMkcsR0FBTCxDQUFTc3RDLENBQVQsRUFBWSxJQUFaLENBQWYsQ0FBSjs7QUFFQSxXQUFLaHZCLE1BQUwsR0FBY25sQixlQUFNK3JFLE9BQU4sQ0FBYzVCLENBQWQsRUFBaUJ2NkQsQ0FBakIsRUFBb0J1a0MsQ0FBcEIsRUFBdUIsS0FBS2h2QixNQUFMLENBQVk3VSxDQUFuQyxDQUFkO0FBQ0EsV0FBS2k3RCxTQUFMLEdBQWlCLEVBQUVwQixJQUFGLEVBQUt2NkQsSUFBTCxFQUFRdWtDLElBQVIsRUFBakI7QUFDQSxXQUFLdm1DLFdBQUw7QUFDQSxXQUFLM0YsS0FBTCxDQUFXOEQsUUFBWCxJQUF1QixLQUFLOUQsS0FBTCxDQUFXOEQsUUFBWCxDQUFvQixLQUFLb1osTUFBekIsQ0FBdkI7QUFDRDs7QUFFRDs7Ozs7Ozs7MENBS3VCaFQsUSxFQUFVO0FBQUEsVUFDdkJpTSxNQUR1QixHQUNaLEtBQUt6VyxJQURPLENBQ3ZCeVcsTUFEdUI7O0FBRS9CLFdBQUsrdEQsV0FBTCxHQUFtQmg2RCxTQUFTM00sQ0FBVCxHQUFhNFksT0FBT25aLFlBQXZDO0FBQ0EsV0FBS3FuRSxPQUFMLENBQWEsS0FBS0gsV0FBbEI7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7OztvQ0FJaUI7QUFBQSxVQUNQL3RELE1BRE8sR0FDSSxLQUFLelcsSUFEVCxDQUNQeVcsTUFETzs7QUFFZixVQUFNN1UsVUFBVTZVLE9BQU9sQixVQUFQLENBQWtCLElBQWxCLENBQWhCOztBQUVBa0IsYUFBTzNXLEtBQVAsR0FBZTJXLE9BQU94WixXQUF0QjtBQUNBd1osYUFBT2hYLE1BQVAsR0FBZ0JnWCxPQUFPblosWUFBdkI7O0FBRUEsV0FBSyxJQUFJTyxJQUFJLENBQWIsRUFBZ0JBLElBQUk0WSxPQUFPaFgsTUFBM0IsRUFBbUM1QixHQUFuQyxFQUF3QztBQUN0QyxZQUFNKzJDLFFBQVEvMkMsSUFBSTRZLE9BQU9oWCxNQUF6QjtBQUNBLFlBQU1tUyxRQUFRdlosZUFBTStyRSxPQUFOLENBQWN4dkIsS0FBZCxFQUFxQixDQUFyQixFQUF3QixDQUF4QixDQUFkOztBQUVBaHpDLGdCQUFRZ2pFLFdBQVIsR0FBc0JoekQsTUFBTTBNLE1BQU4sRUFBdEI7QUFDQTFjLGdCQUFRODFDLFNBQVI7QUFDQTkxQyxnQkFBUSsxQyxNQUFSLENBQWUsQ0FBZixFQUFrQjk1QyxDQUFsQjtBQUNBK0QsZ0JBQVFpMkMsTUFBUixDQUFlcGhDLE9BQU8zVyxLQUF0QixFQUE2QmpDLENBQTdCO0FBQ0ErRCxnQkFBUWlqRSxNQUFSO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7OztvQ0FJaUI7QUFDZixhQUFRO0FBQUE7QUFBQSxVQUFLLEtBQUksdUJBQVQ7QUFDTjtBQUFDLHNDQUFEO0FBQUE7QUFDRSxxQkFBUyxLQUFLbjVELGdCQURoQjtBQUVFLG9CQUFRLEtBQUtDLFdBRmY7QUFHRTtBQUFBO0FBQUE7QUFDRSx3REFBUSxLQUFJLFVBQVosRUFBdUIsS0FBSSxRQUEzQixHQURGO0FBRUU7QUFDRSxtQkFBSSw4QkFETjtBQUVFLG1CQUFJLE1BRk47QUFHRSxxQkFBTyxLQUFLRSxhQUFMLEVBSFQ7QUFGRjtBQUhGO0FBRE0sT0FBUjtBQWFEOzs7O0VBeEt1Q2xTLHNCOztrQkFBckI0cUUsWTs7O0FBMktyQkEsYUFBYW5qRSxZQUFiLEdBQTRCekgsdUJBQWN5SCxZQUExQyxDOzs7Ozs7Ozs7Ozs7Ozs7QUM5S0E7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFsQkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztJQWtCcUIwakUsYTs7Ozs7Ozs7Ozs7O0FBQ25COztBQUVBOzs7Ozs7cUNBTWtCbjBELFMsRUFBV2xULEMsRUFBRztBQUM5QixXQUFLNkMsS0FBTCxDQUFXOEQsUUFBWCxJQUNFLEtBQUs5RCxLQUFMLENBQVc4RCxRQUFYLENBQW9CdU0sU0FBcEIsQ0FERjtBQUVEOztBQUVEOztBQUVBOzs7Ozs7Ozt1Q0FLb0I7QUFBQTs7QUFBQSxVQUNWUixLQURVLEdBQ0EsS0FBSzdQLEtBREwsQ0FDVjZQLEtBRFU7OztBQUdsQixhQUFPQSxNQUFNMUgsR0FBTixDQUFVLGdCQUFRO0FBQUEsWUFDZnM4RCxrQkFEZSxHQUNRLE9BQUt6a0UsS0FEYixDQUNmeWtFLGtCQURlOzs7QUFHdkIsZUFBT3YwRCxLQUFLZSxhQUFMLEdBQ0o5SSxHQURJLENBQ0EscUJBQWE7QUFDaEIsY0FBTXNHLGFBQWFnMkQsdUJBQXVCcDBELFVBQVVVLGFBQVYsRUFBMUM7QUFDQSxjQUFNc04sWUFBWTVQLGFBQWEsV0FBYixHQUEyQixJQUE3Qzs7QUFFQSxpQkFBUTtBQUFBO0FBQUE7QUFDTixtQkFBSSxRQURFO0FBRU4sbUJBQUs0QixVQUFVVSxhQUFWLEVBRkM7QUFHTix5QkFBV3NOLFNBSEw7QUFJTix1QkFBUyxPQUFLcW1ELGdCQUFMLENBQXNCMXJFLElBQXRCLENBQTJCLE1BQTNCLEVBQWlDcVgsU0FBakMsQ0FKSDtBQUtOLDRDQUFDLDhCQUFEO0FBQ0UsMEJBQVlBLFVBQVV3TyxhQUFWLEVBRGQ7QUFFRSwwQkFBWXhPLFVBQVUyVixhQUFWLEVBRmQ7QUFHRSx5QkFBVzNWLFVBQVU2dkQsWUFBVixFQUhiLEdBTE07QUFTTjtBQUFBO0FBQUEsZ0JBQUssS0FBSSxTQUFUO0FBQW9CaHdELG1CQUFLMk8sYUFBTDtBQUFwQjtBQVRNLFdBQVI7QUFXRCxTQWhCSSxDQUFQO0FBaUJELE9BcEJNLENBQVA7QUFxQkQ7O0FBRUQ7O0FBRUE7Ozs7Ozs7b0NBSWlCO0FBQ2YsVUFBTTROLFlBQVksS0FBS0MsZ0JBQUwsRUFBbEI7O0FBRUEsYUFBUTtBQUFBO0FBQUEsVUFBSyxLQUFJLHNDQUFUO0FBQ047QUFBQyxzQ0FBRDtBQUFBO0FBQ0U7QUFBQTtBQUFBLGNBQUksS0FBSSxzQkFBUjtBQUNHRDtBQURIO0FBREY7QUFETSxPQUFSO0FBT0Q7Ozs7RUEvRHdDcHpCLHNCOztrQkFBdEJtckUsYTs7O0FBa0VyQkEsY0FBYzFqRSxZQUFkLEdBQTZCekgsdUJBQWN5SCxZQUEzQyxDOzs7Ozs7Ozs7Ozs7O0FDdkVBOzs7Ozs7K2VBZkE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFnQnFCeVAsSTs7Ozs7Ozs7OztFQUFhc2tCLDRCOztBQUVsQzs7Ozs7OztrQkFGcUJ0a0IsSTtBQU9yQkEsS0FBS2dMLFNBQUwsQ0FBZTZJLGdCQUFmLEdBQWtDO0FBQ2hDalUsY0FBWSxFQUFFbFcsTUFBTTdCLDJCQUFXMDhCLE1BQW5CLEVBQTJCQyxVQUFVLElBQXJDLEVBRG9CO0FBRWhDM2tCLGNBQVksRUFBRW5XLE1BQU03QiwyQkFBV3VzRSxLQUFuQixFQUEwQjV2QyxVQUFVLElBQXBDO0FBRm9CLENBQWxDLEM7Ozs7Ozs7Ozs7Ozs7OztBQ1RBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFsQkE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7Ozs7OztJQU1NNnZDLGE7Ozs7Ozs7Ozs7OztBQUNKOzs7Ozs7NkJBTWlCO0FBQUEsVUFDUHppRSxNQURPLEdBQ0ksS0FBS2IsT0FEVCxDQUNQYSxNQURPOzs7QUFHZkEsYUFBT29yQixJQUFQLENBQVlrcUIsT0FBWjtBQUNBdDFDLGFBQU95ckIsUUFBUCxDQUFnQisvQixNQUFoQixDQUF1QixNQUF2QixFQUErQixNQUEvQjtBQUNBeHJELGFBQU9tTCxNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7OzRCQVFnQndCLFcsRUFBYWxOLE8sRUFBUztBQUFBLFVBQzVCTyxNQUQ0QixHQUNqQixLQUFLYixPQURZLENBQzVCYSxNQUQ0Qjs7O0FBR3BDQSxhQUFPb3JCLElBQVAsQ0FBWTRwQixJQUFaO0FBQ0FoMUMsYUFBT29yQixJQUFQLENBQVkvckIsR0FBWixDQUFnQixNQUFoQixFQUF3QixZQUFNO0FBQzVCO0FBQ0FXLGVBQU9tTCxNQUFQO0FBQ0QsT0FIRDs7QUFLQSxVQUFNUSxtQkFBbUIzTCxPQUFPNEwsbUJBQVAsRUFBekI7QUFDQSxVQUFNbkIseUJBQXlCekssT0FBT29LLFVBQVAsQ0FBa0IrVSxNQUFsQixDQUF5QixRQUF6QixDQUEvQjtBQUNBLFVBQU1qVixZQUFZbEssT0FBT29LLFVBQVAsQ0FBa0JDLFdBQWxCLENBQThCLFFBQTlCLENBQWxCO0FBQ0EsVUFBTXlULFFBQVE1VCxVQUFVOHVCLFdBQVYsRUFBZDtBQUNBLFVBQU10dUIsaUJBQWlCUixVQUFVaXJCLGdCQUFWLENBQTJCaGtCLFNBQTNCLEVBQXNDLElBQXRDLENBQXZCO0FBQ0FqSCxnQkFBVXlxRCxTQUFWLENBQW9CNzJDLEtBQXBCOztBQUVBLFVBQUlyWCxPQUFPM1EsS0FBSzBHLEdBQUwsQ0FBU21QLGlCQUFpQmxQLEdBQWpCLEtBQXlCLElBQWxDLEVBQXdDLENBQXhDLENBQVg7QUFDQSxVQUFJZ0QsUUFBUWlqRSxXQUFSLElBQXVCampFLFFBQVFpakUsV0FBUixDQUFvQjc4RCxNQUFwQixHQUE2QixDQUF4RCxFQUEyRDtBQUN6RFksZUFBT2hILFFBQVFpakUsV0FBUixDQUFvQixDQUFwQixDQUFQO0FBQ0Q7O0FBRUQsVUFBTXZ6RCxRQUFRLElBQUl2WixjQUFKLENBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsQ0FBZDtBQUNBLFVBQU1xb0IsV0FBVyxDQUFqQjs7QUFFQSxXQUFLelQsY0FBTCxDQUFvQjtBQUNsQkMsc0RBRGtCLEVBQ01QLG9CQUROLEVBQ2lCNFQsWUFEakIsRUFDd0JwVCw4QkFEeEIsRUFDd0NqRSxVQUR4QyxFQUM4QzBJLFlBRDlDLEVBQ3FEOE87QUFEckQsT0FBcEI7QUFHRDs7QUFFRDs7Ozs7Ozs7OztnQ0FPb0JqZSxNLEVBQVE7QUFDMUIsYUFBT0EsT0FBT3l1QixhQUFQLENBQXFCLE9BQXJCLEtBQ0x6dUIsT0FBTytuRCxhQUFQLENBQXFCLE9BQXJCLENBREY7QUFFRDs7QUFFRDs7Ozs7Ozs7dUNBSzJCO0FBQ3pCLGFBQU8sRUFBUDtBQUdEOzs7O0VBekV5QnRwQixrQjs7QUE0RTVCOzs7Ozs7O0FBS0Fna0MsY0FBY3ZpRSxpQkFBZCxHQUFrQ3lpRSxnQ0FBbEM7O0FBRUE7Ozs7OztBQU1BRixjQUFjdGlFLHVCQUFkLEdBQXdDeWlFLHNDQUF4Qzs7QUFFQTs7Ozs7QUFLQUgsY0FBY3hqRSxVQUFkLEdBQTJCLE9BQTNCOztBQUVBOzs7OztBQUtBd2pFLGNBQWNyaUUsUUFBZCxHQUF5Qiw2QkFBekI7O0FBRUE7Ozs7O0FBS0FxaUUsY0FBY3BpRSxXQUFkLEdBQTRCLHdCQUE1Qjs7QUFFQTs7OztBQUlBb2lFLGNBQWNuaUUsY0FBZCxHQUErQjtBQUM3Qm9pRSxlQUFhOztBQUdmOzs7O0FBSitCLENBQS9CLENBUUFELGNBQWNoYixrQkFBZCxHQUFtQyxDQUFDLFFBQUQsQ0FBbkM7O2tCQUVlZ2IsYTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4SWY7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7OytlQXJCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBcUJxQkUsc0I7OztBQUNuQixvQ0FBc0I7QUFBQTs7QUFBQTs7QUFBQSxzQ0FBTjlqRSxJQUFNO0FBQU5BLFVBQU07QUFBQTs7QUFBQSwyS0FDWEEsSUFEVzs7QUFHcEIsVUFBS0UsY0FBTCxHQUFzQixLQUF0QjtBQUNBLFVBQUs4akUsYUFBTCxHQUFxQjtBQUNuQnA4RCxZQUFNLE1BQUtsRCxjQUFMLENBQW9CLE1BQXBCLENBRGE7QUFFbkI0TCxhQUFPLE1BQUs1TCxjQUFMLENBQW9CLE9BQXBCLEVBQTZCOUgsS0FBN0I7QUFGWSxLQUFyQjs7QUFLQSxVQUFLcW5FLFdBQUwsR0FBbUIsTUFBS2psRSxLQUFMLENBQVc0QixPQUFYLENBQW1CaWpFLFdBQW5CLElBQ2pCLE1BQUs3a0UsS0FBTCxDQUFXNEIsT0FBWCxDQUFtQmlqRSxXQUFuQixDQUErQjc4RCxNQUEvQixHQUF3QyxDQUQxQztBQUVBLFVBQUtrOUQsVUFBTCxHQUFrQixDQUFDLE1BQUtELFdBQXhCOztBQUVBLFVBQUt0cEUsUUFBTCxDQUNFLGdCQURGLEVBRUUsaUJBRkYsRUFHRSxxQkFIRixFQUlFLHFCQUpGOztBQU9BLFVBQUtDLEtBQUwsR0FBYTtBQUNYdXBFLDJCQUFxQjtBQURWLEtBQWI7O0FBSUEsVUFBS241RCxPQUFMLHVEQUNHelMsbUJBQVVzTSxNQUFWLENBQWlCb0csaUJBRHBCLEVBQ3dDLE1BQUtDLG1CQUQ3QyxrQ0FFRzNTLG1CQUFVc00sTUFBVixDQUFpQnNHLGlCQUZwQixFQUV3QyxNQUFLQyxtQkFGN0M7QUF4Qm9CO0FBNEJyQjs7QUFFRDs7QUFFQTs7Ozs7Ozt3Q0FHcUI7QUFDbkI7O0FBRG1CLFVBR1hqSyxNQUhXLEdBR0EsS0FBS2IsT0FITCxDQUdYYSxNQUhXOztBQUluQkEsYUFBT29yQixJQUFQLENBQVkvckIsR0FBWixDQUFnQixNQUFoQjtBQUNBVyxhQUFPeXJCLFFBQVAsQ0FBZ0J3K0IsT0FBaEIsQ0FBd0IsTUFBeEIsRUFBZ0MsTUFBaEM7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7Ozs7aUNBS2N4akQsSSxFQUFNO0FBQ2xCLFdBQUt3OEQsY0FBTCxDQUFvQng4RCxJQUFwQjtBQUNBLFdBQUtqRCxXQUFMO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O3dDQUtxQjBHLFMsRUFBVztBQUM5QixVQUFJQSxjQUFjLEtBQUszRyxjQUFMLENBQW9CLFdBQXBCLENBQWxCLEVBQW9EO0FBQ3BELFVBQUksS0FBS3ZFLGtCQUFULEVBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFOOEIsVUFPdEJnQixNQVBzQixHQU9YLEtBQUtiLE9BUE0sQ0FPdEJhLE1BUHNCOztBQVE5QixVQUFNbUssZUFBZW5LLE9BQU9vSyxVQUFQLENBQWtCQyxXQUFsQixDQUE4QixRQUE5QixDQUFyQjs7QUFFQSxVQUFNeVQsUUFBUTNULGFBQWE2dUIsV0FBYixFQUFkO0FBQ0E3dUIsbUJBQWF3cUQsU0FBYixDQUF1QjcyQyxLQUF2Qjs7QUFFQSxXQUFLdFQsY0FBTCxDQUFvQjtBQUNsQk4sbUJBQVdDLFlBRE87QUFFbEIyVCxvQkFGa0I7QUFHbEJyVCxnQ0FBd0IsS0FITjtBQUlsQkMsd0JBQWdCO0FBSkUsT0FBcEI7O0FBT0ExSyxhQUFPbUwsTUFBUDtBQUNEOztBQUVEOzs7Ozs7Ozt3Q0FLcUJqQixTLEVBQVc7QUFDOUIsVUFBSUEsY0FBYyxLQUFLM0csY0FBTCxDQUFvQixXQUFwQixDQUFsQixFQUFvRDtBQUNsRDtBQUNBO0FBQ0EsWUFBTTIvRCxnQkFBZ0IsS0FBSzMvRCxjQUFMLENBQW9CLE9BQXBCLENBQXRCO0FBQ0EsWUFBSTIvRCxhQUFKLEVBQW1CO0FBQ2pCLGNBQU1wbEQsUUFBUTVULFVBQVVTLFVBQVYsR0FDWGhGLE1BRFcsQ0FDSixVQUFDSCxDQUFEO0FBQUEsbUJBQU9BLEVBQUV1SCxLQUFGLE9BQWNtMkQsY0FBY24yRCxLQUFkLEVBQXJCO0FBQUEsV0FESSxFQUN3QyxDQUR4QyxDQUFkO0FBRUEsZUFBS3ZDLGNBQUwsQ0FBb0IsRUFBRXNULFlBQUYsRUFBcEI7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsYUFBSzNlLE9BQUwsQ0FBYWEsTUFBYixDQUFvQm1MLE1BQXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNGOztBQUVEOzs7Ozs7OzttQ0FLZ0IxRSxJLEVBQU07QUFDcEIsV0FBSytELGNBQUwsQ0FBb0IsRUFBRS9ELFVBQUYsRUFBcEI7QUFDQSxXQUFLbzhELGFBQUwsQ0FBbUJwOEQsSUFBbkIsR0FBMEJBLElBQTFCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O29DQUtpQjBJLEssRUFBTztBQUN0QixXQUFLM0UsY0FBTCxDQUFvQixFQUFFMkUsWUFBRixFQUFwQjtBQUNBLFdBQUswekQsYUFBTCxDQUFtQjF6RCxLQUFuQixHQUEyQkEsTUFBTTFULEtBQU4sRUFBM0I7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7Ozs7dUNBS29CO0FBQUE7O0FBQUEsVUFDVmluRSxXQURVLEdBQ00sS0FBSzdrRSxLQUFMLENBQVc0QixPQURqQixDQUNWaWpFLFdBRFU7O0FBRWxCLFVBQU0xVixVQUFVbDNELEtBQUswRyxHQUFMLENBQVN5cUMsS0FBVCxDQUFlLElBQWYsRUFBcUJ5N0IsV0FBckIsQ0FBaEI7QUFDQSxhQUFPQSxZQUFZMThELEdBQVosQ0FBZ0IsVUFBQ1MsSUFBRCxFQUFVO0FBQy9CLFlBQU1rcUQsV0FBVyxPQUFLcHRELGNBQUwsQ0FBb0IsTUFBcEIsTUFBZ0NrRCxJQUFqRDtBQUNBLGVBQVEsZ0NBQUMsb0NBQUQ7QUFDTixnQkFBTUEsSUFEQTtBQUVOLG1CQUFTdW1ELE9BRkg7QUFHTixrQkFBUTJELFFBSEY7QUFJTixlQUFLbHFELElBSkM7QUFLTixtQkFBUyxPQUFLMDhELFlBQUwsQ0FBa0J0c0UsSUFBbEIsQ0FBdUIsTUFBdkIsRUFBNkI0UCxJQUE3QixDQUxILEdBQVI7QUFNRCxPQVJNLENBQVA7QUFTRDs7QUFFRDs7Ozs7OztxQ0FJa0I7QUFBQSxVQUNSekcsTUFEUSxHQUNHLEtBQUtiLE9BRFIsQ0FDUmEsTUFEUTs7QUFFaEIsVUFBTW9yQixPQUFPcHJCLE9BQU9vckIsSUFBUCxDQUFZaHNCLEdBQVosRUFBYjtBQUNBLFVBQUl3cUIsUUFBUSxFQUFaOztBQUVBLFVBQUksS0FBS201QyxVQUFULEVBQXFCO0FBQ25CLFlBQU1LLGtCQUFrQnBqRSxPQUFPZ3ZCLGtCQUFQLEVBQXhCO0FBQ0EsWUFBTXEwQyxVQUFVLENBQWhCO0FBQ0EsWUFBTXJXLFVBQVVsM0QsS0FBS3lTLEtBQUwsQ0FBVzY2RCxnQkFBZ0IzbkUsS0FBaEIsR0FBd0I2ZSxRQUF4QixDQUFpQzhRLElBQWpDLEVBQXVDM3VCLEdBQXZDLEtBQStDLENBQTFELENBQWhCO0FBQ0EsWUFBTTZtRSxlQUFlLEtBQUtULGFBQUwsQ0FBbUJwOEQsSUFBeEM7O0FBRUFtakIsY0FBTWx4QixJQUFOLENBQVc7QUFBQTtBQUFBLFlBQUssS0FBSSxpQkFBVDtBQUNULDBDQUFDLHlCQUFEO0FBQ0UsbUJBQU0sT0FEUjtBQUVFLHNCQUFVMnFFLE9BRlo7QUFHRSxzQkFBVXJXLE9BSFo7QUFJRSx1QkFBVSxJQUpaO0FBS0UsdUJBQVcsS0FMYjtBQU1FLG1CQUFPLEtBQUs1d0MsRUFBTCxDQUFRLHVCQUFSLENBTlQ7QUFPRSxzQkFBVSxLQUFLNm1ELGNBUGpCO0FBUUUsbUJBQU9LLFlBUlQ7QUFEUyxTQUFYO0FBV0QsT0FqQkQsTUFpQk8sSUFBSSxLQUFLUixXQUFULEVBQXNCO0FBQzNCbDVDLGNBQU1seEIsSUFBTixDQUFXO0FBQUE7QUFBQSxZQUFLLEtBQUksZUFBVDtBQUNUO0FBQUMsd0NBQUQ7QUFBQTtBQUNFO0FBQUE7QUFBQSxnQkFBSSxLQUFJLFNBQVI7QUFDRyxtQkFBSzZxRSxnQkFBTDtBQURIO0FBREY7QUFEUyxTQUFYO0FBT0Q7O0FBRUQzNUMsWUFBTWx4QixJQUFOLENBQVc7QUFBQTtBQUFBLFVBQUssS0FBSSxzQkFBVDtBQUNULHdDQUFDLDhCQUFEO0FBQ0Usd0JBQWMsS0FBS21xRSxhQUFMLENBQW1CMXpELEtBQW5CLENBQXlCMVQsS0FBekIsRUFEaEI7QUFFRSxvQkFBVSxLQUFLK25FLGVBRmpCO0FBRFMsT0FBWDs7QUFNQSxhQUFPNTVDLEtBQVA7QUFDRDs7OztFQWxNaURockIsMkI7O2tCQUEvQitqRSxzQjs7O0FBcU1yQkEsdUJBQXVCaGtFLFlBQXZCLEdBQXNDQyw0QkFBa0JELFlBQXhELEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNU1BOzs7Ozs7K2VBaEJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFnQnFCOGtFLDBCOzs7Ozs7Ozs7Ozs7QUFDbkI7O0FBRUE7Ozt3Q0FHcUI7QUFDbkI7QUFDQSxXQUFLM3hDLGFBQUw7QUFDRDs7QUFFRDs7Ozs7O3lDQUdzQjtBQUNwQixXQUFLQSxhQUFMO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7b0NBSWlCO0FBQUEsVUFDUDlkLE1BRE8sR0FDSSxLQUFLelcsSUFEVCxDQUNQeVcsTUFETzs7QUFFZixVQUFNN1UsVUFBVTZVLE9BQU9sQixVQUFQLENBQWtCLElBQWxCLENBQWhCOztBQUVBa0IsYUFBTzNXLEtBQVAsR0FBZTJXLE9BQU94WixXQUF0QjtBQUNBd1osYUFBT2hYLE1BQVAsR0FBZ0JnWCxPQUFPblosWUFBdkI7O0FBTGUsbUJBT1csS0FBS2dELEtBUGhCO0FBQUEsVUFPUG12RCxPQVBPLFVBT1BBLE9BUE87QUFBQSxVQU9Fdm1ELElBUEYsVUFPRUEsSUFQRjs7QUFRZixVQUFNa3NELFdBQVczK0MsT0FBTzNXLEtBQVAsSUFBZ0JvSixPQUFPdW1ELE9BQXZCLENBQWpCO0FBQ0EsVUFBTWp0QyxTQUFTNHlDLFdBQVcsQ0FBMUI7O0FBRUF4ekQsY0FBUXdjLFNBQVIsR0FBb0IsT0FBcEI7QUFDQXhjLGNBQVE4MUMsU0FBUjtBQUNBOTFDLGNBQVFnMkMsR0FBUixDQUFZbmhDLE9BQU8zVyxLQUFQLEdBQWUsQ0FBM0IsRUFBOEIyVyxPQUFPaFgsTUFBUCxHQUFnQixDQUE5QyxFQUFpRCtpQixNQUFqRCxFQUF5RCxDQUF6RCxFQUE0RCxJQUFJanFCLEtBQUtpK0IsRUFBckU7QUFDQTUwQixjQUFRdWtFLElBQVI7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7OztvQ0FJaUI7QUFDZixhQUFRO0FBQUE7QUFBQSxVQUFLLFdBQVUscUJBQWY7QUFDTjtBQUFBO0FBQUE7QUFDRSxpQkFBSSxRQUROO0FBRUUscUJBQVMsS0FBSzdsRSxLQUFMLENBQVdrTyxPQUZ0QjtBQUdFO0FBQUE7QUFBQSxjQUFLLFdBQVUsYUFBZjtBQUNFO0FBQUE7QUFBQSxnQkFBSyxLQUFJLHVCQUFULEVBQWlDLFdBQVcsS0FBS2xPLEtBQUwsQ0FBVzA4QyxNQUFYLEdBQW9CLFdBQXBCLEdBQWtDLElBQTlFO0FBQ0UsMERBQVEsS0FBSSxVQUFaLEVBQXVCLEtBQUksUUFBM0IsR0FERjtBQUVFO0FBQUE7QUFBQSxrQkFBSyxLQUFJLFNBQVQ7QUFBb0IscUJBQUsxOEMsS0FBTCxDQUFXNEk7QUFBL0I7QUFGRjtBQURGO0FBSEY7QUFETSxPQUFSO0FBWUQ7Ozs7RUE1RHFEdlAsc0I7O2tCQUFuQ3VzRSwwQjs7O0FBK0RyQkEsMkJBQTJCOWtFLFlBQTNCLEdBQTBDekgsdUJBQWN5SCxZQUF4RCxDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2pFQTs7QUFDQTs7Ozs7Ozs7Ozs7OytlQWpCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBaUJRK0ssVyxHQUFnQm5ULGFBQUkrUyxVQUFKLENBQWVDLGUsQ0FBL0JHLFc7SUFDQTZvQyxXLEdBQWdCaDhDLGFBQUkrUyxVQUFKLENBQWVDLGVBQWYsQ0FBK0JHLFdBQS9CLENBQTJDNG9DLE8sQ0FBM0RDLFc7O0lBRWFxd0IsNEI7OztBQUNuQiwwQ0FBc0I7QUFBQTs7QUFBQTs7QUFBQSxzQ0FBTi9qRSxJQUFNO0FBQU5BLFVBQU07QUFBQTs7QUFBQSx1TEFDWEEsSUFEVzs7QUFHcEIsVUFBSzhrRSxjQUFMLEdBQXNCLEtBQXRCO0FBQ0EsVUFBS0MsUUFBTCxHQUFnQixLQUFoQjtBQUNBLFVBQUtwcUUsUUFBTCxDQUNFLGVBREYsRUFFRSxlQUZGLEVBR0UsY0FIRixFQUlFLGNBSkYsRUFLRSxZQUxGLEVBTUUsc0JBTkYsRUFPRSxpQkFQRjs7QUFVQSxVQUFLcXFFLGlCQUFMLEdBQXlCLElBQXpCOztBQUVBLFVBQUtoNkQsT0FBTCxHQUFlMVQsa0JBQVMyakMsTUFBVCxDQUFnQixNQUFLandCLE9BQXJCLHNCQUNaelMsbUJBQVVzTSxNQUFWLENBQWlCcXVDLGFBREwsRUFDcUIsTUFBS2lQLGVBRDFCLEVBQWY7O0FBSUEsVUFBS3ZuRCxLQUFMLEdBQWE7QUFDWHFxRSxxQkFBZSxLQURKO0FBRVhDLHNCQUFnQixJQUFJdHRFLGdCQUFKO0FBRkwsS0FBYjtBQXJCb0I7QUF5QnJCOztBQUVEOztBQUVBOzs7Ozs7O3dDQUdxQjtBQUNuQjtBQUNBLFdBQUt1dEUsb0JBQUw7QUFDRDs7QUFFRDs7Ozs7O3lDQUdzQjtBQUNwQixVQUFJLEtBQUtMLGNBQVQsRUFBeUI7QUFDdkIsYUFBS0ssb0JBQUw7QUFDQSxhQUFLTCxjQUFMLEdBQXNCLEtBQXRCO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQTs7Ozs7OztzQ0FJbUI7QUFDakIsV0FBS0EsY0FBTCxHQUFzQixJQUF0QjtBQUNEOztBQUVEOzs7Ozs7Ozt3Q0FLcUJ6NUQsUyxFQUFXO0FBQzlCLFdBQUssQ0FBTDtBQUNEOztBQUVEOzs7Ozs7Ozt3Q0FLcUJBLFMsRUFBVztBQUM5QixVQUFJQSxjQUFjLEtBQUszRyxjQUFMLENBQW9CLFdBQXBCLENBQWxCLEVBQW9EO0FBQ2xELGFBQUtDLFdBQUw7QUFDRDtBQUNGOztBQUVEOzs7Ozs7OztpQ0FLY3hJLEMsRUFBRztBQUNmQSxRQUFFeUYsY0FBRjs7QUFFQSxXQUFLd2pFLGtCQUFMLEdBQTBCLEtBQUsxZ0UsY0FBTCxDQUFvQixXQUFwQixFQUFpQzR4QixnQkFBakMsRUFBMUI7QUFDQSxXQUFLK3VDLDJCQUFMLEdBQW1DLEtBQUszZ0UsY0FBTCxDQUFvQix3QkFBcEIsQ0FBbkM7QUFDQSxXQUFLaUgsY0FBTCxDQUFvQixFQUFFQyx3QkFBd0IsSUFBMUIsRUFBcEIsRUFBc0QsS0FBdEQ7O0FBRUEsVUFBTWtCLG1CQUFtQixLQUFLeE0sT0FBTCxDQUFhYSxNQUFiLENBQW9CNEwsbUJBQXBCLEVBQXpCO0FBQ0EsVUFBTW00RCxpQkFBaUIsS0FBS0ksa0JBQUwsQ0FBd0JucEUsQ0FBeEIsQ0FBdkI7O0FBRUEsVUFBTThpQixRQUFRLEtBQUt2YSxjQUFMLENBQW9CLE9BQXBCLENBQWQ7QUFDQSxVQUFNa0QsT0FBTyxLQUFLbEQsY0FBTCxDQUFvQixNQUFwQixJQUE4Qm9JLGlCQUFpQmxQLEdBQWpCLEVBQTNDO0FBQ0EsVUFBTTBTLFFBQVEsS0FBSzVMLGNBQUwsQ0FBb0IsT0FBcEIsQ0FBZDtBQUNBLFVBQU0wYSxXQUFXLEtBQUsxYSxjQUFMLENBQW9CLFVBQXBCLENBQWpCO0FBQ0EsV0FBS3FnRSxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsVUFBTS9wQyxTQUFTLElBQUkwWSxXQUFKLENBQWdCLEVBQUU5ckMsVUFBRixFQUFRd1gsa0JBQVIsRUFBa0I5TyxZQUFsQixFQUFoQixDQUFmO0FBQ0EsV0FBS2kxRCxZQUFMLEdBQW9CdG1ELE1BQU11YixVQUFOLENBQWlCUSxNQUFqQixDQUFwQjtBQUNBLFdBQUt1cUMsWUFBTCxDQUFrQjdxQyxlQUFsQixDQUFrQ3dxQyxlQUFldG9FLEtBQWYsR0FBdUJvUSxNQUF2QixDQUE4QkYsZ0JBQTlCLENBQWxDOztBQUVBMVAsZUFBU0MsZ0JBQVQsQ0FBMEIsV0FBMUIsRUFBdUMsS0FBS21vRSxZQUE1QztBQUNBcG9FLGVBQVNDLGdCQUFULENBQTBCLFdBQTFCLEVBQXVDLEtBQUttb0UsWUFBNUM7QUFDQXBvRSxlQUFTQyxnQkFBVCxDQUEwQixTQUExQixFQUFxQyxLQUFLb29FLFVBQTFDO0FBQ0Fyb0UsZUFBU0MsZ0JBQVQsQ0FBMEIsVUFBMUIsRUFBc0MsS0FBS29vRSxVQUEzQztBQUNEOztBQUVEOzs7Ozs7O2lDQUljO0FBQ1osV0FBS0YsWUFBTCxDQUFrQjlxQyxTQUFsQixDQUE0QixJQUE1Qjs7QUFEWSxVQUdKdDVCLE1BSEksR0FHTyxLQUFLYixPQUhaLENBR0phLE1BSEk7O0FBSVosVUFBTXVrRSwwQkFBMEJ2a0UsT0FBTyt1QiwwQkFBUCxFQUFoQztBQUNBLFdBQUt4ckIsY0FBTCxDQUFvQixPQUFwQixFQUE2QjRILE1BQTdCLENBQW9DbzVELHVCQUFwQzs7QUFFQSxXQUFLSCxZQUFMLEdBQW9CLElBQXBCO0FBQ0EsV0FBS1IsUUFBTCxHQUFnQixLQUFoQjs7QUFFQTVqRSxhQUFPaXJCLE9BQVAsQ0FBZTdpQixHQUFmLENBQ0UsS0FBSzdFLGNBQUwsQ0FBb0IsV0FBcEIsQ0FERixFQUVFLEtBQUswZ0Usa0JBRlAsRUFHRSxLQUFLQywyQkFIUDs7QUFLQWpvRSxlQUFTSSxtQkFBVCxDQUE2QixXQUE3QixFQUEwQyxLQUFLZ29FLFlBQS9DO0FBQ0Fwb0UsZUFBU0ksbUJBQVQsQ0FBNkIsV0FBN0IsRUFBMEMsS0FBS2dvRSxZQUEvQztBQUNBcG9FLGVBQVNJLG1CQUFULENBQTZCLFNBQTdCLEVBQXdDLEtBQUtpb0UsVUFBN0M7QUFDQXJvRSxlQUFTSSxtQkFBVCxDQUE2QixVQUE3QixFQUF5QyxLQUFLaW9FLFVBQTlDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O2tDQUtldHBFLEMsRUFBRztBQUNoQixVQUFNK29FLGlCQUFpQixLQUFLSSxrQkFBTCxDQUF3Qm5wRSxDQUF4QixDQUF2QjtBQUNBLFdBQUtELFFBQUwsQ0FBYztBQUNaK29FLHVCQUFlLElBREg7QUFFWkM7QUFGWSxPQUFkO0FBSUEsV0FBS00sWUFBTCxDQUFrQnJwRSxDQUFsQjtBQUNEOztBQUVEOzs7Ozs7O29DQUlpQjtBQUNmLFdBQUtELFFBQUwsQ0FBYztBQUNaK29FLHVCQUFlO0FBREgsT0FBZDtBQUdEOztBQUVEOzs7Ozs7OztpQ0FLYzlvRSxDLEVBQUc7QUFBQSxVQUNQZ0YsTUFETyxHQUNJLEtBQUtiLE9BRFQsQ0FDUGEsTUFETzs7QUFFZixVQUFNMkwsbUJBQW1CM0wsT0FBTzRMLG1CQUFQLEVBQXpCO0FBQ0EsVUFBTTI0RCwwQkFBMEJ2a0UsT0FBTyt1QiwwQkFBUCxFQUFoQzs7QUFFQSxVQUFNM0QsT0FBT3ByQixPQUFPb3JCLElBQVAsQ0FBWWhzQixHQUFaLEVBQWI7QUFDQSxVQUFNMmtFLGlCQUFpQixLQUFLSSxrQkFBTCxDQUF3Qm5wRSxDQUF4QixDQUF2QjtBQUNBLFdBQUtELFFBQUwsQ0FBYyxFQUFFZ3BFLDhCQUFGLEVBQWQ7O0FBRUEsVUFBSVMsbUJBQUo7QUFDQSxVQUFJLENBQUMsS0FBS1gsaUJBQVYsRUFBNkI7QUFDM0JXLHFCQUFhLElBQWI7QUFDRCxPQUZELE1BRU87QUFDTCxZQUFNQyxZQUFZLEtBQUtsaEUsY0FBTCxDQUFvQixNQUFwQixDQUFsQjtBQUNBLFlBQU1taEUsV0FBVyxLQUFLYixpQkFBTCxDQUF1QnBvRSxLQUF2QixHQUNkTyxRQURjLENBQ0wrbkUsY0FESyxFQUVkdDdELEdBRmMsR0FFUnNhLEdBRlEsS0FFQXFJLElBRmpCO0FBR0FvNUMscUJBQWFFLFlBQVlELFlBQVksRUFBckM7QUFDRDs7QUFFRCxVQUFJLEtBQUtiLFFBQUwsSUFBaUJZLFVBQXJCLEVBQWlDO0FBQy9CLGFBQUtKLFlBQUwsQ0FBa0I3cUMsZUFBbEIsQ0FBa0N3cUMsZUFBZXRvRSxLQUFmLEdBQXVCb1EsTUFBdkIsQ0FBOEJGLGdCQUE5QixDQUFsQzs7QUFFQSxhQUFLcEksY0FBTCxDQUFvQixPQUFwQixFQUE2QjRILE1BQTdCLENBQW9DbzVELHVCQUFwQzs7QUFFQSxhQUFLVixpQkFBTCxHQUF5QkUsZUFBZXRvRSxLQUFmLEVBQXpCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7O3lDQU1zQlQsQyxFQUFHO0FBQ3ZCLFVBQU0rb0UsaUJBQWlCLEtBQUtJLGtCQUFMLENBQXdCbnBFLENBQXhCLENBQXZCO0FBQ0EsV0FBS0QsUUFBTCxDQUFjLEVBQUVncEUsOEJBQUYsRUFBZDtBQUNEOztBQUVEOzs7Ozs7Ozs7dUNBTW9COTNELE0sRUFBUTtBQUMxQixVQUFJcE8sdUtBQWlDb08sTUFBakMsQ0FBSjtBQUNBLFVBQUlBLGtCQUFrQnZDLFdBQXRCLEVBQW1DO0FBQ2pDN0wsY0FBTXFPLFdBQU4sR0FBb0IsS0FBcEI7QUFDRDtBQUNELGFBQU9yTyxLQUFQO0FBQ0Q7QUFDRDs7QUFFQTs7Ozs7Ozs7c0NBS21CO0FBQ2pCLFVBQU00SSxPQUFPLEtBQUtsRCxjQUFMLENBQW9CLE1BQXBCLENBQWI7QUFDQSxVQUFNNEwsUUFBUSxLQUFLNUwsY0FBTCxDQUFvQixPQUFwQixDQUFkOztBQUZpQixVQUlUd2dFLGNBSlMsR0FJVSxLQUFLdHFFLEtBSmYsQ0FJVHNxRSxjQUpTOztBQUtqQixhQUFPO0FBQ0xsb0UsY0FBTWtvRSxlQUFlNW9FLENBRGhCO0FBRUxXLGFBQUtpb0UsZUFBZTNvRSxDQUZmO0FBR0xpQyxlQUFPb0osSUFIRjtBQUlMekosZ0JBQVF5SixJQUpIO0FBS0x5SSxvQkFBWUMsTUFBTTBNLE1BQU4sRUFMUDtBQU1MaTJDLG9CQUFZcnJELE9BQU8sQ0FBQyxHQU5mO0FBT0xzckQsbUJBQVd0ckQsT0FBTyxDQUFDO0FBUGQsT0FBUDtBQVNEOztBQUVEOztBQUVBOzs7Ozs7OzJDQUl3QjtBQUN0QixXQUFLaytELHNCQUFMLEdBQThCLEtBQUtwbkUsSUFBTCxDQUFVcW5FLGNBQVYsQ0FBeUJqcEUscUJBQXpCLEVBQTlCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O3VDQUtvQmtwRSxLLEVBQU87QUFDekIsVUFBTTk4RCxXQUFXM1IsZUFBTW1GLGdCQUFOLENBQXVCc3BFLEtBQXZCLENBQWpCO0FBQ0EsVUFBTW5wRSxlQUFlLEtBQUtpcEUsc0JBQTFCO0FBQ0EsYUFBTzU4RCxTQUNKL0wsUUFESSxDQUNLTixhQUFhRyxJQURsQixFQUN3QkgsYUFBYUksR0FEckMsQ0FBUDtBQUVEOztBQUVEOzs7Ozs7Ozt5Q0FLc0I7QUFDcEIsVUFBSStCLHNLQUFKOztBQUVBQSxZQUFNeUQsV0FBTixHQUFvQnpELE1BQU0yRCxZQUFOLEdBQXFCLEtBQUtzakUsWUFBOUM7QUFDQSxhQUFPam5FLEtBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7OENBSzJCO0FBQ3pCLFVBQUlBLDJLQUFKOztBQUVBO0FBQ0EsYUFBT0EsTUFBTWtPLE9BQWI7O0FBRUFsTyxZQUFNMDNELFlBQU4sR0FBcUIsS0FBS3dQLGFBQTFCO0FBQ0FsbkUsWUFBTTQzRCxZQUFOLEdBQXFCLEtBQUt1UCxhQUExQjtBQUNBbm5FLFlBQU1vbkUsV0FBTixHQUFvQixLQUFLQyxvQkFBekI7QUFDQSxhQUFPcm5FLEtBQVA7QUFDRDs7QUFFRDs7QUFFQTs7Ozs7Ozs7NkNBSzBCO0FBQ3hCLFVBQU1zbkUsY0FBYyxLQUFLMXJFLEtBQUwsQ0FBV3FxRSxhQUFYLEdBQTJCLFlBQTNCLEdBQTBDLElBQTlEO0FBQ0EsYUFDRTtBQUFBO0FBQUEsVUFBSyxLQUFJLHdCQUFUO0FBQ0UsaURBQUssS0FBSSxVQUFULEVBQW9CLFdBQVdxQixXQUEvQixFQUE0QyxPQUFPLEtBQUtDLGVBQUwsRUFBbkQ7QUFERixPQURGO0FBS0Q7Ozs7RUEvU3VEejdELHdDOztrQkFBckNpNUQsNEI7OztBQWtUckJBLDZCQUE2QmprRSxZQUE3QixHQUE0Q2dMLHlDQUErQmhMLFlBQTNFLEM7Ozs7Ozs7Ozs7Ozs7OztBQ3pUQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBakJBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBa0JBOzs7Ozs7SUFNTTBtRSxxQjs7Ozs7Ozs7Ozs7O0FBQ0o7Ozs7Ozs2QkFNaUI7QUFBQSxVQUNQcmxFLE1BRE8sR0FDSSxLQUFLYixPQURULENBQ1BhLE1BRE87O0FBRWYsVUFBTWtLLFlBQVksS0FBSzNHLGNBQUwsQ0FBb0IsV0FBcEIsQ0FBbEI7O0FBRUEsVUFBSTJHLFVBQVVzc0IsUUFBVixHQUFxQjN3QixNQUFyQixLQUFnQyxDQUFwQyxFQUF1QztBQUNyQzdGLGVBQU9vSyxVQUFQLENBQWtCaytDLE1BQWxCLENBQXlCcCtDLFNBQXpCO0FBQ0Q7O0FBRURsSyxhQUFPb3JCLElBQVAsQ0FBWWtxQixPQUFaO0FBQ0F0MUMsYUFBT3lyQixRQUFQLENBQWdCKy9CLE1BQWhCLENBQXVCLE1BQXZCLEVBQStCLE1BQS9CO0FBQ0F4ckQsYUFBT21MLE1BQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7NEJBUWdCd0IsVyxFQUFhbE4sTyxFQUFTO0FBQUEsVUFDNUJPLE1BRDRCLEdBQ2pCLEtBQUtiLE9BRFksQ0FDNUJhLE1BRDRCOzs7QUFHcENBLGFBQU9vckIsSUFBUCxDQUFZNHBCLElBQVo7QUFDQWgxQyxhQUFPb3JCLElBQVAsQ0FBWS9yQixHQUFaLENBQWdCLE1BQWhCLEVBQXdCLFlBQU07QUFDNUJXLGVBQU9tTCxNQUFQO0FBQ0QsT0FGRDs7QUFJQSxVQUFNUSxtQkFBbUIzTCxPQUFPNEwsbUJBQVAsRUFBekI7QUFDQSxVQUFNbkIseUJBQXlCekssT0FBT29LLFVBQVAsQ0FBa0IrVSxNQUFsQixDQUF5QixnQkFBekIsQ0FBL0I7QUFDQSxVQUFNalYsWUFBWWxLLE9BQU9vSyxVQUFQLENBQWtCQyxXQUFsQixDQUE4QixnQkFBOUIsQ0FBbEI7QUFDQSxVQUFNSyxpQkFBaUJSLFVBQVVpckIsZ0JBQVYsRUFBdkI7QUFDQSxVQUFNclgsUUFBUTVULFVBQVU2VCxRQUFWLEVBQWQ7O0FBRUEsVUFBSXRYLE9BQU9rRixpQkFBaUJsUCxHQUFqQixLQUF5QixHQUFwQztBQUNBLFVBQU13aEIsV0FBVyxDQUFqQjs7QUFFQSxVQUFNWixrQkFBa0JuVCxVQUFVb1Qsa0JBQVYsRUFBeEI7O0FBRUEsV0FBSzlTLGNBQUwsQ0FBb0I7QUFDbEJDLHNEQURrQixFQUNNUCxvQkFETixFQUNpQjRULFlBRGpCLEVBQ3dCcFQsOEJBRHhCLEVBQ3dDakUsVUFEeEMsRUFDOEN3WCxrQkFEOUMsRUFDd0RaO0FBRHhELE9BQXBCO0FBR0Q7O0FBRUQ7Ozs7Ozs7Ozs7Z0NBT29CcmQsTSxFQUFRO0FBQzFCLGFBQU9BLE9BQU8rbkQsYUFBUCxDQUFxQixnQkFBckIsQ0FBUDtBQUNEOzs7O0VBN0RpQ3RwQixrQjs7QUFnRXBDOzs7Ozs7O0FBS0E0bUMsc0JBQXNCbmxFLGlCQUF0QixHQUEwQ29sRSx3Q0FBMUM7O0FBRUE7Ozs7OztBQU1BRCxzQkFBc0JsbEUsdUJBQXRCLEdBQWdEb2xFLDhDQUFoRDs7QUFFQTs7Ozs7QUFLQUYsc0JBQXNCcG1FLFVBQXRCLEdBQW1DLGdCQUFuQzs7QUFFQTs7Ozs7QUFLQW9tRSxzQkFBc0JqbEUsUUFBdEIsR0FBaUMsc0NBQWpDOztBQUVBOzs7OztBQUtBaWxFLHNCQUFzQmhsRSxXQUF0QixHQUFvQyxrQ0FBcEM7O0FBRUE7Ozs7QUFJQWdsRSxzQkFBc0Iva0UsY0FBdEIsR0FBdUMsRUFBdkM7O0FBSUE7Ozs7QUFJQStrRSxzQkFBc0I1ZCxrQkFBdEIsR0FBMkMsQ0FBQyxnQkFBRCxDQUEzQzs7a0JBRWU0ZCxxQjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzSGY7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7K2VBbkJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFtQnFCMUMsc0I7OztBQUNuQixvQ0FBc0I7QUFBQTs7QUFBQTs7QUFBQSxzQ0FBTjlqRSxJQUFNO0FBQU5BLFVBQU07QUFBQTs7QUFBQSwyS0FDWEEsSUFEVzs7QUFHcEIsVUFBS0UsY0FBTCxHQUFzQixLQUF0QjtBQUNBLFVBQUt5bUUsVUFBTCxHQUFrQixNQUFLamlFLGNBQUwsQ0FBb0IsTUFBcEIsQ0FBbEI7O0FBRUEsVUFBSy9KLFFBQUwsQ0FDRSxxQkFERixFQUVFLHFCQUZGLEVBR0UsZ0JBSEYsRUFJRSxxQkFKRjs7QUFPQSxVQUFLQyxLQUFMLEdBQWE7QUFDWHVwRSwyQkFBcUI7QUFEVixLQUFiOztBQUlBLFVBQUtuNUQsT0FBTCx1REFDR3pTLG1CQUFVc00sTUFBVixDQUFpQm9HLGlCQURwQixFQUN3QyxNQUFLQyxtQkFEN0Msa0NBRUczUyxtQkFBVXNNLE1BQVYsQ0FBaUJzRyxpQkFGcEIsRUFFd0MsTUFBS0MsbUJBRjdDO0FBakJvQjtBQXFCckI7O0FBRUQ7O0FBRUE7Ozs7Ozs7d0NBR3FCO0FBQ25COztBQURtQixVQUdYakssTUFIVyxHQUdBLEtBQUtiLE9BSEwsQ0FHWGEsTUFIVzs7QUFJbkJBLGFBQU9vckIsSUFBUCxDQUFZL3JCLEdBQVosQ0FBZ0IsTUFBaEI7QUFDQVcsYUFBT3lyQixRQUFQLENBQWdCdytCLE9BQWhCLENBQXdCLE1BQXhCLEVBQWdDLE1BQWhDO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7O3dDQUtxQi8vQyxTLEVBQVc7QUFDOUIsVUFBSUEsY0FBYyxLQUFLM0csY0FBTCxDQUFvQixXQUFwQixDQUFsQixFQUFvRDtBQUNwRCxVQUFJLEtBQUt2RSxrQkFBVCxFQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBTjhCLFVBT3RCZ0IsTUFQc0IsR0FPWCxLQUFLYixPQVBNLENBT3RCYSxNQVBzQjs7QUFROUIsVUFBTW1LLGVBQWVuSyxPQUFPb0ssVUFBUCxDQUFrQkMsV0FBbEIsQ0FBOEIsZ0JBQTlCLENBQXJCO0FBQ0EsVUFBTXlULFFBQVEzVCxhQUFhNFQsUUFBYixFQUFkOztBQUVBLFdBQUt2VCxjQUFMLENBQW9CO0FBQ2xCTixtQkFBV0MsWUFETztBQUVsQjJULG9CQUZrQjtBQUdsQnJULGdDQUF3QixLQUhOO0FBSWxCQyx3QkFBZ0I7QUFKRSxPQUFwQjs7QUFPQTFLLGFBQU9tTCxNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O3dDQUtxQmpCLFMsRUFBVztBQUM5QixVQUFJQSxjQUFjLEtBQUszRyxjQUFMLENBQW9CLFdBQXBCLENBQWxCLEVBQW9EO0FBQUEsWUFDMUN2RCxNQUQwQyxHQUMvQixLQUFLYixPQUQwQixDQUMxQ2EsTUFEMEM7O0FBRWxEQSxlQUFPbUwsTUFBUDtBQUNBLGFBQUszSCxXQUFMO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7bUNBS2dCaUQsSSxFQUFNO0FBQ3BCLFdBQUsrRCxjQUFMLENBQW9CLEVBQUUvRCxVQUFGLEVBQXBCO0FBQ0EsV0FBSysrRCxVQUFMLEdBQWtCLytELElBQWxCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7d0NBT3FCL0UsSyxFQUFPK2pFLGEsRUFBaUM7QUFBQSxVQUFsQkMsUUFBa0IsdUVBQVAsS0FBTzs7QUFDM0QsVUFBTXJvRCxrQkFBa0IsS0FBSzlaLGNBQUwsQ0FBb0IsaUJBQXBCLENBQXhCO0FBQ0EsV0FBS0EsY0FBTCxDQUFvQixXQUFwQixFQUFpQzRzRCxhQUFqQyxDQUErQ3p1RCxRQUFRMmIsZ0JBQWdCNWdCLEdBQWhCLEVBQXZEOztBQUYyRCxVQUluRHVELE1BSm1ELEdBSXhDLEtBQUtiLE9BSm1DLENBSW5EYSxNQUptRDs7QUFLM0RBLGFBQU9tTCxNQUFQOztBQUVBLFVBQUl1NkQsUUFBSixFQUFjO0FBQ1oxbEUsZUFBT2lyQixPQUFQLENBQWU3aUIsR0FBZixDQUNFLEtBQUs3RSxjQUFMLENBQW9CLFdBQXBCLENBREYsRUFFRSxFQUFFdWYsWUFBWTJpRCxnQkFBZ0Jwb0QsZ0JBQWdCNWdCLEdBQWhCLEVBQTlCLEVBRkYsRUFHRSxJQUhGO0FBSUQ7QUFDRjs7QUFFRDs7QUFFQTs7Ozs7Ozs0Q0FJeUI7QUFDdkIsVUFBTTRnQixrQkFBa0IsS0FBSzlaLGNBQUwsQ0FBb0IsaUJBQXBCLENBQXhCO0FBQ0EsVUFBTWd0RCxlQUFlbHpDLGdCQUFnQjVnQixHQUFoQixFQUFyQjtBQUNBLFVBQU1pRixRQUFRLEtBQUs2QixjQUFMLENBQW9CLFdBQXBCLEVBQWlDaXRELGFBQWpDLEtBQW1ERCxZQUFqRTs7QUFFQSxhQUFRLGdDQUFDLGdDQUFEO0FBQ04sa0JBQVUsQ0FESjtBQUVOLGtCQUFVejZELEtBQUsyRyxHQUFMLENBQVMsR0FBVCxFQUFjM0csS0FBS3lTLEtBQUwsQ0FBV2dvRCxlQUFlLEdBQTFCLENBQWQsQ0FGSjtBQUdOLGVBQU83dUQsS0FIRDtBQUlOLG1CQUFVLElBSko7QUFLTixlQUFPLEtBQUswYSxFQUFMLENBQVEsbUNBQVIsQ0FMRDtBQU1OLGtCQUFVLEtBQUtxMEMsbUJBTlQsR0FBUjtBQU9EOztBQUVEOzs7Ozs7O3FDQUlrQjtBQUFBLFVBQ1J6d0QsTUFEUSxHQUNHLEtBQUtiLE9BRFIsQ0FDUmEsTUFEUTs7QUFFaEIsVUFBTW9yQixPQUFPcHJCLE9BQU9vckIsSUFBUCxDQUFZaHNCLEdBQVosRUFBYjtBQUNBLFVBQUl3cUIsUUFBUSxFQUFaOztBQUVBLFVBQU13NUMsa0JBQWtCcGpFLE9BQU9ndkIsa0JBQVAsRUFBeEI7QUFDQSxVQUFNcTBDLFVBQVUsQ0FBaEI7QUFDQSxVQUFNclcsVUFBVWwzRCxLQUFLeVMsS0FBTCxDQUFXNjZELGdCQUFnQjNuRSxLQUFoQixHQUF3QjZlLFFBQXhCLENBQWlDOFEsSUFBakMsRUFBdUMzdUIsR0FBdkMsS0FBK0MsQ0FBMUQsQ0FBaEI7QUFDQSxVQUFNNm1FLGVBQWUsS0FBS2tDLFVBQTFCOztBQUVBNTdDLFlBQU1seEIsSUFBTixDQUFXO0FBQUE7QUFBQSxVQUFLLEtBQUksaUJBQVQ7QUFDVCx3Q0FBQyx5QkFBRDtBQUNFLGlCQUFNLE9BRFI7QUFFRSxvQkFBVTJxRSxPQUZaO0FBR0Usb0JBQVVyVyxPQUhaO0FBSUUscUJBQVUsSUFKWjtBQUtFLHFCQUFXLEtBTGI7QUFNRSxpQkFBTyxLQUFLNXdDLEVBQUwsQ0FBUSxxQkFBUixDQU5UO0FBT0Usb0JBQVUsS0FBSzZtRCxjQVBqQjtBQVFFLGlCQUFPSyxZQVJUO0FBRFMsT0FBWDs7QUFZQSxhQUFPMTVDLEtBQVA7QUFDRDs7OztFQTdKaURockIsMkI7O2tCQUEvQitqRSxzQjs7O0FBZ0tyQkEsdUJBQXVCaGtFLFlBQXZCLEdBQXNDQyw0QkFBa0JELFlBQXhELEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcktBOztBQUNBOzs7Ozs7Ozs7Ozs7K2VBakJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFpQnFCaWtFLDRCOzs7QUFDbkIsMENBQXNCO0FBQUE7O0FBQUE7O0FBQUEsc0NBQU4vakUsSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEsdUxBQ1hBLElBRFc7O0FBR3BCLFVBQUs4a0UsY0FBTCxHQUFzQixLQUF0QjtBQUNBLFVBQUtDLFFBQUwsR0FBZ0IsS0FBaEI7QUFDQSxVQUFLcHFFLFFBQUwsQ0FDRSxlQURGLEVBRUUsZUFGRixFQUdFLGNBSEYsRUFJRSxjQUpGLEVBS0UsWUFMRixFQU1FLHNCQU5GLEVBT0UsaUJBUEY7O0FBVUEsVUFBS3FxRSxpQkFBTCxHQUF5QixJQUF6Qjs7QUFFQSxVQUFLaDZELE9BQUwsR0FBZTFULGtCQUFTMmpDLE1BQVQsQ0FBZ0IsTUFBS2p3QixPQUFyQixzQkFDWnpTLG1CQUFVc00sTUFBVixDQUFpQnF1QyxhQURMLEVBQ3FCLE1BQUtpUCxlQUQxQixFQUFmOztBQUlBLFVBQUt2bkQsS0FBTCxHQUFhO0FBQ1hxcUUscUJBQWUsS0FESjtBQUVYQyxzQkFBZ0IsSUFBSXR0RSxnQkFBSjtBQUZMLEtBQWI7QUFyQm9CO0FBeUJyQjs7QUFFRDs7QUFFQTs7Ozs7Ozt3Q0FHcUI7QUFDbkI7QUFDQSxXQUFLdXRFLG9CQUFMO0FBQ0Q7O0FBRUQ7Ozs7Ozt5Q0FHc0I7QUFDcEIsVUFBSSxLQUFLTCxjQUFULEVBQXlCO0FBQ3ZCLGFBQUtLLG9CQUFMO0FBQ0EsYUFBS0wsY0FBTCxHQUFzQixLQUF0QjtBQUNEO0FBQ0Y7O0FBRUQ7O0FBRUE7Ozs7Ozs7c0NBSW1CO0FBQ2pCLFdBQUtBLGNBQUwsR0FBc0IsSUFBdEI7QUFDRDs7QUFFRDs7Ozs7Ozs7d0NBS3FCejVELFMsRUFBVyxDQUUvQjs7QUFFRDs7Ozs7Ozs7d0NBS3FCQSxTLEVBQVc7QUFDOUIsVUFBSUEsY0FBYyxLQUFLM0csY0FBTCxDQUFvQixXQUFwQixDQUFsQixFQUFvRDtBQUNsRCxhQUFLQyxXQUFMO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7aUNBS2N4SSxDLEVBQUc7QUFDZkEsUUFBRXlGLGNBQUY7O0FBRUEsVUFBTXlKLFlBQVksS0FBSzNHLGNBQUwsQ0FBb0IsV0FBcEIsQ0FBbEI7QUFDQSxXQUFLMGdFLGtCQUFMLEdBQTBCLzVELFVBQVVpckIsZ0JBQVYsRUFBMUI7QUFDQSxXQUFLK3VDLDJCQUFMLEdBQW1DLEtBQUszZ0UsY0FBTCxDQUFvQix3QkFBcEIsQ0FBbkM7QUFDQSxXQUFLaUgsY0FBTCxDQUFvQixFQUFFQyx3QkFBd0IsSUFBMUIsRUFBcEIsRUFBc0QsS0FBdEQ7O0FBRUEsVUFBTWtCLG1CQUFtQixLQUFLeE0sT0FBTCxDQUFhYSxNQUFiLENBQW9CNEwsbUJBQXBCLEVBQXpCO0FBQ0EsVUFBTW00RCxpQkFBaUIsS0FBS0ksa0JBQUwsQ0FBd0JucEUsQ0FBeEIsQ0FBdkI7O0FBRUEsVUFBTXlMLE9BQU8sS0FBS2xELGNBQUwsQ0FBb0IsTUFBcEIsSUFBOEJvSSxpQkFBaUJsUCxHQUFqQixFQUEzQztBQUNBLFVBQU13aEIsV0FBVyxLQUFLMWEsY0FBTCxDQUFvQixVQUFwQixDQUFqQjtBQUNBLFdBQUtxZ0UsUUFBTCxHQUFnQixJQUFoQjs7QUFFQSxXQUFLUSxZQUFMLEdBQW9CbDZELFVBQVVtdkIsVUFBVixDQUFxQjV5QixJQUFyQixFQUEyQndYLFFBQTNCLENBQXBCO0FBQ0EsV0FBS21tRCxZQUFMLENBQWtCN3FDLGVBQWxCLENBQWtDd3FDLGVBQWV0b0UsS0FBZixHQUF1Qm9RLE1BQXZCLENBQThCRixnQkFBOUIsQ0FBbEM7O0FBRUExUCxlQUFTQyxnQkFBVCxDQUEwQixXQUExQixFQUF1QyxLQUFLbW9FLFlBQTVDO0FBQ0Fwb0UsZUFBU0MsZ0JBQVQsQ0FBMEIsV0FBMUIsRUFBdUMsS0FBS21vRSxZQUE1QztBQUNBcG9FLGVBQVNDLGdCQUFULENBQTBCLFNBQTFCLEVBQXFDLEtBQUtvb0UsVUFBMUM7QUFDQXJvRSxlQUFTQyxnQkFBVCxDQUEwQixVQUExQixFQUFzQyxLQUFLb29FLFVBQTNDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7aUNBSWM7QUFDWixXQUFLRixZQUFMLENBQWtCOXFDLFNBQWxCLENBQTRCLElBQTVCOztBQURZLFVBR0p0NUIsTUFISSxHQUdPLEtBQUtiLE9BSFosQ0FHSmEsTUFISTs7QUFJWkEsYUFBT21MLE1BQVA7O0FBRUEsV0FBS2k1RCxZQUFMLEdBQW9CLElBQXBCO0FBQ0EsV0FBS1IsUUFBTCxHQUFnQixLQUFoQjs7QUFFQTVqRSxhQUFPaXJCLE9BQVAsQ0FBZTdpQixHQUFmLENBQ0UsS0FBSzdFLGNBQUwsQ0FBb0IsV0FBcEIsQ0FERixFQUVFLEtBQUswZ0Usa0JBRlAsRUFHRSxLQUFLQywyQkFIUDs7QUFLQWpvRSxlQUFTSSxtQkFBVCxDQUE2QixXQUE3QixFQUEwQyxLQUFLZ29FLFlBQS9DO0FBQ0Fwb0UsZUFBU0ksbUJBQVQsQ0FBNkIsV0FBN0IsRUFBMEMsS0FBS2dvRSxZQUEvQztBQUNBcG9FLGVBQVNJLG1CQUFULENBQTZCLFNBQTdCLEVBQXdDLEtBQUtpb0UsVUFBN0M7QUFDQXJvRSxlQUFTSSxtQkFBVCxDQUE2QixVQUE3QixFQUF5QyxLQUFLaW9FLFVBQTlDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O2tDQUtldHBFLEMsRUFBRztBQUNoQixVQUFNK29FLGlCQUFpQixLQUFLSSxrQkFBTCxDQUF3Qm5wRSxDQUF4QixDQUF2QjtBQUNBLFdBQUtELFFBQUwsQ0FBYztBQUNaK29FLHVCQUFlLElBREg7QUFFWkM7QUFGWSxPQUFkO0FBSUEsV0FBS00sWUFBTCxDQUFrQnJwRSxDQUFsQjtBQUNEOztBQUVEOzs7Ozs7O29DQUlpQjtBQUNmLFdBQUtELFFBQUwsQ0FBYztBQUNaK29FLHVCQUFlO0FBREgsT0FBZDtBQUdEOztBQUVEOzs7Ozs7OztpQ0FLYzlvRSxDLEVBQUc7QUFBQSxVQUNQZ0YsTUFETyxHQUNJLEtBQUtiLE9BRFQsQ0FDUGEsTUFETzs7QUFFZixVQUFNMkwsbUJBQW1CM0wsT0FBTzRMLG1CQUFQLEVBQXpCOztBQUVBLFVBQU13ZixPQUFPcHJCLE9BQU9vckIsSUFBUCxDQUFZaHNCLEdBQVosRUFBYjtBQUNBLFVBQU0ya0UsaUJBQWlCLEtBQUtJLGtCQUFMLENBQXdCbnBFLENBQXhCLENBQXZCO0FBQ0EsV0FBS0QsUUFBTCxDQUFjLEVBQUVncEUsOEJBQUYsRUFBZDs7QUFFQSxVQUFJUyxtQkFBSjtBQUNBLFVBQUksQ0FBQyxLQUFLWCxpQkFBVixFQUE2QjtBQUMzQlcscUJBQWEsSUFBYjtBQUNELE9BRkQsTUFFTztBQUNMLFlBQU1DLFlBQVksS0FBS2xoRSxjQUFMLENBQW9CLE1BQXBCLENBQWxCO0FBQ0EsWUFBTW1oRSxXQUFXLEtBQUtiLGlCQUFMLENBQXVCcG9FLEtBQXZCLEdBQ2RPLFFBRGMsQ0FDTCtuRSxjQURLLEVBRWR0N0QsR0FGYyxHQUVSc2EsR0FGUSxLQUVBcUksSUFGakI7QUFHQW81QyxxQkFBYUUsWUFBWUQsWUFBWSxFQUFyQztBQUNEOztBQUVELFVBQUksS0FBS2IsUUFBTCxJQUFpQlksVUFBckIsRUFBaUM7QUFDL0IsYUFBS0osWUFBTCxDQUFrQjdxQyxlQUFsQixDQUFrQ3dxQyxlQUFldG9FLEtBQWYsR0FBdUJvUSxNQUF2QixDQUE4QkYsZ0JBQTlCLENBQWxDO0FBQ0EsYUFBS2s0RCxpQkFBTCxHQUF5QkUsZUFBZXRvRSxLQUFmLEVBQXpCOztBQUVBdUUsZUFBT21MLE1BQVA7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7eUNBTXNCblEsQyxFQUFHO0FBQ3ZCLFVBQU0rb0UsaUJBQWlCLEtBQUtJLGtCQUFMLENBQXdCbnBFLENBQXhCLENBQXZCO0FBQ0EsV0FBS0QsUUFBTCxDQUFjLEVBQUVncEUsOEJBQUYsRUFBZDtBQUNEOztBQUVEOztBQUVBOzs7Ozs7OztzQ0FLbUI7QUFDakIsVUFBTXQ5RCxPQUFPLEtBQUtsRCxjQUFMLENBQW9CLE1BQXBCLENBQWI7O0FBRGlCLFVBR1R3Z0UsY0FIUyxHQUdVLEtBQUt0cUUsS0FIZixDQUdUc3FFLGNBSFM7O0FBSWpCLGFBQU87QUFDTGxvRSxjQUFNa29FLGVBQWU1b0UsQ0FEaEI7QUFFTFcsYUFBS2lvRSxlQUFlM29FLENBRmY7QUFHTGlDLGVBQU9vSixJQUhGO0FBSUx6SixnQkFBUXlKLElBSkg7QUFLTHFyRCxvQkFBWXJyRCxPQUFPLENBQUMsR0FMZjtBQU1Mc3JELG1CQUFXdHJELE9BQU8sQ0FBQztBQU5kLE9BQVA7QUFRRDs7QUFFRDs7QUFFQTs7Ozs7OzsyQ0FJd0I7QUFDdEIsV0FBS2srRCxzQkFBTCxHQUE4QixLQUFLcG5FLElBQUwsQ0FBVXFuRSxjQUFWLENBQXlCanBFLHFCQUF6QixFQUE5QjtBQUNEOztBQUVEOzs7Ozs7Ozt1Q0FLb0JrcEUsSyxFQUFPO0FBQ3pCLFVBQU05OEQsV0FBVzNSLGVBQU1tRixnQkFBTixDQUF1QnNwRSxLQUF2QixDQUFqQjtBQUNBLFVBQU1ucEUsZUFBZSxLQUFLaXBFLHNCQUExQjtBQUNBLGFBQU81OEQsU0FDSi9MLFFBREksQ0FDS04sYUFBYUcsSUFEbEIsRUFDd0JILGFBQWFJLEdBRHJDLENBQVA7QUFFRDs7QUFFRDs7Ozs7Ozs7eUNBS3NCO0FBQ3BCLFVBQUkrQixzS0FBSjs7QUFFQUEsWUFBTXlELFdBQU4sR0FBb0J6RCxNQUFNMkQsWUFBTixHQUFxQixLQUFLc2pFLFlBQTlDO0FBQ0EsYUFBT2puRSxLQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OzhDQUsyQjtBQUN6QixVQUFJQSwyS0FBSjs7QUFFQTtBQUNBLGFBQU9BLE1BQU1rTyxPQUFiOztBQUVBbE8sWUFBTTAzRCxZQUFOLEdBQXFCLEtBQUt3UCxhQUExQjtBQUNBbG5FLFlBQU00M0QsWUFBTixHQUFxQixLQUFLdVAsYUFBMUI7QUFDQW5uRSxZQUFNb25FLFdBQU4sR0FBb0IsS0FBS0Msb0JBQXpCO0FBQ0EsYUFBT3JuRSxLQUFQO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7O3lDQUtzQjtBQUNwQixhQUFPLElBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7NkNBSzBCO0FBQ3hCLFVBQU1zbkUsY0FBYyxLQUFLMXJFLEtBQUwsQ0FBV3FxRSxhQUFYLEdBQTJCLFlBQTNCLEdBQTBDLElBQTlEO0FBQ0EsYUFDRTtBQUFBO0FBQUEsVUFBSyxLQUFJLGdDQUFUO0FBQ0UsaURBQUssS0FBSSxVQUFULEVBQW9CLFdBQVdxQixXQUEvQixFQUE0QyxPQUFPLEtBQUtDLGVBQUwsRUFBbkQ7QUFERixPQURGO0FBS0Q7Ozs7RUFyU3VEejdELHdDOztrQkFBckNpNUQsNEI7OztBQXdTckJBLDZCQUE2QmprRSxZQUE3QixHQUE0Q2dMLHlDQUErQmhMLFlBQTNFLEM7Ozs7Ozs7Ozs7Ozs7OztBQzVTQTs7OztBQUNBOzs7Ozs7Ozs7OytlQWhCQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWlCQTs7Ozs7O0lBTU1nbkUsYTs7Ozs7Ozs7Ozs7O0FBQ0o7Ozs7Ozs2QkFNaUI7QUFBQSxVQUNQM2xFLE1BRE8sR0FDSSxLQUFLYixPQURULENBQ1BhLE1BRE87O0FBRWYsVUFBTWtLLFlBQVksS0FBSzNHLGNBQUwsQ0FBb0IsV0FBcEIsQ0FBbEI7QUFDQSxVQUFNbUgsaUJBQWlCLEtBQUtuSCxjQUFMLENBQW9CLGdCQUFwQixDQUF2Qjs7QUFFQSxVQUFNMmQsUUFBUWhYLFVBQVUwSSxRQUFWLEVBQWQ7QUFDQSxVQUFNb3BCLFFBQVE5eEIsVUFBVTA3RCxRQUFWLEVBQWQ7O0FBRUEsVUFBSSxDQUFDMWtELFNBQVNBLE1BQU1qaUIsVUFBaEIsT0FBaUN5TCxlQUFld1csS0FBZixJQUF3QnhXLGVBQWV3VyxLQUFmLENBQXFCamlCLFVBQTlFLEtBQ0ErOEIsVUFBVXR4QixlQUFlc3hCLEtBRDdCLEVBQ29DO0FBQ2xDaDhCLGVBQU9pckIsT0FBUCxDQUFlN2lCLEdBQWYsQ0FDRThCLFNBREYsRUFFRSxLQUFLM0csY0FBTCxDQUFvQixnQkFBcEIsQ0FGRixFQUdFLEtBQUtBLGNBQUwsQ0FBb0Isd0JBQXBCLENBSEY7QUFLRDs7QUFFRCxVQUFJLENBQUMyRyxVQUFVMEksUUFBVixFQUFMLEVBQTJCO0FBQ3pCNVMsZUFBT29LLFVBQVAsQ0FBa0JrK0MsTUFBbEIsQ0FBeUJwK0MsU0FBekI7QUFDRDs7QUFFRGxLLGFBQU9tTCxNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7NEJBT2dCd0IsVyxFQUFhO0FBQUEsVUFDbkIzTSxNQURtQixHQUNSLEtBQUtiLE9BREcsQ0FDbkJhLE1BRG1COztBQUUzQixVQUFNeUsseUJBQXlCekssT0FBT29LLFVBQVAsQ0FBa0IrVSxNQUFsQixDQUF5QixPQUF6QixDQUEvQjtBQUNBLFVBQU1qVixZQUFZbEssT0FBT29LLFVBQVAsQ0FBa0JDLFdBQWxCLENBQThCLE9BQTlCLENBQWxCO0FBQ0EsVUFBTUssaUJBQWlCUixVQUFVaXJCLGdCQUFWLEVBQXZCOztBQUVBLFdBQUszcUIsY0FBTCxDQUFvQjtBQUNsQk4sNEJBRGtCO0FBRWxCTyxzREFGa0I7QUFHbEJDLHNDQUhrQjtBQUlsQjJTLHlCQUFpQm5ULFVBQVVvVCxrQkFBVixFQUpDO0FBS2xCNEQsZUFBT2hYLFVBQVUwSSxRQUFWO0FBTFcsT0FBcEI7QUFPRDs7QUFFRDs7Ozs7Ozs7OztnQ0FPb0I1UyxNLEVBQVE7QUFDMUIsYUFBT0EsT0FBT3l1QixhQUFQLENBQXFCLE9BQXJCLEtBQ0x6dUIsT0FBTytuRCxhQUFQLENBQXFCLE9BQXJCLENBREY7QUFFRDs7OztFQS9EeUJ0cEIsa0I7O0FBa0U1Qjs7Ozs7OztBQUtBa25DLGNBQWN6bEUsaUJBQWQsR0FBa0MybEUsZ0NBQWxDOztBQUVBOzs7OztBQUtBRixjQUFjMW1FLFVBQWQsR0FBMkIsT0FBM0I7O0FBRUE7Ozs7O0FBS0EwbUUsY0FBY3ZsRSxRQUFkLEdBQXlCLDZCQUF6Qjs7QUFFQTs7Ozs7QUFLQXVsRSxjQUFjdGxFLFdBQWQsR0FBNEIsd0JBQTVCOztBQUVBOzs7OztBQUtBc2xFLGNBQWNybEUsY0FBZCxHQUErQjtBQUM3QmdtQixVQUFROztBQUdWOzs7O0FBSitCLENBQS9CLENBUUFxL0MsY0FBY2xlLGtCQUFkLEdBQW1DLENBQUMsUUFBRCxDQUFuQzs7QUFFQWtlLGNBQWN0UyxnQkFBZCxHQUFpQzUwQixtQkFBUzQwQixnQkFBMUM7O2tCQUVlc1MsYTs7Ozs7Ozs7Ozs7Ozs7O0FDdkhmOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OzsrZUF4QkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztJQXdCcUJHLDhCOzs7QUFDbkIsNENBQXNCO0FBQUE7O0FBQUE7O0FBQUEsc0NBQU5qbkUsSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEsMkxBQ1hBLElBRFc7O0FBR3BCLFVBQUtxcEQsVUFBTCxHQUFrQixNQUFLM2tELGNBQUwsQ0FBb0IsV0FBcEIsQ0FBbEI7QUFDQSxVQUFLL0osUUFBTCxDQUNFLGdCQURGLEVBRUUsZ0JBRkYsRUFHRSxxQkFIRixFQUlFLHFCQUpGOztBQU9BLFVBQUtxUSxPQUFMLHVEQUNHelMsbUJBQVVzTSxNQUFWLENBQWlCb0csaUJBRHBCLEVBQ3dDLE1BQUtDLG1CQUQ3QyxrQ0FFRzNTLG1CQUFVc00sTUFBVixDQUFpQnNHLGlCQUZwQixFQUV3QyxNQUFLQyxtQkFGN0M7O0FBS0EsVUFBSzg3RCxpQkFBTDtBQWhCb0I7QUFpQnJCOztBQUVEOztBQUVBOzs7Ozs7Ozt3Q0FJcUI7QUFDbkIsV0FBSzFsRCxhQUFMLEdBQXFCLElBQUlDLHNCQUFKLENBQWlCLEtBQUtuaEIsT0FBTCxDQUFhNEUsRUFBOUIsRUFBa0MsS0FBS2xHLEtBQUwsQ0FBVzRCLE9BQTdDLENBQXJCO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7O3dDQUtxQnlLLFMsRUFBVztBQUM5QixVQUFJQSxjQUFjLEtBQUszRyxjQUFMLENBQW9CLFdBQXBCLENBQWxCLEVBQW9EO0FBQ2xELGFBQUs4SCxpQkFBTDtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7O3dDQUtxQm5CLFMsRUFBVztBQUM5QixVQUFJQSxjQUFjLEtBQUszRyxjQUFMLENBQW9CLFdBQXBCLENBQWxCLEVBQW9EO0FBQ3BELFVBQUksS0FBS3ZFLGtCQUFULEVBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFOOEIsVUFPdEJnQixNQVBzQixHQU9YLEtBQUtiLE9BUE0sQ0FPdEJhLE1BUHNCOztBQVE5QixVQUFNbUssZUFBZW5LLE9BQU9vSyxVQUFQLENBQWtCQyxXQUFsQixDQUE4QixPQUE5QixDQUFyQjs7QUFFQSxXQUFLRyxjQUFMLENBQW9CO0FBQ2xCTixtQkFBV0MsWUFETztBQUVsQitXLGVBQU8sSUFGVztBQUdsQnpXLGdDQUF3QixLQUhOO0FBSWxCQyx3QkFBZ0I7QUFKRSxPQUFwQjs7QUFPQTFLLGFBQU9tTCxNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O21DQUtnQjZ3QixLLEVBQU87QUFBQSxVQUNiaDhCLE1BRGEsR0FDRixLQUFLYixPQURILENBQ2JhLE1BRGE7OztBQUdyQixVQUFNcWQsa0JBQWtCLEtBQUs5WixjQUFMLENBQW9CLGlCQUFwQixDQUF4QjtBQUNBLFdBQUsya0QsVUFBTCxDQUFnQjhkLFFBQWhCLENBQXlCaHFDLFFBQVEzZSxnQkFBZ0I1Z0IsR0FBaEIsRUFBakM7O0FBRUF1RCxhQUFPbUwsTUFBUDtBQUNEOztBQUVEOzs7Ozs7OzttQ0FLZ0JnRSxLLEVBQU87QUFDckIsVUFBTWpGLFlBQVksS0FBSzNHLGNBQUwsQ0FBb0IsV0FBcEIsQ0FBbEI7QUFDQTJHLGdCQUFVKzdELFlBQVYsQ0FBdUI5MkQsTUFBTTFULEtBQU4sRUFBdkI7O0FBRnFCLFVBSWJ1RSxNQUphLEdBSUYsS0FBS2IsT0FKSCxDQUliYSxNQUphOztBQUtyQkEsYUFBT21MLE1BQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7aUNBS2NuUSxDLEVBQUc7QUFDZixXQUFLZ0Usa0JBQUwsR0FBMEIsSUFBMUI7QUFDQSxXQUFLbkIsS0FBTCxDQUFXeUIsZ0JBQVgsQ0FBNEIsTUFBNUI7QUFDRDs7QUFFRDs7Ozs7Ozs7a0NBS2U2aEIsUyxFQUFXO0FBQUE7O0FBQUEsVUFDaEJuaEIsTUFEZ0IsR0FDTCxLQUFLYixPQURBLENBQ2hCYSxNQURnQjs7QUFFeEIsVUFBTWtLLFlBQVksS0FBSzNHLGNBQUwsQ0FBb0IsV0FBcEIsQ0FBbEI7QUFDQSxVQUFJNGQsY0FBYyxJQUFsQixFQUF3QjtBQUN0QmpYLGtCQUFVZzhELFFBQVYsQ0FBbUIsSUFBbkI7QUFDQWxtRSxlQUFPbUwsTUFBUDtBQUNBLGVBQU8sS0FBS1gsY0FBTCxDQUFvQixFQUFFMFcsT0FBTyxJQUFULEVBQXBCLENBQVA7QUFDRDs7QUFFRCxVQUFJODNCLHFCQUFKO0FBQ0EsVUFBSWdiLGNBQWN4b0QsV0FBVyxZQUFNO0FBQ2pDd3RDLHVCQUFlNWdELHVCQUFhc3dCLFFBQWIsQ0FBc0J1d0IsY0FBdEIsQ0FBcUMsT0FBSzc4QixFQUFMLENBQVEsMkJBQVIsQ0FBckMsQ0FBZjtBQUNELE9BRmlCLEVBRWYsR0FGZSxDQUFsQjs7QUFJQSxVQUFNOEUsUUFBUSxJQUFJSSxlQUFKLENBQVUsS0FBS25pQixPQUFMLENBQWE0RSxFQUF2QixFQUEyQm9kLFNBQTNCLENBQWQ7O0FBRUFELFlBQU1uYyxJQUFOLEdBQ0dDLElBREgsQ0FDUSxZQUFNO0FBQ1YsWUFBSWcwQyxZQUFKLEVBQWtCQSxhQUFhaHdCLEtBQWI7QUFDbEIsWUFBSWdyQyxXQUFKLEVBQWlCO0FBQ2Y3c0IsdUJBQWE2c0IsV0FBYjtBQUNBQSx3QkFBYyxJQUFkO0FBQ0Q7O0FBRUQsWUFBTW1TLGNBQWNqbEQsTUFBTXRPLFFBQU4sRUFBcEI7QUFDQTFJLGtCQUFVZzhELFFBQVYsQ0FBbUJDLFdBQW5COztBQVJVLFlBVUZubUUsTUFWRSxHQVVTLE9BQUtiLE9BVmQsQ0FVRmEsTUFWRTs7QUFXVkEsZUFBT21MLE1BQVA7O0FBRUEsZUFBS1gsY0FBTCxDQUFvQixFQUFFMFcsWUFBRixFQUFwQjtBQUNELE9BZkg7QUFnQkQ7O0FBRUQ7O0FBRUE7Ozs7Ozs7NENBSXlCO0FBQ3ZCLFVBQU1BLFFBQVEsS0FBSzNkLGNBQUwsQ0FBb0IsT0FBcEIsQ0FBZDs7QUFFQSxVQUFJLENBQUMyZCxLQUFMLEVBQVksT0FBTyxJQUFQOztBQUVaLFVBQU03RCxrQkFBa0IsS0FBSzlaLGNBQUwsQ0FBb0IsaUJBQXBCLENBQXhCOztBQUVBLFVBQU04L0QsVUFBVSxDQUFoQjtBQUNBLFVBQU1yVyxVQUFVbDNELEtBQUt5UyxLQUFMLENBQVcsTUFBTThVLGdCQUFnQjVnQixHQUFoQixFQUFqQixDQUFoQjtBQUNBLFVBQU0ycEUsZUFBZSxLQUFLbGUsVUFBTCxDQUFnQjBkLFFBQWhCLEtBQTZCdm9ELGdCQUFnQjVnQixHQUFoQixFQUFsRDs7QUFFQSxhQUFRLGdDQUFDLGdDQUFEO0FBQ04sa0JBQVU0bUUsT0FESjtBQUVOLGtCQUFVclcsT0FGSjtBQUdOLGVBQU9vWixZQUhEO0FBSU4sbUJBQVUsSUFKSjtBQUtOLG1CQUFXLEtBTEw7QUFNTixlQUFPLEtBQUtocUQsRUFBTCxDQUFRLHdCQUFSLENBTkQ7QUFPTixrQkFBVSxLQUFLaXFELGNBUFQsR0FBUjtBQVFEOztBQUVEOzs7Ozs7Ozt1Q0FLb0I7QUFBQTs7QUFDbEIsVUFBTS8vQyxTQUFTLEtBQUtqRyxhQUFMLENBQW1CaW1ELG9CQUFuQixDQUF3QyxLQUF4QyxDQUFmO0FBQ0EsVUFBTUMsZUFBZSxLQUFLaGpFLGNBQUwsQ0FBb0IsV0FBcEIsRUFBaUNxUCxRQUFqQyxFQUFyQjs7QUFFQSxVQUFNNHpELGNBQWU7QUFBQTtBQUFBO0FBQ25CLGVBQUksUUFEZTtBQUVuQixlQUFJLFVBRmU7QUFHbkIsbUJBQVMsS0FBS0MsYUFBTCxDQUFtQjV2RSxJQUFuQixDQUF3QixJQUF4QixFQUE4QixJQUE5QixDQUhVO0FBSW5CO0FBQUE7QUFBQSxZQUFLLFdBQVUsYUFBZjtBQUNFO0FBQUE7QUFBQSxjQUFLLEtBQUksdUJBQVQ7QUFDRSx5QkFBVyxDQUFDMHZFLFlBQUQsR0FBZ0IsV0FBaEIsR0FBOEIsSUFEM0M7QUFFRSxxREFBSyxLQUFJLFFBQVQsRUFBa0IsS0FBSyxLQUFLOXRELGFBQUwsZ0NBQWtELElBQWxELENBQXZCLEdBRkY7QUFHRTtBQUFBO0FBQUEsZ0JBQUssS0FBSSxTQUFUO0FBQW9CLG1CQUFLMkQsRUFBTCxDQUFRLHlCQUFSO0FBQXBCO0FBSEY7QUFERjtBQUptQixPQUFyQjs7QUFhQSxhQUFPLENBQUNvcUQsV0FBRCxFQUFjcGdFLE1BQWQsQ0FBcUJrZ0IsT0FBT3RnQixHQUFQLENBQVcsVUFBQ2tiLEtBQUQsRUFBUTNFLENBQVIsRUFBYztBQUNuRCxlQUFRLGdDQUFDLDRCQUFEO0FBQ04saUJBQU8yRSxLQUREO0FBRU4sa0JBQVFxbEQsZ0JBQWdCQSxhQUFhdG5FLFVBQWIsS0FBNEJpaUIsTUFBTWppQixVQUZwRDtBQUdOLG1CQUFTLE9BQUt3bkUsYUFBTCxDQUFtQjV2RSxJQUFuQixDQUF3QixNQUF4QixFQUE4QnFxQixLQUE5QixDQUhILEdBQVI7QUFJRCxPQUwyQixDQUFyQixDQUFQO0FBTUQ7O0FBRUQ7Ozs7Ozs7cUNBSWtCO0FBQ2hCLFVBQU1BLFFBQVEsS0FBSzNkLGNBQUwsQ0FBb0IsV0FBcEIsRUFBaUNxUCxRQUFqQyxFQUFkO0FBQ0EsVUFBTTBYLFlBQVksS0FBS0MsZ0JBQUwsRUFBbEI7O0FBRUEsVUFBTVgsUUFBUSxDQUFFO0FBQUE7QUFBQSxVQUFLLEtBQUksZUFBVDtBQUNkO0FBQUMsc0NBQUQ7QUFBQSxZQUFvQixLQUFJLFdBQXhCO0FBQ0U7QUFBQTtBQUFBLGNBQUksS0FBSSxTQUFSO0FBQ0dVO0FBREg7QUFERjtBQURjLE9BQUYsQ0FBZDs7QUFRQSxVQUFJcEosU0FBU0EsTUFBTTJGLFFBQW5CLEVBQTZCO0FBQzNCLFlBQU0zYyxZQUFZLEtBQUszRyxjQUFMLENBQW9CLFdBQXBCLENBQWxCO0FBQ0FxbUIsY0FBTWx4QixJQUFOLENBQVc7QUFBQTtBQUFBLFlBQUssS0FBSSxzQkFBVDtBQUNULDBDQUFDLDhCQUFEO0FBQ0UsMEJBQWN3UixVQUFVNHhCLFlBQVYsR0FBeUJyZ0MsS0FBekIsRUFEaEI7QUFFRSxzQkFBVSxLQUFLMmtFLGNBRmpCO0FBRFMsU0FBWDtBQUtEOztBQUVELGFBQU94MkMsS0FBUDtBQUNEOzs7O0VBbk95RGhyQiwyQjs7a0JBQXZDa25FLDhCOzs7QUFzT3JCQSwrQkFBK0JubkUsWUFBL0IsR0FBOENDLDRCQUFrQkQsWUFBaEUsQzs7Ozs7Ozs7Ozs7Ozs7O0FDaFBBOzs7Ozs7K2VBaEJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFnQnFCK25FLGtCOzs7QUFDbkIsZ0NBQXNCO0FBQUE7O0FBQUE7O0FBQUEsc0NBQU43bkUsSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEsbUtBQ1hBLElBRFc7O0FBR3BCLFVBQUtwRixLQUFMLEdBQWE7QUFDWHluQixhQUFPLE1BQUtyakIsS0FBTCxDQUFXcWpCO0FBRFAsS0FBYjtBQUhvQjtBQU1yQjs7QUFFRDs7Ozs7Ozt3Q0FHcUI7QUFDbkIsV0FBS3lsRCxZQUFMO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OENBSTJCbnNELFMsRUFBVztBQUFBOztBQUNwQyxVQUFJLEtBQUszYyxLQUFMLENBQVdxakIsS0FBWCxLQUFxQjFHLFVBQVUwRyxLQUFuQyxFQUEwQztBQUN4QyxhQUFLbm1CLFFBQUwsQ0FBYyxFQUFFbW1CLE9BQU8xRyxVQUFVMEcsS0FBbkIsRUFBZCxFQUEwQyxZQUFNO0FBQzlDLGlCQUFLeWxELFlBQUw7QUFDRCxTQUZEO0FBR0Q7QUFDRjs7QUFFRDs7Ozs7OzttQ0FJZ0I7QUFBQSxVQUNOM21FLE1BRE0sR0FDSyxLQUFLYixPQURWLENBQ05hLE1BRE07O0FBRWQsVUFBTSt4QixNQUFNL3hCLE9BQU9neUIsTUFBUCxFQUFaOztBQUZjLFVBSU45USxLQUpNLEdBSUksS0FBS3JqQixLQUpULENBSU5xakIsS0FKTTs7O0FBTWQsVUFBTTBsRCxvQkFBb0IsS0FBS251RCxhQUFMLENBQW1CeUksTUFBTWdGLFNBQXpCLENBQTFCO0FBQ0EsVUFBTWxTLFNBQVMsS0FBS3pXLElBQUwsYUFBb0IyakIsTUFBTWppQixVQUExQixDQUFmOztBQUVBLFVBQU04dUIsYUFBYWdFLElBQUlFLGFBQUosRUFBbkI7QUFDQWplLGFBQU8zVyxLQUFQLEdBQWUyVyxPQUFPeFosV0FBUCxHQUFxQnV6QixVQUFwQztBQUNBL1osYUFBT2hYLE1BQVAsR0FBZ0JnWCxPQUFPblosWUFBUCxHQUFzQmt6QixVQUF0Qzs7QUFFQS9aLGFBQU9qWCxLQUFQLENBQWFNLEtBQWIsR0FBd0IyVyxPQUFPeFosV0FBL0I7QUFDQXdaLGFBQU9qWCxLQUFQLENBQWFDLE1BQWIsR0FBeUJnWCxPQUFPblosWUFBaEM7O0FBRUEsVUFBTXNFLFVBQVU2VSxPQUFPbEIsVUFBUCxDQUFrQixJQUFsQixDQUFoQjs7QUFFQSxVQUFNaEIsUUFBUSxJQUFJbmIsT0FBT29iLEtBQVgsRUFBZDtBQUNBRCxZQUFNNVYsZ0JBQU4sQ0FBdUIsTUFBdkIsRUFBK0IsWUFBTTtBQUNuQyxZQUFNOC9CLFFBQVFsbUMsS0FBSzJHLEdBQUwsQ0FBU3VYLE9BQU8zVyxLQUFQLEdBQWV5VSxNQUFNelUsS0FBOUIsRUFBcUMyVyxPQUFPaFgsTUFBUCxHQUFnQjhVLE1BQU05VSxNQUEzRCxDQUFkO0FBQ0EsWUFBTXUzRCxXQUFXLElBQUk5OUQsZ0JBQUosQ0FBWXFiLE1BQU16VSxLQUFsQixFQUF5QnlVLE1BQU05VSxNQUEvQixFQUNkc2QsUUFEYyxDQUNMMGhCLEtBREssQ0FBakI7QUFFQSxZQUFNdzRCLGVBQWUsSUFBSS85RCxnQkFBSixDQUFZdWQsT0FBTzNXLEtBQW5CLEVBQTBCMlcsT0FBT2hYLE1BQWpDLEVBQ2xCNk8sTUFEa0IsQ0FDWCxDQURXLEVBRWxCN1AsUUFGa0IsQ0FFVHU0RCxTQUFTOTRELEtBQVQsR0FBaUJvUSxNQUFqQixDQUF3QixDQUF4QixDQUZTLENBQXJCOztBQUlBMU0sZ0JBQVFtMUIsU0FBUixDQUFrQnhpQixLQUFsQixFQUNFLENBREYsRUFDSyxDQURMLEVBRUVBLE1BQU16VSxLQUZSLEVBRWV5VSxNQUFNOVUsTUFGckIsRUFHRXczRCxhQUFhcjVELENBSGYsRUFHa0JxNUQsYUFBYXA1RCxDQUgvQixFQUlFbTVELFNBQVNwNUQsQ0FKWCxFQUljbzVELFNBQVNuNUQsQ0FKdkI7QUFLRCxPQWJEO0FBY0EwVyxZQUFNa0YsV0FBTixHQUFvQixLQUFLN1gsT0FBTCxDQUFhYSxNQUFiLENBQW9CeWlCLGNBQXBCLEVBQXBCO0FBQ0EzUSxZQUFNSSxHQUFOLEdBQVkwMEQsaUJBQVo7QUFDRDs7QUFFRDs7Ozs7OztvQ0FJaUI7QUFDZixhQUFRO0FBQUE7QUFBQSxVQUFLLFdBQVUsbUJBQWY7QUFDTjtBQUFBO0FBQUE7QUFDRSxpQkFBSSxRQUROO0FBRUUsaUJBQUssS0FBSy9vRSxLQUFMLENBQVdxakIsS0FBWCxDQUFpQmppQixVQUZ4QjtBQUdFLHFCQUFTLEtBQUtwQixLQUFMLENBQVdrTyxPQUh0QjtBQUlFO0FBQUE7QUFBQSxjQUFLLFdBQVUsYUFBZjtBQUNFO0FBQUE7QUFBQSxnQkFBSyxLQUFJLDZCQUFUO0FBQ0UsMERBQVEsS0FBSSxrQkFBWixFQUErQixpQkFBZSxLQUFLbE8sS0FBTCxDQUFXcWpCLEtBQVgsQ0FBaUJqaUIsVUFBL0QsR0FERjtBQUVFO0FBQUE7QUFBQSxrQkFBSyxLQUFJLGdCQUFULEVBQTBCLFdBQVcsS0FBS3BCLEtBQUwsQ0FBVzA4QyxNQUFYLEdBQW9CLFdBQXBCLEdBQWtDLElBQXZFO0FBQ0U7QUFBQTtBQUFBLG9CQUFLLEtBQUksU0FBVDtBQUFvQix1QkFBS24rQixFQUFMLHdCQUE2QixLQUFLdmUsS0FBTCxDQUFXcWpCLEtBQVgsQ0FBaUJqaUIsVUFBOUMsS0FBK0QsS0FBS3BCLEtBQUwsQ0FBV3FqQixLQUFYLENBQWlCbmI7QUFBcEc7QUFERjtBQUZGO0FBREY7QUFKRjtBQURNLE9BQVI7QUFlRDs7OztFQXpGNkM3TyxzQjs7a0JBQTNCd3ZFLGtCOzs7Ozs7Ozs7Ozs7O3FqQkNsQnJCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBY0E7Ozs7SUFFcUJoN0MsYztBQUNuQiwwQkFBYTFyQixNQUFiLEVBQXFCK3hCLEdBQXJCLEVBQTBCdHVCLFFBQTFCLEVBQW9DO0FBQUE7O0FBQ2xDLFNBQUt5YixPQUFMLEdBQWVsZixNQUFmO0FBQ0EsU0FBS21yQixJQUFMLEdBQVk0RyxHQUFaO0FBQ0EsU0FBS3JILFNBQUwsR0FBaUJqbkIsUUFBakI7O0FBRUEsU0FBS1EsUUFBTCxHQUFnQixLQUFLaWIsT0FBTCxDQUFha1ksVUFBYixFQUFoQjs7QUFFQSxTQUFLeXZDLFNBQUwsR0FBaUI7QUFDZkMsWUFBTSxLQUFLN2lFLFFBQUwsQ0FBY2pFLE1BQWQsQ0FBcUIwZ0MsVUFEWjtBQUVmdFYsWUFBTSxLQUFLbm5CLFFBQUwsQ0FBY2pFLE1BQWQsQ0FBcUJ5Z0M7QUFGWixLQUFqQjtBQUlEOztBQUVEOzs7Ozs7Ozs7OEJBS1d4aEMsVSxFQUFZO0FBQ3JCLFVBQU04bkUsd0JBQXdCOW5FLFdBQVc0b0MsTUFBWCxDQUFrQixDQUFsQixFQUFxQnBCLFdBQXJCLEtBQXFDeG5DLFdBQVdrRyxLQUFYLENBQWlCLENBQWpCLENBQW5FO0FBQ0EsVUFBTTZoRSxnQkFBZ0IsS0FBSy9pRSxRQUFMLENBQWNqRSxNQUFkLFlBQThCK21FLHFCQUE5QixDQUF0QjtBQUNBLGFBQU8sS0FBS0YsU0FBTCxDQUFlNW5FLFVBQWYsS0FBOEIrbkUsYUFBckM7QUFDRDs7QUFFRDs7Ozs7Ozs2QkFJd0I7QUFBQTs7QUFBQSx3Q0FBYmxrQixXQUFhO0FBQWJBLG1CQUFhO0FBQUE7O0FBQ3RCQSxrQkFBWXo5QyxPQUFaLENBQW9CLFVBQUNwRyxVQUFELEVBQWdCO0FBQ2xDLGNBQUs0bkUsU0FBTCxDQUFlNW5FLFVBQWYsSUFBNkIsSUFBN0I7QUFDRCxPQUZEO0FBR0EsV0FBS3lyQixTQUFMLENBQWV2eUIsSUFBZixDQUFvQmYsbUJBQVVzTSxNQUFWLENBQWlCZ3VDLGdCQUFyQyxFQUF1RG9SLFdBQXZEO0FBQ0EsV0FBS3A0QixTQUFMLENBQWV2eUIsSUFBZixDQUFvQmYsbUJBQVVzTSxNQUFWLENBQWlCaXVDLGdCQUFyQyxFQUF1RG1SLFdBQXZEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OEJBSXlCO0FBQUE7O0FBQUEseUNBQWJBLFdBQWE7QUFBYkEsbUJBQWE7QUFBQTs7QUFDdkJBLGtCQUFZejlDLE9BQVosQ0FBb0IsVUFBQ3BHLFVBQUQsRUFBZ0I7QUFDbEMsZUFBSzRuRSxTQUFMLENBQWU1bkUsVUFBZixJQUE2QixLQUE3QjtBQUNELE9BRkQ7QUFHQSxXQUFLeXJCLFNBQUwsQ0FBZXZ5QixJQUFmLENBQW9CZixtQkFBVXNNLE1BQVYsQ0FBaUIrdEMsaUJBQXJDLEVBQXdEcVIsV0FBeEQ7QUFDQSxXQUFLcDRCLFNBQUwsQ0FBZXZ5QixJQUFmLENBQW9CZixtQkFBVXNNLE1BQVYsQ0FBaUJpdUMsZ0JBQXJDLEVBQXVEbVIsV0FBdkQ7QUFDRDs7Ozs7O2tCQS9Da0JwM0IsYzs7Ozs7Ozs7Ozs7Ozs7O0FDRnJCOzs7Ozs7K2VBZkE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFnQkEsSUFBTXU3QyxzQkFBc0IsR0FBNUI7O0lBRXFCNTdDLFU7OztBQUNuQixzQkFBYXJyQixNQUFiLEVBQXFCK3hCLEdBQXJCLEVBQTBCdHVCLFFBQTFCLEVBQW9DO0FBQUE7O0FBQUE7O0FBRWxDLFVBQUt5YixPQUFMLEdBQWVsZixNQUFmO0FBQ0EsVUFBS21yQixJQUFMLEdBQVk0RyxHQUFaO0FBQ0EsVUFBS3JILFNBQUwsR0FBaUJqbkIsUUFBakI7O0FBRUEsVUFBS3lqRSxjQUFMLEdBQXNCLEtBQXRCO0FBQ0EsVUFBS0MsS0FBTCxHQUFhLE1BQUtoOEMsSUFBTCxDQUFVaThDLE9BQVYsRUFBYjtBQUNBLFVBQUtuakUsUUFBTCxHQUFnQixNQUFLaWIsT0FBTCxDQUFha1ksVUFBYixFQUFoQjs7QUFFQSxVQUFLaXdDLFdBQUwsR0FBbUIsQ0FDakIsQ0FEaUIsRUFDZCxDQURjLEVBQ1gsQ0FEVyxFQUNSLENBRFEsRUFDTCxDQURLLEVBRWpCLElBRmlCLEVBRVgsSUFGVyxFQUVMLElBRkssRUFHakIsS0FIaUIsRUFHVixFQUhVLEVBR04sS0FITSxFQUdDLEVBSEQsRUFHSyxLQUhMLEVBR1ksR0FIWixFQUlqQixHQUppQixFQUlaLEdBSlksRUFJUCxHQUpPLEVBSUYsR0FKRSxFQUlHLEdBSkgsRUFJUSxHQUpSLEVBSWEsR0FKYixFQUtqQixJQUxpQixFQUtYLElBTFcsRUFLTCxJQUxLLEVBTWpCcmhFLEdBTmlCLENBTWIsVUFBQ3NoRSxDQUFEO0FBQUEsYUFBT0EsSUFBSSxHQUFYO0FBQUEsS0FOYSxDQUFuQjtBQVZrQztBQWlCbkM7O0FBRUQ7Ozs7Ozs7MEJBR007QUFDSixVQUFNQyxVQUFVLEtBQUtDLG9CQUFMLENBQTBCLEtBQUtMLEtBQUwsR0FBYSxLQUF2QyxFQUE4QyxDQUFDLENBQS9DLENBQWhCO0FBQ0EsVUFBSSxDQUFDSSxPQUFMLEVBQWMsT0FBTyxLQUFLRixXQUFMLENBQWlCLEtBQUtBLFdBQUwsQ0FBaUJ4aEUsTUFBakIsR0FBMEIsQ0FBM0MsQ0FBUDtBQUNkLFdBQUt4RyxHQUFMLENBQVNrb0UsT0FBVDtBQUNEOztBQUVEOzs7Ozs7MEJBR087QUFDTCxVQUFNQSxVQUFVLEtBQUtDLG9CQUFMLENBQTBCLEtBQUtMLEtBQUwsR0FBYSxLQUF2QyxFQUE4QyxDQUFDLENBQS9DLENBQWhCO0FBQ0EsVUFBSSxDQUFDSSxPQUFMLEVBQWMsT0FBTyxLQUFLRixXQUFMLENBQWlCLENBQWpCLENBQVA7QUFDZCxXQUFLaG9FLEdBQUwsQ0FBU2tvRSxPQUFUO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7eUNBT3NCRSxTLEVBQVd6dEUsUyxFQUFXO0FBQzFDLFVBQUlBLGNBQWMsQ0FBQyxDQUFuQixFQUFzQjtBQUNwQixlQUFPLEtBQUtxdEUsV0FBTCxDQUNKMWhFLE1BREksQ0FDRyxVQUFDaUwsQ0FBRDtBQUFBLGlCQUFPQSxJQUFJNjJELFNBQVg7QUFBQSxTQURILEVBRUpqcEQsR0FGSSxFQUFQO0FBR0QsT0FKRCxNQUlPLElBQUl4a0IsY0FBYyxDQUFsQixFQUFxQjtBQUMxQixlQUFPLEtBQUtxdEUsV0FBTCxDQUNKMWhFLE1BREksQ0FDRyxVQUFDaUwsQ0FBRDtBQUFBLGlCQUFPQSxJQUFJNjJELFNBQVg7QUFBQSxTQURILEVBQ3lCLENBRHpCLENBQVA7QUFFRDtBQUNGOztBQUVEOzs7Ozs7OEJBR1c7QUFDVCxVQUFJLENBQUMsS0FBS0MsYUFBVixFQUF5QjtBQUN6QixXQUFLcm9FLEdBQUwsQ0FBUyxLQUFLcW9FLGFBQWQ7QUFDQSxXQUFLQSxhQUFMLEdBQXFCLElBQXJCO0FBQ0Q7O0FBRUQ7Ozs7OzsyQkFHUTtBQUNOLFdBQUtBLGFBQUwsR0FBcUIsS0FBS1AsS0FBMUI7QUFDRDs7QUFFRDs7Ozs7Ozs7O3dCQU1LLzdDLEksRUFBTThDLFEsRUFBa0M7QUFBQSxVQUF4Qnk1QyxlQUF3Qix1RUFBTixJQUFNOztBQUMzQyxVQUFJLENBQUMsS0FBS3pvRCxPQUFMLENBQWF5a0MsT0FBYixFQUFMLEVBQTZCO0FBQzNCO0FBQ0Q7O0FBRUQsVUFBSTRqQixVQUFVbjhDLElBQWQ7QUFDQSxVQUFNdzhDLGNBQWMsS0FBS2hrQixVQUFMLEVBQXBCO0FBQ0EsVUFBSXg0QixTQUFTLE1BQVQsSUFBbUJtOEMsWUFBWUssV0FBbkMsRUFBZ0Q7QUFDOUNMLGtCQUFVSyxXQUFWO0FBQ0F4OEMsZUFBTyxNQUFQOztBQUVBLGFBQUs4N0MsY0FBTCxHQUFzQixJQUF0QjtBQUNELE9BTEQsTUFLTztBQUNMLGFBQUtBLGNBQUwsR0FBc0IsS0FBdEI7QUFDRDs7QUFFRCxVQUFNVyxVQUFVL3hFLEtBQUswRyxHQUFMLENBQVMsQ0FBVCxFQUFZb3JFLGNBQWMsQ0FBMUIsQ0FBaEI7QUFDQSxVQUFNRSxVQUFVSCxrQkFBa0IsS0FBS0ksVUFBTCxFQUFsQixHQUFzQyxDQUF0RDtBQUNBUixnQkFBVXp4RSxLQUFLMEcsR0FBTCxDQUFTc3JFLE9BQVQsRUFBa0JoeUUsS0FBSzJHLEdBQUwsQ0FBU29yRSxPQUFULEVBQWtCTixPQUFsQixDQUFsQixDQUFWOztBQUVBLFdBQUtKLEtBQUwsR0FBYUksT0FBYjtBQUNBLFdBQUtwOEMsSUFBTCxDQUFVNjhDLE9BQVYsQ0FBa0IsS0FBS2IsS0FBdkI7QUFDQSxXQUFLaDhDLElBQUwsQ0FBVTg4QyxpQkFBVixDQUE0Qm55RSxLQUFLMkcsR0FBTCxDQUFTLEtBQUswcUUsS0FBZCxFQUFxQixDQUFyQixDQUE1QjtBQUNBLFdBQUtodkUsSUFBTCxDQUFVLEtBQVYsRUFBaUIsS0FBS2d2RSxLQUF0QixFQUE2Qmo1QyxRQUE3QjtBQUNEOztBQUVEOzs7Ozs7O2lDQUljO0FBQ1osVUFBTWsxQyxrQkFBa0IsS0FBS2xrRCxPQUFMLENBQWE4UCxrQkFBYixDQUFnQyxLQUFoQyxDQUF4QjtBQUNBLFVBQU12akIsbUJBQW1CLEtBQUt5VCxPQUFMLENBQWF4VCxtQkFBYixFQUF6QjtBQUNBLFVBQU13OEQsb0JBQW9CL3hFLGtCQUFTMCtELGlCQUFULENBQTJCdU8sZUFBM0IsRUFBNEMzM0QsZ0JBQTVDLENBQTFCOztBQUVBLGFBQU95OEQsa0JBQ0pyOEQsTUFESSxDQUNHdTNELGVBREgsRUFFSmpvRSxDQUZIO0FBR0Q7O0FBRUQ7Ozs7Ozs7aUNBSWM7QUFDWixVQUFNaW9FLGtCQUFrQixLQUFLbGtELE9BQUwsQ0FBYThQLGtCQUFiLEVBQXhCO0FBQ0EsVUFBTW01QyxvQkFBb0JoeUUsa0JBQVMwK0QsaUJBQVQsQ0FDeEJ1TyxlQUR3QixFQUV4QixJQUFJM3NFLGdCQUFKLENBQVl3d0UsbUJBQVosRUFBaUNBLG1CQUFqQyxDQUZ3QixDQUExQjs7QUFLQSxhQUFPa0Isa0JBQ0p0OEQsTUFESSxDQUNHdTNELGVBREgsRUFFSmpvRSxDQUZIO0FBR0Q7O0FBRUQ7Ozs7Ozs7Z0NBSWE7QUFDWCxhQUFPLEtBQUsrckUsY0FBWjtBQUNEOztBQUVEOzs7Ozs7OzBCQUlPO0FBQ0wsYUFBTyxLQUFLQyxLQUFaO0FBQ0Q7Ozs7RUFwSnFDcHhFLHFCOztrQkFBbkJzMUIsVTs7Ozs7Ozs7Ozs7Ozs7O0FDSnJCOzs7Ozs7K2VBZkE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7SUFnQnFCSCxhOzs7QUFDbkIseUJBQWFsckIsTUFBYixFQUFxQit4QixHQUFyQixFQUEwQnR1QixRQUExQixFQUFvQztBQUFBOztBQUFBOztBQUdsQyxVQUFLeWIsT0FBTCxHQUFlbGYsTUFBZjtBQUNBLFVBQUttckIsSUFBTCxHQUFZNEcsR0FBWjtBQUNBLFVBQUtySCxTQUFMLEdBQWlCam5CLFFBQWpCOztBQUVBLFVBQUsya0UsUUFBTCxHQUFnQixFQUFoQjtBQVBrQztBQVFuQzs7QUFFRDs7Ozs7Ozs7a0NBSWU7QUFDYixhQUFPLEtBQUtBLFFBQUwsQ0FBY3ZpRSxNQUFkLEtBQXlCLENBQWhDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7O3dCQVFLcUUsUyxFQUFXekssTyxFQUFTd3JELFEsRUFBdUI7QUFBQTs7QUFBQSxVQUFidkcsSUFBYSx1RUFBTixJQUFNOztBQUM5QyxVQUFJMmpCLG9CQUFKO0FBQ0EsVUFBSW4rRCxxQkFBcUI5SSxLQUF6QixFQUFnQztBQUM5QixZQUFNd29CLFFBQVExZixTQUFkO0FBQ0EsYUFBS2srRCxRQUFMLENBQWMxdkUsSUFBZCxDQUFtQmt4QixLQUFuQjtBQUNBQSxjQUFNdmtCLE9BQU4sQ0FBYyxVQUFDZzVCLElBQUQsRUFBVTtBQUN0QixpQkFBSzNULFNBQUwsQ0FBZXZ5QixJQUFmLENBQW9CZixtQkFBVXNNLE1BQVYsQ0FBaUJrdUMsZUFBckMsRUFBc0R2VCxLQUFLbjBCLFNBQTNEO0FBQ0QsU0FGRDs7QUFJQW0rRCxzQkFBY3orQyxLQUFkO0FBQ0QsT0FSRCxNQVFPO0FBQ0x5K0Msc0JBQWM7QUFDWm4rRCw4QkFEWSxFQUNEekssZ0JBREMsRUFDUXdyRCxrQkFEUixFQUNrQnZHO0FBRGxCLFNBQWQ7QUFHQSxhQUFLMGpCLFFBQUwsQ0FBYzF2RSxJQUFkLENBQW1CMnZFLFdBQW5CO0FBQ0EsYUFBSzM5QyxTQUFMLENBQWV2eUIsSUFBZixDQUFvQmYsbUJBQVVzTSxNQUFWLENBQWlCa3VDLGVBQXJDLEVBQXNEMW5DLFNBQXREO0FBQ0Q7QUFDRCxhQUFPbStELFdBQVA7QUFDRDs7QUFFRDs7Ozs7OzJCQUdRO0FBQUE7O0FBQUEsVUFDRWorRCxVQURGLEdBQ2lCLEtBQUs4VSxPQUR0QixDQUNFOVUsVUFERjs7QUFFTixVQUFNaytELFdBQVcsS0FBS0YsUUFBTCxDQUFjNXBELEdBQWQsRUFBakI7QUFDQSxVQUFJOHBELFFBQUosRUFBYztBQUNaLFlBQU0xK0MsUUFBUSxHQUFHeGpCLE1BQUgsQ0FBVWtpRSxRQUFWLENBQWQ7O0FBRUExK0MsY0FDR3ZrQixPQURILENBQ1csVUFBQ3V1RCxhQUFELEVBQW1CO0FBQUEsY0FDcEIxcEQsU0FEb0IsR0FDbUIwcEQsYUFEbkIsQ0FDcEIxcEQsU0FEb0I7QUFBQSxjQUNUK2dELFFBRFMsR0FDbUIySSxhQURuQixDQUNUM0ksUUFEUztBQUFBLGNBQ0N4ckQsT0FERCxHQUNtQm0wRCxhQURuQixDQUNDbjBELE9BREQ7QUFBQSxjQUNVaWxELElBRFYsR0FDbUJrUCxhQURuQixDQUNVbFAsSUFEVjs7QUFFMUIsaUJBQUtoNkIsU0FBTCxDQUFldnlCLElBQWYsQ0FBb0JmLG1CQUFVc00sTUFBVixDQUFpQm11QyxtQkFBckMsRUFBMEQraEIsYUFBMUQ7O0FBRUEsY0FBSSxDQUFDM0ksUUFBTCxFQUFlO0FBQ2I3Z0QsdUJBQVdrK0MsTUFBWCxDQUFrQnArQyxTQUFsQjtBQUNELFdBRkQsTUFFTztBQUNMQSx3QkFBWUUsV0FBV0MsV0FBWCxDQUF1QkgsVUFBVS9RLFdBQVYsQ0FBc0I4RixVQUE3QyxDQUFaO0FBQ0FpTCxzQkFBVTdLLEdBQVYsQ0FBY0ksT0FBZDtBQUNBLG1CQUFLaXJCLFNBQUwsQ0FBZXZ5QixJQUFmLENBQW9CZixtQkFBVXNNLE1BQVYsQ0FBaUJvRyxpQkFBckMsRUFBd0RJLFNBQXhEO0FBQ0Q7O0FBRUQsY0FBSSxPQUFPdzZDLElBQVAsS0FBZ0IsVUFBcEIsRUFBZ0M7QUFDOUJBLGlCQUFLeDZDLFNBQUwsRUFBZ0J6SyxPQUFoQjtBQUNEOztBQUVELGlCQUFLaXJCLFNBQUwsQ0FBZXZ5QixJQUFmLENBQW9CZixtQkFBVXNNLE1BQVYsQ0FBaUJrdUMsZUFBckMsRUFBc0QxbkMsU0FBdEQ7QUFDQSxpQkFBS3dnQixTQUFMLENBQWV2eUIsSUFBZixDQUFvQmYsbUJBQVVzTSxNQUFWLENBQWlCb3VDLFlBQXJDLEVBQW1ENW5DLFNBQW5EO0FBQ0QsU0FuQkg7O0FBcUJBLGFBQUsvUixJQUFMLENBQVUsTUFBVjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs0QkFHUztBQUNQLFdBQUtpd0UsUUFBTCxHQUFnQixFQUFoQjtBQUNEOzs7O0VBdEZ3Q3J5RSxxQjs7a0JBQXRCbTFCLGE7Ozs7Ozs7Ozs7Ozs7cWpCQ2pCckI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFjQTs7OztBQUNBOzs7Ozs7OztJQUVxQnE5QyxhO0FBQ25CLHlCQUFhdm9FLE1BQWIsRUFBcUI7QUFBQTs7QUFDbkIsU0FBS2tmLE9BQUwsR0FBZWxmLE1BQWY7QUFDRDs7QUFFRDs7Ozs7Ozs7Z0NBSW9CO0FBQ2xCLFVBQU04dkIsYUFBYSxJQUFJRCxvQkFBSixDQUFlLEtBQUszUSxPQUFwQixDQUFuQjtBQUNBLGFBQU80USxXQUFXQyxTQUFYLDZCQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O2dDQUthNzNCLEksRUFBTTtBQUNqQixVQUFNc3dFLGVBQWUsSUFBSUMsc0JBQUosQ0FBaUIsS0FBS3ZwRCxPQUF0QixFQUErQmhuQixJQUEvQixDQUFyQjtBQUNBLGFBQU9zd0UsYUFBYXg0QyxXQUFiLEVBQVA7QUFDRDs7Ozs7O2tCQXRCa0J1NEMsYTs7O0FBeUJyQkEsY0FBY3RvRCxPQUFkLEdBQXdCLE9BQXhCLEM7Ozs7OztBQzNDQTs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0wsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7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YyxVQUFVLCtNQUErTSxZQUFZLFNBQVMsd0NBQXdDLE1BQU0sb0RBQW9ELFNBQVMsaUVBQWlFLE1BQU0sNEVBQTRFLE1BQU0sY0FBYyxnQkFBZ0IsOEJBQThCLFdBQVcsVUFBVSw2QkFBNkIsVUFBVSxtREFBbUQsU0FBUyxrTEFBa0wsWUFBWSxTQUFTLG1FQUFtRSxVQUFVLG1GQUFtRixTQUFTLFNBQVMsMERBQTBELFNBQVMsMERBQTBELFdBQVcsaUlBQWlJLGdCQUFnQixzQ0FBc0MsY0FBYyxTQUFTLG1CQUFtQixXQUFXLGtCQUFrQixTQUFTLHNCQUFzQixVQUFVLHlVIiwiZmlsZSI6IlBob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJwaG90b2VkaXRvcnNkay9qcy9QaG90b0VkaXRvclNES1wiKSwgcmVxdWlyZShcInJlYWN0XCIpLCByZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInBob3RvZWRpdG9yc2RrXCIsIFwicmVhY3RcIiwgXCJyZWFjdC1kb21cIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUGhvdG9FZGl0b3JSZWFjdFVJXCJdID0gZmFjdG9yeShyZXF1aXJlKFwicGhvdG9lZGl0b3JzZGsvanMvUGhvdG9FZGl0b3JTREtcIiksIHJlcXVpcmUoXCJyZWFjdFwiKSwgcmVxdWlyZShcInJlYWN0LWRvbVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiUGhvdG9FZGl0b3JSZWFjdFVJXCJdID0gZmFjdG9yeShyb290W1wiUGhvdG9FZGl0b3JTREtcIl0sIHJvb3RbXCJSZWFjdFwiXSwgcm9vdFtcIlJlYWN0RE9NXCJdKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzdfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xNl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzYyX18pIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNTkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGE0ZjIyZGU5YjM3NTljYTc5Y2NjIiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgUGhvdG9FZGl0b3JTREsgZnJvbSAncGhvdG9lZGl0b3JzZGsnXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgQ2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJ1xuXG5pbXBvcnQgQkVNIGZyb20gJy4vbGliL2JlbSdcbmltcG9ydCBSZWFjdEJFTSBmcm9tICcuL2xpYi9yZWFjdC1iZW0nXG5pbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tICcuL2NvbXBvbmVudHMvYmFzZS1jb21wb25lbnQnXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi9saWIvdXRpbHMnXG5pbXBvcnQgQ29uc3RhbnRzIGZyb20gJy4vbGliL2NvbnN0YW50cydcbmltcG9ydCBTaGFyZWRTdGF0ZSBmcm9tICcuL2xpYi9zaGFyZWQtc3RhdGUnXG5pbXBvcnQgeyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGNhbmNlbEFuaW1hdGlvbkZyYW1lIH0gZnJvbSAnc2hhcmVkL2FzeW5jL2FuaW1hdGlvbi1mcmFtZSdcbmltcG9ydCBMb2cgZnJvbSAnLi4vLi4vc2hhcmVkL2xvZydcbmltcG9ydCBJbWFnZUxvYWRlciBmcm9tICcuLi8uLi9zaGFyZWQvbG9hZGVycy9pbWFnZS1sb2FkZXInXG5pbXBvcnQgU2hhcmVkQ29uc3RhbnRzIGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMnXG5cbmNvbnN0IEJhc2U2NCA9IFBob3RvRWRpdG9yU0RLLkJhc2U2NFxuY29uc3QgQ29sb3IgPSBQaG90b0VkaXRvclNESy5Db2xvclxuY29uc3QgQ29sb3JNYXRyaXggPSBQaG90b0VkaXRvclNESy5NYXRoLkNvbG9yTWF0cml4XG5jb25zdCBFdmVudEVtaXR0ZXIgPSBQaG90b0VkaXRvclNESy5FdmVudEVtaXR0ZXJcbmNvbnN0IEVYSUYgPSBQaG90b0VkaXRvclNESy5FWElGXG5jb25zdCBPcHRpb25UeXBlID0gUGhvdG9FZGl0b3JTREsuT3B0aW9uVHlwZVxuY29uc3QgUHJvbWlzZSA9IFBob3RvRWRpdG9yU0RLLlByb21pc2VcbmNvbnN0IFNES1V0aWxzID0gUGhvdG9FZGl0b3JTREsuVXRpbHNcbmNvbnN0IFJlbmRlclR5cGUgPSBQaG90b0VkaXRvclNESy5SZW5kZXJUeXBlXG5jb25zdCBJbWFnZUZvcm1hdCA9IFBob3RvRWRpdG9yU0RLLkltYWdlRm9ybWF0XG5jb25zdCBTREsgPSBQaG90b0VkaXRvclNES1xuY29uc3QgVW5pZm9ybVR5cGUgPSBQaG90b0VkaXRvclNESy5Vbmlmb3JtVHlwZVxuY29uc3QgVmVjdG9yMiA9IFBob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMlxuXG5jb25zdCBub3cgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3dcbiAgPyB3aW5kb3cucGVyZm9ybWFuY2Uubm93LmJpbmQod2luZG93LnBlcmZvcm1hbmNlKVxuICA6IHJlcXVpcmUoJ3BlcmZvcm1hbmNlLW5vdycpKVxuXG5leHBvcnQge1xuICBQcm9taXNlLCBVdGlscywgUmVhY3QsIEJFTSwgQ2xhc3NuYW1lcywgQmFzZUNvbXBvbmVudCwgUmVhY3RCRU0sIFZlY3RvcjIsXG4gIFNES1V0aWxzLCBFdmVudEVtaXR0ZXIsIENvbnN0YW50cywgU2hhcmVkU3RhdGUsIENvbG9yLCBCYXNlNjQsIFJlbmRlclR5cGUsIE9wdGlvblR5cGUsIFVuaWZvcm1UeXBlLFxuICBSZWFjdERPTSwgRVhJRiwgU0RLLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGNhbmNlbEFuaW1hdGlvbkZyYW1lLCBMb2csIG5vdywgQ29sb3JNYXRyaXgsXG4gIEltYWdlRm9ybWF0LCBJbWFnZUxvYWRlciwgUHJvcFR5cGVzLCBTaGFyZWRDb25zdGFudHNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2dsb2JhbHMuanMiLCIvKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4uL2dsb2JhbHMnXG5cbmNsYXNzIE1vZGFsIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKHR5cGUsIHRpdGxlLCB0ZXh0LCBvdmVybGF5ID0gZmFsc2UpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy50eXBlID0gdHlwZVxuICAgIHRoaXMudGl0bGUgPSB0aXRsZVxuICAgIHRoaXMudGV4dCA9IHRleHRcbiAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5XG4gICAgdGhpcy5kYXRhID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRhdGEgdG8gdGhlIGdpdmVuIG9uZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKi9cbiAgc2V0RGF0YSAoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGFcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScpXG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoaXMgbW9kYWxcbiAgICovXG4gIGNsb3NlICgpIHtcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RhbE1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5fbW9kYWxzID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbG9hZGluZyBtb2RhbFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRleHRcbiAgICogQHJldHVybiB7TW9kYWx9XG4gICAqL1xuICBkaXNwbGF5TG9hZGluZyAodGV4dCkge1xuICAgIGNvbnN0IG1vZGFsID0gbmV3IE1vZGFsKCdsb2FkaW5nJywgbnVsbCwgdGV4dClcbiAgICB0aGlzLmFkZE1vZGFsKG1vZGFsKVxuICAgIHJldHVybiBtb2RhbFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBwcm9ncmVzcyBtb2RhbFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRleHRcbiAgICogQHJldHVybiB7TW9kYWx9XG4gICAqL1xuICBkaXNwbGF5UHJvZ3Jlc3MgKHRleHQsIHByb2dyZXNzID0gMCkge1xuICAgIGNvbnN0IG1vZGFsID0gbmV3IE1vZGFsKCdwcm9ncmVzcycsIG51bGwsIHRleHQpXG4gICAgbW9kYWwuc2V0RGF0YSh7IHByb2dyZXNzIH0pXG4gICAgdGhpcy5hZGRNb2RhbChtb2RhbClcbiAgICByZXR1cm4gbW9kYWxcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdHMgYSB3YXJuaW5nIG1vZGFsXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdGl0bGVcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0ZXh0XG4gICAqIEByZXR1cm4ge01vZGFsfVxuICAgKi9cbiAgZGlzcGxheVdhcm5pbmcgKHRpdGxlLCB0ZXh0KSB7XG4gICAgY29uc3QgbW9kYWwgPSBuZXcgTW9kYWwoJ3dhcm5pbmcnLCB0aXRsZSwgdGV4dClcbiAgICB0aGlzLmFkZE1vZGFsKG1vZGFsKVxuICAgIHJldHVybiBtb2RhbFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZXJyb3IgbW9kYWxcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0aXRsZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRleHRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gb3ZlcmxheSA9IHRydWVcbiAgICogQHJldHVybiB7TW9kYWx9XG4gICAqL1xuICBkaXNwbGF5RXJyb3IgKHRpdGxlLCB0ZXh0LCBvdmVybGF5ID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1vZGFsID0gbmV3IE1vZGFsKCdlcnJvcicsIHRpdGxlLCB0ZXh0LCBvdmVybGF5KVxuICAgIHRoaXMuYWRkTW9kYWwobW9kYWwpXG4gICAgcmV0dXJuIG1vZGFsXG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gbW9kYWwgdG8gdGhlIGxpc3Qgb2YgbW9kYWxzXG4gICAqIEBwYXJhbSB7TW9kYWx9IG1vZGFsXG4gICAqL1xuICBhZGRNb2RhbCAobW9kYWwpIHtcbiAgICB0aGlzLl9tb2RhbHMucHVzaChtb2RhbClcbiAgICBtb2RhbC5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZU1vZGFsKG1vZGFsKVxuICAgIH0pXG4gICAgbW9kYWwub24oJ3VwZGF0ZScsICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgndXBkYXRlJylcbiAgICB9KVxuICAgIHRoaXMuZW1pdCgndXBkYXRlJylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBtb2RhbCBmcm9tIHRoZSBsaXN0IG9mIG1vZGFsc1xuICAgKiBAcGFyYW0gIHtNb2RhbH0gbW9kYWxcbiAgICovXG4gIHJlbW92ZU1vZGFsIChtb2RhbCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbW9kYWxzLmluZGV4T2YobW9kYWwpXG4gICAgdGhpcy5fbW9kYWxzLnNwbGljZShpbmRleCwgMSlcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbW9kYWxzXG4gICAqIEByZXR1cm4ge0FycmF5LjxNb2RhbD59XG4gICAqL1xuICBnZXRNb2RhbHMgKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RhbHNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvbmUgYW5kIG9ubHkgaW5zdGFuY2Ugb2YgdGhpcyBjbGFzc1xuICAgKiBAcmV0dXJuIHtNb2RhbE1hbmFnZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGluc3RhbmNlICgpIHtcbiAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XG4gICAgICB0aGlzLl9pbnN0YW5jZSA9IG5ldyBNb2RhbE1hbmFnZXIoKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faW5zdGFuY2VcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL21vZGFsLW1hbmFnZXIuanMiLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdCwgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQsIFV0aWxzLCBWZWN0b3IyIH0gZnJvbSAnLi4vZ2xvYmFscydcbmltcG9ydCBEcmFnZ2FibGVDb21wb25lbnQgZnJvbSAnLi9kcmFnZ2FibGUtY29tcG9uZW50J1xuY29uc3QgU0NST0xMQkFSX1dJRFRIID0gMTJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Nyb2xsYmFyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG5cbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuTkFUSVZFX1NDUk9MTEJBUl9XSURUSCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5OQVRJVkVfU0NST0xMQkFSX1dJRFRIID0gVXRpbHMuZ2V0U2Nyb2xsYmFyV2lkdGgoKVxuICAgIH1cblxuICAgIHRoaXMuX25lZWRzU3R5bGVGaXhlcyA9IHRydWVcbiAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2VcbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbkJ1dHRvbkRyYWdTdGFydCcsXG4gICAgICAnX29uQnV0dG9uRHJhZycsXG4gICAgICAnX29uQnV0dG9uRHJhZ1N0b3AnLFxuICAgICAgJ19vbkJhckRyYWdTdGFydCcsXG4gICAgICAnX29uQmFyRHJhZycsXG4gICAgICAnX29uQmFyRHJhZ1N0b3AnLFxuICAgICAgJ19vbkxpc3RTY3JvbGwnXG4gICAgKVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBidXR0b25TaXplOiAwLFxuICAgICAgYnV0dG9uUG9zaXRpb246IDAsXG4gICAgICBidXR0b25WaXNpYmxlOiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIExJRkVDWUNMRVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICBzdXBlci5jb21wb25lbnREaWRNb3VudCgpXG4gICAgdGhpcy51cGRhdGUoKVxuICB9XG5cbiAgZml4U3R5bGVzICgpIHtcbiAgICBpZiAoIVV0aWxzLmlzTW9iaWxlKCkpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUxpc3RTaXplKClcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzY3JvbGxzIHRoZSBsaXN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25MaXN0U2Nyb2xsICgpIHtcbiAgICBpZiAodGhpcy5faXNEcmFnZ2luZykgcmV0dXJuXG5cbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLl9nZXREaXJlY3Rpb24oKVxuXG4gICAgbGV0IGxpc3RTY3JvbGxTaXplLCBsaXN0U2Nyb2xsUG9zaXRpb24sIGJhY2tncm91bmRTY3JvbGxTaXplXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gU2Nyb2xsYmFyQ29tcG9uZW50LkhPUklaT05UQUwpIHtcbiAgICAgIGxpc3RTY3JvbGxTaXplID0gdGhpcy5fbGlzdC5zY3JvbGxXaWR0aCAtIHRoaXMuX2xpc3Qub2Zmc2V0V2lkdGhcbiAgICAgIGxpc3RTY3JvbGxQb3NpdGlvbiA9IHRoaXMuX2xpc3Quc2Nyb2xsTGVmdFxuICAgICAgYmFja2dyb3VuZFNjcm9sbFNpemUgPSB0aGlzLl9ub2RlLm9mZnNldFdpZHRoIC0gdGhpcy5zdGF0ZS5idXR0b25TaXplXG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFNjcm9sbGJhckNvbXBvbmVudC5WRVJUSUNBTCkge1xuICAgICAgbGlzdFNjcm9sbFNpemUgPSB0aGlzLl9saXN0LnNjcm9sbEhlaWdodCAtIHRoaXMuX2xpc3Qub2Zmc2V0SGVpZ2h0XG4gICAgICBsaXN0U2Nyb2xsUG9zaXRpb24gPSB0aGlzLl9saXN0LnNjcm9sbFRvcFxuICAgICAgYmFja2dyb3VuZFNjcm9sbFNpemUgPSB0aGlzLl9ub2RlLm9mZnNldEhlaWdodCAtIHRoaXMuc3RhdGUuYnV0dG9uU2l6ZVxuICAgIH1cblxuICAgIGNvbnN0IHByb2dyZXNzID0gbGlzdFNjcm9sbFBvc2l0aW9uIC8gbGlzdFNjcm9sbFNpemVcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGJ1dHRvblBvc2l0aW9uOiBiYWNrZ3JvdW5kU2Nyb2xsU2l6ZSAqIHByb2dyZXNzXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBtb3VzZSBidXR0b24gb24gdGhlIGJhclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQnV0dG9uRHJhZ1N0YXJ0IChlKSB7XG4gICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWVcbiAgICB0aGlzLl9pbml0aWFsQnV0dG9uUG9zaXRpb24gPSB0aGlzLnN0YXRlLmJ1dHRvblBvc2l0aW9uIHx8IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgYnV0dG9uXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gZGlmZlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQnV0dG9uRHJhZyAoZGlmZikge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuX2dldERpcmVjdGlvbigpXG5cbiAgICBsZXQgYnV0dG9uUG9zaXRpb25cbiAgICBpZiAoZGlyZWN0aW9uID09PSBTY3JvbGxiYXJDb21wb25lbnQuSE9SSVpPTlRBTCkge1xuICAgICAgYnV0dG9uUG9zaXRpb24gPSB0aGlzLl9pbml0aWFsQnV0dG9uUG9zaXRpb24gKyBkaWZmLnhcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gU2Nyb2xsYmFyQ29tcG9uZW50LlZFUlRJQ0FMKSB7XG4gICAgICBidXR0b25Qb3NpdGlvbiA9IHRoaXMuX2luaXRpYWxCdXR0b25Qb3NpdGlvbiArIGRpZmYueVxuICAgIH1cbiAgICB0aGlzLl9zZXRCdXR0b25Qb3NpdGlvbihidXR0b25Qb3NpdGlvbilcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBidXR0b25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJ1dHRvbkRyYWdTdG9wICgpIHtcbiAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgYmFyXG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25CYXJEcmFnU3RhcnQgKGUpIHtcbiAgICBjb25zdCBtb3VzZVBvc2l0aW9uID0gVXRpbHMuZ2V0RXZlbnRQb3NpdGlvbihlKVxuICAgIHRoaXMuX2luaXRpYWxQb3NpdGlvbiA9IG1vdXNlUG9zaXRpb24uY2xvbmUoKVxuICAgIGNvbnN0IGJvdW5kaW5nUmVjdCA9IHRoaXMuX25vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBjb25zdCBlbGVtZW50T2Zmc2V0ID0gbmV3IFZlY3RvcjIoXG4gICAgICBib3VuZGluZ1JlY3QubGVmdCxcbiAgICAgIGJvdW5kaW5nUmVjdC50b3BcbiAgICApXG5cbiAgICBjb25zdCByZWxhdGl2ZVBvc2l0aW9uID0gbW91c2VQb3NpdGlvblxuICAgICAgLmNsb25lKClcbiAgICAgIC5zdWJ0cmFjdChlbGVtZW50T2Zmc2V0KVxuXG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5fZ2V0RGlyZWN0aW9uKClcbiAgICBpZiAoZGlyZWN0aW9uID09PSBTY3JvbGxiYXJDb21wb25lbnQuSE9SSVpPTlRBTCkge1xuICAgICAgdGhpcy5fc2V0QnV0dG9uUG9zaXRpb24ocmVsYXRpdmVQb3NpdGlvbi54IC0gdGhpcy5zdGF0ZS5idXR0b25TaXplIC8gMilcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gU2Nyb2xsYmFyQ29tcG9uZW50LlZFUlRJQ0FMKSB7XG4gICAgICB0aGlzLl9zZXRCdXR0b25Qb3NpdGlvbihyZWxhdGl2ZVBvc2l0aW9uLnkgLSB0aGlzLnN0YXRlLmJ1dHRvblNpemUgLyAyKVxuICAgIH1cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uQmFyRHJhZylcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbkJhckRyYWcpXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uQmFyRHJhZ1N0b3ApXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vbkJhckRyYWdTdG9wKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBiYXJcbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJhckRyYWcgKGUpIHtcbiAgICBjb25zdCBtb3VzZVBvc2l0aW9uID0gVXRpbHMuZ2V0RXZlbnRQb3NpdGlvbihlKVxuXG4gICAgY29uc3QgYm91bmRpbmdSZWN0ID0gdGhpcy5fbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGNvbnN0IGVsZW1lbnRPZmZzZXQgPSBuZXcgVmVjdG9yMihcbiAgICAgIGJvdW5kaW5nUmVjdC5sZWZ0LFxuICAgICAgYm91bmRpbmdSZWN0LnRvcFxuICAgIClcblxuICAgIGNvbnN0IHJlbGF0aXZlUG9zaXRpb24gPSBtb3VzZVBvc2l0aW9uXG4gICAgICAuY2xvbmUoKVxuICAgICAgLnN1YnRyYWN0KGVsZW1lbnRPZmZzZXQpXG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5fZ2V0RGlyZWN0aW9uKClcbiAgICBpZiAoZGlyZWN0aW9uID09PSBTY3JvbGxiYXJDb21wb25lbnQuSE9SSVpPTlRBTCkge1xuICAgICAgdGhpcy5fc2V0QnV0dG9uUG9zaXRpb24ocmVsYXRpdmVQb3NpdGlvbi54IC0gdGhpcy5zdGF0ZS5idXR0b25TaXplIC8gMilcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gU2Nyb2xsYmFyQ29tcG9uZW50LlZFUlRJQ0FMKSB7XG4gICAgICB0aGlzLl9zZXRCdXR0b25Qb3NpdGlvbihyZWxhdGl2ZVBvc2l0aW9uLnkgLSB0aGlzLnN0YXRlLmJ1dHRvblNpemUgLyAyKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBiYXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJhckRyYWdTdG9wICgpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbkJhckRyYWcpXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25CYXJEcmFnKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbkJhckRyYWdTdG9wKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25CYXJEcmFnU3RvcClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE1JU0NcblxuICAvKipcbiAgICogU2V0cyB0aGUgYnV0dG9uIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gYnV0dG9uUG9zaXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRCdXR0b25Qb3NpdGlvbiAoYnV0dG9uUG9zaXRpb24pIHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLl9nZXREaXJlY3Rpb24oKVxuXG4gICAgbGV0IHNjcm9sbGFibGVCdXR0b25TaXplLCBzY3JvbGxhYmxlTGlzdFNpemVcbiAgICBpZiAoZGlyZWN0aW9uID09PSBTY3JvbGxiYXJDb21wb25lbnQuSE9SSVpPTlRBTCkge1xuICAgICAgc2Nyb2xsYWJsZUJ1dHRvblNpemUgPSB0aGlzLl9ub2RlLm9mZnNldFdpZHRoIC0gdGhpcy5zdGF0ZS5idXR0b25TaXplXG4gICAgICBzY3JvbGxhYmxlTGlzdFNpemUgPSB0aGlzLl9saXN0LnNjcm9sbFdpZHRoIC0gdGhpcy5fbGlzdC5vZmZzZXRXaWR0aFxuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBTY3JvbGxiYXJDb21wb25lbnQuVkVSVElDQUwpIHtcbiAgICAgIHNjcm9sbGFibGVCdXR0b25TaXplID0gdGhpcy5fbm9kZS5vZmZzZXRIZWlnaHQgLSB0aGlzLnN0YXRlLmJ1dHRvblNpemVcbiAgICAgIHNjcm9sbGFibGVMaXN0U2l6ZSA9IHRoaXMuX2xpc3Quc2Nyb2xsSGVpZ2h0IC0gdGhpcy5fbGlzdC5vZmZzZXRIZWlnaHRcbiAgICB9XG5cbiAgICAvLyBDbGFtcCBidXR0b24gcG9zaXRpb25cbiAgICBidXR0b25Qb3NpdGlvbiA9IE1hdGgubWF4KDAsIGJ1dHRvblBvc2l0aW9uKVxuICAgIGJ1dHRvblBvc2l0aW9uID0gTWF0aC5taW4oYnV0dG9uUG9zaXRpb24sIHNjcm9sbGFibGVCdXR0b25TaXplKVxuXG4gICAgLy8gU2V0IGJ1dHRvbiBwb3NpdGlvblxuICAgIHRoaXMuc2V0U3RhdGUoeyBidXR0b25Qb3NpdGlvbiB9KVxuXG4gICAgLy8gVXBkYXRlIGxpc3Qgc2Nyb2xsIHBvc2l0aW9uXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSBidXR0b25Qb3NpdGlvbiAvIHNjcm9sbGFibGVCdXR0b25TaXplXG4gICAgY29uc3Qgc2Nyb2xsUG9zaXRpb24gPSBzY3JvbGxhYmxlTGlzdFNpemUgKiBwcm9ncmVzc1xuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gU2Nyb2xsYmFyQ29tcG9uZW50LkhPUklaT05UQUwpIHtcbiAgICAgIHRoaXMuX2xpc3Quc2Nyb2xsTGVmdCA9IHNjcm9sbFBvc2l0aW9uXG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFNjcm9sbGJhckNvbXBvbmVudC5WRVJUSUNBTCkge1xuICAgICAgdGhpcy5fbGlzdC5zY3JvbGxUb3AgPSBzY3JvbGxQb3NpdGlvblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBidXR0b24gcG9zaXRpb24gYW5kIHNpemVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVCdXR0b25TaXplIChjYikge1xuICAgIGxldCBidXR0b25TaXplID0gMFxuICAgIGxldCBidXR0b25WaXNpYmxlID0gZmFsc2VcbiAgICBsZXQgcGFyZW50U2l6ZSwgcGFyZW50U2Nyb2xsU2l6ZVxuXG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5fZ2V0RGlyZWN0aW9uKClcbiAgICBpZiAoZGlyZWN0aW9uID09PSBTY3JvbGxiYXJDb21wb25lbnQuSE9SSVpPTlRBTCkge1xuICAgICAgcGFyZW50U2l6ZSA9IHRoaXMuX2xpc3QuY2xpZW50V2lkdGhcbiAgICAgIHBhcmVudFNjcm9sbFNpemUgPSB0aGlzLl9saXN0LnNjcm9sbFdpZHRoXG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFNjcm9sbGJhckNvbXBvbmVudC5WRVJUSUNBTCkge1xuICAgICAgcGFyZW50U2l6ZSA9IHRoaXMuX2xpc3Qub2Zmc2V0SGVpZ2h0XG4gICAgICBwYXJlbnRTY3JvbGxTaXplID0gdGhpcy5fbGlzdC5zY3JvbGxIZWlnaHRcbiAgICB9XG5cbiAgICBidXR0b25TaXplID0gcGFyZW50U2l6ZSAvIHBhcmVudFNjcm9sbFNpemUgKiBwYXJlbnRTaXplXG4gICAgYnV0dG9uVmlzaWJsZSA9IHBhcmVudFNjcm9sbFNpemUgPiBwYXJlbnRTaXplXG5cbiAgICB0aGlzLnNldFN0YXRlKHsgYnV0dG9uU2l6ZSwgYnV0dG9uVmlzaWJsZSB9LCBjYilcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBsaXN0IHNpemVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVMaXN0U2l6ZSAoKSB7XG4gICAgaWYgKCF0aGlzLl9saXN0KSByZXR1cm5cblxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuX2dldERpcmVjdGlvbigpXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gU2Nyb2xsYmFyQ29tcG9uZW50LkhPUklaT05UQUwpIHtcbiAgICAgIHRoaXMuX2xpc3Quc3R5bGUuaGVpZ2h0ID0gJydcbiAgICAgIGNvbnN0IGZ1bGxEaW1lbnNpb25zID0gdGhpcy5fZ2V0RnVsbExpc3REaW1lbnNpb25zKClcbiAgICAgIHRoaXMuX2xpc3RTaXplID0gZnVsbERpbWVuc2lvbnMueVxuICAgICAgdGhpcy5fbGlzdENvbnRlbnRTaXplID0gdGhpcy5fbGlzdC5vZmZzZXRIZWlnaHRcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gU2Nyb2xsYmFyQ29tcG9uZW50LlZFUlRJQ0FMKSB7XG4gICAgICB0aGlzLl9saXN0LnN0eWxlLndpZHRoID0gJydcbiAgICAgIGNvbnN0IGZ1bGxEaW1lbnNpb25zID0gdGhpcy5fZ2V0RnVsbExpc3REaW1lbnNpb25zKClcbiAgICAgIHRoaXMuX2xpc3RTaXplID0gZnVsbERpbWVuc2lvbnMueFxuICAgICAgdGhpcy5fbGlzdENvbnRlbnRTaXplID0gdGhpcy5fbGlzdC5vZmZzZXRXaWR0aFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBvcmRlciB0byBnZXQgdGhlIGFic29sdXRlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGxpc3QsIGluY2x1ZGluZyB0aGUgc2Nyb2xsYmFyLFxuICAgKiB3ZSBuZWVkIHRvIG1ha2UgdXNlIG9mIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRGdWxsTGlzdERpbWVuc2lvbnMgKCkge1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLl9saXN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgcmV0dXJuIG5ldyBWZWN0b3IyKHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUFVCTElDIEFQSVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBkaW1lbnNpb25zIGFuZCBzdHVmZlxuICAgKi9cbiAgdXBkYXRlICgpIHtcbiAgICBpZiAoVXRpbHMuaXNNb2JpbGUoKSkgeyByZXR1cm4gfVxuXG4gICAgY29uc3QgeyByb290LCBsaXN0IH0gPSB0aGlzLnJlZnNcbiAgICB0aGlzLl9ub2RlID0gcm9vdFxuICAgIHRoaXMuX2xpc3QgPSBsaXN0XG5cbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLl9nZXREaXJlY3Rpb24oKVxuICAgIHRoaXMuX3VwZGF0ZUJ1dHRvblNpemUoKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9saXN0U2l6ZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVMaXN0U2l6ZSgpXG4gICAgICB9XG5cbiAgICAgIGxldCBuZXdMaXN0U2l6ZSA9IHRoaXMuX2xpc3RTaXplXG4gICAgICBpZiAodGhpcy5zdGF0ZS5idXR0b25WaXNpYmxlKSB7XG4gICAgICAgIG5ld0xpc3RTaXplICs9IHRoaXMuY29uc3RydWN0b3IuTkFUSVZFX1NDUk9MTEJBUl9XSURUSFxuICAgICAgfVxuXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSBTY3JvbGxiYXJDb21wb25lbnQuSE9SSVpPTlRBTCkge1xuICAgICAgICB0aGlzLl9saXN0LnN0eWxlLmhlaWdodCA9IGAke25ld0xpc3RTaXplfXB4YFxuICAgICAgICB0aGlzLl9ub2RlLnN0eWxlLnRvcCA9IGAke3RoaXMuX2xpc3RDb250ZW50U2l6ZSAtIFNDUk9MTEJBUl9XSURUSH1weGBcbiAgICAgICAgdGhpcy5fbm9kZS5zdHlsZS53aWR0aCA9IGAke3RoaXMuX2xpc3Qub2Zmc2V0V2lkdGh9cHhgXG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gU2Nyb2xsYmFyQ29tcG9uZW50LlZFUlRJQ0FMKSB7XG4gICAgICAgIHRoaXMuX2xpc3Quc3R5bGUud2lkdGggPSBgJHtuZXdMaXN0U2l6ZX1weGBcbiAgICAgICAgdGhpcy5fbm9kZS5zdHlsZS5sZWZ0ID0gYCR7dGhpcy5fbGlzdENvbnRlbnRTaXplIC0gU0NST0xMQkFSX1dJRFRIfXB4YFxuICAgICAgICB0aGlzLl9ub2RlLnN0eWxlLmhlaWdodCA9IGAke3RoaXMuX2xpc3Qub2Zmc2V0SGVpZ2h0fXB4YFxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLl9saXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX29uTGlzdFNjcm9sbClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE1JU0NcblxuICAvKipcbiAgICogUmV0dXJucyB0aGlzIHNjcm9sbGJhcidzIGRpcmVjdGlvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0RGlyZWN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5kaXJlY3Rpb24gfHwgJ2hvcml6b250YWwnXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBTVFlMSU5HXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJ1dHRvbidzIHN0eWxlIG9iamVjdFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0QnV0dG9uU3R5bGUgKCkge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuX2dldERpcmVjdGlvbigpXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiB0aGlzLnN0YXRlLmJ1dHRvblBvc2l0aW9uLFxuICAgICAgICB3aWR0aDogdGhpcy5zdGF0ZS5idXR0b25TaXplXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdGhpcy5zdGF0ZS5idXR0b25Qb3NpdGlvbixcbiAgICAgICAgaGVpZ2h0OiB0aGlzLnN0YXRlLmJ1dHRvblNpemVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBHRVRURVJTXG5cbiAgZ2V0TGlzdCAoKSB7IHJldHVybiB0aGlzLnJlZnMubGlzdCB9XG4gIGdldFJvb3QgKCkgeyByZXR1cm4gdGhpcy5yZWZzLnJvb3QgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBpZiAoVXRpbHMuaXNNb2JpbGUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICB9XG5cbiAgICBjb25zdCBidXR0b25TdHlsZSA9IHRoaXMuX2dldEJ1dHRvblN0eWxlKClcbiAgICBjb25zdCBzY3JvbGxiYXJTdHlsZSA9IHtcbiAgICAgIGRpc3BsYXk6IHRoaXMuc3RhdGUuYnV0dG9uVmlzaWJsZSA/ICdibG9jaycgOiAnbm9uZSdcbiAgICB9XG5cbiAgICBjb25zdCBjaGlsZCA9IFJlYWN0LmNsb25lRWxlbWVudCh0aGlzLnByb3BzLmNoaWxkcmVuLCB7XG4gICAgICByZWY6ICdsaXN0J1xuICAgIH0pXG5cbiAgICByZXR1cm4gKDxkaXY+XG4gICAgICB7Y2hpbGR9XG4gICAgICA8ZGl2XG4gICAgICAgIGJlbT17YCRiOnNjcm9sbGJhciBtOiR7dGhpcy5wcm9wcy5kaXJlY3Rpb24gfHwgJ2hvcml6b250YWwnfSBtOiR7dGhpcy5zdGF0ZS5idXR0b25WaXNpYmxlID8gJ3Zpc2libGUnIDogJ2ludmlzaWJsZSd9YH1cbiAgICAgICAgcmVmPSdyb290J1xuICAgICAgICBzdHlsZT17c2Nyb2xsYmFyU3R5bGV9XG4gICAgICAgIG9uTW91c2VEb3duPXt0aGlzLl9vbkJhckRyYWdTdGFydH1cbiAgICAgICAgb25Ub3VjaFN0YXJ0PXt0aGlzLl9vbkJhckRyYWdTdGFydH0+XG4gICAgICAgIDxEcmFnZ2FibGVDb21wb25lbnRcbiAgICAgICAgICBvblN0YXJ0PXt0aGlzLl9vbkJ1dHRvbkRyYWdTdGFydH1cbiAgICAgICAgICBvbkRyYWc9e3RoaXMuX29uQnV0dG9uRHJhZ31cbiAgICAgICAgICBvblN0b3A9e3RoaXMuX29uQnV0dG9uRHJhZ1N0b3B9PlxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGJlbT0nZTpiYXInXG4gICAgICAgICAgICBzdHlsZT17YnV0dG9uU3R5bGV9XG4gICAgICAgICAgICBvbk1vdXNlRG93bj17dGhpcy5fb25CdXR0b25Eb3dufSAvPlxuICAgICAgICA8L0RyYWdnYWJsZUNvbXBvbmVudD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PilcbiAgfVxufVxuXG5TY3JvbGxiYXJDb21wb25lbnQuSE9SSVpPTlRBTCA9ICdob3Jpem9udGFsJ1xuU2Nyb2xsYmFyQ29tcG9uZW50LlZFUlRJQ0FMID0gJ3ZlcnRpY2FsJ1xuXG5TY3JvbGxiYXJDb21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvc2Nyb2xsYmFyLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgQmFja0J1dHRvbkNvbXBvbmVudCBmcm9tICcuLi9iYWNrLWJ1dHRvbi1jb21wb25lbnQnXG5pbXBvcnQgRG9uZUJ1dHRvbkNvbXBvbmVudCBmcm9tICcuLi9kb25lLWJ1dHRvbi1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRyb2xzQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2hhc0JhY2tCdXR0b24gPSB0cnVlXG4gICAgdGhpcy5faGFzRG9uZUJ1dHRvbiA9IGZhbHNlXG4gICAgdGhpcy5fYmFja0J1dHRvbkNsaWNrZWQgPSBmYWxzZVxuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25CYWNrQ2xpY2snLFxuICAgICAgJ19vbkRvbmVDbGljaydcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZ2xvYmFsIGVkaXRvciBzdGF0ZSBkYXRhIGZvciB0aGlzIHRvb2wuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBnZXRHbG9iYWxUb29sU3RhdGUgKGlkZW50aWZpZXIpIHtcbiAgICBjb25zdCB7IGdsb2JhbFN0YXRlIH0gPSB0aGlzLmNvbnRleHRcbiAgICByZXR1cm4gZ2xvYmFsU3RhdGUuZ2V0KGlkZW50aWZpZXIpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZ2xvYmFsIGVkaXRvciBzdGF0ZSBkYXRhIGZvciB0aGlzIHRvb2wuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBzZXRHbG9iYWxUb29sU3RhdGUgKGlkZW50aWZpZXIsIHN0YXRlKSB7XG4gICAgY29uc3QgeyBnbG9iYWxTdGF0ZSB9ID0gdGhpcy5jb250ZXh0XG4gICAgZ2xvYmFsU3RhdGUuc2V0KHsgW2lkZW50aWZpZXJdOiBzdGF0ZSB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBiYWNrIGJ1dHRvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25CYWNrQ2xpY2sgKGUpIHtcbiAgICB0aGlzLl9iYWNrQnV0dG9uQ2xpY2tlZCA9IHRydWVcbiAgICB0aGlzLnByb3BzLm9uU3dpdGNoQ29udHJvbHMoJ2JhY2snKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBkb25lIGJ1dHRvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Eb25lQ2xpY2sgKGUpIHtcbiAgICB0aGlzLl9vbkJhY2tDbGljaygpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY29udHJvbHMgb2YgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlckNvbnRyb2xzICgpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG92ZXJsYXkgY29udHJvbHMgb2YgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlck92ZXJsYXlDb250cm9scyAoKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBjb25zdCBmb3JjZWRDb250cm9sID0gdGhpcy5wcm9wcy5vcHRpb25zICYmIHRoaXMucHJvcHMub3B0aW9ucy5mb3JjZWRDb250cm9sXG4gICAgY29uc3QgYmFja0J1dHRvbiA9IHRoaXMuX2hhc0JhY2tCdXR0b24gJiYgIWZvcmNlZENvbnRyb2xcbiAgICAgID8gPEJhY2tCdXR0b25Db21wb25lbnQgb25DbGljaz17dGhpcy5fb25CYWNrQ2xpY2t9IC8+XG4gICAgICA6IG51bGxcblxuICAgIGNvbnN0IGRvbmVCdXR0b24gPSB0aGlzLl9oYXNEb25lQnV0dG9uIHx8IGZvcmNlZENvbnRyb2xcbiAgICAgID8gPERvbmVCdXR0b25Db21wb25lbnQgb25DbGljaz17dGhpcy5fb25Eb25lQ2xpY2t9IC8+XG4gICAgICA6IG51bGxcblxuICAgIHJldHVybiAoPGRpdiBiZW09JyRiOmNvbnRyb2xzJyByZWY9J3Jvb3QnPlxuICAgICAge3RoaXMucmVuZGVyT3ZlcmxheUNvbnRyb2xzKCl9XG4gICAgICA8ZGl2IGJlbT0nZTp0YWJsZSc+XG4gICAgICAgIHtiYWNrQnV0dG9ufVxuICAgICAgICB7dGhpcy5yZW5kZXJDb250cm9scygpfVxuICAgICAgICB7ZG9uZUJ1dHRvbn1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PilcbiAgfVxufVxuXG5Db250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9jb250cm9scy1jb21wb25lbnQuanN4IiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBhbGwgY29udHJvbHNcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUlcbiAqL1xuY2xhc3MgQ29udHJvbCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbml0aWFsIHNoYXJlZCBzdGF0ZSBmb3IgdGhpcyBjb250cm9sXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuRWRpdG9yfSBlZGl0b3JcbiAgICogQHBhcmFtICB7T2JqZWN0fSBhZGRpdGlvbmFsU3RhdGUgPSB7fVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0SW5pdGlhbFNoYXJlZFN0YXRlICgpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnbG9iYWwgZWRpdG9yIHN0YXRlIGRhdGEgZm9yIHRoaXMgdG9vbC5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIGdldEdsb2JhbFRvb2xTdGF0ZSAoKSB7XG4gICAgY29uc3QgeyBnbG9iYWxTdGF0ZSB9ID0gdGhpcy5jb250ZXh0XG4gICAgcmV0dXJuIGdsb2JhbFN0YXRlLmdldCh0aGlzLmNvbnN0cnVjdG9yLmlkZW50aWZpZXIpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZ2xvYmFsIGVkaXRvciBzdGF0ZSBkYXRhIGZvciB0aGlzIHRvb2wuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBzZXRHbG9iYWxUb29sU3RhdGUgKHN0YXRlKSB7XG4gICAgY29uc3QgeyBnbG9iYWxTdGF0ZSB9ID0gdGhpcy5jb250ZXh0XG4gICAgZ2xvYmFsU3RhdGUuc2V0KHsgW3RoaXMuY29uc3RydWN0b3IuaWRlbnRpZmllcl06IHN0YXRlIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgY29udHJvbCBpcyBhdmFpbGFibGUgdG8gdGhlIHVzZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5FZGl0b3J9IGVkaXRvclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGlzQXZhaWxhYmxlIChlZGl0b3IpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhc3NldHMgdGhhdCBzaG91bGQgYmUgcHJlbG9hZGVkIGZvciB0aGlzIGNvbnRyb2xcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5FZGl0b3J9IGVkaXRvclxuICAgKiBAcmV0dXJuIHtTdHJpbmdbXX1cbiAgICovXG4gIHN0YXRpYyBnZXRQcmVsb2FkQXNzZXRzICgpIHtcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIHRvcCBiYXIgY29tcG9uZW50LiBVc2VkIGZvciB0aGUgdXBwZXIgcGFydCBvZiB0aGUgZWRpdG9yLlxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuVG9wQmFyQ29udHJvbHNDb21wb25lbnR9XG4gKi9cbkNvbnRyb2wudG9wQmFyQ29udHJvbHNDb21wb25lbnQgPSBudWxsXG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgY29udHJvbHMgY29tcG9uZW50LiBVc2VkIGZvciB0aGUgbG93ZXIgY29udHJvbHMgcGFydCBvZiB0aGUgZWRpdG9yLlxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNDb21wb25lbnR9XG4gKi9cbkNvbnRyb2wuY29udHJvbHNDb21wb25lbnQgPSBudWxsXG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgY2FudmFzIGNvbXBvbmVudC4gVXNlZCBmb3IgdGhlIHVwcGVyIGNvbnRyb2xzIHBhcnQgb2YgdGhlIGVkaXRvciAob25cbiAqIHRvcCBvZiB0aGUgY2FudmFzKVxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNDb21wb25lbnR9XG4gKi9cbkNvbnRyb2wuY2FudmFzQ29udHJvbHNDb21wb25lbnQgPSBudWxsXG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkNvbnRyb2wuaWRlbnRpZmllciA9IG51bGxcblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBpY29uIHBhdGhcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbkNvbnRyb2wuaWNvblBhdGggPSBudWxsXG5cbi8qKlxuICogVGhlIGxhbmd1YWdlIGtleSB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gZGlzcGxheWluZyB0aGlzIGZpbHRlclxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuQ29udHJvbC5sYW5ndWFnZUtleSA9IG51bGxcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGlzIGNvbnRyb2xcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkNvbnRyb2wuZGVmYXVsdE9wdGlvbnMgPSB7fVxuXG5leHBvcnQgZGVmYXVsdCBDb250cm9sXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL2NvbnRyb2xzLmpzIiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cbmltcG9ydCB7IFJlYWN0LCBCYXNlQ29tcG9uZW50LCBVdGlscywgVmVjdG9yMiB9IGZyb20gJy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERyYWdnYWJsZUNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbkRyYWdTdGFydCcsXG4gICAgICAnX29uRHJhZ01vdmUnLFxuICAgICAgJ19vbkRyYWdFbmQnXG4gICAgKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RhcnMgZHJhZ2dpbmcgdGhlIGNoaWxkXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkRyYWdTdGFydCAoZSkge1xuICAgIGlmICh0aGlzLnByb3BzLmRpc2FibGVkKSByZXR1cm5cblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIHRoaXMuX2luaXRpYWxNb3VzZVBvc2l0aW9uID0gVXRpbHMuZ2V0RXZlbnRQb3NpdGlvbihlKVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25EcmFnTW92ZSlcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbkRyYWdNb3ZlKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbkRyYWdFbmQpXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vbkRyYWdFbmQpXG5cbiAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHRoaXMucmVmc1xuICAgIGNvbnN0IGJvdW5kaW5nUmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBjb25zdCBlbGVtZW50T2Zmc2V0ID0gbmV3IFZlY3RvcjIoXG4gICAgICBib3VuZGluZ1JlY3QubGVmdCxcbiAgICAgIGJvdW5kaW5nUmVjdC50b3BcbiAgICApXG5cbiAgICBjb25zdCByZWxhdGl2ZVBvc2l0aW9uID0gdGhpcy5faW5pdGlhbE1vdXNlUG9zaXRpb25cbiAgICAgIC5jbG9uZSgpXG4gICAgICAuc3VidHJhY3QoZWxlbWVudE9mZnNldClcbiAgICB0aGlzLnByb3BzLm9uU3RhcnQgJiYgdGhpcy5wcm9wcy5vblN0YXJ0KHJlbGF0aXZlUG9zaXRpb24sIGUpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIGNoaWxkXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkRyYWdNb3ZlIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgY29uc3QgbW91c2VQb3NpdGlvbiA9IFV0aWxzLmdldEV2ZW50UG9zaXRpb24oZSlcbiAgICBpZiAoIW1vdXNlUG9zaXRpb24pIHJldHVyblxuICAgIGNvbnN0IG1vdXNlRGlmZiA9IG1vdXNlUG9zaXRpb24uY2xvbmUoKS5zdWJ0cmFjdCh0aGlzLl9pbml0aWFsTW91c2VQb3NpdGlvbilcblxuICAgIHRoaXMucHJvcHMub25EcmFnICYmIHRoaXMucHJvcHMub25EcmFnKG1vdXNlRGlmZiwgZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIHRoZSBjaGlsZFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25EcmFnRW5kIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcblxuICAgIHRoaXMuX29uRHJhZ01vdmUoZSlcblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uRHJhZ01vdmUpXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25EcmFnTW92ZSlcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25EcmFnRW5kKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25EcmFnRW5kKVxuXG4gICAgdGhpcy5wcm9wcy5vblN0b3AgJiYgdGhpcy5wcm9wcy5vblN0b3AoZSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0LkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXIgKCkge1xuICAgIGlmICghdGhpcy5wcm9wcy5jaGlsZHJlbiB8fCB0aGlzLnByb3BzLmNoaWxkcmVuIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRHJhZ2dhYmxlQ29tcG9uZW50IGV4cGVjdHMgZXhhY3RseSBvbmUgY2hpbGQuJylcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KHRoaXMucHJvcHMuY2hpbGRyZW4sIHtcbiAgICAgIG9uTW91c2VEb3duOiB0aGlzLl9vbkRyYWdTdGFydCxcbiAgICAgIG9uVG91Y2hTdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG4gICAgICByZWY6ICdlbGVtZW50J1xuICAgIH0pXG4gIH1cbn1cblxuRHJhZ2dhYmxlQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2RyYWdnYWJsZS1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgU0RLVXRpbHMsIFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vZ2xvYmFscydcbmltcG9ydCBTbGlkZXJDb21wb25lbnQgZnJvbSAnLi4vc2xpZGVyLWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2xpZGVyT3ZlcmxheUNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vblNsaWRlclZhbHVlQ2hhbmdlJ1xuICAgIClcblxuICAgIHRoaXMuc3RhdGUgPSB7IHZhbHVlOiB0aGlzLnByb3BzLnZhbHVlIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIExJRkVDWUNMRVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IHJlY2VpdmVzIG5ldyBwcm9wc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHByb3BzXG4gICAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChwcm9wcykge1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdGhpcy5zdGF0ZS52YWx1ZSkge1xuICAgICAgdGhpcy5zdGF0ZS52YWx1ZSA9IHByb3BzLnZhbHVlXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHNsaWRlciB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25TbGlkZXJWYWx1ZUNoYW5nZSAodmFsdWUpIHtcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlICYmXG4gICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHZhbHVlKVxuICAgIHRoaXMuc2V0U3RhdGUoeyB2YWx1ZSB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIFNsaWRlckNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtTbGlkZXJDb21wb25lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyU2xpZGVyICgpIHtcbiAgICBjb25zdCBwcm9wcyA9IFNES1V0aWxzLmRlZmF1bHRzKHRoaXMucHJvcHMsIHtcbiAgICAgIHN0eWxlOiAnJyxcbiAgICAgIG1pZGRsZURvdDogZmFsc2UsXG4gICAgICBtaW5WYWx1ZTogMSxcbiAgICAgIG1heFZhbHVlOiAxMDAsXG4gICAgICBsYWJlbDogJ0xhYmVsJyxcbiAgICAgIG9uQ2hhbmdlOiB0aGlzLl9vblNsaWRlclZhbHVlQ2hhbmdlLFxuICAgICAgdmFsdWU6IHRoaXMuc3RhdGUudmFsdWVcbiAgICB9KVxuICAgIHJldHVybiA8U2xpZGVyQ29tcG9uZW50IHsuLi5wcm9wc30gLz5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICByZXR1cm4gKDxkaXYgYmVtPSckYjpjb250cm9scyBlOm92ZXJsYXkgbTpzbGlkZXIgbTpkYXJrJz5cbiAgICAgIHt0aGlzLl9yZW5kZXJTbGlkZXIoKX1cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuU2xpZGVyT3ZlcmxheUNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9zbGlkZXItb3ZlcmxheS1jb21wb25lbnQuanN4IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzdfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwicGhvdG9lZGl0b3JzZGsvanMvUGhvdG9FZGl0b3JTREtcIixcImNvbW1vbmpzMlwiOlwicGhvdG9lZGl0b3JzZGsvanMvUGhvdG9FZGl0b3JTREtcIixcImFtZFwiOlwicGhvdG9lZGl0b3JzZGtcIixcInJvb3RcIjpcIlBob3RvRWRpdG9yU0RLXCJ9XG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUHJvcFR5cGVzLCBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgSGVhZGVyQ29tcG9uZW50IGZyb20gJy4uL2hlYWRlci1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjcmVlbkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvKipcbiAgICogUmVuZGVycyB0aGUgaGVhZGVyIChpZiBlbmFibGVkKVxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckhlYWRlciAoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRleHQub3B0aW9ucy5zaG93SGVhZGVyKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICByZXR1cm4gKDxIZWFkZXJDb21wb25lbnQgLz4pXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIHNjcmVlblxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclNjcmVlbiAoKSB7XG4gICAgcmV0dXJuIDxkaXYgLz5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBsZXQgc2NyZWVuQkVNU3BlY2lmaWVyID0gJ2I6c2NyZWVuJ1xuICAgIGlmICghdGhpcy5jb250ZXh0Lm9wdGlvbnMuc2hvd0hlYWRlcikge1xuICAgICAgc2NyZWVuQkVNU3BlY2lmaWVyICs9ICcgbTpub0hlYWRlcidcbiAgICB9XG5cbiAgICByZXR1cm4gKDxkaXYgYmVtPXtzY3JlZW5CRU1TcGVjaWZpZXJ9IGNsYXNzTmFtZT17IXRoaXMucHJvcHMudmlzaWJsZSA/ICdpcy1oaWRkZW4nIDogbnVsbH0+XG4gICAgICB7dGhpcy5fcmVuZGVySGVhZGVyKCl9XG4gICAgICB7dGhpcy5fcmVuZGVyU2NyZWVuKCl9XG4gICAgPC9kaXY+KVxuICB9XG59XG5cblNjcmVlbkNvbXBvbmVudC5wcm9wVHlwZXMgPSB7XG4gIGVkaXRvcjogUHJvcFR5cGVzLmFueVxufVxuXG5TY3JlZW5Db21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvc2NyZWVucy9zY3JlZW4tY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFZlY3RvcjIsIEJhc2VDb21wb25lbnQsIENvbnN0YW50cyB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbnZhc0NvbnRyb2xzQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uQ2FudmFzWm9vbURvbmUnXG4gICAgKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gSElUIFRFU1RcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGFueSBvdGhlciBjb250cm9sIHJlYWN0cyB0byBhIGNsaWNrIGF0IHRoZSBnaXZlbiBwb3NpdGlvblxuICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBjbGlja1Bvc2l0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcGVyZm9ybUhpdFRlc3QgKGNsaWNrUG9zaXRpb24pIHtcbiAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gdGhpcy5yZWZzXG4gICAgY29uc3QgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGNvbnN0IGNvbnRhaW5lclBvc2l0aW9uID0gbmV3IFZlY3RvcjIoXG4gICAgICBjb250YWluZXJSZWN0LmxlZnQsXG4gICAgICBjb250YWluZXJSZWN0LnRvcFxuICAgIClcblxuICAgIGNvbnN0IHBvc2l0aW9uT25DYW52YXMgPSBjbGlja1Bvc2l0aW9uXG4gICAgICAuc3VidHJhY3QoY29udGFpbmVyUG9zaXRpb24pXG5cbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3QgY29udHJvbHMgPSBlZGl0b3IuY29udHJvbHMuZ2V0QXZhaWxhYmxlKClcblxuICAgIC8vIENoZWNrIGlmIGFueSBvZiB0aGUgY29udHJvbHMgcmVzcG9uZHMgdG8gYSBjbGlja1xuICAgIC8vIGF0IHRoZSBnaXZlbiBwb3NpdGlvblxuICAgIGZvciAobGV0IGlkZW50aWZpZXIgaW4gY29udHJvbHMpIHtcbiAgICAgIGNvbnN0IGNvbnRyb2wgPSBjb250cm9sc1tpZGVudGlmaWVyXVxuICAgICAgY29uc3QgY2xpY2tSZXNwb25zZSA9IGNvbnRyb2wuY2xpY2tBdFBvc2l0aW9uICYmXG4gICAgICAgIGNvbnRyb2wuY2xpY2tBdFBvc2l0aW9uKHBvc2l0aW9uT25DYW52YXMsIGVkaXRvcilcblxuICAgICAgaWYgKGNsaWNrUmVzcG9uc2UpIHtcbiAgICAgICAgLy8gRG9uJ3QgcmUtc2VsZWN0IGFuIGFscmVhZHkgc2VsZWN0ZWQgaXRlbVxuICAgICAgICBpZiAoY2xpY2tSZXNwb25zZS5zZWxlY3RlZFNwcml0ZSA9PT0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNwb25kcyB0byBjbGljaywgc3dpdGNoIHRvIHRoZSBjb250cm9sc1xuICAgICAgICB0aGlzLnByb3BzLm9uU3dpdGNoQ29udHJvbHMoY29udHJvbCwgY2xpY2tSZXNwb25zZSlcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBhZnRlciB0aGUgY2FudmFzIGhhcyBiZWVuIHpvb21lZCBpbiBvciBvdXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNhbnZhc1pvb21Eb25lICgpIHtcbiAgICB0aGlzLmZvcmNlVXBkYXRlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyB0aGUgZXZlbnRzIGluIF9ldmVudHNcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2JpbmRFdmVudHMgKCkge1xuICAgIHN1cGVyLl9iaW5kRXZlbnRzKClcbiAgICB0aGlzLmNvbnRleHQubWVkaWF0b3Iub24oXG4gICAgICBDb25zdGFudHMuRVZFTlRTLlpPT01fRE9ORSxcbiAgICAgIHRoaXMuX29uQ2FudmFzWm9vbURvbmVcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogVW5iaW5kcyB0aGUgZXZlbnRzIGluIF9ldmVudHNcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3VuYmluZEV2ZW50cyAoKSB7XG4gICAgc3VwZXIuX3VuYmluZEV2ZW50cygpXG4gICAgdGhpcy5jb250ZXh0Lm1lZGlhdG9yLm9mZihcbiAgICAgIENvbnN0YW50cy5FVkVOVFMuWk9PTV9ET05FLFxuICAgICAgdGhpcy5fb25DYW52YXNab29tRG9uZVxuICAgIClcbiAgfVxufVxuXG5DYW52YXNDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9jYW52YXMtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgVXRpbHMgfSBmcm9tICdnbG9iYWxzJ1xuaW1wb3J0IFNoYXJlZENvbnN0YW50cyBmcm9tICdzaGFyZWQvY29uc3RhbnRzJ1xuaW1wb3J0IEpTT05Mb2FkZXIgZnJvbSAnc2hhcmVkL2xvYWRlcnMvanNvbi1sb2FkZXInXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0aWNrZXJNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IgKHVpLCBvcHRpb25zKSB7XG4gICAgdGhpcy5fdWkgPSB1aVxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5fY2F0ZWdvcmllc0J5SWQgPSB7fVxuICAgIHRoaXMuX2NhdGVnb3JpZXMgPSBbXVxuICAgIHRoaXMuX3N0aWNrZXJzQnlJZCA9IHt9XG5cbiAgICB0aGlzLl9hZGRDYXRlZ29yaWVzKFNoYXJlZENvbnN0YW50cy5ERUZBVUxUUy5TVElDS0VSX0NBVEVHT1JJRVMpXG5cbiAgICBjb25zdCB7IGNhdGVnb3JpZXMsIHJlcGxhY2VDYXRlZ29yaWVzIH0gPSB0aGlzLl9vcHRpb25zXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2F0ZWdvcmllcykge1xuICAgICAgdGhpcy5fYWRkQ2F0ZWdvcmllcyhjYXRlZ29yaWVzLCByZXBsYWNlQ2F0ZWdvcmllcylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXBkYXRlQ2F0ZWdvcmllc01hcCgpXG4gICAgICB0aGlzLl91cGRhdGVBbGxDYXRlZ29yeSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIHN0aWNrZXJzIGZyb20gdGhlIGdpdmVuIGV4dGVybmFsIFVSTFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHVybFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgbG9hZEV4dGVybmFsICh1cmwpIHtcbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgSlNPTkxvYWRlcih1cmwpXG4gICAgcmV0dXJuIGxvYWRlci5sb2FkKClcbiAgICAgIC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgIHRoaXMuX2FkZENhdGVnb3JpZXMocmVzdWx0LmNhdGVnb3JpZXMsIHRoaXMuX29wdGlvbnMucmVwbGFjZUNhdGVnb3JpZXMpXG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjYXRlZ29yaWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0W119IGNhdGVnb3JpZXNcbiAgICogQHBhcmFtIHtCb29sZWFufSByZXBsYWNlID0gZmFsc2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hZGRDYXRlZ29yaWVzIChjYXRlZ29yaWVzLCByZXBsYWNlID0gZmFsc2UpIHtcbiAgICBpZiAocmVwbGFjZSkge1xuICAgICAgdGhpcy5fY2F0ZWdvcmllcyA9IGNhdGVnb3JpZXMuc2xpY2UoMClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY2F0ZWdvcmllcyA9IFV0aWxzLm1lcmdlQ2F0ZWdvcmllcyhcbiAgICAgICAgdGhpcy5fY2F0ZWdvcmllcyxcbiAgICAgICAgY2F0ZWdvcmllcyxcbiAgICAgICAgJ3N0aWNrZXJzJ1xuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUNhdGVnb3JpZXNNYXAoKVxuICAgIHRoaXMuX3VwZGF0ZUFsbENhdGVnb3J5KClcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjYXRlZ29yaWVzIG1hcFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZUNhdGVnb3JpZXNNYXAgKCkge1xuICAgIHRoaXMuX2NhdGVnb3JpZXNCeUlkID0ge31cbiAgICB0aGlzLl9jYXRlZ29yaWVzLmZvckVhY2goKGMpID0+IHsgdGhpcy5fY2F0ZWdvcmllc0J5SWRbYy5pZGVudGlmaWVyXSA9IGMgfSlcblxuICAgIC8vIEJ1aWxkIHN0aWNrZXIgaWQgPT4gc3RpY2tlciBoYXNoXG4gICAgdGhpcy5fY2F0ZWdvcmllcy5mb3JFYWNoKGMgPT4ge1xuICAgICAgYy5zdGlja2Vycy5mb3JFYWNoKHMgPT4ge1xuICAgICAgICB0aGlzLl9zdGlja2Vyc0J5SWRbcy5pZGVudGlmaWVyXSA9IHNcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIC8vIEZpbHRlciBzdGlja2Vyc1xuICAgIGlmICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5hdmFpbGFibGVTdGlja2VycyAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5fb3B0aW9ucy5hdmFpbGFibGVTdGlja2VycyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fY2F0ZWdvcmllcy5mb3JFYWNoKGNhdGVnb3J5ID0+IHtcbiAgICAgICAgY2F0ZWdvcnkuc3RpY2tlcnMgPSBjYXRlZ29yeS5zdGlja2Vycy5maWx0ZXIoc3RpY2tlciA9PlxuICAgICAgICAgIHRoaXMuX29wdGlvbnMuYXZhaWxhYmxlU3RpY2tlcnMuaW5kZXhPZihzdGlja2VyLmlkZW50aWZpZXIpICE9PSAtMVxuICAgICAgICApXG4gICAgICB9KVxuXG4gICAgICB0aGlzLl9jYXRlZ29yaWVzID0gdGhpcy5fY2F0ZWdvcmllcy5maWx0ZXIoY2F0ZWdvcnkgPT4gY2F0ZWdvcnkuc3RpY2tlcnMubGVuZ3RoID4gMClcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVBbGxDYXRlZ29yeSgpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYGFsbGAgY2F0ZWdvcnkgd2hpY2ggY29udGFpbnMgYWxsIHN0aWNrZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlQWxsQ2F0ZWdvcnkgKCkge1xuICAgIHRoaXMuX2FsbENhdGVnb3J5ID0ge1xuICAgICAgaWRlbnRpZmllcjogJ2FsbCcsXG4gICAgICBkZWZhdWx0TmFtZTogJ0FsbCcsXG4gICAgICBzdGlja2VyczogdGhpcy5fY2F0ZWdvcmllc1xuICAgICAgICAubWFwKChjKSA9PiBjLnN0aWNrZXJzKVxuICAgICAgICAucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pXG4gICAgfVxuICAgIHRoaXMuX2NhdGVnb3JpZXNCeUlkLmFsbCA9IHRoaXMuX2FsbENhdGVnb3J5XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RpY2tlcnMgZm9yIHRoZSBjYXRlZ29yeSB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqIEBwYXJhbSAge1N0cmluZ30gY2F0ZWdvcnlOYW1lXG4gICAqIEByZXR1cm4ge09iamVjdFtdfVxuICAgKi9cbiAgZ2V0U3RpY2tlcnNGb3JDYXRlZ29yeSAoY2F0ZWdvcnlOYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9jYXRlZ29yaWVzQnlJZFtjYXRlZ29yeU5hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3RpY2tlciBjYXRlZ29yeSAnJHtjYXRlZ29yeU5hbWV9J2ApXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYXRlZ29yaWVzQnlJZFtjYXRlZ29yeU5hbWVdLnN0aWNrZXJzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RpY2tlciB3aXRoIHRoZSBnaXZlbiBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gaWRlbnRpZmllclxuICAgKi9cbiAgZ2V0U3RpY2tlckJ5SWRlbnRpZmllciAoaWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLl9zdGlja2Vyc0J5SWRbaWRlbnRpZmllcl1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjYXRlZ29yaWVzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jbHVkZUFsbENhdGVnb3J5ID0gZmFsc2VcbiAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAqL1xuICBnZXRDYXRlZ29yaWVzIChpbmNsdWRlQWxsQ2F0ZWdvcnkgPSBmYWxzZSkge1xuICAgIGlmIChpbmNsdWRlQWxsQ2F0ZWdvcnkpIHtcbiAgICAgIHJldHVybiBbdGhpcy5fYWxsQ2F0ZWdvcnldLmNvbmNhdCh0aGlzLl9jYXRlZ29yaWVzKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jYXRlZ29yaWVzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2F0ZWdvcnkgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gaWRcbiAgICogQHBhcmFtICB7U3RyaW5nfSBpZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRDYXRlZ29yeSAoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fY2F0ZWdvcmllc0J5SWRbaWRdXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgVVJMIGZvciB0aGUgZ2l2ZW4gc3RpY2tlci4gSWYgdGhlIHVzZXIgaXMgdXNpbmcgSW50ZXJuZXQgRXhwbG9yZXIsIHdlXG4gICAqIGZhbGwgYmFjayB0byB0aGUgc3ZnIHZhcmlhbnQgKGlmIHByZXNlbnQpXG4gICAqIEBwYXJhbSAge09iamVjdH0gc3RpY2tlclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpemVcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldFVSTEZvclN0aWNrZXIgKHN0aWNrZXIsIHNpemUgPSAnYmFzZScpIHtcbiAgICBjb25zdCB7IGltYWdlcyB9ID0gc3RpY2tlclxuICAgIGNvbnN0IG1lZGlhID0gc2l6ZSA9PT0gJ2Jhc2UnID8gKGltYWdlcy5tZWRpYUJhc2UgfHwgaW1hZ2VzLm1lZGlhVGh1bWIpIDogaW1hZ2VzLm1lZGlhVGh1bWJcbiAgICBjb25zdCB1cmlzID0gbWVkaWEudXJpcyB8fCBbbWVkaWEudXJpXVxuICAgIGlmICh0eXBlb2YgVXRpbHMuQnJvd3NlciAhPT0gJ3VuZGVmaW5lZCcgJiYgIVV0aWxzLkJyb3dzZXIuZ2V0SUVWZXJzaW9uKCkpIHtcbiAgICAgIGNvbnN0IHN2Z3MgPSB1cmlzLmZpbHRlcihmID0+IC9cXC5zdmckL2kudGVzdChmKSlcbiAgICAgIHJldHVybiBzdmdzLmxlbmd0aCA/IHN2Z3NbMF0gOiB1cmlzWzBdXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5vdFN2Z3MgPSB1cmlzLmZpbHRlcihmID0+ICEoL1xcLnN2ZyQvaS50ZXN0KGYpKSlcbiAgICAgIHJldHVybiBub3RTdmdzLmxlbmd0aCA/IG5vdFN2Z3NbMF0gOiB1cmlzWzBdXG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9tYW5hZ2Vycy9zdGlja2VyLW1hbmFnZXIuanMiLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvcEJhckNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvKipcbiAgICogUmVuZGVycyB0aGUgY29udGVudCBvZiB0aGlzIFRvcEJhckNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyQ29udGVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICByZXR1cm4gKDxkaXYgYmVtPSckYjp0b3BCYXIgZTpyb3cnPlxuICAgICAgPGRpdiBiZW09J2U6Y2VsbCc+XG4gICAgICAgIHt0aGlzLnJlbmRlckNvbnRlbnQoKX1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PilcbiAgfVxufVxuXG5Ub3BCYXJDb21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvc2hhcmVkL3RvcC1iYXIvdG9wLWJhci1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cbmltcG9ydCB7IFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vZ2xvYmFscydcbmltcG9ydCBEcmFnZ2FibGVDb21wb25lbnQgZnJvbSAnLi9kcmFnZ2FibGUtY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTbGlkZXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25Lbm9iRHJhZ1N0YXJ0JyxcbiAgICAgICdfb25Lbm9iRHJhZycsXG4gICAgICAnX29uS25vYkRyYWdTdG9wJyxcbiAgICAgICdfb25CYXJEcmFnU3RhcnQnLFxuICAgICAgJ19vbkJhckRyYWcnLFxuICAgICAgJ19vbkJhckRyYWdTdG9wJyxcbiAgICAgICdfb25NaWRkbGVEb3RDbGljaydcbiAgICApXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgdmFsdWU6IHRoaXMucHJvcHMudmFsdWUgfHwgMCxcbiAgICAgIHNsaWRlclBvc2l0aW9uOiAwLFxuICAgICAgZm9yZWdyb3VuZExlZnQ6IDAsXG4gICAgICBmb3JlZ3JvdW5kV2lkdGg6IDBcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBMSUZFQ1lDTEVcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgLy8gVHJpZ2dlciBhIHJlLXJlbmRlciB0byBwb3NpdGlvbiB0aGUga25vYlxuICAgIHRoaXMuX3NldFZhbHVlKHRoaXMuc3RhdGUudmFsdWUsIGZhbHNlKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgcmVjZWl2ZXMgbmV3IHByb3BzXG4gICAqIEBwYXJhbSAge09iamVjdH0gcHJvcHNcbiAgICovXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKHByb3BzKSB7XG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB0aGlzLnN0YXRlLnZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXRWYWx1ZShwcm9wcy52YWx1ZSwgZmFsc2UpXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWlkZGxlIGRvdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uTWlkZGxlRG90Q2xpY2sgKCkge1xuICAgIHRoaXMuX3ByZXZpb3VzVmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlXG4gICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLnByb3BzLm1pblZhbHVlICsgKHRoaXMucHJvcHMubWF4VmFsdWUgLSB0aGlzLnByb3BzLm1pblZhbHVlKSAvIDJcbiAgICB0aGlzLl9zZXRWYWx1ZShuZXdWYWx1ZSwgdHJ1ZSwgdHJ1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUga25vYlxuICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBwb3NpdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uS25vYkRyYWdTdGFydCAocG9zaXRpb24pIHtcbiAgICB0aGlzLl9wcmV2aW91c1ZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZVxuICAgIHRoaXMuX2luaXRpYWxTbGlkZXJQb3NpdGlvbiA9IHRoaXMuc3RhdGUuc2xpZGVyUG9zaXRpb25cbiAgICB0aGlzLl9pbml0aWFsUG9zaXRpb24gPSBwb3NpdGlvblxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBrbm9iXG4gICAqIEBwYXJhbSAge1ZlY3RvcjJ9IGRpZmZcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbktub2JEcmFnIChkaWZmKSB7XG4gICAgY29uc3QgeyBiYXIgfSA9IHRoaXMucmVmc1xuICAgIGNvbnN0IGJhcldpZHRoID0gYmFyLm9mZnNldFdpZHRoXG5cbiAgICBsZXQgbmV3U2xpZGVyUG9zaXRpb24gPSB0aGlzLl9pbml0aWFsU2xpZGVyUG9zaXRpb24gKyBkaWZmLnhcbiAgICBuZXdTbGlkZXJQb3NpdGlvbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKG5ld1NsaWRlclBvc2l0aW9uLCBiYXJXaWR0aCkpXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSBuZXdTbGlkZXJQb3NpdGlvbiAvIGJhcldpZHRoXG4gICAgbGV0IG5ld1ZhbHVlID0gdGhpcy5wcm9wcy5taW5WYWx1ZSArICh0aGlzLnByb3BzLm1heFZhbHVlIC0gdGhpcy5wcm9wcy5taW5WYWx1ZSkgKiBwcm9ncmVzc1xuXG4gICAgdGhpcy5fc2V0VmFsdWUobmV3VmFsdWUpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUga25vYlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uS25vYkRyYWdTdG9wICgpIHtcbiAgICB0aGlzLl9zZXRWYWx1ZSh0aGlzLnN0YXRlLnZhbHVlLCB0cnVlLCB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBiYXJcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gcG9zaXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJhckRyYWdTdGFydCAocG9zaXRpb24pIHtcbiAgICB0aGlzLl9wcmV2aW91c1ZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZVxuICAgIHRoaXMuX2luaXRpYWxQb3NpdGlvbiA9IHBvc2l0aW9uLmNsb25lKClcblxuICAgIGNvbnN0IHsgYmFyIH0gPSB0aGlzLnJlZnNcbiAgICBjb25zdCBiYXJXaWR0aCA9IGJhci5vZmZzZXRXaWR0aFxuICAgIGNvbnN0IHByb2dyZXNzID0gcG9zaXRpb24ueCAvIGJhcldpZHRoXG4gICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLnByb3BzLm1pblZhbHVlICsgKHRoaXMucHJvcHMubWF4VmFsdWUgLSB0aGlzLnByb3BzLm1pblZhbHVlKSAqIHByb2dyZXNzXG4gICAgdGhpcy5fc2V0VmFsdWUobmV3VmFsdWUpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIGJhclxuICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBkaWZmXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25CYXJEcmFnIChkaWZmKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLl9pbml0aWFsUG9zaXRpb24uY2xvbmUoKVxuICAgICAgLmFkZChkaWZmKVxuXG4gICAgY29uc3QgeyBiYXIgfSA9IHRoaXMucmVmc1xuICAgIGNvbnN0IGJhcldpZHRoID0gYmFyLm9mZnNldFdpZHRoXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSBwb3NpdGlvbi54IC8gYmFyV2lkdGhcbiAgICBsZXQgbmV3VmFsdWUgPSB0aGlzLnByb3BzLm1pblZhbHVlICsgKHRoaXMucHJvcHMubWF4VmFsdWUgLSB0aGlzLnByb3BzLm1pblZhbHVlKSAqIHByb2dyZXNzXG4gICAgbmV3VmFsdWUgPSBNYXRoLm1heCh0aGlzLnByb3BzLm1pblZhbHVlLCBNYXRoLm1pbih0aGlzLnByb3BzLm1heFZhbHVlLCBuZXdWYWx1ZSkpXG4gICAgdGhpcy5fc2V0VmFsdWUobmV3VmFsdWUpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgYmFyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25CYXJEcmFnU3RvcCAoKSB7XG4gICAgdGhpcy5fc2V0VmFsdWUodGhpcy5zdGF0ZS52YWx1ZSwgdHJ1ZSwgdHJ1ZSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFNUWUxJTkdcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3R5bGUgZm9yIHRoZSBrbm9iIChwb3NpdGlvbilcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEtub2JTdHlsZSAoKSB7XG4gICAgcmV0dXJuIHsgbGVmdDogdGhpcy5zdGF0ZS5zbGlkZXJQb3NpdGlvbiB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3R5bGUgZm9yIHRoZSBmb3JlZ3JvdW5kIGJhclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0Rm9yZWdyb3VuZFN0eWxlICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogdGhpcy5zdGF0ZS5mb3JlZ3JvdW5kTGVmdCxcbiAgICAgIHdpZHRoOiB0aGlzLnN0YXRlLmZvcmVncm91bmRXaWR0aFxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE1JU0NcblxuICAvKipcbiAgICogRGVjaWRlcyB3aGV0aGVyIG9yIG5vdCB0aGlzIHNsaWRlciBzaG91bGQgaGF2ZSBhIG1pZGRsZSBkb3Qgb24gdGhlIGJhclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Rpc3BsYXlNaWRkbGVEb3QgKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLm1pZGRsZURvdCAhPT0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSB0byB0aGUgZ2l2ZW4gdmFsdWUsIHVwZGF0ZXMgdGhlIHNsaWRlciBwb3NpdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtCb29sZWFufSBlbWl0Q2hhbmdlID0gdHJ1ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVtaXRSZWxlYXNlID0gZmFsc2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRWYWx1ZSAodmFsdWUsIGVtaXRDaGFuZ2UgPSB0cnVlLCBlbWl0UmVsZWFzZSA9IGZhbHNlKSB7XG4gICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKVxuICAgIGNvbnN0IHsgbWluVmFsdWUsIG1heFZhbHVlIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSAodmFsdWUgLSBtaW5WYWx1ZSkgLyAobWF4VmFsdWUgLSBtaW5WYWx1ZSlcblxuICAgIC8vIENhbGN1bGF0ZSBzbGlkZXIgcG9zaXRpb25cbiAgICBjb25zdCB7IGJhciB9ID0gdGhpcy5yZWZzXG4gICAgY29uc3QgYmFyV2lkdGggPSBiYXIub2Zmc2V0V2lkdGhcbiAgICBjb25zdCBzbGlkZXJQb3NpdGlvbiA9IGJhcldpZHRoICogcHJvZ3Jlc3NcblxuICAgIC8vIENhbGN1bGF0ZSBmb3JlZ3JvdW5kIHBvc2l0aW9uIGFuZCB3aWR0aFxuICAgIGxldCBmb3JlZ3JvdW5kV2lkdGggPSBwcm9ncmVzcyAqIGJhcldpZHRoXG4gICAgbGV0IGZvcmVncm91bmRMZWZ0ID0gMFxuICAgIGlmICh0aGlzLl9kaXNwbGF5TWlkZGxlRG90KCkpIHtcbiAgICAgIGZvcmVncm91bmRXaWR0aCA9IE1hdGguYWJzKHByb2dyZXNzIC0gMC41KSAqIGJhcldpZHRoXG4gICAgICBmb3JlZ3JvdW5kTGVmdCA9IHByb2dyZXNzIDwgMC41XG4gICAgICAgID8gKGJhcldpZHRoICogMC41IC0gZm9yZWdyb3VuZFdpZHRoKVxuICAgICAgICA6ICc1MCUnXG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IHZhbHVlLCBzbGlkZXJQb3NpdGlvbiwgZm9yZWdyb3VuZFdpZHRoLCBmb3JlZ3JvdW5kTGVmdCB9KVxuXG4gICAgaWYgKGVtaXRDaGFuZ2UpIHtcbiAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UgJiYgdGhpcy5wcm9wcy5vbkNoYW5nZSh2YWx1ZSwgdGhpcy5fcHJldmlvdXNWYWx1ZSwgZW1pdFJlbGVhc2UpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIGRpc3BsYXkgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gcHJvcHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9idWlsZFZhbHVlICh2YWx1ZSkge1xuICAgIC8vIExpbWl0IGRlY2ltYWxzIHRvIHR3byBkaWdpdHMsIGlmIHByZXNlbnRcbiAgICBpZiAodmFsdWUgJSAxICE9PSAwKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvRml4ZWQoMilcbiAgICB9XG5cbiAgICAvLyBBZGQgcG9zaXRpdmUgdmFsdWUgcHJlZml4ICgrKSBpZiB2YWx1ZSBpcyA+IDBcbiAgICBpZiAodGhpcy5wcm9wcy5wb3NpdGl2ZVZhbHVlUHJlZml4ICYmIHZhbHVlID49IDApIHtcbiAgICAgIHZhbHVlID0gYCR7dGhpcy5wcm9wcy5wb3NpdGl2ZVZhbHVlUHJlZml4fSR7dmFsdWV9YFxuICAgIH1cblxuICAgIC8vIEFkZCB1bml0IGlmIHByZXNlbnRcbiAgICBpZiAodGhpcy5wcm9wcy52YWx1ZVVuaXQpIHtcbiAgICAgIHZhbHVlICs9IHRoaXMucHJvcHMudmFsdWVVbml0XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgbGV0IG1pZGRsZURvdCA9IG51bGxcbiAgICBpZiAodGhpcy5fZGlzcGxheU1pZGRsZURvdCgpKSB7XG4gICAgICBtaWRkbGVEb3QgPSAoXG4gICAgICAgIDxkaXYgYmVtPSdlOm1pZGRsZURvdCcgb25DbGljaz17dGhpcy5fb25NaWRkbGVEb3RDbGlja30gLz5cbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBmb3JlZ3JvdW5kUHJvcHMgPSB7XG4gICAgICBzdHlsZTogdGhpcy5fZ2V0Rm9yZWdyb3VuZFN0eWxlKClcbiAgICB9XG5cbiAgICBjb25zdCBjb21wb25lbnRCZW0gPSAnJGI6c2xpZGVyJyArICh0aGlzLnByb3BzLnN0eWxlID8gJyBtOicgKyB0aGlzLnByb3BzLnN0eWxlIDogJycpXG4gICAgcmV0dXJuICg8ZGl2IGJlbT17Y29tcG9uZW50QmVtfT5cbiAgICAgIDxkaXYgYmVtPSckZTpiYXInIHJlZj0nYmFyJz5cbiAgICAgICAgPERyYWdnYWJsZUNvbXBvbmVudFxuICAgICAgICAgIG9uU3RhcnQ9e3RoaXMuX29uQmFyRHJhZ1N0YXJ0fVxuICAgICAgICAgIG9uRHJhZz17dGhpcy5fb25CYXJEcmFnfVxuICAgICAgICAgIG9uU3RvcD17dGhpcy5fb25CYXJEcmFnU3RvcH0+XG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxkaXYgYmVtPSckZTpiYWNrZ3JvdW5kJyAvPlxuICAgICAgICAgICAgPGRpdiBiZW09JyRlOmZvcmVncm91bmQnIHsuLi5mb3JlZ3JvdW5kUHJvcHN9IC8+XG4gICAgICAgICAgICA8RHJhZ2dhYmxlQ29tcG9uZW50XG4gICAgICAgICAgICAgIG9uU3RhcnQ9e3RoaXMuX29uS25vYkRyYWdTdGFydH1cbiAgICAgICAgICAgICAgb25EcmFnPXt0aGlzLl9vbktub2JEcmFnfVxuICAgICAgICAgICAgICBvblN0b3A9e3RoaXMuX29uS25vYkRyYWdTdG9wfT5cbiAgICAgICAgICAgICAgPGRpdiBiZW09J2U6a25vYiBiOmtub2IgbTpzbGlkZXInIHN0eWxlPXt0aGlzLl9nZXRLbm9iU3R5bGUoKX0gLz5cbiAgICAgICAgICAgIDwvRHJhZ2dhYmxlQ29tcG9uZW50PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L0RyYWdnYWJsZUNvbXBvbmVudD5cbiAgICAgICAge21pZGRsZURvdH1cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBiZW09JyRlOmxhYmVscyc+XG4gICAgICAgIDxkaXYgYmVtPSdlOmxhYmVsIG06bG93ZXJCb3VuZGFyeSc+e3RoaXMuX2J1aWxkVmFsdWUodGhpcy5wcm9wcy5taW5WYWx1ZSl9PC9kaXY+XG4gICAgICAgIDxkaXYgYmVtPSdlOmxhYmVsIG06dmFsdWUnPnt0aGlzLnByb3BzLmxhYmVsfSB7dGhpcy5fYnVpbGRWYWx1ZSh0aGlzLnN0YXRlLnZhbHVlKX08L2Rpdj5cbiAgICAgICAgPGRpdiBiZW09J2U6bGFiZWwgbTp1cHBlckJvdW5kYXJ5Jz57dGhpcy5fYnVpbGRWYWx1ZSh0aGlzLnByb3BzLm1heFZhbHVlKX08L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PilcbiAgfVxufVxuXG5TbGlkZXJDb21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvc2xpZGVyLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBDb25zdGFudHMsIFV0aWxzLCBTREssIFJlYWN0QkVNIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBUZXh0SXRlbUNvbXBvbmVudCBmcm9tICcuL2l0ZW1zL3RleHQtaXRlbS1jb21wb25lbnQnXG5pbXBvcnQgU3RpY2tlckl0ZW1Db21wb25lbnQgZnJvbSAnLi9pdGVtcy9zdGlja2VyLWl0ZW0tY29tcG9uZW50J1xuaW1wb3J0IEJydXNoSXRlbUNvbXBvbmVudCBmcm9tICcuL2l0ZW1zL2JydXNoLWl0ZW0tY29tcG9uZW50J1xuaW1wb3J0IENhbnZhc0NvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4uL2NhbnZhcy1jb250cm9scy1jb21wb25lbnQnXG5jb25zdCB7IFN0aWNrZXJTcHJpdGUsIFRleHRTcHJpdGUsIEJydXNoU3ByaXRlIH0gPSBTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb25cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ByaXRlc0NhbnZhc0NvbnRyb2xzQ29tcG9uZW50IGV4dGVuZHMgQ2FudmFzQ29udHJvbHNDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbkNhbnZhc0NsaWNrJyxcbiAgICAgICdfb25TcHJpdGVEcmFnU3RhcnQnLFxuICAgICAgJ19vblNwcml0ZURyYWdTdG9wJyxcbiAgICAgICdfb25PcGVyYXRpb25VcGRhdGVkJyxcbiAgICAgICdfb25PcGVyYXRpb25SZW1vdmVkJyxcbiAgICAgICdfb25TcHJpdGVGbGlwJyxcbiAgICAgICdfb25TcHJpdGVUYWtlVG9Gcm9udCcsXG4gICAgICAnX29uU3ByaXRlUmVtb3ZlJ1xuICAgIClcblxuICAgIHRoaXMuX2NhbnZhc0NsaWNrRGlzYWJsZWQgPSBmYWxzZVxuXG4gICAgdGhpcy5fZXZlbnRzID0ge1xuICAgICAgW0NvbnN0YW50cy5FVkVOVFMuT1BFUkFUSU9OX1VQREFURURdOiB0aGlzLl9vbk9wZXJhdGlvblVwZGF0ZWQsXG4gICAgICBbQ29uc3RhbnRzLkVWRU5UUy5PUEVSQVRJT05fUkVNT1ZFRF06IHRoaXMuX29uT3BlcmF0aW9uUmVtb3ZlZFxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGFuIG9wZXJhdGlvbiBoYXMgYmVlbiByZW1vdmVkXG4gICAqIEBwYXJhbSAge09wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25PcGVyYXRpb25SZW1vdmVkIChvcGVyYXRpb24pIHtcbiAgICBjb25zdCBzZWxlY3RlZFNwcml0ZSA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3NlbGVjdGVkU3ByaXRlJylcbiAgICBpZiAob3BlcmF0aW9uICE9PSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKSB8fCAhc2VsZWN0ZWRTcHJpdGUpIHJldHVyblxuXG4gICAgLy8gT3BlcmF0aW9uIGNhbiBiZSByZW1vdmVkIGJ5IHRoZSB1bmRvIGJ1dHRvbi4gV2UgbmVlZFxuICAgIC8vIHRvIG1ha2Ugc3VyZSB3ZSByZS1jcmVhdGUgdGhlIG9wZXJhdGlvbiBmb3IgdGhlIGxpZmV0aW1lXG4gICAgLy8gb2YgdGhpcyBjb250cm9sXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG5ld09wZXJhdGlvbiA9IGVkaXRvci5vcGVyYXRpb25zLmdldE9yQ3JlYXRlKCdzcHJpdGUnLCB7XG4gICAgICBzcHJpdGVzOiBbc2VsZWN0ZWRTcHJpdGVdLFxuICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICB9KVxuICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUoe1xuICAgICAgb3BlcmF0aW9uOiBuZXdPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb25FeGlzdGVkQmVmb3JlOiBmYWxzZSxcbiAgICAgIGluaXRpYWxPcHRpb25zOiB7fVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBvcGVyYXRpb24gaGFzIGJlZW4gdXBkYXRlZFxuICAgKiBAcGFyYW0gIHtPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uT3BlcmF0aW9uVXBkYXRlZCAob3BlcmF0aW9uKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRTcHJpdGUgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdzZWxlY3RlZFNwcml0ZScpXG4gICAgaWYgKG9wZXJhdGlvbiAhPT0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJykgfHwgIXNlbGVjdGVkU3ByaXRlKSByZXR1cm5cblxuICAgIC8vIElmIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgc3ByaXRlIGlzIG5vIGxvbmdlciBleGlzdGVudCxcbiAgICAvLyByZS1hZGQgaXRcbiAgICBjb25zdCBzcHJpdGVzID0gb3BlcmF0aW9uLmdldFNwcml0ZXMoKVxuICAgIGlmIChzcHJpdGVzLmluZGV4T2Yoc2VsZWN0ZWRTcHJpdGUpID09PSAtMSkge1xuICAgICAgc3ByaXRlcy5wdXNoKHNlbGVjdGVkU3ByaXRlKVxuICAgIH1cblxuICAgIHRoaXMuZm9yY2VVcGRhdGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHNlbGVjdGVkIGl0ZW0gaXMgZGVzZWxlY3RlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uSXRlbUJsdXIgKCkge1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgc29tZXdoZXJlIG9uIHRoZSBjYW52YXNcbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNhbnZhc0NsaWNrIChlKSB7XG4gICAgaWYgKHRoaXMuX2NhbnZhc0NsaWNrRGlzYWJsZWQpIHJldHVyblxuXG4gICAgY29uc3QgaGl0VGVzdCA9IHRoaXMuX3BlcmZvcm1IaXRUZXN0KFV0aWxzLmdldEV2ZW50UG9zaXRpb24oZSkpXG4gICAgaWYgKCFoaXRUZXN0KSB7XG4gICAgICBpZiAodGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKSkge1xuICAgICAgICB0aGlzLl9vbkl0ZW1CbHVyKClcbiAgICAgIH1cbiAgICAgIHRoaXMucHJvcHMub25Td2l0Y2hDb250cm9scygnaG9tZScpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgZmxpcHMgdGhlIHNlbGVjdGVkIHNwcml0ZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpcmVjdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uU3ByaXRlRmxpcCAoZGlyZWN0aW9uKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRTcHJpdGUgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdzZWxlY3RlZFNwcml0ZScpXG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgIGNhc2UgJ2gnOlxuICAgICAgICBzZWxlY3RlZFNwcml0ZS5zZXRGbGlwSG9yaXpvbnRhbGx5KCFzZWxlY3RlZFNwcml0ZS5nZXRGbGlwSG9yaXpvbnRhbGx5KCkpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICd2JzpcbiAgICAgICAgc2VsZWN0ZWRTcHJpdGUuc2V0RmxpcFZlcnRpY2FsbHkoIXNlbGVjdGVkU3ByaXRlLmdldEZsaXBWZXJ0aWNhbGx5KCkpXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBlZGl0b3IucmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHRha2VzIHRoZSBzZWxlY3RlZCBzcHJpdGUgdG8gZnJvbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblNwcml0ZVRha2VUb0Zyb250IChkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxuICAgIG9wZXJhdGlvbi50YWtlU3ByaXRlVG9Gcm9udCh0aGlzLmdldFNoYXJlZFN0YXRlKCdzZWxlY3RlZFNwcml0ZScpKVxuICAgIHRoaXMuZm9yY2VTaGFyZWRVcGRhdGUoKVxuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBlZGl0b3IucmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHJlbW92ZXMgdGhlIHNlbGVjdGVkIHNwcml0ZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpcmVjdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uU3ByaXRlUmVtb3ZlICgpIHtcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxuICAgIGNvbnN0IHNlbGVjdGVkU3ByaXRlID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKVxuICAgIG9wZXJhdGlvbi5yZW1vdmVTcHJpdGUoc2VsZWN0ZWRTcHJpdGUpXG4gICAgc2VsZWN0ZWRTcHJpdGUuZGlzcG9zZSgpXG5cbiAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHtcbiAgICAgIHNlbGVjdGVkU3ByaXRlOiBudWxsXG4gICAgfSlcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgZWRpdG9yLnJlbmRlcigpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBEUkFHR0lOR1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGEgc3ByaXRlIGhhcyByZWNlaXZlZCBhIGRyYWdnaW5nIGV2ZW50LiBCbG9ja3MgdGhlIGBfb25DYW52YXNDbGlja2BcbiAgICogaGFuZGxlciB1bnRpbCBgX29uU3ByaXRlRHJhZ1N0b3BgXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25TcHJpdGVEcmFnU3RhcnQgKCkge1xuICAgIHRoaXMuX2NhbnZhc0NsaWNrRGlzYWJsZWQgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogU2luY2UgYF9vbkNhbnZhc0NsaWNrYCBpcyB0cmlnZ2VyZWQgcmlnaHQgYWZ0ZXIgdGhlIGRyYWcgZW5kIGV2ZW50IGZvciBrbm9icyBpcyB0cmlnZ2VyZWQsXG4gICAqIHdlIG5lZWQgdG8gd2FpdCBhIHNob3J0IGFtb3VudCBvZiB0aW1lIHVudGlsIHdlIHJlLWVuYWJhbGUgdGhlIGNhbnZhcyBjbGlja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uU3ByaXRlRHJhZ1N0b3AgKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fY2FudmFzQ2xpY2tEaXNhYmxlZCA9IGZhbHNlXG4gICAgfSwgMTAwKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gU1RZTElOR1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb250YWluZXIgc3R5bGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldENvbnRhaW5lclN0eWxlICgpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3QgY2FudmFzRGltZW5zaW9ucyA9IGVkaXRvci5nZXRDYW52YXNEaW1lbnNpb25zKClcbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuXG4gICAgY29uc3QgeyB4LCB5IH0gPSBjYW52YXNEaW1lbnNpb25zLmNsb25lKClcbiAgICAgIC5kaXZpZGUoMilcbiAgICAgIC5zdWJ0cmFjdChcbiAgICAgICAgb3V0cHV0RGltZW5zaW9ucy5jbG9uZSgpLmRpdmlkZSgyKVxuICAgICAgKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IHgsXG4gICAgICB0b3A6IHksXG4gICAgICB3aWR0aDogb3V0cHV0RGltZW5zaW9ucy54LFxuICAgICAgaGVpZ2h0OiBvdXRwdXREaW1lbnNpb25zLnlcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBNSVNDXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByb3BlcnRpZXMgZm9yIHRoZSBvdXRlciBjb250YWluZXJcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldENvbnRhaW5lclByb3BzICgpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcm9wZXJ0aWVzIGZvciB0aGUgY2FudmFzIGNvbnRhaW5lclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0SW5uZXJDb250YWluZXJQcm9wcyAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0eWxlOiB0aGlzLl9nZXRDb250YWluZXJTdHlsZSgpLFxuICAgICAgb25DbGljazogdGhpcy5fb25DYW52YXNDbGlja1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcm9wcyB0aGF0IGFyZSBwYXNzZWQgdG8gdGhlIGl0ZW0gY29tcG9uZW50IG9mIHRoZSBnaXZlbiBzcHJpdGVcbiAgICogQHBhcmFtICB7U3ByaXRlfSBzcHJpdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFByb3BzRm9yU3ByaXRlIChzcHJpdGUpIHtcbiAgICBsZXQgcHJvcHMgPSB7IGhpZGVDb250ZW50OiB0cnVlIH1cbiAgICByZXR1cm4gcHJvcHNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb21wb25lbnQtdHlwZSBmb3IgYSBnaXZlbiBzcHJpdGVcbiAgICogQHBhcmFtIHtTcHJpdGV9IHNwcml0ZVxuICAgKiBAcmV0dXJuIHtJdGVtQ29tcG9uZW50fVxuICAgKi9cbiAgX2dldENvbXBvbmVudFR5cGVGb3JTcHJpdGUgKHNwcml0ZSkge1xuICAgIGlmIChzcHJpdGUgaW5zdGFuY2VvZiBUZXh0U3ByaXRlKSB7XG4gICAgICByZXR1cm4gVGV4dEl0ZW1Db21wb25lbnRcbiAgICB9IGVsc2UgaWYgKHNwcml0ZSBpbnN0YW5jZW9mIFN0aWNrZXJTcHJpdGUpIHtcbiAgICAgIHJldHVybiBTdGlja2VySXRlbUNvbXBvbmVudFxuICAgIH0gZWxzZSBpZiAoc3ByaXRlIGluc3RhbmNlb2YgQnJ1c2hTcHJpdGUpIHtcbiAgICAgIHJldHVybiBCcnVzaEl0ZW1Db21wb25lbnRcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgc3ByaXRlIGl0ZW1zXG4gICAqIEByZXR1cm4ge0FycmF5LjxTcHJpdGVJdGVtQ29tcG9uZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJTcHJpdGVJdGVtcyAoKSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICBjb25zdCBzcHJpdGVzID0gb3BlcmF0aW9uLmdldFNwcml0ZXMoKVxuICAgIGNvbnN0IHNlbGVjdGVkU3ByaXRlID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKVxuXG4gICAgcmV0dXJuIHNwcml0ZXNcbiAgICAgIC5tYXAoKHNwcml0ZSkgPT4ge1xuICAgICAgICBjb25zdCBpc1NlbGVjdGVkID0gKHNwcml0ZSA9PT0gc2VsZWN0ZWRTcHJpdGUpXG4gICAgICAgIGNvbnN0IFNwcml0ZUNvbXBvbmVudCA9IHRoaXMuX2dldENvbXBvbmVudFR5cGVGb3JTcHJpdGUoc3ByaXRlKVxuICAgICAgICBjb25zdCBzcHJpdGVQcm9wcyA9IHRoaXMuX2dldFByb3BzRm9yU3ByaXRlKHNwcml0ZSlcbiAgICAgICAgcmV0dXJuICg8U3ByaXRlQ29tcG9uZW50XG4gICAgICAgICAgb3BlcmF0aW9uPXtvcGVyYXRpb259XG4gICAgICAgICAgc2hhcmVkU3RhdGU9e3RoaXMucHJvcHMuc2hhcmVkU3RhdGV9XG4gICAgICAgICAgc3ByaXRlPXtzcHJpdGV9XG4gICAgICAgICAgc2VsZWN0ZWQ9e2lzU2VsZWN0ZWR9XG4gICAgICAgICAgb25EcmFnU3RhcnQ9e3RoaXMuX29uU3ByaXRlRHJhZ1N0YXJ0fVxuICAgICAgICAgIG9uRHJhZ1N0b3A9e3RoaXMuX29uU3ByaXRlRHJhZ1N0b3B9XG4gICAgICAgICAgb25SZW1vdmU9e3RoaXMuX29uU3ByaXRlUmVtb3ZlLmJpbmQodGhpcywgc3ByaXRlKX1cbiAgICAgICAgICBvcHRpb25zPXt0aGlzLnByb3BzLm9wdGlvbnN9XG4gICAgICAgICAgcmVmPXtgc3ByaXRlLSR7c3ByaXRlLmdldElkKCl9YH1cbiAgICAgICAgICB7Li4uc3ByaXRlUHJvcHN9IC8+KVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIHJlbmRlcnMgY29udHJvbHMgb24gdG9wIG9mIHRoZSBzcHJpdGVzXG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyT3ZlcmxheUNvbnRyb2xzICgpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIHJldHVybiAoPGRpdlxuICAgICAgYmVtPSckYjpjYW52YXNDb250cm9scyBlOmNvbnRhaW5lciBtOmZ1bGwnXG4gICAgICByZWY9J2NvbnRhaW5lcidcbiAgICAgIHsuLi50aGlzLl9nZXRDb250YWluZXJQcm9wcygpfT5cbiAgICAgIDxkaXZcbiAgICAgICAgYmVtPSdiOmNhbnZhc0NvbnRyb2xzIGU6aW5uZXJDb250YWluZXInXG4gICAgICAgIHJlZj0naW5uZXJDb250YWluZXInXG4gICAgICAgIHsuLi50aGlzLl9nZXRJbm5lckNvbnRhaW5lclByb3BzKCl9PlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgYmVtPSckYjpzcHJpdGVzQ2FudmFzQ29udHJvbHMnXG4gICAgICAgICAgcmVmPSdjb250YWluZXInPlxuICAgICAgICAgIHt0aGlzLl9yZW5kZXJTcHJpdGVJdGVtcygpfVxuICAgICAgICAgIHt0aGlzLl9yZW5kZXJPdmVybGF5Q29udHJvbHMoKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuU3ByaXRlc0NhbnZhc0NvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IENhbnZhc0NvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9zcHJpdGVzL3Nwcml0ZXMtY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCIvKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IENvbnN0YW50cyB9IGZyb20gJ2dsb2JhbHMnXG5pbXBvcnQgRm9udCBmcm9tICcuLi9hc3NldHMvZm9udCdcbmltcG9ydCBMb2cgZnJvbSAnLi4vbG9nJ1xuaW1wb3J0IEZvbnRWYXJpYXRpb24gZnJvbSAnLi4vYXNzZXRzL2ZvbnQtdmFyaWF0aW9uJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb250TWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yICh1aSwgb3B0aW9ucykge1xuICAgIHRoaXMuX3VpID0gdWlcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMuX2ZvbnRzID0gW11cbiAgICB0aGlzLl92YXJpYXRpb25zQnlJZGVudGlmaWVyID0ge31cbiAgICB0aGlzLl9mb250c0J5Rm9udEZhbWlseSA9IHt9XG5cbiAgICB0aGlzLl9pbml0Rm9udHMoKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBmb250c1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRGb250cyAoKSB7XG4gICAgbGV0IHsgZm9udHM6IGFkZGl0aW9uYWxGb250cywgcmVwbGFjZUZvbnRzLCBhdmFpbGFibGVWYXJpYXRpb25zIH0gPSB0aGlzLl9vcHRpb25zXG5cbiAgICAvLyBSZXBsYWNlIG9yIGFwcGVuZCBmb250c1xuICAgIGxldCBmb250cyA9IENvbnN0YW50cy5ERUZBVUxUUy5GT05UU1xuICAgIGlmIChyZXBsYWNlRm9udHMpIHtcbiAgICAgIGZvbnRzID0gYWRkaXRpb25hbEZvbnRzXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvbnRzID0gZm9udHMuY29uY2F0KGFkZGl0aW9uYWxGb250cyB8fCBbXSlcbiAgICB9XG5cbiAgICAvLyBUdXJuIGZvbnRzIGludG8gYWN0dWFsIEZvbnQgb2JqZWN0cyB3aXRoIEZvbnRWYXJpYXRpb24gb2JqZWN0c1xuICAgIGxldCBkZWZhdWx0VmFyaWF0aW9uXG4gICAgZm9udHMgPSBmb250cy5tYXAoKGZvbnQpID0+IHtcbiAgICAgIGNvbnN0IHsgZm9udEZhbWlseSB9ID0gZm9udFxuICAgICAgbGV0IHZhcmlhdGlvbnMgPSBmb250LnZhcmlhdGlvbnNcblxuICAgICAgaWYgKGF2YWlsYWJsZVZhcmlhdGlvbnMpIHtcbiAgICAgICAgdmFyaWF0aW9ucyA9IHZhcmlhdGlvbnMuZmlsdGVyKHZhcmlhdGlvbiA9PlxuICAgICAgICAgIGF2YWlsYWJsZVZhcmlhdGlvbnMuaW5kZXhPZih2YXJpYXRpb24uaWRlbnRpZmllcikgIT09IC0xXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgaWYgKHZhcmlhdGlvbnMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbFxuXG4gICAgICBjb25zdCBmb250SW5zdGFuY2UgPSBuZXcgRm9udCh7XG4gICAgICAgIGZvbnRGYW1pbHlcbiAgICAgIH0pXG4gICAgICB2YXJpYXRpb25zID0gdmFyaWF0aW9uc1xuICAgICAgICAubWFwKHZhcmlhdGlvbiA9PiB7XG4gICAgICAgICAgY29uc3QgdmFyaWF0aW9uSW5zdGFuY2UgPSBuZXcgRm9udFZhcmlhdGlvbih2YXJpYXRpb24pXG4gICAgICAgICAgdmFyaWF0aW9uSW5zdGFuY2Uuc2V0Rm9udEZhbWlseShmb250RmFtaWx5KVxuICAgICAgICAgIHZhcmlhdGlvbkluc3RhbmNlLnNldEZvbnQoZm9udEluc3RhbmNlKVxuICAgICAgICAgIGlmICh2YXJpYXRpb24uZGVmYXVsdCAmJiAhZGVmYXVsdFZhcmlhdGlvbikge1xuICAgICAgICAgICAgZGVmYXVsdFZhcmlhdGlvbiA9IHZhcmlhdGlvbkluc3RhbmNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhcmlhdGlvbkluc3RhbmNlLmdldFRleHRNZXRyaWNzKCkgPT0gbnVsbCkge1xuICAgICAgICAgICAgTG9nLndhcm4oXG4gICAgICAgICAgICAgIGBNaXNzaW5nIGZvbnQgbWV0cmljcyBmb3IgJHt2YXJpYXRpb25JbnN0YW5jZS5nZXRJZGVudGlmaWVyKCl9LiBUaGUgU0RLIHdpbGwgZmFsbCBiYWNrIHRvIGJhc2ljIGZvbnQgcmVuZGVyaW5nLCB3aGljaCBtYXkgbGVhZCB0byBsYXlvdXQgaXNzdWVzLiBQbGVhc2UgcHJvdmlkZSBmb250IG1ldHJpY3MgZm9yIHlvdXIgY3VzdG9tIGZvbnRzLiBTZWUgaHR0cHM6Ly9kb2NzLnBob3RvZWRpdG9yc2RrLmNvbS9ndWlkZXMvaHRtbDUvIGZvciBtb3JlIGRldGFpbHMuYFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3ZhcmlhdGlvbnNCeUlkZW50aWZpZXJbdmFyaWF0aW9uSW5zdGFuY2UuZ2V0SWRlbnRpZmllcigpXSA9IHZhcmlhdGlvbkluc3RhbmNlXG4gICAgICAgICAgcmV0dXJuIHZhcmlhdGlvbkluc3RhbmNlXG4gICAgICAgIH0pXG4gICAgICBmb250SW5zdGFuY2Uuc2V0VmFyaWF0aW9ucyh2YXJpYXRpb25zKVxuICAgICAgdGhpcy5fZm9udHNCeUZvbnRGYW1pbHlbZm9udEZhbWlseV0gPSBmb250SW5zdGFuY2VcbiAgICAgIHJldHVybiBmb250SW5zdGFuY2VcbiAgICB9KS5maWx0ZXIoZiA9PiBmKVxuXG4gICAgaWYgKCFkZWZhdWx0VmFyaWF0aW9uKSB7XG4gICAgICBkZWZhdWx0VmFyaWF0aW9uID0gZm9udHNbMF0uZ2V0VmFyaWF0aW9ucygpWzBdXG4gICAgfVxuXG4gICAgdGhpcy5fZGVmYXVsdFZhcmlhdGlvbiA9IGRlZmF1bHRWYXJpYXRpb25cbiAgICB0aGlzLl9mb250cyA9IGZvbnRzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgYXZhaWxhYmxlIGZvbnRzXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLlVJLkRlc2t0b3BVSS5Gb250W119XG4gICAqL1xuICBnZXRGb250cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZm9udCBmb3IgdGhlIGdpdmVuIGZvbnQgZmFtaWx5XG4gICAqIEBwYXJhbSAge1N0cmluZ30gZm9udEZhbWlseVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5VSS5EZXNrdG9wVUkuRm9udH1cbiAgICovXG4gIGdldEZvbnRCeUZvbnRGYW1pbHkgKGZvbnRGYW1pbHkpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udHNCeUZvbnRGYW1pbHlbZm9udEZhbWlseV1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmb250IHZhcmlhdGlvbiBmb3IgdGhlIGdpdmVuIGlkZW50aWZpZXJcbiAgICogQHBhcmFtICB7U3RyaW5nfSBpZGVudGlmaWVyXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLlVJLkRlc2t0b3BVSS5Gb250VmFyaWF0aW9ufVxuICAgKi9cbiAgZ2V0VmFyaWF0aW9uQnlJZGVudGlmaWVyIChpZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhcmlhdGlvbnNCeUlkZW50aWZpZXJbaWRlbnRpZmllcl1cbiAgfVxuXG4gIGdldFZhcmlhdGlvbnNCeUlkZW50aWZpZXIgKCkge1xuICAgIHJldHVybiB7Li4udGhpcy5fdmFyaWF0aW9uc0J5SWRlbnRpZmllcn1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhcmlhdGlvblxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5VSS5EZXNrdG9wVUkuRm9udFZhcmlhdGlvbn1cbiAgICovXG4gIGdldERlZmF1bHRWYXJpYXRpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWZhdWx0VmFyaWF0aW9uXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvanMvc2hhcmVkL21hbmFnZXJzL2ZvbnQtbWFuYWdlci5qcyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xNl9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIHtcInJvb3RcIjpcIlJlYWN0XCIsXCJjb21tb25qczJcIjpcInJlYWN0XCIsXCJjb21tb25qc1wiOlwicmVhY3RcIixcImFtZFwiOlwicmVhY3RcIn1cbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vc2RrL2NvcmUvbGliL3V0aWxzJ1xuXG5cbmNvbnN0IGRlZmF1bHRMZXZlbHMgPSBbXG4gIHsgbmFtZTogJ3RyYWNlJywgdHlwZTogJ3RyYWNlJywgYmFja2dyb3VuZDogJyNFRUVFRUUnLCBjb2xvcjogJyNBQUFBQUEnIH0sXG4gIHsgbmFtZTogJ2luZm8nLCB0eXBlOiAnbG9nJywgYmFja2dyb3VuZDogJyNCREU1RjgnLCBjb2xvcjogJyMwMDUyOUInIH0sXG4gIHsgbmFtZTogJ3dhcm4nLCB0eXBlOiAnd2FybicsIGJhY2tncm91bmQ6ICcjRkVFRkIzJywgY29sb3I6ICcjOUY2MDAwJyB9LFxuICB7IG5hbWU6ICdlcnJvcicsIHR5cGU6ICdlcnJvcicsIGJhY2tncm91bmQ6ICcjRkZCQUJBJywgY29sb3I6ICcjRDgwMDBDJyB9LFxuICB7IG5hbWU6ICdsb2cnLCB0eXBlOiAnbG9nJywgYmFja2dyb3VuZDogJyNFRUVFRUUnLCBjb2xvcjogJyMxZjRmNmInIH1cbl1cblxuY29uc3QgaGFzQ29uc29sZUdyb3VwcyA9ICgpID0+IGNvbnNvbGUgJiYgY29uc29sZS5ncm91cCAmJiBjb25zb2xlLmdyb3VwQ29sbGFwc2VkICYmIGNvbnNvbGUuZ3JvdXBFbmRcblxuY29uc3QgaGFzQ29sb3JPdXRwdXQgPSAoKSA9PlxuICAoIXByb2Nlc3MgfHwgKHByb2Nlc3MgJiYgcHJvY2Vzcy5icm93c2VyKSkgJiZcbiAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvR2Vja298V2ViS2l0L2kpICYmXG4gICAgIW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1RyaWRlbnQvKSlcblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGdldExvZ1N0eWxlcyA9IChiYWNrZ3JvdW5kLCBjb2xvcikgPT4gW1xuICAnYmFja2dyb3VuZDogIzJEN0JGRjsgbGluZS1oZWlnaHQ6IDIwcHg7IHBhZGRpbmc6IDRweCAwJyxcbiAgJ2JhY2tncm91bmQ6ICMyQjJCMkI7IGNvbG9yOiB3aGl0ZTsgbGluZS1oZWlnaHQ6IDIwcHg7IHBhZGRpbmc6IDRweCAwJyxcbiAgJ2JhY2tncm91bmQ6ICMyRDdCRkY7IGxpbmUtaGVpZ2h0OiAyMHB4OyBwYWRkaW5nOiA0cHggMCcsXG4gIGBiYWNrZ3JvdW5kOiAke2JhY2tncm91bmR9OyBjb2xvcjogJHtjb2xvcn07IGxpbmUtaGVpZ2h0OiAyMHB4OyBwYWRkaW5nOiA0cHggMDsgZm9udC13ZWlnaHQ6IGJvbGRgLFxuICAnYmFja2dyb3VuZDogIzJCMkIyQjsgY29sb3I6IHdoaXRlOyBsaW5lLWhlaWdodDogMjBweDsgcGFkZGluZzogNHB4IDAnLFxuICAnYmFja2dyb3VuZDogIzJEN0JGRjsgbGluZS1oZWlnaHQ6IDIwcHg7IHBhZGRpbmc6IDRweCAwJyxcbl1cbi8qIGVzbGludC1lbmFibGUgKi9cblxuZXhwb3J0IGNsYXNzIExvZ2dlciB7XG4gIGNvbnN0cnVjdG9yIChtYXhMZXZlbCA9ICd3YXJuJywgbGV2ZWxzID0gZGVmYXVsdExldmVscykge1xuICAgIHRoaXMuX2xldmVscyA9IFsuLi5sZXZlbHNdXG4gICAgdGhpcy5fbWF4TGV2ZWwgPSB0aGlzLmdldExldmVsSW5kZXhCeU5hbWUobWF4TGV2ZWwpXG5cbiAgICB0aGlzLl9jb25zb2xlRnVuY3MgPSB7XG4gICAgICB0cmFjZTogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGhhc0NvbnNvbGVHcm91cHMoKSkge1xuICAgICAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoLi4uYXJncylcbiAgICAgICAgICBjb25zb2xlLnRyYWNlKClcbiAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLnRyYWNlKC4uLmFyZ3MpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9sZXZlbHMuZm9yRWFjaCgoeyBuYW1lIH0pID0+IHtcbiAgICAgIHRoaXNbbmFtZV0gPSAodGFnLCAuLi5hcmdzKSA9PiB7IHRoaXMuX2xvZyhuYW1lLCB0YWcsIC4uLmFyZ3MpIH1cbiAgICB9KVxuICB9XG5cbiAgZ2V0TGV2ZWxJbmRleEJ5TmFtZSAobGV2ZWxOYW1lKSB7XG4gICAgcmV0dXJuIFV0aWxzLkFycmF5LmZpbmRJbmRleCh0aGlzLl9sZXZlbHMsIGwgPT4gbC5uYW1lID09PSBsZXZlbE5hbWUpXG4gIH1cblxuICBnZXRMZXZlbE9iamVjdEJ5TmFtZSAobGV2ZWxOYW1lKSB7XG4gICAgcmV0dXJuIFV0aWxzLkFycmF5LmZpbmQodGhpcy5fbGV2ZWxzLCBsID0+IGwubmFtZSA9PT0gbGV2ZWxOYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gbG9nIGxldmVsIGlzIGN1cnJlbnRseSBlbmFibGVkIG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxldmVsTmFtZVxuICAgKi9cbiAgY2FuTG9nIChsZXZlbE5hbWUpIHtcbiAgICBjb25zdCBsZXZlbCA9IHRoaXMuZ2V0TGV2ZWxJbmRleEJ5TmFtZShsZXZlbE5hbWUpXG5cbiAgICBpZiAobGV2ZWwgPCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gbGV2ZWwgPj0gdGhpcy5fbWF4TGV2ZWxcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IGxvZyBsZXZlbC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxldmVsTmFtZVxuICAgKiBAbWVtYmVyb2YgTG9nZ2VyXG4gICAqL1xuICBzZXRMZXZlbCAobGV2ZWxOYW1lKSB7XG4gICAgY29uc3QgbGV2ZWwgPSB0aGlzLmdldExldmVsSW5kZXhCeU5hbWUobGV2ZWxOYW1lKVxuXG4gICAgaWYgKGxldmVsIDwgMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fbWF4TGV2ZWwgPSBsZXZlbFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlbnRyeSBpbiB0aGUgY29uc29sZS4gVGhlIHNwZWNpZmljIGNvbnNvbGUgbWV0aG9kIGlzIGRldGVybWluZWRcbiAgICogYnkgdGhlIGxldmVsIGBsZXZlbE5hbWVgLiBJZiBjb2xvciBpcyBhdmFpbGFibGUsIHVzZSBjb2xvcml6ZWQgb3V0cHV0LiBJZlxuICAgKiBtb3JlIHRoYW4gb25lIGFyZ3VtZW50IGlzIHN1cHBsaWVkIGluIGBhcmdzYCwgYSBjb25zb2xlIGdyb3VwIGlzIGNyZWF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbE5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRhZ1xuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGFyZ3NcbiAgICpcbiAgICovXG4gIF9sb2cgKGxldmVsTmFtZSwgdGFnLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgbGV2ZWwgPSB0aGlzLmdldExldmVsT2JqZWN0QnlOYW1lKGxldmVsTmFtZSlcblxuICAgIGlmICghbGV2ZWwgfHwgIXRoaXMuY2FuTG9nKGxldmVsTmFtZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHsgbmFtZSwgdHlwZSwgYmFja2dyb3VuZCwgY29sb3IgfSA9IGxldmVsXG5cbiAgICBjb25zdCBvdXRwdXRzID0gYXJncy5maWx0ZXIoYXJnID0+IGFyZyAhPT0gdW5kZWZpbmVkKS5tYXAoYXJnID0+IHtcbiAgICAgIGlmIChhcmcudG9PYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYXJnLnRvT2JqZWN0KCkpKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJnXG4gICAgfSlcblxuICAgIGxldCBjb25zb2xlRnVuYyA9IHRoaXMuX2NvbnNvbGVGdW5jc1t0eXBlXSB8fCBjb25zb2xlW3R5cGVdID8gKC4uLmFyZ3MpID0+IGNvbnNvbGVbdHlwZV0oLi4uYXJncykgOiAoLi4uYXJncykgPT4gY29uc29sZS5sb2coLi4uYXJncylcbiAgICBsZXQgb3V0cHV0c0xlbiA9IG91dHB1dHMubGVuZ3RoXG4gICAgbGV0IHN0eWxlcyA9IGdldExvZ1N0eWxlcyhiYWNrZ3JvdW5kLCBjb2xvcilcblxuICAgIGlmICghaGFzQ29sb3JPdXRwdXQoKSkge1xuICAgICAgY29uc3Qgb3V0cHV0c0xlbiA9IG91dHB1dHMubGVuZ3RoXG4gICAgICBpZiAob3V0cHV0c0xlbiA8PSAwKSB7XG4gICAgICAgIGNvbnNvbGVGdW5jKGBQaG90b0VkaXRvclNESyB8ICR7dGFnfSBgKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKG91dHB1dHNMZW4gPT09IDEgJiYgdHlwZW9mIG91dHB1dHNbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnNvbGVGdW5jKGBQaG90b0VkaXRvclNESyB8ICR7dGFnfSB8ICR7b3V0cHV0c1swXX1gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc29sZUZ1bmMoYFBob3RvRWRpdG9yU0RLIHwgJHt0YWd9IHwgYCwgLi4ub3V0cHV0cylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChvdXRwdXRzTGVuIDw9IDApIHtcbiAgICAgIGNvbnNvbGVGdW5jKGAlYyAgJWMgUGhvdG9FZGl0b3JTREsgJWMgICVjICR7dGFnfSAlYyAlYyAgYCwgLi4uc3R5bGVzKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKG91dHB1dHNMZW4gPT09IDEgJiYgdHlwZW9mIG91dHB1dHNbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zb2xlRnVuYyhgJWMgICVjIFBob3RvRWRpdG9yU0RLICVjICAlYyAke3RhZ30gJWMgICR7b3V0cHV0c1swXX0gICVjICBgLCAuLi5zdHlsZXMpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCB0cnkgdG8gZ3JvdXAgdGhlIGxvZ1xuICAgIGlmIChoYXNDb25zb2xlR3JvdXBzKCkpIHtcbiAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoYCVjICAlYyBQaG90b0VkaXRvclNESyAlYyAgJWMgJHt0YWd9ICVjYCwgLi4uVXRpbHMuQXJyYXkuaW5pdChzdHlsZXMpKVxuICAgICAgY29uc29sZUZ1bmMoLi4ub3V0cHV0cylcbiAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlRnVuYyhgJWMgICVjIFBob3RvRWRpdG9yU0RLICVjICAlYyAke3RhZ30gJWNgLCAuLi5VdGlscy5BcnJheS5pbml0KHN0eWxlcyksIC4uLm91dHB1dHMpXG4gICAgfVxuXG4gIH1cblxuICAvKipcbiAgICogTG9ncyBhbiBpbWFnZSBpbnRvIHRoZSBicm93c2VyJ3MgY29uc29sZS4gRG9lc1xuICAgKiBub3RoaW5nIGluIGEgbm9kZSBlbnZpcm9ubWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXN8c3RyaW5nfSBzb3VyY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICAgKi9cbiAgaW1hZ2UgKHRhZyA9ICcnLCBzb3VyY2UpIHtcbiAgICBsZXQgaW1hZ2UgPSBuZXcgd2luZG93LkltYWdlKClcblxuICAgIGNvbnN0IG9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2Uud2lkdGhcbiAgICAgIGNvbnN0IGhlaWdodCA9IGltYWdlLmhlaWdodFxuICAgICAgdGFnICYmIGNvbnNvbGUubG9nKHRhZylcbiAgICAgIGNvbnNvbGUubG9nKGAlYytgLCBgXG4gICAgICAgIGZvbnQtc2l6ZTogMXB4O1xuICAgICAgICBwYWRkaW5nOiAwcHggJHtNYXRoLmZsb29yKHdpZHRoIC8gMil9cHg7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAke2hlaWdodH1weDtcbiAgICAgICAgYmFja2dyb3VuZDogdXJsKCR7aW1hZ2Uuc3JjfSk7XG4gICAgICAgIGNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbiAgICAgICAgYmFja2dyb3VuZC1zaXplOiAke3dpZHRofXB4ICR7aGVpZ2h0fXB4O2ApXG4gICAgfVxuXG4gICAgaW1hZ2Uub25sb2FkID0gb25sb2FkXG5cbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2Ygd2luZG93LkhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICBpbWFnZS5zcmMgPSBzb3VyY2UudG9EYXRhVVJMKClcbiAgICB9IGVsc2UgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIHdpbmRvdy5JbWFnZSkge1xuICAgICAgaW1hZ2UgPSBzb3VyY2VcbiAgICAgIG9ubG9hZCgpXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgaW1hZ2Uuc3JjID0gc291cmNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nKHRhZywgc291cmNlKVxuICAgIH1cbiAgICByZXR1cm4gaW1hZ2VcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGEgYFBob3RvRWRpdG9yU0RLLkVuZ2luZS5UZXh0dXJlYCBpbnRvIHRoZSBicm93c2VyJ3MgY29uc29sZS4gRG9lc1xuICAgKiBub3RoaW5nIGluIGEgbm9kZSBlbnZpcm9ubWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZWB9IHRleHR1cmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICAgKlxuICAgKi9cbiAgdGV4dHVyZSAodGFnID0gJycsIHRleHR1cmUpIHtcbiAgICBpZiAoIXRleHR1cmUpIHtcbiAgICAgIHRoaXMubG9nKHRhZywgJ3RleHR1cmU6IG51bGwgb3IgdW5kZWZpbmVkJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGJhc2VUZXh0dXJlID0gdGV4dHVyZS5nZXRCYXNlVGV4dHVyZSgpXG4gICAgbGV0IHJlbmRlcmVycyA9IGJhc2VUZXh0dXJlLmdldFJlbmRlcmVycygpXG5cbiAgICBsZXQgZ2xSZW5kZXJlciA9IFV0aWxzLkFycmF5LmZpbmQocmVuZGVyZXJzLCByID0+IHIgJiYgci5jb25zdHJ1Y3Rvci50eXBlID09PSAnV2ViR0wnKVxuXG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBiYXNlVGV4dHVyZS5nZXRGcmFtZSgpXG5cbiAgICBpZiAoZ2xSZW5kZXJlcikge1xuICAgICAgY29uc3QgZ2wgPSBnbFJlbmRlcmVyLmdldENvbnRleHQoKVxuICAgICAgY29uc3QgZ2xUZXh0dXJlID0gYmFzZVRleHR1cmUuZ2V0R0xUZXh0dXJlRm9yUmVuZGVyZXIoZ2xSZW5kZXJlcilcbiAgICAgIHRoaXMubG9nR2xUZXh0dXJlKGdsLCBnbFRleHR1cmUsIHdpZHRoLCBoZWlnaHQsIHRhZylcbiAgICB9IGVsc2Uge1xuICAgICAgTG9nLmltYWdlKHRhZywgYmFzZVRleHR1cmUuZ2V0U291cmNlKCkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgYSBXZWJHTFRleHR1cmUgaW50byB0aGUgYnJvd3NlcidzIGNvbnNvbGUuIERvZXNcbiAgICogbm90aGluZyBpbiBhIG5vZGUgZW52aXJvbm1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4dHVyZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPTE1MF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9MTUwXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gICAqL1xuICBsb2dHbFRleHR1cmUgKGdsLCB0ZXh0dXJlLCB3aWR0aCA9IDE1MCwgaGVpZ2h0ID0gMTUwLCB0YWcpIHtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKVxuICAgIGxldCBmcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKClcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKVxuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMClcblxuICAgIC8vIFJlYWQgdGhlIGNvbnRlbnRzIG9mIHRoZSBmcmFtZWJ1ZmZlclxuICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KVxuICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgZGF0YSlcblxuICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKVxuXG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aFxuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHRcblxuICAgIGxldCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcblxuICAgIC8vIENvcHkgdGhlIHBpeGVscyB0byBhIDJEIGNhbnZhc1xuICAgIGxldCBpbWFnZURhdGEgPSBjb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KVxuICAgIGltYWdlRGF0YS5kYXRhLnNldChkYXRhKVxuICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMClcblxuICAgIHJldHVybiBMb2cuaW1hZ2UodGFnLCBjYW52YXMpXG4gIH1cbn1cblxuY29uc3QgTG9nID0gbmV3IExvZ2dlcignd2FybicpXG5cbmV4cG9ydCBkZWZhdWx0IExvZ1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zaGFyZWQvbG9nLmpzIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogZ2xvYmFsIFhNTEh0dHBSZXF1ZXN0ICovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBQcm9taXNlIGZyb20gJy4uL3ZlbmRvci9wcm9taXNlJ1xuaW1wb3J0IFVSTCBmcm9tICd1cmwnXG5cbmNvbnN0IFRJTUVPVVQgPSA1MDAwXG5cbmNvbnN0IHJvb3QgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpID8gd2luZG93IDogZ2xvYmFsXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEpTT05Mb2FkZXIge1xuICBjb25zdHJ1Y3RvciAodXJsKSB7XG4gICAgdGhpcy5fdXJsID0gdXJsXG4gICAgdGhpcy5fcGFyc2VkVXJsID0gVVJMLnBhcnNlKHRoaXMuX3VybCwgdHJ1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyByZXF1ZXN0IGlzIGEgSlNPTlAgcmVxdWVzdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgX2lzSlNPTlBSZXF1ZXN0ICgpIHtcbiAgICBjb25zdCB7IHF1ZXJ5IH0gPSB0aGlzLl9wYXJzZWRVcmxcbiAgICBmb3IgKGxldCBrZXkgaW4gcXVlcnkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcXVlcnlba2V5XVxuICAgICAgaWYgKHZhbHVlID09PSAnPycpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgdGhlIEpTT04oUCkgZnJvbSB0aGUgZ2l2ZW4gVVJMXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBsb2FkICgpIHtcbiAgICBpZiAodGhpcy5faXNKU09OUFJlcXVlc3QoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWRKU09OUCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkSlNPTigpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBVUkwgYXMgSlNPTlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgX2xvYWRKU09OICgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHhoclxuICAgICAgaWYgKHJvb3QuWERvbWFpblJlcXVlc3QpIHtcbiAgICAgICAgeGhyID0gbmV3IHJvb3QuWERvbWFpblJlcXVlc3QoKVxuXG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dClcbiAgICAgICAgICByZXNvbHZlKGpzb24pXG4gICAgICAgIH1cbiAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJlamVjdChlKVxuICAgICAgICB9XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCB0aGlzLl91cmwsIHRydWUpXG4gICAgICAgIHhoci5zZW5kKClcbiAgICAgIH0gZWxzZSBpZiAocm9vdC5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAob0V2ZW50KSB7XG4gICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpXG4gICAgICAgICAgICAgIHJlc29sdmUoanNvbilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEhUVFAgU3RhdHVzICR7eGhyLnN0YXR1c31gKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHRoaXMuX3VybCwgdHJ1ZSlcbiAgICAgICAgeGhyLnNlbmQoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgdGhlIFVSTCBhcyBKU09OUFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgX2xvYWRKU09OUCAoKSB7XG4gICAgbGV0IGZhaWxlZCA9IGZhbHNlXG4gICAgbGV0IHN1Y2NlZWRlZCA9IGZhbHNlXG5cbiAgICBjb25zdCBmbk5hbWUgPSAncGVzZGsnICsgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogOTk5OTk5OTk5OTk5OTkpXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9jcmVhdGVKU09OUE5vZGUoZm5OYW1lKVxuICAgICAgcm9vdFtmbk5hbWVdID0gKHJlc3VsdCkgPT4ge1xuICAgICAgICB0aGlzLl9yZW1vdmVKU09OUE5vZGUobm9kZSlcbiAgICAgICAgaWYgKCFmYWlsZWQpIHtcbiAgICAgICAgICBzdWNjZWVkZWQgPSB0cnVlXG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcm9vdC5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKCFzdWNjZWVkZWQpIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVKU09OUE5vZGUobm9kZSlcbiAgICAgICAgICBmYWlsZWQgPSB0cnVlXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVGltZW91dCBvZiA1IHNlY29uZHMgZXhjZWVkZWQuJykpXG4gICAgICAgIH1cbiAgICAgIH0sIFRJTUVPVVQpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgSlNPTlAgPHNjcmlwdD4gbm9kZSBpbnNpZGUgdGhlIDxoZWFkPiBlbGVtZW50XG4gICAqIEBwYXJhbSAge1N0cmluZ30gZm5OYW1lXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlSlNPTlBOb2RlIChmbk5hbWUpIHtcbiAgICBjb25zdCBKU09OUFVybCA9IHRoaXMuX2J1aWxkSlNPTlBVcmwoZm5OYW1lKVxuICAgIGNvbnN0IGhlYWROb2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpXG4gICAgY29uc3Qgc2NyaXB0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG4gICAgc2NyaXB0Tm9kZS5zcmMgPSBKU09OUFVybFxuICAgIGhlYWROb2RlLmFwcGVuZENoaWxkKHNjcmlwdE5vZGUpXG4gICAgcmV0dXJuIHNjcmlwdE5vZGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBKU09OUCA8c2NyaXB0PiBub2RlIGZyb20gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW1vdmVKU09OUE5vZGUgKG5vZGUpIHtcbiAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBKU09OUCB1cmwgZm9yIHRoZSBnaXZlbiBmdW5jdGlvbiBuYW1lXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZm5OYW1lXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIF9idWlsZEpTT05QVXJsIChmbk5hbWUpIHtcbiAgICAvLyBGaW5kIEpTT05QIHBhcmFtZXRlclxuICAgIGNvbnN0IHsgcXVlcnkgfSA9IHRoaXMuX3BhcnNlZFVybFxuICAgIGxldCBwYXJhbWV0ZXIgPSBudWxsXG4gICAgZm9yIChsZXQgcGFyYW0gaW4gcXVlcnkpIHtcbiAgICAgIGlmIChxdWVyeVtwYXJhbV0gPT09ICc/Jykge1xuICAgICAgICBwYXJhbWV0ZXIgPSBwYXJhbVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLl9wYXJzZWRVcmwuc2VhcmNoXG4gICAgcXVlcnlbcGFyYW1ldGVyXSA9IGZuTmFtZVxuXG4gICAgcmV0dXJuIFVSTC5mb3JtYXQodGhpcy5fcGFyc2VkVXJsKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9sb2FkZXJzL2pzb24tbG9hZGVyLmpzIiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBicmFjZS1zdHlsZSAqL1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbG9hZCAodXJsLCBjcm9zc09yaWdpbiA9IHsgY29yczogdHJ1ZSwgdmFsdWU6ICdhbm9ueW1vdXMnIH0pIHtcbiAgICBjb25zdCBsb2FkUHJvbWlzZSA9ICgpID0+IHtcbiAgICAgIGlmICh1cmwuc3Vic3RyKDAsIDUpID09PSAnZGF0YTonIHx8IHR5cGVvZiBXRUJQQUNLICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFt1cmwsIHVybF0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvYWRQcm9taXNlKClcbiAgICAgIC50aGVuKChbb3JpZ2luYWxTcmMsIHNyY10pID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUFuZExvYWRJbWFnZShvcmlnaW5hbFNyYywgc3JjLCBjcm9zc09yaWdpbilcbiAgICAgIH0pXG4gIH0sXG5cbiAgX2NyZWF0ZUFuZExvYWRJbWFnZSAob3JpZ2luYWxTcmMsIHNyYywgY3Jvc3NPcmlnaW4gPSB7IGNvcnM6IHRydWUsIHZhbHVlOiAnYW5vbnltb3VzJyB9KSB7XG4gICAgaWYgKHR5cGVvZiBXRUJQQUNLICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgd2luZG93LkltYWdlKClcbiAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKGltYWdlKVxuICAgICAgICB9KVxuICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBpbWFnZSBhdCAke3NyY31gKSlcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoY3Jvc3NPcmlnaW4uY29ycykge1xuICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW4udmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIGltYWdlLnNyYyA9IHNyY1xuICAgICAgfSlcbiAgICB9XG5cbiAgfSxcblxuICBsb2FkWEhSICh1cmwsIG1pbWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHhoclxuICAgICAgaWYgKHdpbmRvdy5YRG9tYWluUmVxdWVzdCkge1xuICAgICAgICB4aHIgPSBuZXcgd2luZG93LlhEb21haW5SZXF1ZXN0KClcbiAgICAgICAgaWYgKG1pbWUpIHhoci5vdmVycmlkZU1pbWVUeXBlKG1pbWUpXG5cbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXNvbHZlKHhocilcbiAgICAgICAgfVxuICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgIHhociA9IG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKVxuICAgICAgICBpZiAobWltZSkgeGhyLm92ZXJyaWRlTWltZVR5cGUobWltZSlcblxuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKG9FdmVudCkge1xuICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICByZXNvbHZlKHhocilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEhUVFAgU3RhdHVzICR7eGhyLnN0YXR1c31gKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSlcbiAgICAgIHhoci5zZW5kKClcbiAgICB9KVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9sb2FkZXJzL2ltYWdlLWxvYWRlci5qcyIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFByb3BUeXBlcywgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3dDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fYmluZEFsbCgnX29uQ2xpY2snKVxuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYnV0dG9uXG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25DbGljayAoZSkge1xuICAgIHRoaXMucHJvcHMub25DbGljayAmJiB0aGlzLnByb3BzLm9uQ2xpY2soKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyByb3cncyBjb250ZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyQ29udGVudCAoKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBsZXQgcm93QkVNID0gYCRlOnJvdyBtOiR7dGhpcy5fbW9kaWZpZXJ9YFxuICAgIGlmICh0aGlzLnByb3BzLnRvdGFsUm93cykge1xuICAgICAgcm93QkVNICs9IGAgbTpyb3ctJHt0aGlzLnByb3BzLnRvdGFsUm93c31gXG4gICAgfVxuXG4gICAgcmV0dXJuICg8YmVtIHNwZWNpZmllcj0nYjpzcGxhc2hTY3JlZW4nPlxuICAgICAgPGRpdiBiZW09e3Jvd0JFTX0+XG4gICAgICAgIHt0aGlzLl9yZW5kZXJDb250ZW50KCl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2JlbT4pXG4gIH1cbn1cblxuUm93Q29tcG9uZW50LnByb3BUeXBlcyA9IHtcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmNcbn1cblxuUm93Q29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL3NjcmVlbnMvc3BsYXNoL3Jvdy1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IEZpbGVMb2FkZXIgZnJvbSAnc2hhcmVkL2xvYWRlcnMvZmlsZS1sb2FkZXInXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludmlzaWJsZVVwbG9hZENvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbk5ld0ZpbGUnXG4gICAgKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHRoaXMuX2ZpbGVMb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLnJlZnMuZmlsZUlucHV0KVxuICAgIHRoaXMuX2ZpbGVMb2FkZXIub24oJ2ZpbGUnLCB0aGlzLl9vbk5ld0ZpbGUpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyBhYm91dCB0byBiZSB1bm1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50ICgpIHtcbiAgICB0aGlzLl9maWxlTG9hZGVyLm9mZignZmlsZScsIHRoaXMuX29uTmV3RmlsZSlcbiAgICB0aGlzLl9maWxlTG9hZGVyLmRpc3Bvc2UoKVxuICAgIHRoaXMuX2ZpbGVMb2FkZXIgPSBudWxsXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgRmlsZUxvYWRlciBlbWl0cyBhIG5ldyBmaWxlXG4gICAqIEBwYXJhbSAge0ZpbGV9IGZpbGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk5ld0ZpbGUgKGZpbGUpIHtcbiAgICB0aGlzLnByb3BzLm9uTmV3RmlsZSAmJlxuICAgICAgdGhpcy5wcm9wcy5vbk5ld0ZpbGUoZmlsZSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFBVQkxJQyBBUElcblxuICAvKipcbiAgICogUHVibGljIG1ldGhvZCBmb3Igb3BlbmluZyB0aGUgZmlsZSBsb2FkZXJcbiAgICovXG4gIG9wZW4gKCkge1xuICAgIHRoaXMuX2ZpbGVMb2FkZXIub3BlbigpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgcmV0dXJuIDxpbnB1dCB0eXBlPSdmaWxlJyBhY2NlcHQ9J2ltYWdlLyonIGJlbT0nYjpoaWRkZW5GaWxlSW5wdXQnIHJlZj0nZmlsZUlucHV0JyAvPlxuICB9XG59XG5cbkludmlzaWJsZVVwbG9hZENvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9zaGFyZWQvaW52aXNpYmxlLXVwbG9hZC1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb3BCYXJCdXR0b25Db21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIC8vIEJ1aWxkIEJFTSBzcGVjaWZpZXJcbiAgICBsZXQgYmVtID0gJyRlOmJ1dHRvbidcbiAgICBpZiAodGhpcy5wcm9wcy5zdHlsZSkge1xuICAgICAgYmVtICs9IGAgbToke3RoaXMucHJvcHMuc3R5bGV9YFxuICAgIH1cbiAgICBpZiAodGhpcy5wcm9wcy5pY29uKSB7XG4gICAgICBiZW0gKz0gJyBtOndpdGhJY29uJ1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIGljb25cbiAgICBsZXQgaWNvbiA9IG51bGxcbiAgICBpZiAodGhpcy5wcm9wcy5pY29uKSB7XG4gICAgICBpY29uID0gKDxpbWdcbiAgICAgICAgYmVtPSdlOmljb24nXG4gICAgICAgIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKHRoaXMucHJvcHMuaWNvbiwgdHJ1ZSl9IC8+KVxuICAgIH1cblxuICAgIHJldHVybiAoPGJlbSBzcGVjaWZpZXI9JyRiOnRvcEJhcic+XG4gICAgICA8ZGl2IGJlbT17YmVtfSBvbkNsaWNrPXt0aGlzLnByb3BzLm9uQ2xpY2t9PlxuICAgICAgICB7aWNvbn1cbiAgICAgICAgPGRpdiBiZW09J2U6bGFiZWwnPnt0aGlzLnByb3BzLmxhYmVsIHx8ICdCdXR0b24nfTwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9iZW0+KVxuICB9XG59XG5cblRvcEJhckJ1dHRvbkNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9zaGFyZWQvdG9wLWJhci9idXR0b24tY29tcG9uZW50LmpzeCIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgU0RLLCBTaGFyZWRDb25zdGFudHMsIFV0aWxzLCBJbWFnZUxvYWRlciB9IGZyb20gJ2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbHRlck1hbmFnZXIge1xuICBjb25zdHJ1Y3RvciAodWksIG9wdGlvbnMpIHtcbiAgICB0aGlzLl91aSA9IHVpXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLl9jYXRlZ29yaWVzQnlJZCA9IHt9XG4gICAgdGhpcy5fZmlsdGVyc0J5SWRlbnRpZmllciA9IHtcbiAgICAgIGlkZW50aXR5OiBTREsuT3BlcmF0aW9ucy5GaWx0ZXJPcGVyYXRpb24uRmlsdGVycy5JZGVudGl0eUZpbHRlclxuICAgIH1cblxuICAgIHRoaXMuX2NhdGVnb3JpZXMgPSBTaGFyZWRDb25zdGFudHMuREVGQVVMVFMuRklMVEVSUy5zbGljZSgwKVxuXG4gICAgdGhpcy5faW5pdENhdGVnb3JpZXMoKVxuICB9XG5cbiAgaW5zdGFudGlhdGVGaWx0ZXJXaXRoSWRlbnRpZmllciAoaWRlbnRpZmllcikge1xuICAgIGNvbnN0IEZpbHRlciA9IHRoaXMuZ2V0RmlsdGVyQnlJZGVudGlmaWVyKGlkZW50aWZpZXIpXG4gICAgaWYgKCFGaWx0ZXIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYFVua25vd24gZmlsdGVyIHdpdGggaWRlbnRpZmllciBcXGAke2lkZW50aWZpZXJ9XFxgIWApKVxuICAgIH1cblxuICAgIGlmICghKEZpbHRlci5wcm90b3R5cGUgaW5zdGFuY2VvZiBTREsuT3BlcmF0aW9ucy5GaWx0ZXJPcGVyYXRpb24uRmlsdGVyKSkge1xuICAgICAgY29uc3QgeyBsdXRJbWFnZSwgcmVzb2x1dGlvbiwgaG9yaXpvbnRhbFRpbGVDb3VudCwgdmVydGljYWxUaWxlQ291bnQgfSA9IEZpbHRlclxuICAgICAgbGV0IHByZWxvYWRlZEltYWdlXG4gICAgICBpZiAodGhpcy5fdWkuZ2V0UHJlbG9hZGVyKSB7XG4gICAgICAgIHByZWxvYWRlZEltYWdlID0gdGhpcy5fdWkuZ2V0UHJlbG9hZGVyKCkuZ2V0QXNzZXQobHV0SW1hZ2UpXG4gICAgICB9XG4gICAgICBsZXQgbG9hZFByb21pc2VcbiAgICAgIGlmIChwcmVsb2FkZWRJbWFnZSkge1xuICAgICAgICBsb2FkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShwcmVsb2FkZWRJbWFnZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWRQcm9taXNlID0gSW1hZ2VMb2FkZXIubG9hZCh0aGlzLl91aS5nZXRBc3NldFBhdGgobHV0SW1hZ2UpKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9hZFByb21pc2VcbiAgICAgICAgLnRoZW4oaW1hZ2UgPT4ge1xuICAgICAgICAgIHJldHVybiBJbWFnZUxvYWRlci5sb2FkKHRoaXMuX3VpLmdldEFzc2V0UGF0aChsdXRJbWFnZSkpXG4gICAgICAgICAgICAudGhlbihpbWFnZSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgU0RLLk9wZXJhdGlvbnMuRmlsdGVyT3BlcmF0aW9uLkZpbHRlcnMuVGhyZWVETFVURmlsdGVyKHtcbiAgICAgICAgICAgICAgICBpbWFnZSwgcmVzb2x1dGlvbiwgaG9yaXpvbnRhbFRpbGVDb3VudCwgdmVydGljYWxUaWxlQ291bnRcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEZpbHRlcigpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY2F0ZWdvcmllc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRDYXRlZ29yaWVzICgpIHtcbiAgICAvLyBTaG91bGQgdGhlIGNhdGVnb3JpZXMgcGFzc2VkIGluIGJ5IHRoZSB1c2VyIHJlcGxhY2UgdGhlIGV4aXN0aW5nIG9uZXM/XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2F0ZWdvcmllcykge1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMucmVwbGFjZUNhdGVnb3JpZXMpIHtcbiAgICAgICAgdGhpcy5fY2F0ZWdvcmllcyA9IHRoaXMuX29wdGlvbnMuY2F0ZWdvcmllc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY2F0ZWdvcmllcyA9IFV0aWxzLm1lcmdlQ2F0ZWdvcmllcyhcbiAgICAgICAgICB0aGlzLl9jYXRlZ29yaWVzLFxuICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2F0ZWdvcmllcyxcbiAgICAgICAgICAnZmlsdGVycydcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBmaWx0ZXJzIHRoYXQgc2hvdWxkIG5vdCBiZSBzZWxlY3RhYmxlXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuYXZhaWxhYmxlRmlsdGVycykge1xuICAgICAgY29uc3QgbmV3Q2F0ZWdvcmllcyA9IFtdXG4gICAgICB0aGlzLl9jYXRlZ29yaWVzLmZvckVhY2goKGNhdGVnb3J5KSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbHRlcnMgPSBjYXRlZ29yeS5maWx0ZXJzLmZpbHRlcigoZikgPT5cbiAgICAgICAgICB0aGlzLl9vcHRpb25zLmF2YWlsYWJsZUZpbHRlcnMuaW5kZXhPZihmLmlkZW50aWZpZXIpICE9PSAtMVxuICAgICAgICApXG4gICAgICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBuZXdDYXRlZ29yaWVzLnB1c2goe1xuICAgICAgICAgICAgaWRlbnRpZmllcjogY2F0ZWdvcnkuaWRlbnRpZmllcixcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiBjYXRlZ29yeS5kZWZhdWx0TmFtZSxcbiAgICAgICAgICAgIGZpbHRlcnNcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdGhpcy5fY2F0ZWdvcmllcyA9IG5ld0NhdGVnb3JpZXNcbiAgICB9XG5cbiAgICBjb25zdCBhbGxDYXRlZ29yeSA9IHtcbiAgICAgIGlkZW50aWZpZXI6ICdhbGwnLFxuICAgICAgZGVmYXVsdE5hbWU6ICdBbGwnLFxuICAgICAgZmlsdGVyczogdGhpcy5fY2F0ZWdvcmllcy5sZW5ndGggPD0gMFxuICAgICAgICA/IFtdXG4gICAgICAgIDogdGhpcy5fY2F0ZWdvcmllc1xuICAgICAgICAgIC5tYXAoKGMpID0+IGMuZmlsdGVycylcbiAgICAgICAgICAucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSlcbiAgICB9XG4gICAgdGhpcy5fY2F0ZWdvcmllcy51bnNoaWZ0KGFsbENhdGVnb3J5KVxuICAgIHRoaXMuX2NhdGVnb3JpZXNCeUlkLmFsbCA9IGFsbENhdGVnb3J5XG4gICAgdGhpcy5fY2F0ZWdvcmllcy5mb3JFYWNoKChjKSA9PiB7IHRoaXMuX2NhdGVnb3JpZXNCeUlkW2MuaWRlbnRpZmllcl0gPSBjIH0pXG4gICAgYWxsQ2F0ZWdvcnkuZmlsdGVycy5mb3JFYWNoKGZpbHRlciA9PiB7XG4gICAgICB0aGlzLl9maWx0ZXJzQnlJZGVudGlmaWVyW2ZpbHRlci5pZGVudGlmaWVyXSA9IGZpbHRlclxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlsdGVycyBmb3IgdGhlIGNhdGVnb3J5IHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBjYXRlZ29yeUlkZW50aWZpZXJcbiAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAqL1xuICBnZXRGaWx0ZXJzRm9yQ2F0ZWdvcnkgKGNhdGVnb3J5SWRlbnRpZmllcikge1xuICAgIGlmICghdGhpcy5fY2F0ZWdvcmllc0J5SWRbY2F0ZWdvcnlJZGVudGlmaWVyXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGZpbHRlciBjYXRlZ29yeSAnJHtjYXRlZ29yeUlkZW50aWZpZXJ9J2ApXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYXRlZ29yaWVzQnlJZFtjYXRlZ29yeUlkZW50aWZpZXJdLmZpbHRlcnNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaWx0ZXIgd2l0aCB0aGUgZ2l2ZW4gaWRlbnRpZmllclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGlkZW50aWZpZXJcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuRmlsdGVyfVxuICAgKi9cbiAgZ2V0RmlsdGVyQnlJZGVudGlmaWVyIChpZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbHRlcnNCeUlkZW50aWZpZXJbaWRlbnRpZmllcl1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjYXRlZ29yaWVzXG4gICAqIEByZXR1cm4ge09iamVjdFtdfVxuICAgKi9cbiAgZ2V0Q2F0ZWdvcmllcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhdGVnb3JpZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjYXRlZ29yeSB3aXRoIHRoZSBnaXZlbiBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gaWRlbnRpZmllclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRDYXRlZ29yeUJ5SWRlbnRpZmllciAoaWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLl9jYXRlZ29yaWVzQnlJZFtpZGVudGlmaWVyXVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9tYW5hZ2Vycy9maWx0ZXItbWFuYWdlci5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uLy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEl0ZW1Db21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25JdGVtRHJhZ1N0YXJ0JyxcbiAgICAgICdfb25JdGVtRHJhZ1N0b3AnLFxuICAgICAgJ19vbkl0ZW1EcmFnJyxcbiAgICAgICdfb25TcHJpdGVVcGRhdGUnXG4gICAgKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gQ0FMQ1VMQVRJT05TXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBzcHJpdGVcbiAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRBYnNvbHV0ZVNwcml0ZVBvc2l0aW9uICgpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgb3V0cHV0RGltZW5zaW9ucyA9IGVkaXRvci5nZXRPdXRwdXREaW1lbnNpb25zKClcblxuICAgIHJldHVybiB0aGlzLnByb3BzLnNwcml0ZS5nZXRQb3NpdGlvbigpXG4gICAgICAuY2xvbmUoKVxuICAgICAgLm11bHRpcGx5KG91dHB1dERpbWVuc2lvbnMpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBMSUZFQ1lDTEVcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgc3VwZXIuY29tcG9uZW50RGlkTW91bnQoKVxuICAgIHRoaXMucHJvcHMuc3ByaXRlLm9uKCd1cGRhdGUnLCB0aGlzLl9vblNwcml0ZVVwZGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGlzIGFib3V0IHRvIGJlIHVubW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVubW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudFdpbGxVbm1vdW50KClcbiAgICB0aGlzLnByb3BzLnNwcml0ZS5vZmYoJ3VwZGF0ZScsIHRoaXMuX29uU3ByaXRlVXBkYXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgd2lsbCByZWNlaXZlIG5ldyBwcm9wc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IG5leHRQcm9wc1xuICAgKi9cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAobmV4dFByb3BzKSB7XG4gICAgdGhpcy5wcm9wcy5zcHJpdGUub2ZmKCd1cGRhdGUnLCB0aGlzLl9vblNwcml0ZVVwZGF0ZSlcbiAgICBuZXh0UHJvcHMuc3ByaXRlLm9uKCd1cGRhdGUnLCB0aGlzLl9vblNwcml0ZVVwZGF0ZSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50J3Mgc3ByaXRlIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblNwcml0ZVVwZGF0ZSAoKSB7XG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhpcyBpdGVtXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25JdGVtRHJhZ1N0YXJ0ICgpIHtcbiAgICBjb25zdCB7IHNwcml0ZSB9ID0gdGhpcy5wcm9wc1xuICAgIHRoaXMuX2luaXRpYWxQb3NpdGlvbiA9IHNwcml0ZS5nZXRQb3NpdGlvbigpXG5cbiAgICB0aGlzLnByb3BzLm9uRHJhZ1N0YXJ0ICYmIHRoaXMucHJvcHMub25EcmFnU3RhcnQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoaXMgaXRlbVxuICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBvZmZzZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkl0ZW1EcmFnIChvZmZzZXQpIHtcbiAgICBjb25zdCB7IHNwcml0ZSB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcblxuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSBlZGl0b3IuZ2V0T3V0cHV0RGltZW5zaW9ucygpXG4gICAgY29uc3QgbmV3UG9zaXRpb24gPSB0aGlzLl9pbml0aWFsUG9zaXRpb24uY2xvbmUoKVxuICAgICAgLmFkZChvZmZzZXQuZGl2aWRlKG91dHB1dERpbWVuc2lvbnMpKVxuXG4gICAgc3ByaXRlLnNldFBvc2l0aW9uKG5ld1Bvc2l0aW9uKVxuICAgIGVkaXRvci5yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhpcyBpdGVtXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25JdGVtRHJhZ1N0b3AgKCkge1xuICAgIHRoaXMucHJvcHMub25EcmFnU3RvcCAmJiB0aGlzLnByb3BzLm9uRHJhZ1N0b3AoKVxuICB9XG59XG5cbkl0ZW1Db21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvc3ByaXRlcy9pdGVtcy9pdGVtLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCwgVXRpbHMsIENvbnN0YW50cyB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgQ29sb3JQaWNrZXJPdmVybGF5Q29tcG9uZW50IGZyb20gJy4vb3ZlcmxheS1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbG9yUGlja2VyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5wcm9wcy5pbml0aWFsVmFsdWUuY2xvbmUoKVxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uQnV0dG9uQ2xpY2snLFxuICAgICAgJ19vblZhbHVlQ2hhbmdlJyxcbiAgICAgICdfb25Db2xvclBpY2tlck9wZW4nLFxuICAgICAgJ19vbkNvbG9yUGlja2VyQ2xvc2UnXG4gICAgKVxuXG4gICAgdGhpcy5fZXZlbnRzID0ge1xuICAgICAgW0NvbnN0YW50cy5FVkVOVFMuQ09MT1JQSUNLRVJfT1BFTl06IHRoaXMuX29uQ29sb3JQaWNrZXJPcGVuXG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG92ZXJsYXlWaXNpYmxlOiBmYWxzZVxuICAgIH1cblxuICAgIHRoaXMuX3RyYW5zcGFyZW50UGF0dGVybkNhbnZhcyA9IFV0aWxzLmNyZWF0ZVRyYW5zcGFyZW50UGF0dGVybkNhbnZhcygpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBMSUZFQ1lDTEVcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCB3aWxsIHJlY2VpdmUgbmV3IHByb3BzXG4gICAqIEBwYXJhbSAge09iamVjdH0gbmV4dFByb3BzXG4gICAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChuZXh0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLmluaXRpYWxWYWx1ZSAhPT0gdGhpcy5wcm9wcy5pbml0aWFsVmFsdWUpIHtcbiAgICAgIHRoaXMuX3ZhbHVlID0gbmV4dFByb3BzLmluaXRpYWxWYWx1ZS5jbG9uZSgpXG4gICAgICB0aGlzLl9yZW5kZXJDb2xvcigpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudERpZE1vdW50KClcbiAgICB0aGlzLl9yZW5kZXJDb2xvcigpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgYWZ0ZXIgdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gdXBkYXRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkVXBkYXRlICgpIHtcbiAgICB0aGlzLl9yZW5kZXJDb2xvcigpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhIGNvbG9ycGlja2VyIGhhcyBiZWVuIG9wZW5lZC4gSWYgaXQgaXMgbm90IHRoZSBzYW1lXG4gICAqIGNvbG9yIHBpY2tlciBhcyB0aGlzLCB0aGlzIG9uZSBnZXRzIGNsb3NlZC4gVGhpcyBtYWtlcyBzdXJlIHRoYXQgdGhlcmVcbiAgICogaXMgb25seSBvbmUgY29sb3IgcGlja2VyIG9wZW4gYXQgYSB0aW1lXG4gICAqIEBwYXJhbSAge0NvbG9yUGlja2VyQ29tcG9uZW50fSBjb2xvclBpY2tlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ29sb3JQaWNrZXJPcGVuIChjb2xvclBpY2tlcikge1xuICAgIGlmIChjb2xvclBpY2tlciA9PT0gdGhpcykgcmV0dXJuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IG92ZXJsYXlWaXNpYmxlOiBmYWxzZSB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGNvbG9yIHBpY2tlciBvdmVybGF5IHRyaWVzIHRvIGNsb3NlIGl0c2VsZlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ29sb3JQaWNrZXJDbG9zZSAoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IG92ZXJsYXlWaXNpYmxlOiBmYWxzZSB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGNvbG9yIHBpY2tlciBidXR0b24gaGFzIGJlZW4gY2xpY2tlZFxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQnV0dG9uQ2xpY2sgKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICBpZiAoIXRoaXMuc3RhdGUub3ZlcmxheVZpc2libGUpIHtcbiAgICAgIHRoaXMuX2VtaXRFdmVudChDb25zdGFudHMuRVZFTlRTLkNPTE9SUElDS0VSX09QRU4sIHRoaXMpXG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IG92ZXJsYXlWaXNpYmxlOiAhdGhpcy5zdGF0ZS5vdmVybGF5VmlzaWJsZSB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXNcbiAgICogQHBhcmFtICB7Q29sb3J9IHZhbHVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25WYWx1ZUNoYW5nZSAodmFsdWUpIHtcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlXG4gICAgdGhpcy5fcmVuZGVyQ29sb3IoKVxuICAgIHRoaXMuZm9yY2VVcGRhdGUoKVxuXG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZSAmJiB0aGlzLnByb3BzLm9uQ2hhbmdlKHZhbHVlKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGN1cnJlbnQgY29sb3Igb24gdGhlIHByZXZpZXcgY2FudmFzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyQ29sb3IgKCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMucmVmcy5jYW52YXNcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcblxuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5vZmZzZXRXaWR0aFxuICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMub2Zmc2V0SGVpZ2h0XG5cbiAgICBjb25zdCBwYXR0ZXJuID0gY29udGV4dC5jcmVhdGVQYXR0ZXJuKHRoaXMuX3RyYW5zcGFyZW50UGF0dGVybkNhbnZhcywgJ3JlcGVhdCcpXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBwYXR0ZXJuXG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuX3ZhbHVlLnRvUkdCQSgpXG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgbGV0IE92ZXJsYXkgPSBudWxsXG4gICAgaWYgKHRoaXMuc3RhdGUub3ZlcmxheVZpc2libGUpIHtcbiAgICAgIE92ZXJsYXkgPSAoPENvbG9yUGlja2VyT3ZlcmxheUNvbXBvbmVudFxuICAgICAgICBpbml0aWFsVmFsdWU9e3RoaXMuX3ZhbHVlfVxuICAgICAgICBvbkNoYW5nZT17dGhpcy5fb25WYWx1ZUNoYW5nZX1cbiAgICAgICAgb25DbG9zZT17dGhpcy5fb25Db2xvclBpY2tlckNsb3NlfVxuICAgICAgICBhbHBoYT17dGhpcy5wcm9wcy5hbHBoYX0gLz4pXG4gICAgfVxuXG4gICAgY29uc3QgY2xhc3NOYW1lID0gdGhpcy5zdGF0ZS5vdmVybGF5VmlzaWJsZSA/ICdpcy1hY3RpdmUnIDogbnVsbFxuXG4gICAgcmV0dXJuICg8YmVtIHNwZWNpZmllcj0nJGI6Y29udHJvbHMnPlxuICAgICAgPGRpdiBiZW09JyRiOmNvbG9yUGlja2VyJyBjbGFzc05hbWU9e2NsYXNzTmFtZX0gb25DbGljaz17dGhpcy5fb25CdXR0b25DbGlja30+XG4gICAgICAgIDxjYW52YXMgYmVtPSdlOnByZXZpZXcnIHJlZj0nY2FudmFzJyAvPlxuICAgICAgICA8ZGl2IGJlbT0nZTpsYWJlbCc+e3RoaXMucHJvcHMubGFiZWwgfHwgdGhpcy5fdCgncGVzZGsuY29tbW9uLnRleHQuY29sb3InKX08L2Rpdj5cbiAgICAgICAge092ZXJsYXl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2JlbT4pXG4gIH1cbn1cblxuQ29sb3JQaWNrZXJDb21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29sb3ItcGlja2VyL2NvbG9yLXBpY2tlci1jb21wb25lbnQuanN4IiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuaW1wb3J0IEdvb2dsZUZvbnRzTG9hZGVyIGZyb20gJy4vbG9hZGVycy9nb29nbGUtZm9udC1sb2FkZXInXG5pbXBvcnQgRmlsZUZvbnRzTG9hZGVyIGZyb20gJy4vbG9hZGVycy9maWxlLWZvbnQtbG9hZGVyJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb250TG9hZGVyIHtcbiAgY29uc3RydWN0b3IgKHVpLCBmb250cykge1xuICAgIHRoaXMuX3VpID0gdWlcbiAgICB0aGlzLl9mb250cyA9IGZvbnRzXG4gICAgdGhpcy5fbG9hZGVkRm9udHMgPSBbXVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZvbnRzXG4gICAqIEBwYXJhbSB7Rm9udFtdfSBmb250c1xuICAgKi9cbiAgc2V0Rm9udHMgKGZvbnRzKSB7XG4gICAgdGhpcy5fZm9udHMgPSBmb250c1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZm9udCBsb2FkZXIgbmVlZHMgdG8gbG9hZCBzb21ldGhpbmdcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIG5lZWRzVG9Mb2FkICgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2ZvbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgcHJvdmlkZXJcbiAgICAgIHRoaXMuX2ZvbnRzW2ldLmdldFZhcmlhdGlvbnMoKVxuICAgICAgICAuZm9yRWFjaCh2YXJpYXRpb24gPT4ge1xuICAgICAgICAgIHByb3ZpZGVyID0gcHJvdmlkZXIgfHwgdmFyaWF0aW9uLmdldFByb3ZpZGVyKClcbiAgICAgICAgfSlcbiAgICAgIGlmICghcHJvdmlkZXIpIGNvbnRpbnVlXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGZvbnQgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWRcbiAgICogQHBhcmFtICB7Rm9udH0gZm9udFxuICAgKi9cbiAgZm9udExvYWRlZCAoZm9udCkge1xuICAgIGNvbnN0IGlkZW50aWZpZXIgPSBmb250LmdldEZvbnRGYW1pbHkoKVxuICAgIHJldHVybiB0aGlzLl9sb2FkZWRGb250cy5pbmRleE9mKGlkZW50aWZpZXIpICE9PSAtMVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdpdmVuIGZvbnQgdG8gbG9hZGVkXG4gICAqIEBwYXJhbSB7Rm9udH0gZm9udFxuICAgKi9cbiAgc2V0Rm9udExvYWRlZCAoZm9udCkge1xuICAgIGlmICghdGhpcy5mb250TG9hZGVkKGZvbnQpKSB7XG4gICAgICBjb25zdCBpZGVudGlmaWVyID0gZm9udC5nZXRGb250RmFtaWx5KClcbiAgICAgIHRoaXMuX2xvYWRlZEZvbnRzLnB1c2goaWRlbnRpZmllcilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgdGhlIGdpdmVuIGZvbnRzXG4gICAqIEBwYXJhbSAge09iamVjdFtdfSBmb250c1xuICAgKi9cbiAgbG9hZCAoKSB7XG4gICAgY29uc3QgZm9udHMgPSB0aGlzLl9mb250c1xuICAgIGNvbnN0IGxvYWRlcnMgPSB7XG4gICAgICBnb29nbGU6IG5ldyBHb29nbGVGb250c0xvYWRlcih0aGlzLl91aSksXG4gICAgICBmaWxlOiBuZXcgRmlsZUZvbnRzTG9hZGVyKHRoaXMuX3VpKVxuICAgIH1cblxuICAgIGNvbnN0IGRpc3Bvc2VMb2FkZXJzID0gKCkgPT4ge1xuICAgICAgZm9yIChsZXQgaWRlbnRpZmllciBpbiBsb2FkZXJzKSB7XG4gICAgICAgIGNvbnN0IGxvYWRlciA9IGxvYWRlcnNbaWRlbnRpZmllcl1cbiAgICAgICAgbG9hZGVyLmRpc3Bvc2UoKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvbnRzXG4gICAgICAuZmlsdGVyKChmb250KSA9PiAhdGhpcy5mb250TG9hZGVkKGZvbnQpKVxuICAgICAgLmZvckVhY2goKGZvbnQpID0+IHtcbiAgICAgICAgZm9udC5nZXRWYXJpYXRpb25zKClcbiAgICAgICAgICAuZm9yRWFjaCh2YXJpYXRpb24gPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB2YXJpYXRpb24uZ2V0UHJvdmlkZXIoKVxuICAgICAgICAgICAgaWYgKCFwcm92aWRlcikgcmV0dXJuXG5cbiAgICAgICAgICAgIGNvbnN0IGxvYWRlciA9IGxvYWRlcnNbcHJvdmlkZXJdXG4gICAgICAgICAgICBsb2FkZXIuYWRkKHZhcmlhdGlvbilcbiAgICAgICAgICB9KVxuICAgICAgfSlcblxuICAgIGNvbnN0IHByb21pc2VzID0gW11cbiAgICBmb3IgKGxldCBuYW1lIGluIGxvYWRlcnMpIHtcbiAgICAgIHByb21pc2VzLnB1c2gobG9hZGVyc1tuYW1lXS5sb2FkKCkpXG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcylcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgZGlzcG9zZUxvYWRlcnMoKVxuICAgICAgICBmb250cy5mb3JFYWNoKChmb250KSA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRGb250TG9hZGVkKGZvbnQpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICBkaXNwb3NlTG9hZGVycygpXG4gICAgICAgIHRocm93IGVcbiAgICAgIH0pXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9mb250LWxvYWRlci9pbmRleC5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IFByZXZpb3VzU2VyaWFsaXplciBmcm9tICcuLi8xLjAuMS9zZXJpYWxpemVyJ1xuaW1wb3J0IEJsZW5kTW9kZXMgZnJvbSAnLi9ibGVuZC1tb2RlcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgdjIwMFNlcmlhbGl6ZXIgZXh0ZW5kcyBQcmV2aW91c1NlcmlhbGl6ZXIge1xuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gc3RpY2tlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbi5TdGlja2VyU3ByaXRlfSBzcHJpdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlcmlhbGl6ZVN0aWNrZXIgKG9wZXJhdGlvbiwgc3ByaXRlKSB7XG4gICAgY29uc3QgaW5wdXREaW1lbnNpb25zID0gb3BlcmF0aW9uLmdldElucHV0RGltZW5zaW9ucyhmYWxzZSlcbiAgICBjb25zdCByZXNwb25zZSA9IHN1cGVyLl9zZXJpYWxpemVTdGlja2VyKG9wZXJhdGlvbiwgc3ByaXRlKVxuXG4gICAgLy8gTmV3IGluIDIuMC4wOiBgdGludENvbG9yYFxuICAgIGlmIChzcHJpdGUuZ2V0VGludE1vZGUoKSAhPT0gJ25vbmUnKSB7XG4gICAgICByZXNwb25zZS5vcHRpb25zLnRpbnRDb2xvciA9IHNwcml0ZS5zZXJpYWxpemVPcHRpb24oJ3RpbnRDb2xvcicsIHRydWUpXG4gICAgfVxuXG4gICAgLy8gRGltZW5zaW9ucyBhcmUgcmVsYXRpdmUsIG5vdCBhYnNvbHV0ZSBhbnltb3JlXG4gICAgcmVzcG9uc2Uub3B0aW9ucy5kaW1lbnNpb25zID0gc3ByaXRlLmdldERpbWVuc2lvbnMoKS5jbG9uZSgpLmRpdmlkZShpbnB1dERpbWVuc2lvbnMubWluKCkpLnRvT2JqZWN0KClcblxuICAgIC8vIGBuYW1lYCBpcyBub3cgYGlkZW50aWZpZXJgXG4gICAgcmVzcG9uc2Uub3B0aW9ucy5pZGVudGlmaWVyID0gcmVzcG9uc2Uub3B0aW9ucy5uYW1lXG4gICAgZGVsZXRlIHJlc3BvbnNlLm9wdGlvbnMubmFtZVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gcGF0aFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbi5CcnVzaFNwcml0ZS5QYXRofSBwYXRoXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXJpYWxpemVQYXRoIChwYXRoKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBzdXBlci5fc2VyaWFsaXplUGF0aChwYXRoKVxuXG4gICAgY29uc3QgYnJ1c2ggPSBwYXRoLmdldEJydXNoKClcbiAgICBpZiAoYnJ1c2guaGFzT3B0aW9uKCdoYXJkbmVzcycpKSB7XG4gICAgICByZXNwb25zZS5oYXJkbmVzcyA9IGJydXNoLmdldE9wdGlvbignaGFyZG5lc3MnKVxuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIGdpdmVuIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25bXX0gb3BlcmF0aW9uc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VyaWFsaXplT3BlcmF0aW9uIChvcGVyYXRpb24sIG9wZXJhdGlvbnMpIHtcbiAgICBpZiAob3BlcmF0aW9uLmNvbnN0cnVjdG9yLmlkZW50aWZpZXIgPT09ICdmcmFtZScpIHtcbiAgICAgIHRoaXMuX3NlcmlhbGl6ZUZyYW1lT3BlcmF0aW9uKG9wZXJhdGlvbiwgb3BlcmF0aW9ucylcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgaWYgKG9wZXJhdGlvbi5jb25zdHJ1Y3Rvci5pZGVudGlmaWVyID09PSAnb3ZlcmxheScpIHtcbiAgICAgIHRoaXMuX3NlcmlhbGl6ZU92ZXJsYXlPcGVyYXRpb24ob3BlcmF0aW9uLCBvcGVyYXRpb25zKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuX3NlcmlhbGl6ZU9wZXJhdGlvbihvcGVyYXRpb24sIG9wZXJhdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZnJhbWUgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9uLkZyYW1lT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25bXX0gb3BlcmF0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlcmlhbGl6ZUZyYW1lT3BlcmF0aW9uIChvcGVyYXRpb24sIG9wZXJhdGlvbnMpIHtcbiAgICAvLyBTaW5jZSBzZXJpYWxpemF0aW9uIDIuMC4wIHN0b3JlcyBmcmFtZXMgYXMgcGFydCBvZiB0aGUgU3ByaXRlT3BlcmF0aW9uLCB3ZSBuZWVkXG4gICAgLy8gdG8gY2hlY2sgaWYgYSBzcHJpdGUgb3BlcmF0aW9uIGlzIHByZXNlbnQgYW5kIGV4dGVuZCBpdHMgYHNwcml0ZXNgIG9wdGlvblxuICAgIGNvbnN0IHNwcml0ZU9wZXJhdGlvbnMgPSBvcGVyYXRpb25zLmZpbHRlcihvID0+IG8udHlwZSA9PT0gJ3Nwcml0ZScpXG4gICAgbGV0IHNwcml0ZU9wZXJhdGlvblxuICAgIGlmIChzcHJpdGVPcGVyYXRpb25zLmxlbmd0aCkge1xuICAgICAgc3ByaXRlT3BlcmF0aW9uID0gc3ByaXRlT3BlcmF0aW9ucy5wb3AoKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBzcHJpdGUgb3BlcmF0aW9uIGV4aXN0cywgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgc3ByaXRlT3BlcmF0aW9uID0ge1xuICAgICAgICB0eXBlOiAnc3ByaXRlJyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHNwcml0ZXM6IFtdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9wZXJhdGlvbnMucHVzaChzcHJpdGVPcGVyYXRpb24pXG4gICAgfVxuXG4gICAgc3ByaXRlT3BlcmF0aW9uLm9wdGlvbnMuc3ByaXRlcy5wdXNoKHtcbiAgICAgIHR5cGU6ICdmcmFtZScsXG4gICAgICBvcHRpb25zOiB0aGlzLl9nZXRGcmFtZU9wdGlvbnMob3BlcmF0aW9uKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgb3ZlcmxheSBvcGVyYXRpb25cbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb24uT3ZlcmxheU9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9uW119IG9wZXJhdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXJpYWxpemVPdmVybGF5T3BlcmF0aW9uIChvcGVyYXRpb24sIG9wZXJhdGlvbnMpIHtcbiAgICBpZiAoIW9wZXJhdGlvbi5nZXRJZGVudGlmaWVyKCkpIHJldHVyblxuXG4gICAgLy8gU2luY2Ugc2VyaWFsaXphdGlvbiAyLjAuMCBzdG9yZXMgb3ZlcmxheXMgYXMgcGFydCBvZiB0aGUgU3ByaXRlT3BlcmF0aW9uLCB3ZSBuZWVkXG4gICAgLy8gdG8gY2hlY2sgaWYgYSBzcHJpdGUgb3BlcmF0aW9uIGlzIHByZXNlbnQgYW5kIGV4dGVuZCBpdHMgYHNwcml0ZXNgIG9wdGlvblxuICAgIGNvbnN0IHNwcml0ZU9wZXJhdGlvbnMgPSBvcGVyYXRpb25zLmZpbHRlcihvID0+IG8udHlwZSA9PT0gJ3Nwcml0ZScpXG4gICAgbGV0IHNwcml0ZU9wZXJhdGlvblxuICAgIGlmIChzcHJpdGVPcGVyYXRpb25zLmxlbmd0aCkge1xuICAgICAgc3ByaXRlT3BlcmF0aW9uID0gc3ByaXRlT3BlcmF0aW9ucy5wb3AoKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBzcHJpdGUgb3BlcmF0aW9uIGV4aXN0cywgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgc3ByaXRlT3BlcmF0aW9uID0ge1xuICAgICAgICB0eXBlOiAnc3ByaXRlJyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHNwcml0ZXM6IFtdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9wZXJhdGlvbnMucHVzaChzcHJpdGVPcGVyYXRpb24pXG4gICAgfVxuXG4gICAgc3ByaXRlT3BlcmF0aW9uLm9wdGlvbnMuc3ByaXRlcy5wdXNoKHtcbiAgICAgIHR5cGU6ICdvdmVybGF5JyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgaWRlbnRpZmllcjogb3BlcmF0aW9uLmdldElkZW50aWZpZXIoKSxcbiAgICAgICAgaW50ZW5zaXR5OiBvcGVyYXRpb24uZ2V0QWxwaGEoKSxcbiAgICAgICAgYmxlbmRNb2RlOiBCbGVuZE1vZGVzW29wZXJhdGlvbi5nZXRCbGVuZE1vZGUoKV1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbnMgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gRnJhbWVPcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5GcmFtZU9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRGcmFtZU9wdGlvbnMgKG9wZXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBpZGVudGlmaWVyOiBvcGVyYXRpb24uZ2V0RnJhbWUoKS5pZGVudGlmaWVyXG4gICAgfVxuICB9XG5cbiAgX3NlcmlhbGl6ZU9yaWVudGF0aW9uT3BlcmF0aW9uIChvcGVyYXRpb24pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IHN1cGVyLl9zZXJpYWxpemVPcmllbnRhdGlvbk9wZXJhdGlvbihvcGVyYXRpb24pXG5cbiAgICAvLyBGb3Igc29tZSB1bmtub3duIHJlYXNvbiwgd2Ugc3RhcnQgdGhpcyBcImZpcnN0IHJvdGF0ZSwgdGhlbiBmbGlwXCIgdGhpbmcgd2l0aCAyLjAuMFxuICAgIGlmIChyZXNwb25zZS5vcHRpb25zLnJvdGF0aW9uID09PSA5MCB8fCByZXNwb25zZS5vcHRpb25zLnJvdGF0aW9uID09PSAyNzApIHtcbiAgICAgIHJlc3BvbnNlLm9wdGlvbnMuZmxpcEhvcml6b250YWxseSA9ICFyZXNwb25zZS5vcHRpb25zLmZsaXBIb3Jpem9udGFsbHlcbiAgICAgIHJlc3BvbnNlLm9wdGlvbnMuZmxpcFZlcnRpY2FsbHkgPSAhcmVzcG9uc2Uub3B0aW9ucy5mbGlwVmVydGljYWxseVxuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIGdpdmVuIHRyYW5zZm9ybSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9uLlRyYW5zZm9ybU9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXJpYWxpemVUcmFuc2Zvcm1PcGVyYXRpb24gKG9wZXJhdGlvbikge1xuICAgIGNvbnN0IHsgb3BlcmF0aW9ucyB9ID0gdGhpcy5fZWRpdG9yXG5cbiAgICAvLyBWZXJzaW9uIDIuMCBhbmQgdXAgaGFzIGRpZmZlcmVudCBvcGVyYXRpb24gb3JkZXI6IEZpcnN0IHRyYW5zZm9ybSwgdGhlbiBvcmllbnRhdGlvbi5cbiAgICBpZiAob3BlcmF0aW9ucy5leGlzdHMoJ29yaWVudGF0aW9uJykpIHtcbiAgICAgIC8vIFVwZGF0aW5nIHRoZSBvcmlnaW5hbCBvcGVyYXRpb24gd2lsbCBtZXNzIHVwIHRoZSBlZGl0b3Igc3RhdGVcbiAgICAgIG9wZXJhdGlvbiA9IG9wZXJhdGlvbi5jbG9uZSgpXG5cbiAgICAgIC8vIFVuZG8gb3JpZW50YXRpb24gdGhhdCBoYXMgYmVlbiBhcHBsaWVkIHRvIHRoZSB0cmFuc2Zvcm1zXG4gICAgICBjb25zdCBvcmllbnRhdGlvbk9wZXJhdGlvbiA9IG9wZXJhdGlvbnMuZ2V0KCdvcmllbnRhdGlvbicpXG4gICAgICBvcGVyYXRpb24ucm90YXRlKC1vcmllbnRhdGlvbk9wZXJhdGlvbi5nZXRSb3RhdGlvbigpKVxuICAgICAgaWYgKG9yaWVudGF0aW9uT3BlcmF0aW9uLmdldEZsaXBWZXJ0aWNhbGx5KCkpIHtcbiAgICAgICAgb3BlcmF0aW9uLmZsaXAoJ3ZlcnRpY2FsJylcbiAgICAgICAgb3BlcmF0aW9uLnNldFJvdGF0aW9uKG9wZXJhdGlvbi5nZXRSb3RhdGlvbigpICogLTEpXG4gICAgICB9XG4gICAgICBpZiAob3JpZW50YXRpb25PcGVyYXRpb24uZ2V0RmxpcEhvcml6b250YWxseSgpKSB7XG4gICAgICAgIG9wZXJhdGlvbi5mbGlwKCdob3Jpem9udGFsJylcbiAgICAgICAgb3BlcmF0aW9uLnNldFJvdGF0aW9uKG9wZXJhdGlvbi5nZXRSb3RhdGlvbigpICogLTEpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmVyc2lvbiAyLjAgYW5kIHVwOiBDcm9wIG9wZXJhdGlvbiBpcyBub3cgY2FsbGVkIHRyYW5zZm9ybSBvcGVyYXRpb25cbiAgICBjb25zdCByZXNwb25zZSA9IHN1cGVyLl9zZXJpYWxpemVUcmFuc2Zvcm1PcGVyYXRpb24ob3BlcmF0aW9uKVxuXG4gICAgcmVzcG9uc2UudHlwZSA9ICd0cmFuc2Zvcm0nXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gdGV4dCBzcHJpdGVcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb24uVGV4dFNwcml0ZX0gc3ByaXRlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXJpYWxpemVUZXh0IChvcGVyYXRpb24sIHNwcml0ZSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gc3VwZXIuX3NlcmlhbGl6ZVRleHQob3BlcmF0aW9uLCBzcHJpdGUpXG5cbiAgICBjb25zdCBpbnB1dERpbWVuc2lvbnMgPSBvcGVyYXRpb24uZ2V0SW5wdXREaW1lbnNpb25zKGZhbHNlKVxuICAgIHJlc3BvbnNlLm9wdGlvbnMuZm9udElkZW50aWZpZXIgPSBzcHJpdGUuZ2V0Rm9udElkZW50aWZpZXIoKVxuXG4gICAgLy8gRm9yIHdoYXRldmVyIHJlYXNvbiwgbWF4IHdpZHRoIGlzIHJlbGF0aXZlIHRvIHNob3J0ZXN0IHNpZGUsIHdoaWxlIGZvbnQgc2l6ZSBpc24ndFxuICAgIHJlc3BvbnNlLm9wdGlvbnMubWF4V2lkdGggPSByZXNwb25zZS5vcHRpb25zLm1heFdpZHRoICogaW5wdXREaW1lbnNpb25zLnggLyBpbnB1dERpbWVuc2lvbnMubWluKClcbiAgICBkZWxldGUgcmVzcG9uc2Uub3B0aW9ucy5mb250RmFtaWx5XG5cbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBmaWx0ZXIgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuRmlsdGVyT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlcmlhbGl6ZUZpbHRlck9wZXJhdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBzdXBlci5fc2VyaWFsaXplRmlsdGVyT3BlcmF0aW9uKG9wZXJhdGlvbilcbiAgICBpZiAoIXJlc3BvbnNlKSByZXR1cm4gbnVsbFxuXG4gICAgcmVzcG9uc2Uub3B0aW9ucy5pZGVudGlmaWVyID0gcmVzcG9uc2Uub3B0aW9ucy5uYW1lXG4gICAgZGVsZXRlIHJlc3BvbnNlLm9wdGlvbnMubmFtZVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gcmFkaWFsIGZvY3VzIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlJhZGlhbEZvY3VzT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlcmlhbGl6ZVJhZGlhbEZvY3VzT3BlcmF0aW9uIChvcGVyYXRpb24pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IHN1cGVyLl9zZXJpYWxpemVSYWRpYWxGb2N1c09wZXJhdGlvbihvcGVyYXRpb24pXG5cbiAgICBjb25zdCBmb2N1c09wdGlvbnMgPSByZXNwb25zZS5vcHRpb25zLm9wdGlvbnNcbiAgICBmb2N1c09wdGlvbnMuc3RhcnQgPSBmb2N1c09wdGlvbnMucG9zaXRpb25cbiAgICBkZWxldGUgZm9jdXNPcHRpb25zLnBvc2l0aW9uXG4gICAgZm9jdXNPcHRpb25zLmVuZCA9IHtcbiAgICAgIHg6IGZvY3VzT3B0aW9ucy5zdGFydC54ICsgZm9jdXNPcHRpb25zLnJhZGl1cyxcbiAgICAgIHk6IGZvY3VzT3B0aW9ucy5zdGFydC55XG4gICAgfVxuICAgIGRlbGV0ZSBmb2N1c09wdGlvbnMucmFkaXVzXG5cbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfVxufVxuXG52MjAwU2VyaWFsaXplci52ZXJzaW9uID0gJzIuMC4wJ1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zaGFyZWQvc2VyaWFsaXphdGlvbi8yLjAuMC9zZXJpYWxpemVyLmpzIiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBWZWN0b3IyLCBDb2xvciwgU0RLLCBMb2csIFNES1V0aWxzIH0gZnJvbSAnZ2xvYmFscydcbmltcG9ydCBQcmV2aW91c0Rlc2VyaWFsaXplciBmcm9tICcuLi8xLjAuMS9kZXNlcmlhbGl6ZXInXG5pbXBvcnQgRnJhbWVNYW5hZ2VyIGZyb20gJ3NoYXJlZC9tYW5hZ2Vycy9mcmFtZS1tYW5hZ2VyJ1xuaW1wb3J0IE92ZXJsYXlNYW5hZ2VyIGZyb20gJ3NoYXJlZC9tYW5hZ2Vycy9vdmVybGF5LW1hbmFnZXInXG5pbXBvcnQgU3RpY2tlck1hbmFnZXIgZnJvbSAnc2hhcmVkL21hbmFnZXJzL3N0aWNrZXItbWFuYWdlcidcblxuaW1wb3J0IEZyYW1lIGZyb20gJ2xpYi9mcmFtZSdcbmltcG9ydCBGb250TG9hZGVyIGZyb20gJ2xpYi9mb250LWxvYWRlcidcbmltcG9ydCBJbWFnZUxvYWRlciBmcm9tICdzaGFyZWQvbG9hZGVycy9pbWFnZS1sb2FkZXInXG5pbXBvcnQgQmxlbmRNb2RlcyBmcm9tICcuL2JsZW5kLW1vZGVzJ1xuXG5jb25zdCBibGVuZE1vZGVCeU5hbWUgPSBTREtVdGlscy5mbGlwT2JqZWN0KEJsZW5kTW9kZXMpXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHYyMDBEZXNlcmlhbGl6ZXIgZXh0ZW5kcyBQcmV2aW91c0Rlc2VyaWFsaXplciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2ZyYW1lTWFuYWdlciA9IG5ldyBGcmFtZU1hbmFnZXIodGhpcy5fdWksIHRoaXMuX2dldE9wdGlvbnMoJ2ZyYW1lJykpXG5cbiAgICBjb25zdCBvdmVybGF5T3B0aW9ucyA9IHRoaXMuX2dldE9wdGlvbnMoJ292ZXJsYXknKVxuICAgIGlmIChvdmVybGF5T3B0aW9ucykge1xuICAgICAgdGhpcy5fb3ZlcmxheU1hbmFnZXIgPSBuZXcgT3ZlcmxheU1hbmFnZXIodGhpcy5fdWksIG92ZXJsYXlPcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZXMgdGhlIGdpdmVuIHNwcml0ZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbn0gc3ByaXRlT3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uLlNwcml0ZX0gc3ByaXRlXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVzZXJpYWxpemVTcHJpdGUgKHNwcml0ZU9wZXJhdGlvbiwgc3ByaXRlKSB7XG4gICAgaWYgKHNwcml0ZS50eXBlID09PSAnZnJhbWUnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVzZXJpYWxpemVGcmFtZShzcHJpdGVPcGVyYXRpb24sIHNwcml0ZSlcbiAgICB9XG4gICAgaWYgKHNwcml0ZS50eXBlID09PSAnb3ZlcmxheScpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZU92ZXJsYXkoc3ByaXRlT3BlcmF0aW9uLCBzcHJpdGUpXG4gICAgfVxuICAgIHJldHVybiBzdXBlci5fZGVzZXJpYWxpemVTcHJpdGUoc3ByaXRlT3BlcmF0aW9uLCBzcHJpdGUpXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXNlcmlhbGl6ZU9wZXJhdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSAndHJhbnNmb3JtJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rlc2VyaWFsaXplVHJhbnNmb3JtT3BlcmF0aW9uKG9wZXJhdGlvbilcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLl9kZXNlcmlhbGl6ZU9wZXJhdGlvbihvcGVyYXRpb24pXG4gIH1cblxuICBfZGVzZXJpYWxpemVPcmllbnRhdGlvbk9wZXJhdGlvbiAob3BlcmF0aW9uRGF0YSkge1xuICAgIGlmIChvcGVyYXRpb25EYXRhLm9wdGlvbnMucm90YXRpb24gPT09IDkwIHx8IG9wZXJhdGlvbkRhdGEub3B0aW9ucy5yb3RhdGlvbiA9PT0gMjcwKSB7XG4gICAgICBvcGVyYXRpb25EYXRhLm9wdGlvbnMuZmxpcEhvcml6b250YWxseSA9ICFvcGVyYXRpb25EYXRhLm9wdGlvbnMuZmxpcEhvcml6b250YWxseVxuICAgICAgb3BlcmF0aW9uRGF0YS5vcHRpb25zLmZsaXBWZXJ0aWNhbGx5ID0gIW9wZXJhdGlvbkRhdGEub3B0aW9ucy5mbGlwVmVydGljYWxseVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5fZGVzZXJpYWxpemVPcmllbnRhdGlvbk9wZXJhdGlvbihvcGVyYXRpb25EYXRhKVxuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplcyB0aGUgZ2l2ZW4gdHJhbnNmb3JtIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wZXJhdGlvbkRhdGFcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXNlcmlhbGl6ZVRyYW5zZm9ybU9wZXJhdGlvbiAob3BlcmF0aW9uRGF0YSkge1xuICAgIC8vIFZlcnNpb24gMi4wIGFuZCB1cDogQ3JvcCBvcGVyYXRpb24gaXMgbm93IGNhbGxlZCB0cmFuc2Zvcm0gb3BlcmF0aW9uXG4gICAgcmV0dXJuIHN1cGVyLl9kZXNlcmlhbGl6ZUNyb3BPcGVyYXRpb24ob3BlcmF0aW9uRGF0YSlcbiAgICAgIC50aGVuKG9wZXJhdGlvbiA9PiB7XG4gICAgICAgIGlmICghb3BlcmF0aW9uKSByZXR1cm5cblxuICAgICAgICBsZXQgb3JpZW50YXRpb25EYXRhID0gU0RLVXRpbHMuQXJyYXkuZmluZCh0aGlzLl9kYXRhLm9wZXJhdGlvbnMsIG9wID0+IG9wLnR5cGUgPT09ICdvcmllbnRhdGlvbicpXG4gICAgICAgIGlmIChvcmllbnRhdGlvbkRhdGEpIHtcbiAgICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IG9yaWVudGF0aW9uRGF0YVxuICAgICAgICAgIGxldCB7IHJvdGF0aW9uLCBmbGlwSG9yaXpvbnRhbGx5LCBmbGlwVmVydGljYWxseSB9ID0gb3B0aW9uc1xuXG4gICAgICAgICAgaWYgKHJvdGF0aW9uID09PSA5MCB8fCByb3RhdGlvbiA9PT0gMjcwKSB7XG4gICAgICAgICAgICBpZiAoKCFmbGlwSG9yaXpvbnRhbGx5ICYmIGZsaXBWZXJ0aWNhbGx5KSB8fCAoZmxpcEhvcml6b250YWxseSAmJiAhZmxpcFZlcnRpY2FsbHkpKSB7XG4gICAgICAgICAgICAgIGZsaXBIb3Jpem9udGFsbHkgPSAhZmxpcEhvcml6b250YWxseVxuICAgICAgICAgICAgICBmbGlwVmVydGljYWxseSA9ICFmbGlwVmVydGljYWxseVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG9wZXJhdGlvbi5yb3RhdGUob3B0aW9ucy5yb3RhdGlvbilcbiAgICAgICAgICBpZiAoZmxpcEhvcml6b250YWxseSkge1xuICAgICAgICAgICAgb3BlcmF0aW9uLmZsaXAoJ2hvcml6b250YWwnKVxuICAgICAgICAgICAgb3BlcmF0aW9uLnNldFJvdGF0aW9uKG9wZXJhdGlvbi5nZXRSb3RhdGlvbigpICogLTEpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmbGlwVmVydGljYWxseSkge1xuICAgICAgICAgICAgb3BlcmF0aW9uLmZsaXAoJ3ZlcnRpY2FsJylcbiAgICAgICAgICAgIG9wZXJhdGlvbi5zZXRSb3RhdGlvbihvcGVyYXRpb24uZ2V0Um90YXRpb24oKSAqIC0xKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcGVyYXRpb25cbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBmcmFtZSBzcHJpdGVcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb259IHNwcml0ZU9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGZyYW1lXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVzZXJpYWxpemVGcmFtZSAoc3ByaXRlT3BlcmF0aW9uLCBmcmFtZSkge1xuICAgIGNvbnN0IHsgaWRlbnRpZmllciB9ID0gZnJhbWUub3B0aW9uc1xuXG4gICAgY29uc3QgZnJhbWVEYXRhID0gdGhpcy5fZnJhbWVNYW5hZ2VyLmdldEZyYW1lQnlJZGVudGlmaWVyKGlkZW50aWZpZXIpXG4gICAgaWYgKCFmcmFtZURhdGEpIHtcbiAgICAgIExvZy53YXJuKCdEZXNlcmlhbGl6ZXInLCBgVW5rbm93biBmcmFtZSBcXGAke2lkZW50aWZpZXJ9XFxgLiBTa2lwcGluZyBmcmFtZS5gKVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuICAgIGNvbnN0IGZyYW1lSW5zdGFuY2UgPSBuZXcgRnJhbWUodGhpcy5fdWksIGZyYW1lRGF0YSlcbiAgICByZXR1cm4gZnJhbWVJbnN0YW5jZS5sb2FkKClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5fZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ2ZyYW1lJywge1xuICAgICAgICAgIGZyYW1lOiBmcmFtZUluc3RhbmNlLmdldEZyYW1lKClcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBvdmVybGF5IHNwcml0ZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbn0gc3ByaXRlT3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3ZlcmxheVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Rlc2VyaWFsaXplT3ZlcmxheSAoc3ByaXRlT3BlcmF0aW9uLCBvdmVybGF5KSB7XG4gICAgY29uc3QgeyBibGVuZE1vZGUsIGludGVuc2l0eSwgaWRlbnRpZmllciB9ID0gb3ZlcmxheS5vcHRpb25zXG5cbiAgICBjb25zdCBvdmVybGF5RGF0YSA9IHRoaXMuX292ZXJsYXlNYW5hZ2VyLmdldE92ZXJsYXlCeUlkZW50aWZpZXIoaWRlbnRpZmllcilcbiAgICBpZiAoIW92ZXJsYXlEYXRhKSB7XG4gICAgICBMb2cud2FybignRGVzZXJpYWxpemVyJywgYFVua25vd24gb3ZlcmxheSBcXGAke2lkZW50aWZpZXJ9XFxgLiBTa2lwcGluZyBvdmVybGF5LmApXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9XG5cbiAgICBjb25zdCBvdmVybGF5UGF0aCA9IHRoaXMuX2VkaXRvci5nZXRVSSgpLmdldEFzc2V0UGF0aChvdmVybGF5RGF0YS5pbWFnZSlcbiAgICByZXR1cm4gSW1hZ2VMb2FkZXIubG9hZChvdmVybGF5UGF0aClcbiAgICAgIC50aGVuKGltYWdlID0+IHtcbiAgICAgICAgdGhpcy5fZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ292ZXJsYXknLCB7XG4gICAgICAgICAgYWxwaGE6IGludGVuc2l0eSxcbiAgICAgICAgICBpZGVudGlmaWVyLFxuICAgICAgICAgIGJsZW5kTW9kZTogcGFyc2VJbnQoYmxlbmRNb2RlQnlOYW1lW2JsZW5kTW9kZSB8fCBvdmVybGF5RGF0YS5ibGVuZE1vZGVdLCAxMCksXG4gICAgICAgICAgaW1hZ2VcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGJydXNoIGZhY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbi5TcHJpdGVzLkJydXNoU3ByaXRlLlBhdGh9IHBhdGhcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb24uU3ByaXRlcy5CcnVzaFNwcml0ZS5CcnVzaH1cbiAgICovXG4gIF9jcmVhdGVCcnVzaEZvclBhdGggKHBhdGgpIHtcbiAgICBjb25zdCBicnVzaCA9IHN1cGVyLl9jcmVhdGVCcnVzaEZvclBhdGgocGF0aClcbiAgICBpZiAodHlwZW9mIHBhdGguaGFyZG5lc3MgIT09ICd1bmRlZmluZWQnICYmIGJydXNoLmhhc09wdGlvbignaGFyZG5lc3MnKSkge1xuICAgICAgYnJ1c2guc2V0SGFyZG5lc3MocGF0aC5oYXJkbmVzcylcbiAgICB9XG4gICAgcmV0dXJuIGJydXNoXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBzdGlja2VyIGZvciB0aGUgZ2l2ZW4gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBzcHJpdGVcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb24uU3RpY2tlclNwcml0ZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXNlcmlhbGl6ZVN0aWNrZXIgKG9wZXJhdGlvbiwgc3ByaXRlKSB7XG4gICAgY29uc3QgeyBTcHJpdGVPcGVyYXRpb24gfSA9IFNESy5PcGVyYXRpb25zXG5cbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHNwcml0ZVxuICAgIGNvbnN0IHN0aWNrZXIgPSB0aGlzLl9zdGlja2VyTWFuYWdlci5nZXRTdGlja2VyQnlJZGVudGlmaWVyKG9wdGlvbnMuaWRlbnRpZmllcilcbiAgICBjb25zdCB1cmwgPSBTdGlja2VyTWFuYWdlci5nZXRVUkxGb3JTdGlja2VyKHN0aWNrZXIsICdiYXNlJylcbiAgICBpZiAoIXN0aWNrZXIpIHtcbiAgICAgIExvZy53YXJuKCdEZXNlcmlhbGl6ZXInLCBgVW5rbm93biBzdGlja2VyIFxcYCR7b3B0aW9ucy5pZGVudGlmaWVyfVxcYC4gU2tpcHBpbmcgc3ByaXRlLmApXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9XG4gICAgY29uc3QgaW5wdXREaW1lbnNpb25zID0gb3BlcmF0aW9uLmdldElucHV0RGltZW5zaW9ucyhmYWxzZSlcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgd2luZG93LkltYWdlKClcbiAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFkanVzdG1lbnRzID0gU3ByaXRlT3BlcmF0aW9uLlN0aWNrZXJTcHJpdGUucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMuYWRqdXN0bWVudHMuc3RydWN0dXJlXG4gICAgICAgIGNvbnN0IHsgcm90YXRpb24sIGZsaXBIb3Jpem9udGFsbHksIGZsaXBWZXJ0aWNhbGx5IH0gPSBvcHRpb25zXG4gICAgICAgIGNvbnN0IHN0aWNrZXJPcHRpb25zID0ge1xuICAgICAgICAgIGlkZW50aWZpZXI6IG9wdGlvbnMuaWRlbnRpZmllcixcbiAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICBwb3NpdGlvbjogVmVjdG9yMi5mcm9tT2JqZWN0KG9wdGlvbnMucG9zaXRpb24pLFxuICAgICAgICAgIGRpbWVuc2lvbnM6IFZlY3RvcjIuZnJvbU9iamVjdChvcHRpb25zLmRpbWVuc2lvbnMpLm11bHRpcGx5KGlucHV0RGltZW5zaW9ucy5taW4oKSksXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgZmxpcEhvcml6b250YWxseSxcbiAgICAgICAgICBmbGlwVmVydGljYWxseSxcbiAgICAgICAgICBhZGp1c3RtZW50czoge31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hZGp1c3RtZW50cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBbJ2JyaWdodG5lc3MnLCAnY29udHJhc3QnLCAnc2F0dXJhdGlvbiddLmZvckVhY2gob3B0aW9uID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hZGp1c3RtZW50c1tvcHRpb25dICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBzdGlja2VyT3B0aW9ucy5hZGp1c3RtZW50c1tvcHRpb25dID0gb3B0aW9ucy5hZGp1c3RtZW50c1tvcHRpb25dICsgYWRqdXN0bWVudHNbb3B0aW9uXS5kZWZhdWx0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50aW50Q29sb3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBzdGlja2VyLnRpbnRNb2RlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHN0aWNrZXJPcHRpb25zLnRpbnRDb2xvciA9IENvbG9yLmZyb21BcnJheShvcHRpb25zLnRpbnRDb2xvcilcbiAgICAgICAgICBzdGlja2VyT3B0aW9ucy50aW50TW9kZSA9IHN0aWNrZXIudGludE1vZGVcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKG9wZXJhdGlvbi5jcmVhdGVTdGlja2VyKHN0aWNrZXJPcHRpb25zKSlcbiAgICAgIH0pXG4gICAgICBpbWFnZS5jcm9zc09yaWdpbiA9IHRoaXMuX2VkaXRvci5nZXRDcm9zc09yaWdpbigpXG4gICAgICBpbWFnZS5zcmMgPSB0aGlzLl9lZGl0b3IuZ2V0VUkoKS5nZXRBc3NldFBhdGgodXJsKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBmaWx0ZXIgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3BlcmF0aW9uXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVzZXJpYWxpemVGaWx0ZXJPcGVyYXRpb24gKG9wZXJhdGlvbikge1xuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gb3BlcmF0aW9uXG5cbiAgICBpZiAoIXRoaXMuX2ZpbHRlck1hbmFnZXIuZ2V0RmlsdGVyQnlJZGVudGlmaWVyKG9wdGlvbnMuaWRlbnRpZmllcikpIHtcbiAgICAgIExvZy53YXJuKCdEZXNlcmlhbGl6ZXInLCBgVW5rbm93biBmaWx0ZXIgXFxgJHtvcHRpb25zLmlkZW50aWZpZXJ9XFxgYClcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9maWx0ZXJNYW5hZ2VyLmluc3RhbnRpYXRlRmlsdGVyV2l0aElkZW50aWZpZXIob3B0aW9ucy5pZGVudGlmaWVyKVxuICAgICAgLnRoZW4oZmlsdGVyID0+IHtcbiAgICAgICAgY29uc3QgZmlsdGVyT3BlcmF0aW9uID0gdGhpcy5fZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ2ZpbHRlcicpXG4gICAgICAgIGlmICghZmlsdGVyT3BlcmF0aW9uKSByZXR1cm5cbiAgICAgICAgZmlsdGVyT3BlcmF0aW9uLnNldCh7XG4gICAgICAgICAgaWRlbnRpZmllcjogb3B0aW9ucy5pZGVudGlmaWVyLFxuICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICBpbnRlbnNpdHk6IG9wdGlvbnMuaW50ZW5zaXR5XG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBmaWx0ZXJPcGVyYXRpb25cbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBmb2N1cyBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcGVyYXRpb25cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXNlcmlhbGl6ZUZvY3VzT3BlcmF0aW9uIChvcGVyYXRpb24pIHtcbiAgICBjb25zdCB7IG9wdGlvbnMsIHR5cGUgfSA9IG9wZXJhdGlvbi5vcHRpb25zXG4gICAgaWYgKHR5cGUgIT09ICdyYWRpYWwnKSByZXR1cm4gc3VwZXIuX2Rlc2VyaWFsaXplRm9jdXNPcGVyYXRpb24ob3BlcmF0aW9uKVxuXG4gICAgY29uc3QgeyBzdGFydCwgZW5kLCBncmFkaWVudFJhZGl1cywgYmx1clJhZGl1cyB9ID0gb3B0aW9uc1xuICAgIGNvbnN0IHJhZGl1cyA9IFZlY3RvcjIuZnJvbU9iamVjdChlbmQpXG4gICAgICAuc3VidHJhY3QoXG4gICAgICAgIFZlY3RvcjIuZnJvbU9iamVjdChzdGFydClcbiAgICAgICkubGVuKClcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2VkaXRvci5vcGVyYXRpb25zLmdldE9yQ3JlYXRlKCdyYWRpYWwtZm9jdXMnLCB7XG4gICAgICBwb3NpdGlvbjogVmVjdG9yMi5mcm9tT2JqZWN0KHN0YXJ0KSxcbiAgICAgIHJhZGl1cyxcbiAgICAgIGdyYWRpZW50UmFkaXVzLFxuICAgICAgYmx1clJhZGl1c1xuICAgIH0pKVxuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplcyB0aGUgZ2l2ZW4gdGV4dCBmb3IgdGhlIGdpdmVuIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gdGV4dFxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbi5UZXh0U3ByaXRlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Rlc2VyaWFsaXplVGV4dCAob3BlcmF0aW9uLCB0ZXh0KSB7XG4gICAgY29uc3QgeyBvcHRpb25zIH0gPSB0ZXh0XG4gICAgY29uc3QgeyBmb250U2l6ZSwgbGluZUhlaWdodCwgZm9udElkZW50aWZpZXIsIGFsaWdubWVudCwgcm90YXRpb24sIG1heFdpZHRoLCBjb2xvciwgYmFja2dyb3VuZENvbG9yIH0gPSBvcHRpb25zXG5cbiAgICBjb25zdCBmb250TG9hZGVyID0gbmV3IEZvbnRMb2FkZXIodGhpcy5fdWkpXG4gICAgbGV0IHZhcmlhdGlvbiA9IHRoaXMuX2ZvbnRNYW5hZ2VyLmdldFZhcmlhdGlvbkJ5SWRlbnRpZmllcihmb250SWRlbnRpZmllcilcbiAgICBpZiAoIXZhcmlhdGlvbikge1xuICAgICAgdmFyaWF0aW9uID0gdGhpcy5fZm9udE1hbmFnZXIuZ2V0RGVmYXVsdEZvbnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICBmb250TG9hZGVyLnNldEZvbnRzKFt2YXJpYXRpb24uZ2V0Rm9udCgpXSlcbiAgICB9XG4gICAgcmV0dXJuIGZvbnRMb2FkZXIubG9hZCgpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IG9wZXJhdGlvbi5nZXRJbnB1dERpbWVuc2lvbnMoZmFsc2UpXG5cbiAgICAgICAgLy8gRm9yIHdoYXRldmVyIHJlYXNvbiwgbWF4IHdpZHRoIGlzIHJlbGF0aXZlIHRvIHNob3J0ZXN0IHNpZGUsIHdoaWxlIGZvbnQgc2l6ZSBpc24ndFxuICAgICAgICBjb25zdCBmaXhlZE1heFdpZHRoID0gbWF4V2lkdGggKiBpbnB1dERpbWVuc2lvbnMubWluKCkgLyBpbnB1dERpbWVuc2lvbnMueFxuICAgICAgICByZXR1cm4gb3BlcmF0aW9uLmNyZWF0ZVRleHQoe1xuICAgICAgICAgIGZvbnRTaXplLFxuICAgICAgICAgIGxpbmVIZWlnaHQsXG4gICAgICAgICAgZm9udEZhbWlseTogdmFyaWF0aW9uLmdldEZvbnRGYW1pbHkoKSxcbiAgICAgICAgICBmb250V2VpZ2h0OiB2YXJpYXRpb24uZ2V0Rm9udFdlaWdodCgpLFxuICAgICAgICAgIGZvbnRJZGVudGlmaWVyOiB2YXJpYXRpb24uZ2V0SWRlbnRpZmllcigpLFxuICAgICAgICAgIGFsaWdubWVudCxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBtYXhXaWR0aDogZml4ZWRNYXhXaWR0aCxcbiAgICAgICAgICB0ZXh0OiBvcHRpb25zLnRleHQsXG4gICAgICAgICAgY29sb3I6IENvbG9yLmZyb21BcnJheShjb2xvciksXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBDb2xvci5mcm9tQXJyYXkoYmFja2dyb3VuZENvbG9yKSxcbiAgICAgICAgICBwb3NpdGlvbjogVmVjdG9yMi5mcm9tT2JqZWN0KG9wdGlvbnMucG9zaXRpb24pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICB9XG59XG5cbnYyMDBEZXNlcmlhbGl6ZXIudmVyc2lvbiA9ICcyLjAuMCdcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvanMvc2hhcmVkL3NlcmlhbGl6YXRpb24vMi4wLjAvZGVzZXJpYWxpemVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICBTeW1ib2wuZm9yICYmXG4gICAgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuICAgIDB4ZWFjNztcblxuICB2YXIgaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH07XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE2IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcyAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZykpO1xuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuY29uc3QgZWxlbWVudFNlcGFyYXRvciA9ICdfXydcbmNvbnN0IG1vZGlmaWVyU2VwYXJhdG9yID0gJy0tJ1xuY29uc3QgYmxvY2tQcmVmaXggPSAncGVzZGstcmVhY3QtJ1xuXG4vKipcbiAqIEBjbGFzcyBCRU1PYmplY3RcbiAqIEBpZ25vcmVcbiAqL1xuY2xhc3MgQkVNT2JqZWN0IHtcbiAgY29uc3RydWN0b3IgKHBhcmVudCwgdHlwZSwgbmFtZSkge1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudFxuICAgIHRoaXMuX3R5cGUgPSB0eXBlXG4gICAgdGhpcy5fbmFtZSA9IG5hbWVcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQkVNT2JqZWN0IG9mIHR5cGUgXCJlbGVtZW50XCIgdGhhdCBoYXMgdGhpcyBlbGVtZW50IGFzIHBhcmVudFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWVcbiAgICogQHJldHVybiB7QkVNT2JqZWN0fVxuICAgKi9cbiAgZWxlbWVudCAobmFtZSkge1xuICAgIHJldHVybiBuZXcgQkVNT2JqZWN0KHRoaXMsICdlbGVtZW50JywgbmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQkVNT2JqZWN0IG9mIHR5cGUgXCJtb2RpZmllclwiIHRoYXQgaGFzIHRoaXMgZWxlbWVudCBhcyBwYXJlbnRcbiAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge0JFTU9iamVjdH1cbiAgICovXG4gIG1vZGlmaWVyIChuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBCRU1PYmplY3QodGhpcywgJ21vZGlmaWVyJywgbmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGNsYXNzIG5hbWUgZm9yIHRoaXMgQkVNT2JqZWN0XG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldCBzdHIgKCkge1xuICAgIGxldCByZXNwb25zZSA9IHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5zdHIgOiAnJ1xuICAgIHN3aXRjaCAodGhpcy5fdHlwZSkge1xuICAgICAgY2FzZSAnYmxvY2snOlxuICAgICAgICByZXNwb25zZSArPSBgJHtibG9ja1ByZWZpeH0ke3RoaXMuX25hbWV9YFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnZWxlbWVudCc6XG4gICAgICAgIHJlc3BvbnNlICs9IGAke2VsZW1lbnRTZXBhcmF0b3J9JHt0aGlzLl9uYW1lfWBcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgcmVzcG9uc2UgKz0gYCR7bW9kaWZpZXJTZXBhcmF0b3J9JHt0aGlzLl9uYW1lfWBcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIEJFTU9iamVjdCBvZiB0eXBlIFwiYmxvY2tcIiB0aGF0IGhhcyB0aGlzIGVsZW1lbnQgYXMgcGFyZW50XG4gICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHtCRU1PYmplY3R9XG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGJsb2NrIChuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBCRU1PYmplY3QobnVsbCwgJ2Jsb2NrJywgbmFtZSlcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL2JlbS5qc3giLCIvKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBDbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnXG5pbXBvcnQgQkVNIGZyb20gJy4vYmVtJ1xuXG5mdW5jdGlvbiBmbGF0dGVuIChhcnIpIHtcbiAgbGV0IHJlc3VsdCA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGZsYXR0ZW4oYXJyW2ldKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2goYXJyW2ldKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmNvbnN0IEJFTV9UWVBFUyA9IHtcbiAgYjogJ2Jsb2NrJyxcbiAgZTogJ2VsZW1lbnQnLFxuICBtOiAnbW9kaWZpZXInXG59XG5jb25zdCBSZWFjdEJFTSA9IHtcbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgZ2l2ZW4gUmVhY3RCRU0gc3BlY2lmaWVyIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mXG4gICAqIEJFTSBpbmZvcm1hdGlvbiAodHlwZSwgbmFtZSwgcGFzcylcbiAgICogQHBhcmFtICB7c3RyaW5nfSBzcGVjaWZpZXJcbiAgICogQHJldHVybiB7QXJyYXkuPE9iamVjdD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcGFyc2VCZW1TcGVjaWZpZXIgKHNwZWNpZmllcikge1xuICAgIGlmICghc3BlY2lmaWVyKSByZXR1cm4gW11cblxuICAgIGNvbnN0IHBhcnRzID0gc3BlY2lmaWVyLnNwbGl0KCcgJylcbiAgICBsZXQgZGF0YSA9IHBhcnRzLm1hcCgocGFydCkgPT4ge1xuICAgICAgY29uc3QgbWF0Y2ggPSBwYXJ0Lm1hdGNoKC9eKFxcJCk/KFtiZW1dKTooLiopJC9pKVxuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQkVNIHNwZWNpZmllcjogJyArIHBhcnQpXG4gICAgICB9XG5cbiAgICAgIGxldCBwYXNzID0gdHlwZW9mIG1hdGNoWzFdICE9PSAndW5kZWZpbmVkJ1xuICAgICAgbGV0IHR5cGUgPSBCRU1fVFlQRVNbbWF0Y2hbMl1dXG4gICAgICBsZXQgbmFtZSA9IG1hdGNoWzNdXG4gICAgICByZXR1cm4geyB0eXBlLCBuYW1lLCBwYXNzIH1cbiAgICB9KVxuICAgIHJldHVybiBkYXRhXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIEJFTSBpbmZvIGZvciB0aGUgZ2l2ZW4gbm9kZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG5vZGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEJlbUluZm9Gb3JOb2RlIChub2RlKSB7XG4gICAgY29uc3QgaXNCZW1Ob2RlID0gbm9kZS50eXBlID09PSAnYmVtJ1xuICAgIGNvbnN0IHNwZWNpZmllciA9IGlzQmVtTm9kZSA/IG5vZGUucHJvcHMuc3BlY2lmaWVyIDogbm9kZS5wcm9wcy5iZW1cblxuICAgIGlmIChpc0JlbU5vZGUgJiYgIXNwZWNpZmllcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCc8YmVtPiBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGhhdmUgYSBgc3BlY2lmaWVyYCBwcm9wZXJ0eScpXG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX3BhcnNlQmVtU3BlY2lmaWVyKHNwZWNpZmllcilcblxuICAgIC8vIDxiZW0+IG5vZGVzIHBhc3MgYWxsIGJlbSBpbmZvcm1hdGlvbiB0byB0aGUgY2hpbGRyZW5cbiAgICBpZiAoaXNCZW1Ob2RlKSB7XG4gICAgICBkYXRhLmZvckVhY2goKG9iaikgPT4ge1xuICAgICAgICBvYmoucGFzcyA9IHRydWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZGF0YSwgaXNCZW1Ob2RlIH1cbiAgfSxcblxuICAvKipcbiAgICogVXNlZCBpbiBSZWFjdC5Db21wb25lbnQncyBgcmVuZGVyYCBtZXRob2RcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSAge09iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtICB7QXJyYXkuPE9iamVjdD59IFsuLi5jaGlsZHJlbl1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgY3JlYXRlRWxlbWVudCAodHlwZSwgcHJvcHMsIC4uLmNoaWxkcmVuKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fVxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW5cbiAgICAgIC5maWx0ZXIoKGNoaWxkKSA9PlxuICAgICAgICBjaGlsZCAhPT0gbnVsbCAmJiB0eXBlb2YgY2hpbGQgIT09ICd1bmRlZmluZWQnXG4gICAgICApXG4gICAgcmV0dXJuIHsgdHlwZSwgcHJvcHMsIGNoaWxkcmVuIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgd2UgY2FuIGFwcGx5IGEgYmVtIGNsYXNzIHRvIHRoZSBnaXZlbiBub2RlXG4gICAqIEBwYXJhbSAgez99ICBub2RlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaXNOb2RlQkVNYWJsZSAobm9kZSkge1xuICAgIHJldHVybiBub2RlICE9PSBudWxsICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiAhUmVhY3QuaXNWYWxpZEVsZW1lbnQobm9kZSlcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgQkVNIGNsYXNzIGZvciB0aGUgZ2l2ZW4gbm9kZS4gSXRlcmF0ZXMgdGhyb3VnaCBpdHNcbiAgICogY2hpbGRyZW4gYW5kIHNldHMgdGhlaXIgQkVNIGNsYXNzIGFzIHdlbGxcbiAgICogQHBhcmFtICB7T2JqZWN0fSBub2RlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseUJFTUNsYXNzZXMgKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuX2lzTm9kZUJFTWFibGUobm9kZSkpIHJldHVybiBub2RlXG5cbiAgICBsZXQgY2xhc3NOYW1lcyA9IG5vZGUucHJvcHMuY2xhc3NOYW1lID8gW25vZGUucHJvcHMuY2xhc3NOYW1lXSA6IFtdXG5cbiAgICAvLyBQcmVwYXJlIEJFTSBvYmplY3RzXG4gICAgY29uc3QgYmVtSW5mbyA9IHRoaXMuX2dldEJlbUluZm9Gb3JOb2RlKG5vZGUpXG4gICAgbGV0IG93bkJlbU9iamVjdCA9IG5vZGUucHJvcHMuX19iZW1PYmplY3RcbiAgICBsZXQgY2hpbGRyZW5CZW1PYmplY3QgPSBub2RlLnByb3BzLl9fYmVtT2JqZWN0XG4gICAgYmVtSW5mby5kYXRhLmZvckVhY2goKG9iaikgPT4ge1xuICAgICAgaWYgKG9iai50eXBlID09PSAnYmxvY2snKSB7XG4gICAgICAgIG93bkJlbU9iamVjdCA9IEJFTS5ibG9jayhvYmoubmFtZSlcbiAgICAgICAgaWYgKG9iai5wYXNzKSB7XG4gICAgICAgICAgY2hpbGRyZW5CZW1PYmplY3QgPSBCRU0uYmxvY2sob2JqLm5hbWUpXG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKG93bkJlbU9iamVjdC5zdHIpXG4gICAgICB9IGVsc2UgaWYgKG9iai50eXBlID09PSAnZWxlbWVudCcpIHtcbiAgICAgICAgaWYgKCFvd25CZW1PYmplY3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIHRvIGNyZWF0ZSBhbiBlbGVtZW50LCBidXQgbm8gcGFyZW50IGJsb2NrIGhhcyBiZWVuIGZvdW5kLicpXG4gICAgICAgIH1cblxuICAgICAgICBvd25CZW1PYmplY3QgPSBvd25CZW1PYmplY3QuZWxlbWVudChvYmoubmFtZSlcbiAgICAgICAgaWYgKG9iai5wYXNzKSB7XG4gICAgICAgICAgY2hpbGRyZW5CZW1PYmplY3QgPSBjaGlsZHJlbkJlbU9iamVjdC5lbGVtZW50KG9iai5uYW1lKVxuICAgICAgICB9XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaChvd25CZW1PYmplY3Quc3RyKVxuICAgICAgfSBlbHNlIGlmIChvYmoudHlwZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgICBpZiAoIW93bkJlbU9iamVjdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgdG8gY3JlYXRlIGEgbW9kaWZpZXIsIGJ1dCBubyBwYXJlbnQgYmxvY2sgaGFzIGJlZW4gZm91bmQuJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmoucGFzcykge1xuICAgICAgICAgIGNoaWxkcmVuQmVtT2JqZWN0ID0gY2hpbGRyZW5CZW1PYmplY3QubW9kaWZpZXIob2JqLm5hbWUpXG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKG93bkJlbU9iamVjdC5tb2RpZmllcihvYmoubmFtZSkuc3RyKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBBcHBseSBjbGFzc25hbWUgKGlmIG5lY2Vzc2FyeSlcbiAgICBjb25zdCBjbGFzc05hbWUgPSBDbGFzc25hbWVzKGNsYXNzTmFtZXMpXG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgbm9kZS5wcm9wcy5jbGFzc05hbWUgPSBjbGFzc05hbWVcbiAgICB9XG5cbiAgICBub2RlLmNoaWxkcmVuID0gZmxhdHRlbihub2RlLmNoaWxkcmVuKVxuXG4gICAgLy8gUGFzcyBgY2hpbGRyZW5CZW1PYmplY3RgIHRvIGNoaWxkIG5vZGVzXG4gICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9pc05vZGVCRU1hYmxlKGNoaWxkKSkgcmV0dXJuXG4gICAgICBjaGlsZC5wcm9wcy5fX2JlbU9iamVjdCA9IGNoaWxkcmVuQmVtT2JqZWN0XG4gICAgfSlcblxuICAgIC8vIEFwcGx5IEJFTSBvYmplY3RzIHRvIGNoaWxkcmVuXG4gICAgbm9kZS5jaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5QkVNQ2xhc3NlcyhjaGlsZClcbiAgICB9KVxuXG4gICAgbm9kZS5jaGlsZHJlbiA9IGZsYXR0ZW4obm9kZS5jaGlsZHJlbilcblxuICAgIC8vIFJlbW92ZSB1bm5lY2Vzc2FyeSBwcm9wc1xuICAgIGRlbGV0ZSBub2RlLnByb3BzLl9fYmVtT2JqZWN0XG4gICAgZGVsZXRlIG5vZGUucHJvcHMuYmVtXG5cbiAgICBpZiAoYmVtSW5mby5pc0JlbU5vZGUpIHtcbiAgICAgIGlmIChub2RlLmNoaWxkcmVuIGluc3RhbmNlb2YgQXJyYXkgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bMF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVcbiAgfSxcblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gUmVhY3RCRU0gZWxlbWVudCBhbmQgaXRzIGNoaWxkcmVuIGludG9cbiAgICogYWN0dWFsIFJlYWN0SlMgZWxlbWVudHNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBub2RlXG4gICAqIEByZXR1cm4ge1JlYWN0LkVsZW1lbnR9XG4gICAqL1xuICBfdHJhbnNmb3JtVG9SZWFjdCAobm9kZSkge1xuICAgIGlmICghdGhpcy5faXNOb2RlQkVNYWJsZShub2RlKSkgcmV0dXJuIG5vZGVcblxuICAgIG5vZGUuY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1Ub1JlYWN0KGNoaWxkKVxuICAgIH0pXG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChub2RlLnR5cGUsIG5vZGUucHJvcHMsIC4uLm5vZGUuY2hpbGRyZW4pXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhlIGdpdmVuIFJlYWN0QkVNIG9iamVjdCBhbmQgaXRzIGNoaWxkcmVuXG4gICAqIEBwYXJhbSAge09iamVjdH0gcm9vdFxuICAgKiBAcmV0dXJuIHtSZWFjdC5FbGVtZW50fVxuICAgKi9cbiAgdHJhbnNmb3JtIChyb290KSB7XG4gICAgcm9vdCA9IHRoaXMuX2FwcGx5QkVNQ2xhc3Nlcyhyb290KVxuXG4gICAgLy8gUm9vdCBub2RlIHNob3VsZCBiZSBhIHNpbmdsZSBub2RlLCBub3QgYW4gYXJyYXkuIFJldHVybmluZyB0aGUgYXJyYXlcbiAgICAvLyBoZXJlIHdpbGwgY2F1c2UgUmVhY3QgdG8gdGhyb3cgYW4gZXJyb3Igc2F5aW5nIHRoYXQgdGhpcyBpcyBhIG5vLWdvXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAocm9vdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICByZXR1cm4gcm9vdFxuICAgIH1cblxuICAgIHJvb3QgPSB0aGlzLl90cmFuc2Zvcm1Ub1JlYWN0KHJvb3QpXG4gICAgcmV0dXJuIHJvb3RcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZWFjdEJFTVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL3JlYWN0LWJlbS5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQge1xuICBERUZBVUxUUzoge1xuICAgIEZJTFRFUlM6IFtcbiAgICAgIC8vIHtcbiAgICAgIC8vICAgaWRlbnRpZmllcjogJ2ltZ2x5X2ZpbHRlcnNfdGVzdCcsXG4gICAgICAvLyAgIGRlZmF1bHROYW1lOiAnVGVzdCcsXG4gICAgICAvLyAgIGZpbHRlcnM6IFtcbiAgICAgIC8vICAgICB7XG4gICAgICAvLyAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X2lkZW50aXR5XzVfNScsXG4gICAgICAvLyAgICAgICBkZWZhdWx0TmFtZTogJ0lkZW50aXR5IDV4NScsXG4gICAgICAvLyAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X2lkZW50aXR5XzVfNV8xMjgucG5nJ1xuICAgICAgLy8gICAgIH1cbiAgICAgIC8vICAgXVxuICAgICAgLy8gfSxcbiAgICAgIHtcbiAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2ZpbHRlcnNfYW5hbG9nJyxcbiAgICAgICAgZGVmYXVsdE5hbWU6ICdBbmFsb2cnLFxuICAgICAgICBmaWx0ZXJzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2x1dF9jb29sJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQ29vbCcsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X2Nvb2xfNV81XzEyOC5wbmcnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X2JsdWVzJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQmx1ZXMnLFxuICAgICAgICAgICAgbHV0SW1hZ2U6ICdmaWx0ZXJzL2ltZ2x5X2x1dF9ibHVlc181XzVfMTI4LnBuZydcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X2JsdWVzaGFkb3dzJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQmx1ZSBTaGFkb3dzJyxcbiAgICAgICAgICAgIGx1dEltYWdlOiAnZmlsdGVycy9pbWdseV9sdXRfYmx1ZXNoYWRvd3NfNV81XzEyOC5wbmcnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X2s2JyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnSzYnLFxuICAgICAgICAgICAgbHV0SW1hZ2U6ICdmaWx0ZXJzL2ltZ2x5X2x1dF9rNl81XzVfMTI4LnBuZydcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X2tkeW5hbWljJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnS0R5bmFtaWMnLFxuICAgICAgICAgICAgbHV0SW1hZ2U6ICdmaWx0ZXJzL2ltZ2x5X2x1dF9rZHluYW1pY181XzVfMTI4LnBuZydcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9sdXRfbHVjaWQnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdMdWNpZCcsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X2x1Y2lkXzVfNV8xMjgucG5nJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2x1dF9wYWxlJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnUGFsZScsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X3BhbGVfNV81XzEyOC5wbmcnXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfZmlsdGVyc19idycsXG4gICAgICAgIGRlZmF1bHROYW1lOiAnQmxhY2sgJiBXaGl0ZScsXG4gICAgICAgIGZpbHRlcnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X3NpbicsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ1NpbicsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X3Npbl84XzhfNTEyLnBuZycsXG4gICAgICAgICAgICByZXNvbHV0aW9uOiA1MTIsXG4gICAgICAgICAgICBob3Jpem9udGFsVGlsZUNvdW50OiA4LFxuICAgICAgICAgICAgdmVydGljYWxUaWxlQ291bnQ6IDhcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9sdXRfYWQxOTIwJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnMTkyMCBBLkQuJyxcbiAgICAgICAgICAgIGx1dEltYWdlOiAnZmlsdGVycy9pbWdseV9sdXRfYWQxOTIwXzVfNV8xMjgucG5nJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2x1dF9idycsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ0IgJiBXJyxcbiAgICAgICAgICAgIGx1dEltYWdlOiAnZmlsdGVycy9pbWdseV9sdXRfYndfNV81XzEyOC5wbmcnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X2xpdGhvJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnTGl0aG8nLFxuICAgICAgICAgICAgbHV0SW1hZ2U6ICdmaWx0ZXJzL2ltZ2x5X2x1dF9saXRob181XzVfMTI4LnBuZydcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9sdXRfcGxhdGUnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdQbGF0ZScsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X3BsYXRlXzVfNV8xMjgucG5nJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2x1dF94NDAwJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnWDQwMCcsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X3g0MDBfNV81XzEyOC5wbmcnXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfZmlsdGVyc19yZXRybycsXG4gICAgICAgIGRlZmF1bHROYW1lOiAnUmV0cm8nLFxuICAgICAgICBmaWx0ZXJzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2x1dF9jZWxzaXVzJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQ2Vsc2l1cycsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X2NlbHNpdXNfOF84XzUxMi5wbmcnLFxuICAgICAgICAgICAgcmVzb2x1dGlvbjogNTEyLFxuICAgICAgICAgICAgaG9yaXpvbnRhbFRpbGVDb3VudDogOCxcbiAgICAgICAgICAgIHZlcnRpY2FsVGlsZUNvdW50OiA4XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X2syJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnSzInLFxuICAgICAgICAgICAgbHV0SW1hZ2U6ICdmaWx0ZXJzL2ltZ2x5X2x1dF9rMl84XzhfNTEyLnBuZycsXG4gICAgICAgICAgICByZXNvbHV0aW9uOiA1MTIsXG4gICAgICAgICAgICBob3Jpem9udGFsVGlsZUNvdW50OiA4LFxuICAgICAgICAgICAgdmVydGljYWxUaWxlQ291bnQ6IDhcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9sdXRfc2VwaWFoaWdoJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnU2VwaWEgSGlnaCcsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X3NlcGlhaGlnaF81XzVfMTI4LnBuZydcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9sdXRfYW5jaWVudCcsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ0FuY2llbnQnLFxuICAgICAgICAgICAgbHV0SW1hZ2U6ICdmaWx0ZXJzL2ltZ2x5X2x1dF9hbmNpZW50XzVfNV8xMjgucG5nJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2x1dF9jbGFzc2ljJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQ2xhc3NpYycsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X2NsYXNzaWNfNV81XzEyOC5wbmcnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X2VpZ2h0aWVzJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnRWlnaHRpZXMnLFxuICAgICAgICAgICAgbHV0SW1hZ2U6ICdmaWx0ZXJzL2ltZ2x5X2x1dF9laWdodGllc181XzVfMTI4LnBuZydcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9sdXRfZWxkZXInLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdFbGRlcicsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X2VsZGVyXzVfNV8xMjgucG5nJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2x1dF9nbGFtJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnR2xhbScsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X2dsYW1fNV81XzEyOC5wbmcnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X2dvYmJsaW4nLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdHb2JibGluJyxcbiAgICAgICAgICAgIGx1dEltYWdlOiAnZmlsdGVycy9pbWdseV9sdXRfZ29iYmxpbl81XzVfMTI4LnBuZydcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9sdXRfb3JjaGlkJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnT3JjaGlkJyxcbiAgICAgICAgICAgIGx1dEltYWdlOiAnZmlsdGVycy9pbWdseV9sdXRfb3JjaGlkXzVfNV8xMjgucG5nJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2x1dF9zZXZlbnRpZXMnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdTZXZlbnRpZXMnLFxuICAgICAgICAgICAgbHV0SW1hZ2U6ICdmaWx0ZXJzL2ltZ2x5X2x1dF9zZXZlbnRpZXNfNV81XzEyOC5wbmcnXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfZmlsdGVyc19zcGVjaWFsJyxcbiAgICAgICAgZGVmYXVsdE5hbWU6ICdTcGVjaWFsJyxcbiAgICAgICAgZmlsdGVyczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9sdXRfZml4aWUnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdGaXhpZScsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X2ZpeGllXzhfOF81MTIucG5nJyxcbiAgICAgICAgICAgIHJlc29sdXRpb246IDUxMixcbiAgICAgICAgICAgIGhvcml6b250YWxUaWxlQ291bnQ6IDgsXG4gICAgICAgICAgICB2ZXJ0aWNhbFRpbGVDb3VudDogOFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2x1dF9jb2xvcmZ1bCcsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ0NvbG9yZnVsJyxcbiAgICAgICAgICAgIGx1dEltYWdlOiAnZmlsdGVycy9pbWdseV9sdXRfY29sb3JmdWxfNV81XzEyOC5wbmcnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X2NvdHRvbmNhbmR5JyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQ290dG9uIENhbmR5JyxcbiAgICAgICAgICAgIGx1dEltYWdlOiAnZmlsdGVycy9pbWdseV9sdXRfY290dG9uY2FuZHlfNV81XzEyOC5wbmcnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X2Zvb2QnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdGb29kJyxcbiAgICAgICAgICAgIGx1dEltYWdlOiAnZmlsdGVycy9pbWdseV9sdXRfZm9vZF81XzVfMTI4LnBuZydcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9sdXRfaGlnaGNvbnRyYXN0JyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnSGlnaCBDb250cmFzdCcsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X2hpZ2hjb250cmFzdF81XzVfMTI4LnBuZydcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9sdXRfazEnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdLMScsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X2sxXzVfNV8xMjgucG5nJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2x1dF9sb21vMTAwJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnTG9tbyAxMDAnLFxuICAgICAgICAgICAgbHV0SW1hZ2U6ICdmaWx0ZXJzL2ltZ2x5X2x1dF9sb21vMTAwXzVfNV8xMjgucG5nJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2x1dF9uZWF0JyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnTmVhdCcsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X25lYXRfNV81XzEyOC5wbmcnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X25vZ3JlZW4nLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdObyBHcmVlbicsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X25vZ3JlZW5fNV81XzEyOC5wbmcnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X3BvbGE2NjknLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdQb2xhIDY2OScsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X3BvbGE2NjlfNV81XzEyOC5wbmcnXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2x1dF9wb2xhc3gnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdQb2xhIFNYJyxcbiAgICAgICAgICAgIGx1dEltYWdlOiAnZmlsdGVycy9pbWdseV9sdXRfcG9sYXN4XzVfNV8xMjgucG5nJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2x1dF9wcm80MDAnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdQcm8gNDAwJyxcbiAgICAgICAgICAgIGx1dEltYWdlOiAnZmlsdGVycy9pbWdseV9sdXRfcHJvNDAwXzVfNV8xMjgucG5nJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2x1dF90d2lsaWdodCcsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ1R3aWxpZ2h0JyxcbiAgICAgICAgICAgIGx1dEltYWdlOiAnZmlsdGVycy9pbWdseV9sdXRfdHdpbGlnaHRfNV81XzEyOC5wbmcnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X3NldHRsZWQnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdTZXR0bGVkJyxcbiAgICAgICAgICAgIGx1dEltYWdlOiAnZmlsdGVycy9pbWdseV9sdXRfc2V0dGxlZF81XzVfMTI4LnBuZydcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9sdXRfc3RlZWwnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdTdGVlbCcsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X3N0ZWVsXzVfNV8xMjgucG5nJ1xuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2ZpbHRlcnNfc3VtbWVyJyxcbiAgICAgICAgZGVmYXVsdE5hbWU6ICdTdW1tZXInLFxuICAgICAgICBmaWx0ZXJzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2x1dF90ZXhhcycsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ1RleGFzJyxcbiAgICAgICAgICAgIGx1dEltYWdlOiAnZmlsdGVycy9pbWdseV9sdXRfdGV4YXNfOF84XzUxMi5wbmcnLFxuICAgICAgICAgICAgcmVzb2x1dGlvbjogNTEyLFxuICAgICAgICAgICAgaG9yaXpvbnRhbFRpbGVDb3VudDogOCxcbiAgICAgICAgICAgIHZlcnRpY2FsVGlsZUNvdW50OiA4XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X21lbGxvdycsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ01lbGxvdycsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X21lbGxvd184XzhfNTEyLnBuZycsXG4gICAgICAgICAgICByZXNvbHV0aW9uOiA1MTIsXG4gICAgICAgICAgICBob3Jpem9udGFsVGlsZUNvdW50OiA4LFxuICAgICAgICAgICAgdmVydGljYWxUaWxlQ291bnQ6IDhcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9sdXRfY2hlc3QnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdDaGVzdCcsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X2NoZXN0XzhfOF81MTIucG5nJyxcbiAgICAgICAgICAgIHJlc29sdXRpb246IDUxMixcbiAgICAgICAgICAgIGhvcml6b250YWxUaWxlQ291bnQ6IDgsXG4gICAgICAgICAgICB2ZXJ0aWNhbFRpbGVDb3VudDogOFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2x1dF9jcmVhbXknLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdDcmVhbXknLFxuICAgICAgICAgICAgbHV0SW1hZ2U6ICdmaWx0ZXJzL2ltZ2x5X2x1dF9jcmVhbXlfNV81XzEyOC5wbmcnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X2V2ZW5pbmcnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdFdmVuaW5nJyxcbiAgICAgICAgICAgIGx1dEltYWdlOiAnZmlsdGVycy9pbWdseV9sdXRfZXZlbmluZ181XzVfMTI4LnBuZydcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9sdXRfZmFsbCcsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ0ZhbGwnLFxuICAgICAgICAgICAgbHV0SW1hZ2U6ICdmaWx0ZXJzL2ltZ2x5X2x1dF9mYWxsXzVfNV8xMjgucG5nJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2x1dF9mcm9udCcsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ0Zyb250JyxcbiAgICAgICAgICAgIGx1dEltYWdlOiAnZmlsdGVycy9pbWdseV9sdXRfZnJvbnRfOF84XzUxMi5wbmcnLFxuICAgICAgICAgICAgcmVzb2x1dGlvbjogNTEyLFxuICAgICAgICAgICAgaG9yaXpvbnRhbFRpbGVDb3VudDogOCxcbiAgICAgICAgICAgIHZlcnRpY2FsVGlsZUNvdW50OiA4XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X2hpZ2hjYXJiJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnSGlnaCBDYXJiJyxcbiAgICAgICAgICAgIGx1dEltYWdlOiAnZmlsdGVycy9pbWdseV9sdXRfaGlnaGNhcmJfNV81XzEyOC5wbmcnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X2tlZW4nLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdLZWVuJyxcbiAgICAgICAgICAgIGx1dEltYWdlOiAnZmlsdGVycy9pbWdseV9sdXRfa2Vlbl81XzVfMTI4LnBuZydcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9sdXRfcGl0Y2hlZCcsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ1BpdGNoZWQnLFxuICAgICAgICAgICAgbHV0SW1hZ2U6ICdmaWx0ZXJzL2ltZ2x5X2x1dF9waXRjaGVkXzVfNV8xMjgucG5nJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2x1dF9zb2Z0JyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnU29mdCcsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X3NvZnRfNV81XzEyOC5wbmcnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X3N1bW1lcicsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ1N1bW1lcicsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X3N1bW1lcl81XzVfMTI4LnBuZydcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9sdXRfc3Vuc2V0JyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnU3Vuc2V0JyxcbiAgICAgICAgICAgIGx1dEltYWdlOiAnZmlsdGVycy9pbWdseV9sdXRfc3Vuc2V0XzVfNV8xMjgucG5nJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2x1dF90ZW5kZXInLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdUZW5kZXInLFxuICAgICAgICAgICAgbHV0SW1hZ2U6ICdmaWx0ZXJzL2ltZ2x5X2x1dF90ZW5kZXJfNV81XzEyOC5wbmcnXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfZmlsdGVyc193aW50ZXInLFxuICAgICAgICBkZWZhdWx0TmFtZTogJ1dpbnRlcicsXG4gICAgICAgIGZpbHRlcnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X2ZyaWRnZScsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ0ZyaWRnZScsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X2ZyaWRnZV84XzhfNTEyLnBuZycsXG4gICAgICAgICAgICByZXNvbHV0aW9uOiA1MTIsXG4gICAgICAgICAgICBob3Jpem9udGFsVGlsZUNvdW50OiA4LFxuICAgICAgICAgICAgdmVydGljYWxUaWxlQ291bnQ6IDhcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9sdXRfYmxlYWNoZWQnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdCbGVhY2hlZCcsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X2JsZWFjaGVkXzVfNV8xMjgucG5nJ1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9sdXRfYmxlYWNoZWRibHVlJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQmxlYWNoZWQgQmx1ZScsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X2JsZWFjaGVkYmx1ZV81XzVfMTI4LnBuZydcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X2JyZWV6ZScsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ0JyZWV6ZScsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X2JyZWV6ZV81XzVfMTI4LnBuZydcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X2xlbmluJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnTGVuaW4nLFxuICAgICAgICAgICAgbHV0SW1hZ2U6ICdmaWx0ZXJzL2ltZ2x5X2x1dF9sZW5pbl81XzVfMTI4LnBuZydcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X3F1b3ppJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnUXVvemknLFxuICAgICAgICAgICAgbHV0SW1hZ2U6ICdmaWx0ZXJzL2ltZ2x5X2x1dF9xdW96aV81XzVfMTI4LnBuZydcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfbHV0X3dpbnRlcicsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ1dpbnRlcicsXG4gICAgICAgICAgICBsdXRJbWFnZTogJ2ZpbHRlcnMvaW1nbHlfbHV0X3dpbnRlcl81XzVfMTI4LnBuZydcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdLFxuICAgIE9WRVJMQVlTOiBbXG4gICAgICB7XG4gICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9vdmVybGF5X2dvbGRlbicsXG4gICAgICAgIGRlZmF1bHROYW1lOiAnR29sZGVuJyxcbiAgICAgICAgaW1hZ2U6ICdvdmVybGF5cy9pbWdseV9vdmVybGF5X2dvbGRlbi5qcGcnLFxuICAgICAgICB0aHVtYm5haWw6ICdvdmVybGF5cy9pbWdseV9vdmVybGF5X2dvbGRlbl90aHVtYi5qcGcnLFxuICAgICAgICBibGVuZE1vZGU6ICdsaWdodGVuJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X292ZXJsYXlfYm9rZWgnLFxuICAgICAgICBkZWZhdWx0TmFtZTogJ0Jva2VoJyxcbiAgICAgICAgaW1hZ2U6ICdvdmVybGF5cy9pbWdseV9vdmVybGF5X2Jva2VoLmpwZycsXG4gICAgICAgIHRodW1ibmFpbDogJ292ZXJsYXlzL2ltZ2x5X292ZXJsYXlfYm9rZWhfdGh1bWIuanBnJyxcbiAgICAgICAgYmxlbmRNb2RlOiAnbGlnaHRlbidcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9vdmVybGF5X2hlYXJ0cycsXG4gICAgICAgIGRlZmF1bHROYW1lOiAnSGVhcnRzJyxcbiAgICAgICAgaW1hZ2U6ICdvdmVybGF5cy9pbWdseV9vdmVybGF5X2hlYXJ0cy5qcGcnLFxuICAgICAgICB0aHVtYm5haWw6ICdvdmVybGF5cy9pbWdseV9vdmVybGF5X2hlYXJ0c190aHVtYi5qcGcnLFxuICAgICAgICBibGVuZE1vZGU6ICdzY3JlZW4nXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfb3ZlcmxheV9saWdodGxlYWsxJyxcbiAgICAgICAgZGVmYXVsdE5hbWU6ICdMaWdodCBMZWFrJyxcbiAgICAgICAgaW1hZ2U6ICdvdmVybGF5cy9pbWdseV9vdmVybGF5X2xpZ2h0bGVhazEuanBnJyxcbiAgICAgICAgdGh1bWJuYWlsOiAnb3ZlcmxheXMvaW1nbHlfb3ZlcmxheV9saWdodGxlYWsxX3RodW1iLmpwZycsXG4gICAgICAgIGJsZW5kTW9kZTogJ3NjcmVlbidcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9vdmVybGF5X2xpZ2h0bGVhazInLFxuICAgICAgICBkZWZhdWx0TmFtZTogJ0xpZ2h0IExlYWsgMicsXG4gICAgICAgIGltYWdlOiAnb3ZlcmxheXMvaW1nbHlfb3ZlcmxheV9saWdodGxlYWsyLmpwZycsXG4gICAgICAgIHRodW1ibmFpbDogJ292ZXJsYXlzL2ltZ2x5X292ZXJsYXlfbGlnaHRsZWFrMl90aHVtYi5qcGcnLFxuICAgICAgICBibGVuZE1vZGU6ICdsaWdodGVuJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X292ZXJsYXlfcmFpbicsXG4gICAgICAgIGRlZmF1bHROYW1lOiAnUmFpbicsXG4gICAgICAgIGltYWdlOiAnb3ZlcmxheXMvaW1nbHlfb3ZlcmxheV9yYWluLmpwZycsXG4gICAgICAgIHRodW1ibmFpbDogJ292ZXJsYXlzL2ltZ2x5X292ZXJsYXlfcmFpbl90aHVtYi5qcGcnLFxuICAgICAgICBibGVuZE1vZGU6ICdvdmVybGF5J1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X292ZXJsYXlfd29vZCcsXG4gICAgICAgIGRlZmF1bHROYW1lOiAnV29vZCcsXG4gICAgICAgIGltYWdlOiAnb3ZlcmxheXMvaW1nbHlfb3ZlcmxheV93b29kLmpwZycsXG4gICAgICAgIHRodW1ibmFpbDogJ292ZXJsYXlzL2ltZ2x5X292ZXJsYXlfd29vZF90aHVtYi5qcGcnLFxuICAgICAgICBibGVuZE1vZGU6ICdtdWx0aXBseSdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9vdmVybGF5X21vc2FpYycsXG4gICAgICAgIGRlZmF1bHROYW1lOiAnTW9zYWljJyxcbiAgICAgICAgaW1hZ2U6ICdvdmVybGF5cy9pbWdseV9vdmVybGF5X21vc2FpYy5qcGcnLFxuICAgICAgICB0aHVtYm5haWw6ICdvdmVybGF5cy9pbWdseV9vdmVybGF5X21vc2FpY190aHVtYi5qcGcnLFxuICAgICAgICBibGVuZE1vZGU6ICdtdWx0aXBseSdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9vdmVybGF5X2Nob3AnLFxuICAgICAgICBkZWZhdWx0TmFtZTogJ0Nob3AnLFxuICAgICAgICBpbWFnZTogJ292ZXJsYXlzL2ltZ2x5X292ZXJsYXlfY2hvcC5qcGcnLFxuICAgICAgICB0aHVtYm5haWw6ICdvdmVybGF5cy9pbWdseV9vdmVybGF5X2Nob3BfdGh1bWIuanBnJyxcbiAgICAgICAgYmxlbmRNb2RlOiAnbXVsdGlwbHknXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfb3ZlcmxheV92aW50YWdlJyxcbiAgICAgICAgZGVmYXVsdE5hbWU6ICdWaW50YWdlJyxcbiAgICAgICAgaW1hZ2U6ICdvdmVybGF5cy9pbWdseV9vdmVybGF5X3ZpbnRhZ2UuanBnJyxcbiAgICAgICAgdGh1bWJuYWlsOiAnb3ZlcmxheXMvaW1nbHlfb3ZlcmxheV92aW50YWdlX3RodW1iLmpwZycsXG4gICAgICAgIGJsZW5kTW9kZTogJ2RhcmtlbidcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9vdmVybGF5X21ldGFsJyxcbiAgICAgICAgZGVmYXVsdE5hbWU6ICdNZXRhbCcsXG4gICAgICAgIGltYWdlOiAnb3ZlcmxheXMvaW1nbHlfb3ZlcmxheV9tZXRhbC5qcGcnLFxuICAgICAgICB0aHVtYm5haWw6ICdvdmVybGF5cy9pbWdseV9vdmVybGF5X21ldGFsX3RodW1iLmpwZycsXG4gICAgICAgIGJsZW5kTW9kZTogJ292ZXJsYXknXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfb3ZlcmxheV9wYXBlcicsXG4gICAgICAgIGRlZmF1bHROYW1lOiAnUGFwZXInLFxuICAgICAgICBpbWFnZTogJ292ZXJsYXlzL2ltZ2x5X292ZXJsYXlfcGFwZXIuanBnJyxcbiAgICAgICAgdGh1bWJuYWlsOiAnb3ZlcmxheXMvaW1nbHlfb3ZlcmxheV9wYXBlcl90aHVtYi5qcGcnLFxuICAgICAgICBibGVuZE1vZGU6ICdtdWx0aXBseSdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9vdmVybGF5X3BhaW50aW5nJyxcbiAgICAgICAgZGVmYXVsdE5hbWU6ICdQYWludGluZycsXG4gICAgICAgIGltYWdlOiAnb3ZlcmxheXMvaW1nbHlfb3ZlcmxheV9wYWludGluZy5qcGcnLFxuICAgICAgICB0aHVtYm5haWw6ICdvdmVybGF5cy9pbWdseV9vdmVybGF5X3BhaW50aW5nX3RodW1iLmpwZycsXG4gICAgICAgIGJsZW5kTW9kZTogJ292ZXJsYXknXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfb3ZlcmxheV9ncmFpbicsXG4gICAgICAgIGRlZmF1bHROYW1lOiAnR3JhaW4nLFxuICAgICAgICBpbWFnZTogJ292ZXJsYXlzL2ltZ2x5X292ZXJsYXlfZ3JhaW4uanBnJyxcbiAgICAgICAgdGh1bWJuYWlsOiAnb3ZlcmxheXMvaW1nbHlfb3ZlcmxheV9ncmFpbl90aHVtYi5qcGcnLFxuICAgICAgICBibGVuZE1vZGU6ICdvdmVybGF5J1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X292ZXJsYXlfY2xvdWRzJyxcbiAgICAgICAgZGVmYXVsdE5hbWU6ICdDbG91ZHMnLFxuICAgICAgICBpbWFnZTogJ292ZXJsYXlzL2ltZ2x5X292ZXJsYXlfY2xvdWRzLmpwZycsXG4gICAgICAgIHRodW1ibmFpbDogJ292ZXJsYXlzL2ltZ2x5X292ZXJsYXlfY2xvdWRzX3RodW1iLmpwZycsXG4gICAgICAgIGJsZW5kTW9kZTogJ3NvZnRMaWdodCdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9vdmVybGF5X3dhbGwxJyxcbiAgICAgICAgZGVmYXVsdE5hbWU6ICdXYWxsJyxcbiAgICAgICAgaW1hZ2U6ICdvdmVybGF5cy9pbWdseV9vdmVybGF5X3dhbGwxLmpwZycsXG4gICAgICAgIHRodW1ibmFpbDogJ292ZXJsYXlzL2ltZ2x5X292ZXJsYXlfd2FsbDFfdGh1bWIuanBnJyxcbiAgICAgICAgYmxlbmRNb2RlOiAnbGlnaHRlbidcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9vdmVybGF5X3dhbGwyJyxcbiAgICAgICAgZGVmYXVsdE5hbWU6ICdXYWxsIDInLFxuICAgICAgICBpbWFnZTogJ292ZXJsYXlzL2ltZ2x5X292ZXJsYXlfd2FsbDIuanBnJyxcbiAgICAgICAgdGh1bWJuYWlsOiAnb3ZlcmxheXMvaW1nbHlfb3ZlcmxheV93YWxsMl90aHVtYi5qcGcnLFxuICAgICAgICBibGVuZE1vZGU6ICdvdmVybGF5J1xuICAgICAgfVxuICAgIF0sXG4gICAgRlJBTUVfQ0FURUdPUklFUzogW1xuICAgICAge1xuICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfZnJhbWVfZ2VuZXJpYycsXG4gICAgICAgIGRlZmF1bHROYW1lOiAnR2VuZXJpYycsXG4gICAgICAgIG1ldGFEYXRhOiB7XG4gICAgICAgICAgYmFja2dyb3VuZEltYWdlOiAnZnJhbWVzL2dlbmVyaWMucG5nJyAvLyBOb3QgdXNlZCB5ZXRcbiAgICAgICAgfSxcbiAgICAgICAgZnJhbWVzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2ZyYW1lX2RpYScsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ0RpYScsXG4gICAgICAgICAgICBsYXlvdXRNb2RlOiAnaG9yaXpvbnRhbC1pbnNpZGUnLFxuICAgICAgICAgICAgdGh1bWJuYWlsOiAnZnJhbWVzL2ltZ2x5X2ZyYW1lX2RpYS9pbWdseV9mcmFtZV9kaWFfdGh1bWIucG5nJyxcbiAgICAgICAgICAgIGltYWdlR3JvdXBzOiB7XG4gICAgICAgICAgICAgIHRvcDoge1xuICAgICAgICAgICAgICAgIG1pZDoge1xuICAgICAgICAgICAgICAgICAgaW1hZ2U6ICdmcmFtZXMvaW1nbHlfZnJhbWVfZGlhL2ltZ2x5X2ZyYW1lX2RpYV90b3AucG5nJyxcbiAgICAgICAgICAgICAgICAgIG1vZGU6ICdyZXBlYXQnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBsZWZ0OiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6ICdmcmFtZXMvaW1nbHlfZnJhbWVfZGlhL2ltZ2x5X2ZyYW1lX2RpYV90b3BfY29ybmVyX2xlZnQucG5nJyxcbiAgICAgICAgICAgICAgICBtaWQ6ICdmcmFtZXMvaW1nbHlfZnJhbWVfZGlhL2ltZ2x5X2ZyYW1lX2RpYV9sZWZ0LnBuZycsXG4gICAgICAgICAgICAgICAgZW5kOiAnZnJhbWVzL2ltZ2x5X2ZyYW1lX2RpYS9pbWdseV9mcmFtZV9kaWFfYm90dG9tX2Nvcm5lcl9sZWZ0LnBuZydcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmlnaHQ6IHtcbiAgICAgICAgICAgICAgICBzdGFydDogJ2ZyYW1lcy9pbWdseV9mcmFtZV9kaWEvaW1nbHlfZnJhbWVfZGlhX3RvcF9jb3JuZXJfcmlnaHQucG5nJyxcbiAgICAgICAgICAgICAgICBtaWQ6ICdmcmFtZXMvaW1nbHlfZnJhbWVfZGlhL2ltZ2x5X2ZyYW1lX2RpYV9yaWdodC5wbmcnLFxuICAgICAgICAgICAgICAgIGVuZDogJ2ZyYW1lcy9pbWdseV9mcmFtZV9kaWEvaW1nbHlfZnJhbWVfZGlhX2JvdHRvbV9jb3JuZXJfcmlnaHQucG5nJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBib3R0b206IHtcbiAgICAgICAgICAgICAgICBtaWQ6IHtcbiAgICAgICAgICAgICAgICAgIGltYWdlOiAnZnJhbWVzL2ltZ2x5X2ZyYW1lX2RpYS9pbWdseV9mcmFtZV9kaWFfYm90dG9tLnBuZycsXG4gICAgICAgICAgICAgICAgICBtb2RlOiAncmVwZWF0J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2ZyYW1lX2FydF9kZWNvcicsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ0FydCBEZWNvcicsXG4gICAgICAgICAgICB0aW50YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGxheW91dE1vZGU6ICdob3Jpem9udGFsLWluc2lkZScsXG4gICAgICAgICAgICB0aHVtYm5haWw6ICdmcmFtZXMvaW1nbHlfZnJhbWVfYXJ0X2RlY29yL2ltZ2x5X2ZyYW1lX2FydF9kZWNvcl90aHVtYi5wbmcnLFxuICAgICAgICAgICAgaW1hZ2VHcm91cHM6IHtcbiAgICAgICAgICAgICAgdG9wOiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6ICdmcmFtZXMvaW1nbHlfZnJhbWVfYXJ0X2RlY29yL2ltZ2x5X2ZyYW1lX2FydF9kZWNvcl90b3BfY29ybmVyX2xlZnQucG5nJyxcbiAgICAgICAgICAgICAgICBtaWQ6IHtcbiAgICAgICAgICAgICAgICAgIGltYWdlOiAnZnJhbWVzL2ltZ2x5X2ZyYW1lX2FydF9kZWNvci9pbWdseV9mcmFtZV9hcnRfZGVjb3JfdG9wLnBuZycsXG4gICAgICAgICAgICAgICAgICBtb2RlOiAnc3RyZXRjaCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVuZDogJ2ZyYW1lcy9pbWdseV9mcmFtZV9hcnRfZGVjb3IvaW1nbHlfZnJhbWVfYXJ0X2RlY29yX3RvcF9jb3JuZXJfcmlnaHQucG5nJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBsZWZ0OiB7XG4gICAgICAgICAgICAgICAgbWlkOiB7XG4gICAgICAgICAgICAgICAgICBpbWFnZTogJ2ZyYW1lcy9pbWdseV9mcmFtZV9hcnRfZGVjb3IvaW1nbHlfZnJhbWVfYXJ0X2RlY29yX2xlZnQucG5nJyxcbiAgICAgICAgICAgICAgICAgIG1vZGU6ICdzdHJldGNoJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmlnaHQ6IHtcbiAgICAgICAgICAgICAgICBtaWQ6IHtcbiAgICAgICAgICAgICAgICAgIGltYWdlOiAnZnJhbWVzL2ltZ2x5X2ZyYW1lX2FydF9kZWNvci9pbWdseV9mcmFtZV9hcnRfZGVjb3JfcmlnaHQucG5nJyxcbiAgICAgICAgICAgICAgICAgIG1vZGU6ICdzdHJldGNoJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYm90dG9tOiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6ICdmcmFtZXMvaW1nbHlfZnJhbWVfYXJ0X2RlY29yL2ltZ2x5X2ZyYW1lX2FydF9kZWNvcl9ib3R0b21fY29ybmVyX2xlZnQucG5nJyxcbiAgICAgICAgICAgICAgICBtaWQ6IHtcbiAgICAgICAgICAgICAgICAgIGltYWdlOiAnZnJhbWVzL2ltZ2x5X2ZyYW1lX2FydF9kZWNvci9pbWdseV9mcmFtZV9hcnRfZGVjb3JfYm90dG9tLnBuZycsXG4gICAgICAgICAgICAgICAgICBtb2RlOiAnc3RyZXRjaCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVuZDogJ2ZyYW1lcy9pbWdseV9mcmFtZV9hcnRfZGVjb3IvaW1nbHlfZnJhbWVfYXJ0X2RlY29yX2JvdHRvbV9jb3JuZXJfcmlnaHQucG5nJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfZnJhbWVfYmxhY2tfcGFzc2VwYXJ0b3V0JyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQmxhY2sgUGFzc2VwYXJ0b3V0JyxcbiAgICAgICAgICAgIGxheW91dE1vZGU6ICdob3Jpem9udGFsLWluc2lkZScsXG4gICAgICAgICAgICB0aHVtYm5haWw6ICdmcmFtZXMvaW1nbHlfZnJhbWVfYmxhY2tfcGFzc2VwYXJ0b3V0L2ltZ2x5X2ZyYW1lX2JsYWNrX3Bhc3NlcGFydG91dF90aHVtYi5wbmcnLFxuICAgICAgICAgICAgaW1hZ2VHcm91cHM6IHtcbiAgICAgICAgICAgICAgdG9wOiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6ICdmcmFtZXMvaW1nbHlfZnJhbWVfYmxhY2tfcGFzc2VwYXJ0b3V0L2ltZ2x5X2ZyYW1lX2JsYWNrX3Bhc3NlcGFydG91dF90b3BfY29ybmVyX2xlZnQucG5nJyxcbiAgICAgICAgICAgICAgICBtaWQ6IHtcbiAgICAgICAgICAgICAgICAgIGltYWdlOiAnZnJhbWVzL2ltZ2x5X2ZyYW1lX2JsYWNrX3Bhc3NlcGFydG91dC9pbWdseV9mcmFtZV9ibGFja19wYXNzZXBhcnRvdXRfdG9wLnBuZycsXG4gICAgICAgICAgICAgICAgICBtb2RlOiAnc3RyZXRjaCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVuZDogJ2ZyYW1lcy9pbWdseV9mcmFtZV9ibGFja19wYXNzZXBhcnRvdXQvaW1nbHlfZnJhbWVfYmxhY2tfcGFzc2VwYXJ0b3V0X3RvcF9jb3JuZXJfcmlnaHQucG5nJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBsZWZ0OiB7XG4gICAgICAgICAgICAgICAgbWlkOiB7XG4gICAgICAgICAgICAgICAgICBpbWFnZTogJ2ZyYW1lcy9pbWdseV9mcmFtZV9ibGFja19wYXNzZXBhcnRvdXQvaW1nbHlfZnJhbWVfYmxhY2tfcGFzc2VwYXJ0b3V0X2xlZnQucG5nJyxcbiAgICAgICAgICAgICAgICAgIG1vZGU6ICdzdHJldGNoJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmlnaHQ6IHtcbiAgICAgICAgICAgICAgICBtaWQ6IHtcbiAgICAgICAgICAgICAgICAgIGltYWdlOiAnZnJhbWVzL2ltZ2x5X2ZyYW1lX2JsYWNrX3Bhc3NlcGFydG91dC9pbWdseV9mcmFtZV9ibGFja19wYXNzZXBhcnRvdXRfcmlnaHQucG5nJyxcbiAgICAgICAgICAgICAgICAgIG1vZGU6ICdzdHJldGNoJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYm90dG9tOiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6ICdmcmFtZXMvaW1nbHlfZnJhbWVfYmxhY2tfcGFzc2VwYXJ0b3V0L2ltZ2x5X2ZyYW1lX2JsYWNrX3Bhc3NlcGFydG91dF9ib3R0b21fY29ybmVyX2xlZnQucG5nJyxcbiAgICAgICAgICAgICAgICBtaWQ6IHtcbiAgICAgICAgICAgICAgICAgIGltYWdlOiAnZnJhbWVzL2ltZ2x5X2ZyYW1lX2JsYWNrX3Bhc3NlcGFydG91dC9pbWdseV9mcmFtZV9ibGFja19wYXNzZXBhcnRvdXRfYm90dG9tLnBuZycsXG4gICAgICAgICAgICAgICAgICBtb2RlOiAnc3RyZXRjaCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVuZDogJ2ZyYW1lcy9pbWdseV9mcmFtZV9ibGFja19wYXNzZXBhcnRvdXQvaW1nbHlfZnJhbWVfYmxhY2tfcGFzc2VwYXJ0b3V0X2JvdHRvbV9jb3JuZXJfcmlnaHQucG5nJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfZnJhbWVfbG93cG9seV9zaGFkb3cnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdMb3cgUG9seScsXG4gICAgICAgICAgICBsYXlvdXRNb2RlOiAnaG9yaXpvbnRhbC1pbnNpZGUnLFxuICAgICAgICAgICAgdGh1bWJuYWlsOiAnZnJhbWVzL2ltZ2x5X2ZyYW1lX2xvd3BvbHlfc2hhZG93L2ltZ2x5X2ZyYW1lX2xvd3BvbHlfc2hhZG93X3RodW1iLnBuZycsXG4gICAgICAgICAgICBpbWFnZUdyb3Vwczoge1xuICAgICAgICAgICAgICB0b3A6IHtcbiAgICAgICAgICAgICAgICBzdGFydDogJ2ZyYW1lcy9pbWdseV9mcmFtZV9sb3dwb2x5X3NoYWRvdy9pbWdseV9mcmFtZV9sb3dwb2x5X3NoYWRvd190b3BfY29ybmVyX2xlZnQucG5nJyxcbiAgICAgICAgICAgICAgICBtaWQ6IHtcbiAgICAgICAgICAgICAgICAgIGltYWdlOiAnZnJhbWVzL2ltZ2x5X2ZyYW1lX2xvd3BvbHlfc2hhZG93L2ltZ2x5X2ZyYW1lX2xvd3BvbHlfc2hhZG93X3RvcC5wbmcnLFxuICAgICAgICAgICAgICAgICAgbW9kZTogJ3N0cmV0Y2gnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbmQ6ICdmcmFtZXMvaW1nbHlfZnJhbWVfbG93cG9seV9zaGFkb3cvaW1nbHlfZnJhbWVfbG93cG9seV9zaGFkb3dfdG9wX2Nvcm5lcl9yaWdodC5wbmcnXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGxlZnQ6IHtcbiAgICAgICAgICAgICAgICBtaWQ6IHtcbiAgICAgICAgICAgICAgICAgIGltYWdlOiAnZnJhbWVzL2ltZ2x5X2ZyYW1lX2xvd3BvbHlfc2hhZG93L2ltZ2x5X2ZyYW1lX2xvd3BvbHlfc2hhZG93X2xlZnQucG5nJyxcbiAgICAgICAgICAgICAgICAgIG1vZGU6ICdzdHJldGNoJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmlnaHQ6IHtcbiAgICAgICAgICAgICAgICBtaWQ6IHtcbiAgICAgICAgICAgICAgICAgIGltYWdlOiAnZnJhbWVzL2ltZ2x5X2ZyYW1lX2xvd3BvbHlfc2hhZG93L2ltZ2x5X2ZyYW1lX2xvd3BvbHlfc2hhZG93X3JpZ2h0LnBuZycsXG4gICAgICAgICAgICAgICAgICBtb2RlOiAnc3RyZXRjaCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGJvdHRvbToge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiAnZnJhbWVzL2ltZ2x5X2ZyYW1lX2xvd3BvbHlfc2hhZG93L2ltZ2x5X2ZyYW1lX2xvd3BvbHlfc2hhZG93X2JvdHRvbV9jb3JuZXJfbGVmdC5wbmcnLFxuICAgICAgICAgICAgICAgIG1pZDoge1xuICAgICAgICAgICAgICAgICAgaW1hZ2U6ICdmcmFtZXMvaW1nbHlfZnJhbWVfbG93cG9seV9zaGFkb3cvaW1nbHlfZnJhbWVfbG93cG9seV9zaGFkb3dfYm90dG9tLnBuZycsXG4gICAgICAgICAgICAgICAgICBtb2RlOiAnc3RyZXRjaCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVuZDogJ2ZyYW1lcy9pbWdseV9mcmFtZV9sb3dwb2x5X3NoYWRvdy9pbWdseV9mcmFtZV9sb3dwb2x5X3NoYWRvd19ib3R0b21fY29ybmVyX3JpZ2h0LnBuZydcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2ZyYW1lX3dvb2RfcGFzc2VwYXJ0b3V0JyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnV29vZCBQYXNzZXBhcnRvdXQnLFxuICAgICAgICAgICAgbGF5b3V0TW9kZTogJ2hvcml6b250YWwtaW5zaWRlJyxcbiAgICAgICAgICAgIHRodW1ibmFpbDogJ2ZyYW1lcy9pbWdseV9mcmFtZV93b29kX3Bhc3NlcGFydG91dC9pbWdseV9mcmFtZV93b29kX3Bhc3NlcGFydG91dF90aHVtYi5wbmcnLFxuICAgICAgICAgICAgaW1hZ2VHcm91cHM6IHtcbiAgICAgICAgICAgICAgdG9wOiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6ICdmcmFtZXMvaW1nbHlfZnJhbWVfd29vZF9wYXNzZXBhcnRvdXQvaW1nbHlfZnJhbWVfd29vZF9wYXNzZXBhcnRvdXRfdG9wX2Nvcm5lcl9sZWZ0LnBuZycsXG4gICAgICAgICAgICAgICAgbWlkOiB7XG4gICAgICAgICAgICAgICAgICBpbWFnZTogJ2ZyYW1lcy9pbWdseV9mcmFtZV93b29kX3Bhc3NlcGFydG91dC9pbWdseV9mcmFtZV93b29kX3Bhc3NlcGFydG91dF90b3AucG5nJyxcbiAgICAgICAgICAgICAgICAgIG1vZGU6ICdzdHJldGNoJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5kOiAnZnJhbWVzL2ltZ2x5X2ZyYW1lX3dvb2RfcGFzc2VwYXJ0b3V0L2ltZ2x5X2ZyYW1lX3dvb2RfcGFzc2VwYXJ0b3V0X3RvcF9jb3JuZXJfcmlnaHQucG5nJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBsZWZ0OiB7XG4gICAgICAgICAgICAgICAgbWlkOiB7XG4gICAgICAgICAgICAgICAgICBpbWFnZTogJ2ZyYW1lcy9pbWdseV9mcmFtZV93b29kX3Bhc3NlcGFydG91dC9pbWdseV9mcmFtZV93b29kX3Bhc3NlcGFydG91dF9sZWZ0LnBuZycsXG4gICAgICAgICAgICAgICAgICBtb2RlOiAnc3RyZXRjaCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHJpZ2h0OiB7XG4gICAgICAgICAgICAgICAgbWlkOiB7XG4gICAgICAgICAgICAgICAgICBpbWFnZTogJ2ZyYW1lcy9pbWdseV9mcmFtZV93b29kX3Bhc3NlcGFydG91dC9pbWdseV9mcmFtZV93b29kX3Bhc3NlcGFydG91dF9yaWdodC5wbmcnLFxuICAgICAgICAgICAgICAgICAgbW9kZTogJ3N0cmV0Y2gnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBib3R0b206IHtcbiAgICAgICAgICAgICAgICBzdGFydDogJ2ZyYW1lcy9pbWdseV9mcmFtZV93b29kX3Bhc3NlcGFydG91dC9pbWdseV9mcmFtZV93b29kX3Bhc3NlcGFydG91dF9ib3R0b21fY29ybmVyX2xlZnQucG5nJyxcbiAgICAgICAgICAgICAgICBtaWQ6IHtcbiAgICAgICAgICAgICAgICAgIGltYWdlOiAnZnJhbWVzL2ltZ2x5X2ZyYW1lX3dvb2RfcGFzc2VwYXJ0b3V0L2ltZ2x5X2ZyYW1lX3dvb2RfcGFzc2VwYXJ0b3V0X2JvdHRvbS5wbmcnLFxuICAgICAgICAgICAgICAgICAgbW9kZTogJ3N0cmV0Y2gnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbmQ6ICdmcmFtZXMvaW1nbHlfZnJhbWVfd29vZF9wYXNzZXBhcnRvdXQvaW1nbHlfZnJhbWVfd29vZF9wYXNzZXBhcnRvdXRfYm90dG9tX2Nvcm5lcl9yaWdodC5wbmcnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdLFxuICAgIFNUSUNLRVJfQ0FURUdPUklFUzogW1xuICAgICAge1xuICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfc3RpY2tlcl9lbW90aWNvbnMnLFxuICAgICAgICBkZWZhdWx0TmFtZTogJ0Vtb3RpY29ucycsXG4gICAgICAgICdtZXRhRGF0YSc6IHtcbiAgICAgICAgICAnYmFja2dyb3VuZEltYWdlJzogJ3N0aWNrZXJzL2Vtb3RpY29ucy9iYWNrZ3JvdW5kLnBuZydcbiAgICAgICAgfSxcbiAgICAgICAgJ3N0aWNrZXJzJzogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19hbGllbicsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ0FsaWVuJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19hbGllbi5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYWxpZW4ucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDYyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNThcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVkaWFCYXNlOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19hbGllbi5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9iYXNlL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2FsaWVuLnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogOTM1XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19hbmdlbCcsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ0FuZ2VsJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19hbmdlbC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYW5nZWwucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDYyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjRcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVkaWFCYXNlOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19hbmdlbC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9iYXNlL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2FuZ2VsLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19hbmdyeScsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ0FuZ3J5JyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19hbmdyeS5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYW5ncnkucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDYyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVkaWFCYXNlOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19hbmdyeS5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9iYXNlL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2FuZ3J5LnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19hbnhpb3VzJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQW54aW91cycsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYW54aW91cy5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYW54aW91cy5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogNjIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1OFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2FueGlvdXMuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19hbnhpb3VzLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19hc2xlZXAnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdBc2xlZXAnLFxuICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgIG1lZGlhVGh1bWI6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2FzbGVlcC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYXNsZWVwLnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2MixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDU4XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYXNsZWVwLnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYXNsZWVwLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19hdHRlbnRpb24nLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdBdHRlbnRpb24nLFxuICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgIG1lZGlhVGh1bWI6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2F0dGVudGlvbi5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYXR0ZW50aW9uLnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2MixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDYwXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYXR0ZW50aW9uLnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYXR0ZW50aW9uLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19iYWJ5X2NoaWNrZW4nLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdCYWJ5IENoaWNrZW4nLFxuICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgIG1lZGlhVGh1bWI6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2JhYnlfY2hpY2tlbi5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYmFieV9jaGlja2VuLnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2MSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDQyXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYmFieV9jaGlja2VuLnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYmFieV9jaGlja2VuLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19iYXRtYW4nLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdCYXRtYW4nLFxuICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgIG1lZGlhVGh1bWI6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2JhdG1hbi5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYmF0bWFuLnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2MixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDU4XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYmF0bWFuLnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYmF0bWFuLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19iZWVyJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQmVlcicsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYmVlci5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYmVlci5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogNjIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1OVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2JlZXIuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19iZWVyLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19ibHVzaCcsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ0JsdXNoJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19ibHVzaC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYmx1c2gucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDYyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNThcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVkaWFCYXNlOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19ibHVzaC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9iYXNlL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2JsdXNoLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19ib3hlcicsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ0JveGVyJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19ib3hlci5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYm94ZXIucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDYyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVkaWFCYXNlOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19ib3hlci5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9iYXNlL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2JveGVyLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19idXNpbmVzcycsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ0J1c2luZXNzJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19idXNpbmVzcy5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfYnVzaW5lc3MucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDYwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjNcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVkaWFCYXNlOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19idXNpbmVzcy5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9iYXNlL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2J1c2luZXNzLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19jaGlja2VuJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQ2hpY2tlbicsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfY2hpY2tlbi5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfY2hpY2tlbi5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogNjMsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1NVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2NoaWNrZW4uc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19jaGlja2VuLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19jb29sJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQ29vbCcsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfY29vbC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfY29vbC5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogNjIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1OFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2Nvb2wuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19jb29sLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19jcnknLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdDcnknLFxuICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgIG1lZGlhVGh1bWI6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2NyeS5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfY3J5LnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2MixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDU4XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfY3J5LnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfY3J5LnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19kZWNlYXNlZCcsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ0RlY2Vhc2VkJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19kZWNlYXNlZC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfZGVjZWFzZWQucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDYyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNThcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVkaWFCYXNlOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19kZWNlYXNlZC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9iYXNlL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2RlY2Vhc2VkLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19kZXZpbCcsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ0RldmlsJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19kZXZpbC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfZGV2aWwucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDYyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNThcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVkaWFCYXNlOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19kZXZpbC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9iYXNlL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2RldmlsLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19kdWNrZmFjZScsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ0R1Y2tmYWNlJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19kdWNrZmFjZS5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfZHVja2ZhY2UucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDYyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNThcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVkaWFCYXNlOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19kdWNrZmFjZS5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9iYXNlL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2R1Y2tmYWNlLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19mdXJpb3VzJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnRnVyaW91cycsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfZnVyaW91cy5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfZnVyaW91cy5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogNjIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA2MVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2Z1cmlvdXMuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19mdXJpb3VzLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19ncmluJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnR3JpbicsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfZ3Jpbi5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfZ3Jpbi5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogNjIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1OFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2dyaW4uc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19ncmluLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19ndWl0YXInLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdHdWl0YXInLFxuICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgIG1lZGlhVGh1bWI6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2d1aXRhci5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfZ3VpdGFyLnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2NCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDYwXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfZ3VpdGFyLnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfZ3VpdGFyLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19oYXJyeV9wb3R0ZXInLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdIYXJyeSBQb3R0ZXInLFxuICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgIG1lZGlhVGh1bWI6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2hhcnJ5X3BvdHRlci5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfaGFycnlfcG90dGVyLnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2NCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDYyXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfaGFycnlfcG90dGVyLnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfaGFycnlfcG90dGVyLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19oaXBwaWUnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdIaXBwaWUnLFxuICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgIG1lZGlhVGh1bWI6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2hpcHBpZS5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfaGlwcGllLnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2MixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDYyXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfaGlwcGllLnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfaGlwcGllLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19oaXRtYW4nLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdIaXRtYW4nLFxuICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgIG1lZGlhVGh1bWI6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2hpdG1hbi5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfaGl0bWFuLnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2NCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDYwXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfaGl0bWFuLnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfaGl0bWFuLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19odW1vdXJvdXMnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdIdW1vdXJvdXMnLFxuICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgIG1lZGlhVGh1bWI6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2h1bW91cm91cy5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfaHVtb3Vyb3VzLnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2NCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDY0XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfaHVtb3Vyb3VzLnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfaHVtb3Vyb3VzLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19pZGVhJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnSWRlYScsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfaWRlYS5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfaWRlYS5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogNjQsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA2MlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2lkZWEuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19pZGVhLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19pbXBhdGllbnQnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdJbXBhdGllbnQnLFxuICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgIG1lZGlhVGh1bWI6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2ltcGF0aWVudC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfaW1wYXRpZW50LnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2MixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDU4XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfaW1wYXRpZW50LnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfaW1wYXRpZW50LnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19raXNzJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnS2lzcycsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfa2lzcy5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfa2lzcy5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogNjIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1OFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2tpc3Muc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19raXNzLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19raXNzZXMnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdLaXNzZXMnLFxuICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgIG1lZGlhVGh1bWI6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2tpc3Nlcy5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfa2lzc2VzLnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2MixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDU4XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfa2lzc2VzLnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfa2lzc2VzLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19sYXVnaCcsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ0xhdWdoJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19sYXVnaC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfbGF1Z2gucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDYyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNThcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVkaWFCYXNlOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19sYXVnaC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9iYXNlL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2xhdWdoLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19sb3VkX2NyeScsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ0xvdWQgQ3J5JyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19sb3VkX2NyeS5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfbG91ZF9jcnkucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDY0LFxuICAgICAgICAgICAgICAgIGhlaWdodDogNThcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVkaWFCYXNlOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19sb3VkX2NyeS5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9iYXNlL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2xvdWRfY3J5LnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19sb3ZpbmcnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdMb3ZpbmcnLFxuICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgIG1lZGlhVGh1bWI6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX2xvdmluZy5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfbG92aW5nLnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2MixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDU4XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfbG92aW5nLnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfbG92aW5nLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19tYXNrZWQnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdNYXNrZWQnLFxuICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgIG1lZGlhVGh1bWI6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX21hc2tlZC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfbWFza2VkLnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2MixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDYyXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfbWFza2VkLnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfbWFza2VkLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19tdXNpYycsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ011c2ljJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19tdXNpYy5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfbXVzaWMucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDYyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNTRcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVkaWFCYXNlOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19tdXNpYy5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9iYXNlL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX211c2ljLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19uZXJkJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnTmVyZCcsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfbmVyZC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfbmVyZC5wbmcnXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX25lcmQuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19uZXJkLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19uaW5qYScsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ05pbmphJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19uaW5qYS5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfbmluamEucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDYyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNThcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVkaWFCYXNlOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19uaW5qYS5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9iYXNlL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX25pbmphLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19ub3Rfc3BlYWtpbmdfdG9feW91JyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnTm90IFNwZWFraW5nIFRvIFlvdScsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfbm90X3NwZWFraW5nX3RvX3lvdS5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfbm90X3NwZWFraW5nX3RvX3lvdS5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogNjIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1OFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX25vdF9zcGVha2luZ190b195b3Uuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19ub3Rfc3BlYWtpbmdfdG9feW91LnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19waWcnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdQaWcnLFxuICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgIG1lZGlhVGh1bWI6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX3BpZy5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfcGlnLnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2MyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDQxXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfcGlnLnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfcGlnLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19wdW1wa2luJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnUHVtcGtpbicsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfcHVtcGtpbi5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfcHVtcGtpbi5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogNjIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA2MFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX3B1bXBraW4uc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19wdW1wa2luLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19xdWVzdGlvbicsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ1F1ZXN0aW9uJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19xdWVzdGlvbi5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfcXVlc3Rpb24ucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDYyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVkaWFCYXNlOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19xdWVzdGlvbi5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9iYXNlL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX3F1ZXN0aW9uLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19yYWJiaXQnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdSYWJiaXQnLFxuICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgIG1lZGlhVGh1bWI6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX3JhYmJpdC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfcmFiYml0LnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2NSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDQ3XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfcmFiYml0LnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfcmFiYml0LnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19zYWQnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdTYWQnLFxuICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgIG1lZGlhVGh1bWI6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX3NhZC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc2FkLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc2FkLnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc2FkLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19zaWNrJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnU2ljaycsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc2ljay5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc2ljay5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogNjIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1OFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX3NpY2suc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19zaWNrLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19za2F0ZWJvYXJkJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnU2thdGVib2FyZCcsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc2thdGVib2FyZC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc2thdGVib2FyZC5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogNjIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA2NFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX3NrYXRlYm9hcmQuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19za2F0ZWJvYXJkLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19za3VsbCcsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ1NrdWxsJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19za3VsbC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc2t1bGwucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDYyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVkaWFCYXNlOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19za3VsbC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9iYXNlL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX3NrdWxsLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19zbGVlcHknLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdTbGVlcHknLFxuICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgIG1lZGlhVGh1bWI6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX3NsZWVweS5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc2xlZXB5LnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2MixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDYwXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc2xlZXB5LnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc2xlZXB5LnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19zbWlsZScsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ1NtaWxlJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19zbWlsZS5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc21pbGUucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDYyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNThcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVkaWFCYXNlOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19zbWlsZS5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9iYXNlL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX3NtaWxlLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19zbW9raW5nJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnU21va2luZycsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc21va2luZy5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc21va2luZy5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogNjIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1OFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX3Ntb2tpbmcuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19zbW9raW5nLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19zb2JiaW5nJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnU29iYmluZycsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc29iYmluZy5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc29iYmluZy5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogNjIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1OVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX3NvYmJpbmcuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19zb2JiaW5nLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19zdGFyJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnU3RhcicsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc3Rhci5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc3Rhci5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogNjQsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA2NFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX3N0YXIuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19zdGFyLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19zdGVhbWluZ19mdXJpb3VzJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnU3RlYW1pbmcgRnVyaW91cycsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc3RlYW1pbmdfZnVyaW91cy5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc3RlYW1pbmdfZnVyaW91cy5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogNjIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1OFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX3N0ZWFtaW5nX2Z1cmlvdXMuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19zdGVhbWluZ19mdXJpb3VzLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc19zdW5iYXRoaW5nJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnU3VuYmF0aGluZycsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc3VuYmF0aGluZy5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfc3VuYmF0aGluZy5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogNjIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1OFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX3N1bmJhdGhpbmcuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX2Vtb3RpY29uc19zdW5iYXRoaW5nLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc190aXJlZCcsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ1RpcmVkJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc190aXJlZC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfdGlyZWQucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDYyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjBcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVkaWFCYXNlOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc190aXJlZC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9iYXNlL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX3RpcmVkLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc190b25ndWVfb3V0X3dpbmsnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdUb25ndWUgT3V0IFdpbmsnLFxuICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgIG1lZGlhVGh1bWI6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX3Rvbmd1ZV9vdXRfd2luay5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfdG9uZ3VlX291dF93aW5rLnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2MixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDU4XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfdG9uZ3VlX291dF93aW5rLnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfdG9uZ3VlX291dF93aW5rLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc193YXZlJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnV2F2ZScsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfd2F2ZS5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfd2F2ZS5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogNjIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA2MFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX3dhdmUuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX2Vtb3RpY29uc193YXZlLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc193aWRlX2dyaW4nLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdXaWRlIEdyaW4nLFxuICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgIG1lZGlhVGh1bWI6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX3dpZGVfZ3Jpbi5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfd2lkZV9ncmluLnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA2MixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDU4XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfd2lkZV9ncmluLnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfd2lkZV9ncmluLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc193aW5rJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnV2luaycsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfd2luay5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfd2luay5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogNjIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1OFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvZW1vdGljb25zL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX3dpbmsuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9lbW90aWNvbnMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX2Vtb3RpY29uc193aW5rLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX2Vtb3RpY29uc193cmVzdGxlcicsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ1dyZXN0bGVyJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc193cmVzdGxlci5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNfd3Jlc3RsZXIucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDYyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjBcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVkaWFCYXNlOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9pbWdseV9zdGlja2VyX2Vtb3RpY29uc193cmVzdGxlci5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL2Vtb3RpY29ucy9zdGlja2Vycy9iYXNlL2ltZ2x5X3N0aWNrZXJfZW1vdGljb25zX3dyZXN0bGVyLnBuZydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX3NoYXBlcycsXG4gICAgICAgIGRlZmF1bHROYW1lOiAnU2hhcGVzJyxcbiAgICAgICAgJ21ldGFEYXRhJzoge1xuICAgICAgICAgICdiYWNrZ3JvdW5kSW1hZ2UnOiAnc3RpY2tlcnMvc2hhcGVzL2JhY2tncm91bmQucG5nJ1xuICAgICAgICB9LFxuICAgICAgICAnc3RpY2tlcnMnOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X3N0aWNrZXJfc2hhcGVzX2Fycm93XzAyJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQXJyb3cgMScsXG4gICAgICAgICAgICB0aW50TW9kZTogJ3NvbGlkJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy9pbWdseV9zdGlja2VyX3NoYXBlc19hcnJvd18wMi5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYXJyb3dfMDIucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIwMDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMjM2XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYXJyb3dfMDIuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX3NoYXBlc19hcnJvd18wMi5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogMjAwMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyMzZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X3N0aWNrZXJfc2hhcGVzX2Fycm93XzAzJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQXJyb3cgMicsXG4gICAgICAgICAgICB0aW50TW9kZTogJ3NvbGlkJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy9pbWdseV9zdGlja2VyX3NoYXBlc19hcnJvd18wMy5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYXJyb3dfMDMucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIwMDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMDAwXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYXJyb3dfMDMuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX3NoYXBlc19hcnJvd18wMy5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogMjAwMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDIwMDBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X3N0aWNrZXJfc2hhcGVzX2JhZGdlXzAxJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQmFkZ2UgMScsXG4gICAgICAgICAgICB0aW50TW9kZTogJ3NvbGlkJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8wMS5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMDEucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIwMDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMDAwXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMDEuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8wMS5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogMjAwMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDIwMDBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X3N0aWNrZXJfc2hhcGVzX2JhZGdlXzA0JyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQmFkZ2UgMicsXG4gICAgICAgICAgICB0aW50TW9kZTogJ3NvbGlkJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8wNC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMDQucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIwMDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxNTg5XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMDQuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8wNC5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogMjAwMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDE1ODlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X3N0aWNrZXJfc2hhcGVzX2JhZGdlXzA2JyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQmFkZ2UgMycsXG4gICAgICAgICAgICB0aW50TW9kZTogJ3NvbGlkJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8wNi5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMDYucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIwMDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxNzMzXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMDYuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8wNi5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogMjAwMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDE3MzNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X3N0aWNrZXJfc2hhcGVzX2JhZGdlXzA4JyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQmFkZ2UgNCcsXG4gICAgICAgICAgICB0aW50TW9kZTogJ3NvbGlkJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8wOC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMDgucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIwMDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMDAwXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMDguc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8wOC5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogMjAwMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDIwMDBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X3N0aWNrZXJfc2hhcGVzX2JhZGdlXzExJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQmFkZ2UgNScsXG4gICAgICAgICAgICB0aW50TW9kZTogJ3NvbGlkJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8xMS5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMTEucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIwMDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMDAwXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMTEuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8xMS5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogMjAwMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDIwMDBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X3N0aWNrZXJfc2hhcGVzX2JhZGdlXzEyJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQmFkZ2UgNicsXG4gICAgICAgICAgICB0aW50TW9kZTogJ3NvbGlkJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8xMi5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMTIucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIwMDEsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxOTAzXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMTIuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8xMi5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogMjAwMSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDE5MDNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X3N0aWNrZXJfc2hhcGVzX2JhZGdlXzEzJyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQmFkZ2UgNycsXG4gICAgICAgICAgICB0aW50TW9kZTogJ3NvbGlkJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8xMy5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMTMucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIwMDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxNzE4XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMTMuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8xMy5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogMjAwMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDE3MThcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X3N0aWNrZXJfc2hhcGVzX2JhZGdlXzE1JyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQmFkZ2UgOCcsXG4gICAgICAgICAgICB0aW50TW9kZTogJ3NvbGlkJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8xNS5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMTUucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDE2MTgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMDAwXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMTUuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8xNS5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogMTYxOCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDIwMDBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X3N0aWNrZXJfc2hhcGVzX2JhZGdlXzE4JyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQmFkZ2UgOScsXG4gICAgICAgICAgICB0aW50TW9kZTogJ3NvbGlkJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8xOC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMTgucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDExOTgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMDAwXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMTguc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8xOC5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogMTE5OCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDIwMDBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X3N0aWNrZXJfc2hhcGVzX2JhZGdlXzE5JyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQmFkZ2UgMTAnLFxuICAgICAgICAgICAgdGludE1vZGU6ICdzb2xpZCcsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMTkuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvdGh1bWJzL2ltZ2x5X3N0aWNrZXJfc2hhcGVzX2JhZGdlXzE5LnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAyMTI3LFxuICAgICAgICAgICAgICAgIGhlaWdodDogNDgxXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMTkuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8xOS5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogMjEyNyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDQ4MVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMjAnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdCYWRnZSAxMScsXG4gICAgICAgICAgICB0aW50TW9kZTogJ3NvbGlkJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8yMC5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMjAucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIwMDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxNDA0XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMjAuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8yMC5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogMjAwMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDE0MDRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X3N0aWNrZXJfc2hhcGVzX2JhZGdlXzI4JyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQmFkZ2UgMTInLFxuICAgICAgICAgICAgdGludE1vZGU6ICdzb2xpZCcsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMjguc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvdGh1bWJzL2ltZ2x5X3N0aWNrZXJfc2hhcGVzX2JhZGdlXzI4LnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAyMDAwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMjAwMFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvc2hhcGVzL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfc2hhcGVzX2JhZGdlXzI4LnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvc2hhcGVzL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMjgucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIwMDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMDAwXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8zMicsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ0JhZGdlIDEzJyxcbiAgICAgICAgICAgIHRpbnRNb2RlOiAnc29saWQnLFxuICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgIG1lZGlhVGh1bWI6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvc2hhcGVzL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfc2hhcGVzX2JhZGdlXzMyLnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvc2hhcGVzL3N0aWNrZXJzL3RodW1icy9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8zMi5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogMTk2MCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDIwMDBcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVkaWFCYXNlOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8zMi5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy9iYXNlL2ltZ2x5X3N0aWNrZXJfc2hhcGVzX2JhZGdlXzMyLnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxOTYwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMjAwMFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMzUnLFxuICAgICAgICAgICAgZGVmYXVsdE5hbWU6ICdCYWRnZSAxNCcsXG4gICAgICAgICAgICB0aW50TW9kZTogJ3NvbGlkJyxcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICBtZWRpYVRodW1iOiB7XG4gICAgICAgICAgICAgICAgdXJpczogW1xuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8zNS5zdmcnLFxuICAgICAgICAgICAgICAgICAgJ3N0aWNrZXJzL3NoYXBlcy9zdGlja2Vycy90aHVtYnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMzUucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIwMDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMDAyXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lZGlhQmFzZToge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMzUuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvYmFzZS9pbWdseV9zdGlja2VyX3NoYXBlc19iYWRnZV8zNS5wbmcnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3aWR0aDogMjAwMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDIwMDJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X3N0aWNrZXJfc2hhcGVzX2JhZGdlXzM2JyxcbiAgICAgICAgICAgIGRlZmF1bHROYW1lOiAnQmFkZ2UgMTUnLFxuICAgICAgICAgICAgdGludE1vZGU6ICdzb2xpZCcsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMzYuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvdGh1bWJzL2ltZ2x5X3N0aWNrZXJfc2hhcGVzX2JhZGdlXzM2LnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAyMDAwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTY2OFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvc2hhcGVzL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfc2hhcGVzX2JhZGdlXzM2LnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvc2hhcGVzL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9zaGFwZXNfYmFkZ2VfMzYucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDIwMDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxNjY4XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX3NoYXBlc19zcHJheV8wMScsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ1NwcmF5IDEnLFxuICAgICAgICAgICAgdGludE1vZGU6ICdzb2xpZCcsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfc3ByYXlfMDEuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvdGh1bWJzL2ltZ2x5X3N0aWNrZXJfc2hhcGVzX3NwcmF5XzAxLnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxOTEyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMjAzOVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvc2hhcGVzL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfc2hhcGVzX3NwcmF5XzAxLnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvc2hhcGVzL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9zaGFwZXNfc3ByYXlfMDEucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDE5MTIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMDM5XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX3NoYXBlc19zcHJheV8wMycsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ1NwcmF5IDInLFxuICAgICAgICAgICAgdGludE1vZGU6ICdzb2xpZCcsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfc3ByYXlfMDMuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvdGh1bWJzL2ltZ2x5X3N0aWNrZXJfc2hhcGVzX3NwcmF5XzAzLnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxNjgxLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTc3OVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvc2hhcGVzL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfc2hhcGVzX3NwcmF5XzAzLnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvc2hhcGVzL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9zaGFwZXNfc3ByYXlfMDMucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDE2ODEsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxNzc5XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9zdGlja2VyX3NoYXBlc19zcHJheV8wNCcsXG4gICAgICAgICAgICBkZWZhdWx0TmFtZTogJ1NwcmF5IDMnLFxuICAgICAgICAgICAgdGludE1vZGU6ICdzb2xpZCcsXG4gICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgbWVkaWFUaHVtYjoge1xuICAgICAgICAgICAgICAgIHVyaXM6IFtcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvaW1nbHlfc3RpY2tlcl9zaGFwZXNfc3ByYXlfMDQuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICdzdGlja2Vycy9zaGFwZXMvc3RpY2tlcnMvdGh1bWJzL2ltZ2x5X3N0aWNrZXJfc2hhcGVzX3NwcmF5XzA0LnBuZydcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxNDA3LFxuICAgICAgICAgICAgICAgIGhlaWdodDogMjI0OFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZWRpYUJhc2U6IHtcbiAgICAgICAgICAgICAgICB1cmlzOiBbXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvc2hhcGVzL3N0aWNrZXJzL2ltZ2x5X3N0aWNrZXJfc2hhcGVzX3NwcmF5XzA0LnN2ZycsXG4gICAgICAgICAgICAgICAgICAnc3RpY2tlcnMvc2hhcGVzL3N0aWNrZXJzL2Jhc2UvaW1nbHlfc3RpY2tlcl9zaGFwZXNfc3ByYXlfMDQucG5nJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDE0MDcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyMjQ4XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvanMvc2hhcmVkL2NvbnN0YW50cy9pbmRleC5qcyIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIGdldE5hbm9TZWNvbmRzLCBocnRpbWUsIGxvYWRUaW1lO1xuXG4gIGlmICgodHlwZW9mIHBlcmZvcm1hbmNlICE9PSBcInVuZGVmaW5lZFwiICYmIHBlcmZvcm1hbmNlICE9PSBudWxsKSAmJiBwZXJmb3JtYW5jZS5ub3cpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MgIT09IG51bGwpICYmIHByb2Nlc3MuaHJ0aW1lKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoZ2V0TmFub1NlY29uZHMoKSAtIGxvYWRUaW1lKSAvIDFlNjtcbiAgICB9O1xuICAgIGhydGltZSA9IHByb2Nlc3MuaHJ0aW1lO1xuICAgIGdldE5hbm9TZWNvbmRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaHI7XG4gICAgICBociA9IGhydGltZSgpO1xuICAgICAgcmV0dXJuIGhyWzBdICogMWU5ICsgaHJbMV07XG4gICAgfTtcbiAgICBsb2FkVGltZSA9IGdldE5hbm9TZWNvbmRzKCk7XG4gIH0gZWxzZSBpZiAoRGF0ZS5ub3cpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIERhdGUubm93KCkgLSBsb2FkVGltZTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gRGF0ZS5ub3coKTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gbG9hZFRpbWU7XG4gICAgfTtcbiAgICBsb2FkVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9XG5cbn0pLmNhbGwodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9ub2RlX21vZHVsZXMvcGVyZm9ybWFuY2Utbm93L2xpYi9wZXJmb3JtYW5jZS1ub3cuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi8uLi8uLi9nbG9iYWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWFyY2hTdWdnZXN0aW9uQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uQ2xpY2snXG4gICAgKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBzZWFyY2ggc3VnZ2VzdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ2xpY2sgKCkge1xuICAgIHRoaXMucHJvcHMub25DbGljayAmJlxuICAgICAgdGhpcy5wcm9wcy5vbkNsaWNrKHRoaXMucHJvcHMuc2VhcmNoU3VnZ2VzdGlvbilcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBjb25zdCB7IHNlYXJjaFN1Z2dlc3Rpb24gfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgke3NlYXJjaFN1Z2dlc3Rpb24uY292ZXJJbWFnZX0pYFxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8YmVtIHNwZWNpZmllcj0nYjpwaG90b1JvbGwgZTpsaWJyYXJ5TGlzdCc+XG4gICAgICAgIDxsaSBiZW09J2U6aXRlbScgc3R5bGU9e3N0eWxlfSBvbkNsaWNrPXt0aGlzLl9vbkNsaWNrfT5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTpvdmVybGF5JyAvPlxuICAgICAgICAgIDxkaXYgYmVtPSdlOm5hbWUnPntzZWFyY2hTdWdnZXN0aW9uLnF1ZXJ5fTwvZGl2PlxuICAgICAgICA8L2xpPlxuICAgICAgPC9iZW0+XG4gICAgKVxuICB9XG59XG5cblNlYXJjaFN1Z2dlc3Rpb25Db21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvc2NyZWVucy9waG90by1yb2xsL2l0ZW1zL3NlYXJjaC1zdWdnZXN0aW9uLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuaW1wb3J0IHsgVmVjdG9yMiwgVXRpbHMsIFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBNb2RhbE1hbmFnZXIgZnJvbSAnLi4vLi4vLi4vbGliL21vZGFsLW1hbmFnZXInXG5pbXBvcnQgUGhvdG9Db21wb25lbnQgZnJvbSAnLi9pdGVtcy9waG90by1jb21wb25lbnQnXG5pbXBvcnQgU2Nyb2xsYmFyQ29tcG9uZW50IGZyb20gJy4uLy4uL3Njcm9sbGJhci1jb21wb25lbnQnXG5cbmNvbnN0IENPTFVNTl9XSURUSCA9IDI0MFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQaG90b0xpc3RDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fbmVlZHNTdHlsZUZpeGVzID0gdHJ1ZVxuICAgIHRoaXMuX3RvdGFsUGhvdG9zSGVpZ2h0ID0gMFxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgIHBob3RvczogW11cbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBMSUZFQ1lDTEVcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgc3VwZXIuY29tcG9uZW50RGlkTW91bnQoKVxuICAgIHRoaXMuX2xvYWRQaG90b3MoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gdXBkYXRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkVXBkYXRlICguLi5hcmdzKSB7XG4gICAgaWYgKHRoaXMucmVmcy5zY3JvbGxiYXIpIHtcbiAgICAgIHRoaXMucmVmcy5zY3JvbGxiYXIudXBkYXRlKClcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYSBwaG90b1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLlBob3RvUm9sbC5QaG90b30gcGhvdG9cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblBob3RvQ2xpY2tlZCAocGhvdG8pIHtcbiAgICB0aGlzLnByb3BzLm9uUGhvdG9DbGlja2VkICYmXG4gICAgICB0aGlzLnByb3BzLm9uUGhvdG9DbGlja2VkKHBob3RvKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTUlTQ1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoZWFkbGluZSBmb3IgdGhpcyB2aWV3XG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRIZWFkbGluZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMubGlicmFyeS5uYW1lXG4gIH1cblxuICAvKipcbiAgICogQSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgc3R5bGVzIG5lZWQgdG8gYmUgZml4ZWQgYnkgdGhlIEphdmFTY3JpcHQuXG4gICAqIFRoaXMgbmVlZHMgdG8gYmUgZG9uZSB0aGFua3MgdG8gb2xkZXIgSW50ZXJuZXQgRXhwbG9yZXIgYnJvd3NlcnMgd2hpY2ggaGF2ZVxuICAgKiBhIGJ1bmNoIG9mIENTUyBidWdzLlxuICAgKi9cbiAgZml4U3R5bGVzICgpIHtcbiAgICBpZiAoVXRpbHMuQnJvd3Nlci5pc0lFbHRlKDExKSkge1xuICAgICAgY29uc3QgeyBjZWxsIH0gPSB0aGlzLnJlZnNcbiAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLnJlZnMuc2Nyb2xsYmFyLmdldExpc3QoKVxuICAgICAgaWYgKCEoY2VsbCAmJiBsaXN0KSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNlbGxIZWlnaHQgPSBjZWxsLm9mZnNldEhlaWdodFxuICAgICAgbGlzdC5zdHlsZS5oZWlnaHQgPSBgJHtjZWxsSGVpZ2h0fXB4YFxuICAgIH1cblxuICAgIGlmICh0aGlzLnJlZnMuc2Nyb2xsYmFyKSB7XG4gICAgICB0aGlzLnJlZnMuc2Nyb2xsYmFyLnVwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTE9BRElOR1xuXG4gIF9yZW5kZXJDb2x1bW5zICgpIHtcbiAgICBjb25zdCB7IHBob3RvcyB9ID0gdGhpcy5zdGF0ZVxuICAgIGNvbnN0IGNvbHVtbkNvdW50ID0gM1xuICAgIGNvbnN0IGNvbHVtbkhlaWdodHMgPSBbXVxuXG4gICAgY29uc3QgY29sdW1ucyA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICBjb2x1bW5zLnB1c2goW10pXG4gICAgICBjb2x1bW5IZWlnaHRzLnB1c2goMClcbiAgICB9XG5cbiAgICBwaG90b3MuZm9yRWFjaCgocGhvdG8pID0+IHtcbiAgICAgIGNvbnN0IHsgZGltZW5zaW9ucyB9ID0gcGhvdG9cblxuICAgICAgLy8gRmluZCBzaG9ydGVzdCBjb2x1bW5cbiAgICAgIGxldCBzaG9ydGVzdENvbHVtbkluZGV4ID0gbnVsbFxuICAgICAgbGV0IHNob3J0ZXN0Q29sdW1uSGVpZ2h0ID0gSW5maW5pdHlcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgICBpZiAoY29sdW1uSGVpZ2h0c1tpXSA8IHNob3J0ZXN0Q29sdW1uSGVpZ2h0KSB7XG4gICAgICAgICAgc2hvcnRlc3RDb2x1bW5JbmRleCA9IGlcbiAgICAgICAgICBzaG9ydGVzdENvbHVtbkhlaWdodCA9IGNvbHVtbkhlaWdodHNbaV1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb2x1bW5zW3Nob3J0ZXN0Q29sdW1uSW5kZXhdLnB1c2goPFBob3RvQ29tcG9uZW50XG4gICAgICAgIHBob3RvPXtwaG90by5vYmp9XG4gICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uUGhvdG9DbGlja2VkLmJpbmQodGhpcywgcGhvdG8ub2JqKX0gLz4pXG4gICAgICBjb2x1bW5IZWlnaHRzW3Nob3J0ZXN0Q29sdW1uSW5kZXhdICs9IGRpbWVuc2lvbnMueVxuICAgIH0pXG5cbiAgICByZXR1cm4gY29sdW1uc1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGNvbnRlbnQgZm9yIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyUGhvdG9zICgpIHtcbiAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5fcmVuZGVyQ29sdW1ucygpXG4gICAgcmV0dXJuICg8ZGl2IGJlbT0nJGI6cGhvdG9Sb2xsIGU6cm93IG06ZnVsbEhlaWdodCc+XG4gICAgICA8ZGl2IGJlbT0nZTpjZWxsJyByZWY9J2NlbGwnPlxuICAgICAgICA8U2Nyb2xsYmFyQ29tcG9uZW50IGRpcmVjdGlvbj0ndmVydGljYWwnIHJlZj0nc2Nyb2xsYmFyJz5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTpjb250YWluZXInIHJlZj0nY29udGFpbmVyJz5cbiAgICAgICAgICAgIDxkaXYgYmVtPSdlOmlubmVyQ29udGFpbmVyJz5cbiAgICAgICAgICAgICAgPGRpdiBiZW09J2U6aGVhZGxpbmUnPnt0aGlzLl9nZXRIZWFkbGluZSgpfTwvZGl2PlxuICAgICAgICAgICAgICA8YmVtIHNwZWNpZmllcj0nZTpwaG90b0xpc3QnPlxuICAgICAgICAgICAgICAgIHtjb2x1bW5zLm1hcCgoY29sdW1uKSA9PlxuICAgICAgICAgICAgICAgICAgPHVsIGJlbT0nJGU6bGlzdCc+e2NvbHVtbn08L3VsPlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgIDwvYmVtPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvU2Nyb2xsYmFyQ29tcG9uZW50PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+KVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBwaG90b3NcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sb2FkUGhvdG9zICgpIHtcbiAgICB0aGlzLl90b3RhbFBob3Rvc0hlaWdodCA9IDBcblxuICAgIGNvbnN0IG1vZGFsID0gTW9kYWxNYW5hZ2VyLmluc3RhbmNlLmRpc3BsYXlQcm9ncmVzcyh0aGlzLl90KCdwZXNkay5jb21tb24udGV4dC5sb2FkaW5nJykpXG4gICAgY29uc3QgUGhvdG9Sb2xsUHJvdmlkZXIgPSB0aGlzLmNvbnRleHQub3B0aW9ucy5waG90b1JvbGwucHJvdmlkZXJcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBQaG90b1JvbGxQcm92aWRlcigpXG5cbiAgICBwcm92aWRlci5nZXRQaG90b3NGb3JMaWJyYXJ5KHRoaXMucHJvcHMubGlicmFyeSlcbiAgICAgIC50aGVuKChwaG90b3MpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZWxvYWRQaG90b3MocGhvdG9zLCBtb2RhbClcbiAgICAgIH0pXG4gICAgICAudGhlbigocGhvdG9zKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBwaG90b3MsIGxvYWRpbmc6IGZhbHNlIH0pXG4gICAgICAgIG1vZGFsLmNsb3NlKClcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgbW9kYWwuY2xvc2UoKVxuICAgICAgICBNb2RhbE1hbmFnZXIuaW5zdGFuY2UuZGlzcGxheUVycm9yKHRoaXMuX3QoJ3Blc2RrLmxpYnJhcnkudGl0bGUucGhvdG9Sb2xsTG9hZEZhaWwnKSwgdGhpcy5fdCgncGVzZGsubGlicmFyeS50ZXh0LnBob3RvUm9sbExvYWRGYWlsJywgeyBlcnJvcjogZS5tZXNzYWdlIH0pKVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVsb2FkcyB0aGUgcGhvdG9zXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5QaG90b1JvbGwuUGhvdG9bXX0gcGhvdG9zXG4gICAqIEBwYXJhbSB7TW9kYWx9IG1vZGFsXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJlbG9hZFBob3RvcyAocGhvdG9zLCBtb2RhbCkge1xuICAgIGNvbnN0IHRvdGFsUGhvdG9zID0gcGhvdG9zLmxlbmd0aFxuICAgIGxldCBsb2FkZWRQaG90b3MgPSAwXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBob3Rvcy5tYXAoKHBob3RvKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJlbG9hZFBob3RvKHBob3RvKVxuICAgICAgICAudGhlbigoaW1hZ2UpID0+IHtcbiAgICAgICAgICBjb25zdCBwaG90b0RpbWVuc2lvbnMgPSBuZXcgVmVjdG9yMihpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KVxuICAgICAgICAgIHBob3RvRGltZW5zaW9ucy5tdWx0aXBseShDT0xVTU5fV0lEVEggLyBpbWFnZS53aWR0aClcbiAgICAgICAgICB0aGlzLl90b3RhbFBob3Rvc0hlaWdodCArPSBwaG90b0RpbWVuc2lvbnMueVxuXG4gICAgICAgICAgbG9hZGVkUGhvdG9zKytcbiAgICAgICAgICBtb2RhbC5zZXREYXRhKHsgcHJvZ3Jlc3M6IGxvYWRlZFBob3RvcyAvIHRvdGFsUGhvdG9zIH0pXG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb2JqOiBwaG90byxcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHBob3RvRGltZW5zaW9uc1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVsb2FkcyB0aGUgZ2l2ZW4gcGhvdG9cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5QaG90b1JvbGwuUGhvdG99IHBob3RvXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJlbG9hZFBob3RvIChwaG90bykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBpbWFnZSA9IG5ldyB3aW5kb3cuSW1hZ2UoKVxuICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShpbWFnZSlcbiAgICAgIH0pXG4gICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShpbWFnZSlcbiAgICAgIH0pXG4gICAgICBpbWFnZS5jcm9zc09yaWdpbiA9IHRoaXMucHJvcHMuY3Jvc3NPcmlnaW4gfHwgJ2Fub255bW91cydcbiAgICAgIGltYWdlLnNyYyA9IHBob3RvLnVybHMudGh1bWJcbiAgICB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5sb2FkaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGhvdG9zKClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDxkaXYgLz5cbiAgICB9XG4gIH1cbn1cblxuUGhvdG9MaXN0Q29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL3NjcmVlbnMvcGhvdG8tcm9sbC9waG90by1saXN0LWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi4vY29udHJvbHMtY29tcG9uZW50J1xuaW1wb3J0IFNjcm9sbGJhckNvbXBvbmVudCBmcm9tICcuLi8uLi9zY3JvbGxiYXItY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPdmVydmlld0NvbnRyb2xzQ29tcG9uZW50IGV4dGVuZHMgQ29udHJvbHNDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgdGhpcy5faGFzQmFja0J1dHRvbiA9IGZhbHNlXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBpdGVtIGhhcyBiZWVuIGNsaWNrZWRcbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkl0ZW1DbGljayAoY29udHJvbHMpIHtcbiAgICB0aGlzLnByb3BzLm9uU3dpdGNoQ29udHJvbHMoY29udHJvbHMpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgbGlzdCBpdGVtcyBmb3IgdGhpcyBjb250cm9sXG4gICAqIEByZXR1cm4ge0FycmF5LjxSZWFjdEJFTS5FbGVtZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJMaXN0SXRlbXMgKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcblxuICAgIGxldCBpdGVtcyA9IFtdXG4gICAgY29uc3QgbWFrZUl0ZW0gPSAoaWRlbnRpZmllcikgPT4ge1xuICAgICAgY29uc3QgY29udHJvbCA9IGVkaXRvci5jb250cm9scy5nZXQoaWRlbnRpZmllcilcbiAgICAgIHJldHVybiAoPGxpXG4gICAgICAgIGJlbT0nZTppdGVtJ1xuICAgICAgICBrZXk9e2NvbnRyb2wuaWRlbnRpZmllcn1cbiAgICAgICAgZGF0YS1pZGVudGlmaWVyPXtjb250cm9sLmlkZW50aWZpZXJ9XG4gICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uSXRlbUNsaWNrLmJpbmQodGhpcywgY29udHJvbCl9PlxuICAgICAgICA8YmVtIHNwZWNpZmllcj0nJGI6Y29udHJvbHMnPlxuICAgICAgICAgIDxkaXYgYmVtPSckZTpidXR0b24gbTp3aXRoTGFiZWwnPlxuICAgICAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXt0aGlzLl9nZXRBc3NldFBhdGgoY29udHJvbC5pY29uUGF0aCwgdHJ1ZSl9IC8+XG4gICAgICAgICAgICA8ZGl2IGJlbT0nZTpsYWJlbCc+e3RoaXMuX3QoY29udHJvbC5sYW5ndWFnZUtleSl9PC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvYmVtPlxuICAgICAgPC9saT4pXG4gICAgfVxuXG4gICAgY29uc3QgeyBjb250cm9sc09yZGVyIH0gPSB0aGlzLmNvbnRleHQub3B0aW9ucy5lZGl0b3JcbiAgICBjb250cm9sc09yZGVyLmZvckVhY2goKGdyb3VwT3JJZGVudGlmaWVyKSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShncm91cE9ySWRlbnRpZmllcikpIHtcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBncm91cE9ySWRlbnRpZmllclxuXG4gICAgICAgIGxldCBncm91cEl0ZW1zID0gW11cbiAgICAgICAgZ3JvdXAuZm9yRWFjaCgoaWRlbnRpZmllcikgPT4ge1xuICAgICAgICAgIGlmICghZWRpdG9yLmNvbnRyb2xzLmlzRW5hYmxlZChpZGVudGlmaWVyKSkgcmV0dXJuXG4gICAgICAgICAgZ3JvdXBJdGVtcy5wdXNoKG1ha2VJdGVtKGlkZW50aWZpZXIpKVxuICAgICAgICB9KVxuXG4gICAgICAgIGlmIChncm91cEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goZ3JvdXBJdGVtcylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGdyb3VwT3JJZGVudGlmaWVyXG4gICAgICAgIGlmICghZWRpdG9yLmNvbnRyb2xzLmlzRW5hYmxlZChpZGVudGlmaWVyKSkgcmV0dXJuXG4gICAgICAgIGl0ZW1zLnB1c2gobWFrZUl0ZW0oaWRlbnRpZmllcikpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGxldCBmaW5hbEl0ZW1zID0gW11cbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtT3JHcm91cCkgPT4ge1xuICAgICAgZmluYWxJdGVtcyA9IGZpbmFsSXRlbXMuY29uY2F0KGl0ZW1Pckdyb3VwKVxuICAgICAgaWYgKGl0ZW1Pckdyb3VwICE9PSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXSkge1xuICAgICAgICBmaW5hbEl0ZW1zLnB1c2goPGxpIGJlbT0nZTpzZXBhcmF0b3InIC8+KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gZmluYWxJdGVtc1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlckNvbnRyb2xzICgpIHtcbiAgICBjb25zdCBsaXN0SXRlbXMgPSB0aGlzLl9yZW5kZXJMaXN0SXRlbXMoKVxuXG4gICAgcmV0dXJuICg8ZGl2IGJlbT0nZTpjZWxsIG06bGlzdCc+XG4gICAgICA8U2Nyb2xsYmFyQ29tcG9uZW50PlxuICAgICAgICA8dWwgYmVtPSckZTpsaXN0Jz5cbiAgICAgICAgICB7bGlzdEl0ZW1zfVxuICAgICAgICA8L3VsPlxuICAgICAgPC9TY3JvbGxiYXJDb21wb25lbnQ+XG4gICAgPC9kaXY+KVxuICB9XG59XG5cbk92ZXJ2aWV3Q29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzID0gQ29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL292ZXJ2aWV3L292ZXJ2aWV3LWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCIvKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7XG4gIEV2ZW50RW1pdHRlciwgU0RLLCBDb25zdGFudHMsIFZlY3RvcjIsIFV0aWxzLCBTREtVdGlscyxcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBjYW5jZWxBbmltYXRpb25GcmFtZSwgUHJvbWlzZSwgTG9nXG59IGZyb20gJy4uL2dsb2JhbHMnXG5pbXBvcnQgRXhwb3J0ZXIgZnJvbSAnc2hhcmVkL2V4cG9ydGVyJ1xuaW1wb3J0IEltYWdlUmVzaXplciBmcm9tICcuL2ltYWdlLXJlc2l6ZXInXG5cbmltcG9ydCBFZGl0b3JPcGVyYXRpb25zIGZyb20gJy4vZWRpdG9yL29wZXJhdGlvbnMnXG5pbXBvcnQgRWRpdG9yQ29udHJvbHMgZnJvbSAnLi9lZGl0b3IvY29udHJvbHMnXG5pbXBvcnQgRWRpdG9yRmVhdHVyZXMgZnJvbSAnLi9lZGl0b3IvZmVhdHVyZXMnXG5pbXBvcnQgRWRpdG9yWm9vbSBmcm9tICcuL2VkaXRvci96b29tJ1xuaW1wb3J0IEVkaXRvckhpc3RvcnkgZnJvbSAnLi9lZGl0b3IvaGlzdG9yeSdcblxuLyoqXG4gKiBUaGUgRWRpdG9yIGNsYXNzIGlzIGFuIGludGVyZmFjZSB0byB0aGUgU0RLLCBtYW5hZ2luZyBvcGVyYXRpb25zLCByZW5kZXJpbmcsXG4gKiBoaXN0b3J5LCB6b29tIGV0Yy5cbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUlcbiAqL1xuY2xhc3MgRWRpdG9yIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKHVpLCBvcHRpb25zLCBtZWRpYXRvciwgc2hhbGxvdyA9IGZhbHNlKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX3VpID0gdWlcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMuX21lZGlhdG9yID0gbWVkaWF0b3JcbiAgICB0aGlzLl9yZWFkeSA9IGZhbHNlXG4gICAgdGhpcy5fcGFkZGluZyA9IFswLCAwLCAwLCAwXVxuICAgIHRoaXMuX3NoYWxsb3cgPSBzaGFsbG93XG5cbiAgICBpZiAoIXNoYWxsb3cpIHtcbiAgICAgIHRoaXMuX2luaXRTREsoKVxuXG4gICAgICB0aGlzLl9vblpvb20gPSB0aGlzLl9vblpvb20uYmluZCh0aGlzKVxuICAgICAgdGhpcy5fb25VbmRvID0gdGhpcy5fb25VbmRvLmJpbmQodGhpcylcblxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEVkaXRvckhpc3RvcnkodGhpcywgdGhpcy5fc2RrLCB0aGlzLl9tZWRpYXRvcilcbiAgICAgIHRoaXMuaGlzdG9yeS5vbigndW5kbycsIHRoaXMuX29uVW5kbylcbiAgICAgIHRoaXMuem9vbSA9IG5ldyBFZGl0b3Jab29tKHRoaXMsIHRoaXMuX3NkaywgdGhpcy5fbWVkaWF0b3IpXG4gICAgICB0aGlzLnpvb20ub24oJ3NldCcsIHRoaXMuX29uWm9vbSlcblxuICAgICAgdGhpcy5faW5pdFNlcmlhbGl6ZXJzKClcbiAgICB9XG5cbiAgICB0aGlzLm9wZXJhdGlvbnMgPSBuZXcgRWRpdG9yT3BlcmF0aW9ucyh0aGlzLCB0aGlzLl9zZGssIHRoaXMuX21lZGlhdG9yKVxuICAgIHRoaXMuY29udHJvbHMgPSBuZXcgRWRpdG9yQ29udHJvbHModGhpcywgdGhpcy5fc2RrLCB0aGlzLl9tZWRpYXRvcilcbiAgICB0aGlzLmZlYXR1cmVzID0gbmV3IEVkaXRvckZlYXR1cmVzKHRoaXMsIHRoaXMuX3NkaywgdGhpcy5fbWVkaWF0b3IpXG5cbiAgICAvLyBSZW5kZXJpbmdcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2VcbiAgICB0aGlzLl9yZW5kZXJSZXF1ZXN0ZWQgPSB0cnVlXG4gICAgdGhpcy5fcmVuZGVyQ2FsbGJhY2tzID0gW11cbiAgICB0aGlzLl9hbmltYXRpb25GcmFtZVJlcXVlc3QgPSBudWxsXG5cbiAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyLmJpbmQodGhpcylcbiAgICB0aGlzLl90aWNrID0gdGhpcy5fdGljay5iaW5kKHRoaXMpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBJTklUSUFMSVpBVElPTlxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBnaXZlbiBpbWFnZSB0byBiZSByZW5kZXJlZC4gSWYgdGhlIGltYWdlIG5lZWRzIHRvIGJlIHJlc2l6ZWQgdG8gZml0IGludG8gYVxuICAgKiBXZWJHTCB0ZXh0dXJlIG9yIHRvIG1hdGNoIHRoZSBgbWF4TWVnYVBpeGVsc2Agb3B0aW9uLCByZXNpemluZyBpcyBkb25lIGJlZm9yZSBzZXR0aW5nXG4gICAqIHRoZSBpbWFnZS5cbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VcbiAgICogQHBhcmFtIHtCb29sZWFufSByZXNldEVkaXRvclxuICAgKi9cbiAgc2V0SW1hZ2UgKGltYWdlID0gdGhpcy5fb3B0aW9ucy5lZGl0b3IuaW1hZ2UsIHJlc2V0RWRpdG9yID0gdHJ1ZSkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fc2RrLmdldFJlbmRlcmVyKClcbiAgICBjb25zdCBpbml0aWFsRGltZW5zaW9ucyA9IG5ldyBWZWN0b3IyKGltYWdlLm5hdHVyYWxXaWR0aCwgaW1hZ2UubmF0dXJhbEhlaWdodClcbiAgICBjb25zdCBtYXhQaXhlbHMgPSB0aGlzLmdldE1heE1lZ2FwaXhlbHMoKSAqIDEwMDAwMDBcbiAgICBjb25zdCBtYXhEaW1lbnNpb25zID0gcmVuZGVyZXIuZ2V0TWF4RGltZW5zaW9ucygpXG5cbiAgICBpZiAocmVzZXRFZGl0b3IpIHtcbiAgICAgIHRoaXMucmVzZXQoKVxuICAgIH1cblxuICAgIGNvbnN0IGltYWdlUmVzaXplciA9IG5ldyBJbWFnZVJlc2l6ZXIoXG4gICAgICBpbWFnZSxcbiAgICAgIG1heFBpeGVscyxcbiAgICAgIG1heERpbWVuc2lvbnNcbiAgICApXG4gICAgbGV0IGV4aWYgPSBudWxsXG5cbiAgICBjb25zdCBkb25lID0gKGltYWdlLCBkaW1lbnNpb25zID0gaW5pdGlhbERpbWVuc2lvbnMsIHJlc2l6ZVJlYXNvbiA9IG51bGwpID0+IHtcbiAgICAgIHRoaXMuX3NldEltYWdlKGltYWdlLCBleGlmLCBkaW1lbnNpb25zKVxuXG4gICAgICB0aGlzLl9pbml0V2F0ZXJtYXJrKClcblxuICAgICAgdGhpcy5fcmVhZHkgPSB0cnVlXG4gICAgICB0aGlzLmVtaXQoJ3JlYWR5JylcbiAgICB9XG5cbiAgICBpZiAoIWltYWdlUmVzaXplci5uZWVkc1Jlc2l6ZSgpKSB7XG4gICAgICBkb25lKGltYWdlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXQoJ3Jlc2l6ZScpXG4gICAgICBleGlmID0gdGhpcy5fc2RrLnBhcnNlRXhpZihpbWFnZSlcbiAgICAgIGltYWdlUmVzaXplci5yZXNpemUoKVxuICAgICAgICAudGhlbigoeyBjYW52YXMsIGRpbWVuc2lvbnMsIHJlYXNvbiB9KSA9PiB7XG4gICAgICAgICAgLy8gRmxhZyBjYW52YXMgYXMgSlBFRyBzbyB0aGF0IGV4cG9ydCB3aWxsIHJlY29nbml6ZSB0aGF0XG4gICAgICAgICAgLy8gaXQgbmVlZHMgdG8gcmVzdG9yZSBFWElGIGRhdGFcbiAgICAgICAgICBjYW52YXMuc3JjID0gJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsJ1xuXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZXNpemVkJywgeyBkaW1lbnNpb25zLCByZWFzb24gfSlcbiAgICAgICAgICBkb25lKGNhbnZhcywgZGltZW5zaW9ucywgcmVhc29uKVxuICAgICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgd2F0ZXJtYXJrIG9wZXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRXYXRlcm1hcmsgKCkge1xuICAgIGlmICh0aGlzLl9vcHRpb25zLmVkaXRvci53YXRlcm1hcmtJbWFnZSkge1xuICAgICAgdGhpcy5fd2F0ZXJtYXJrT3BlcmF0aW9uID0gdGhpcy5vcGVyYXRpb25zLmdldE9yQ3JlYXRlKCd3YXRlcm1hcmsnLCB7XG4gICAgICAgIGltYWdlOiB0aGlzLl9vcHRpb25zLmVkaXRvci53YXRlcm1hcmtJbWFnZVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIFNES1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRTREsgKCkge1xuICAgIGNvbnN0IHsgbG9nTGV2ZWwsIGRpc3BsYXlXZWxjb21lTWVzc2FnZSwgZGVidWcsIGxpY2Vuc2UsIGNyb3NzT3JpZ2luIH0gPSB0aGlzLl9vcHRpb25zXG4gICAgY29uc3QgeyBzbW9vdGhEb3duc2NhbGluZywgc21vb3RoVXBzY2FsaW5nLCBwcmVmZXJyZWRSZW5kZXJlciwgcGl4ZWxSYXRpbyB9ID0gdGhpcy5fb3B0aW9ucy5lZGl0b3JcbiAgICBjb25zdCByZW5kZXJlck9wdGlvbnMgPSB7XG4gICAgICBsb2dMZXZlbCxcbiAgICAgIGRlYnVnLFxuICAgICAgZGlzcGxheVdlbGNvbWVNZXNzYWdlLFxuICAgICAgcGl4ZWxSYXRpbyxcbiAgICAgIHNtb290aERvd25zY2FsaW5nLFxuICAgICAgc21vb3RoVXBzY2FsaW5nLFxuICAgICAgY3Jvc3NPcmlnaW4sXG4gICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgIGxpY2Vuc2VcbiAgICB9XG4gICAgdGhpcy5fc2RrID0gbmV3IFNESyhwcmVmZXJyZWRSZW5kZXJlciwgcmVuZGVyZXJPcHRpb25zKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gWk9PTUlOR1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBhZnRlciBhIG5ldyB6b29tIGxldmVsIGhhcyBiZWVuIHNldC4gUmUtcmVuZGVycyB0aGUgZWRpdG9yLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHpvb21cbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblpvb20gKHpvb20sIGNhbGxiYWNrID0gbnVsbCkge1xuICAgIHRoaXMuZml4T2Zmc2V0KClcbiAgICB0aGlzLnJlbmRlcigoKSA9PiB7XG4gICAgICB0aGlzLl9tZWRpYXRvci5lbWl0KENvbnN0YW50cy5FVkVOVFMuWk9PTV9ET05FKVxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgYWZ0ZXIgYW4gdW5kbyBoYXBwZW5lZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uVW5kbyAoKSB7XG4gICAgdGhpcy5yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcm90YXRpb25cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0Um90YXRpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zZGsuZ2V0Um90YXRpb24oKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJvdGF0aW9uIHRvIHRoZSBnaXZlbiB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcm90YXRpb25cbiAgICovXG4gIHNldFJvdGF0aW9uIChyb3RhdGlvbikge1xuICAgIHRoaXMuX3Nkay5zZXRSb3RhdGlvbihyb3RhdGlvbilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNwcml0ZSBzY2FsZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRTcHJpdGVTY2FsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nkay5nZXRTcHJpdGVTY2FsZSgpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3ByaXRlIHNjYWxlIHRvIHRoZSBnaXZlbiB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gc3ByaXRlU2NhbGVcbiAgICovXG4gIHNldFNwcml0ZVNjYWxlIChzcHJpdGVTY2FsZSkge1xuICAgIHRoaXMuX3Nkay5zZXRTcHJpdGVTY2FsZShzcHJpdGVTY2FsZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjcm9zc09yaWdpbiB2YWx1ZSB0byBiZSBzZXQgdG8gaW1hZ2UgZWxlbWVudHMsIGFjY29yZGluZ1xuICAgKiB0byB0aGUgcGFzc2VkIGBjcm9zc09yaWdpbmAgb3B0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyBTdHJpbmdcbiAgICovXG4gIGdldENyb3NzT3JpZ2luICgpIHtcbiAgICByZXR1cm4gU0RLVXRpbHMuZ2V0Q3Jvc3NPcmlnaW5WYWx1ZSh0aGlzLl9vcHRpb25zLmNyb3NzT3JpZ2luIHx8ICdhbm9ueW1vdXMnKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTUlTQyBQUklWQVRFIEFQSVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIHRvb2wgaXMgYWxsb3dlZCBieSB0aGUgbGljZW5zZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBpZGVudGlmaWVyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc1Rvb2xBbGxvd2VkIChpZGVudGlmaWVyKSB7XG4gICAgaWYgKHRoaXMuX3NoYWxsb3cpIHJldHVybiB0cnVlXG5cbiAgICByZXR1cm4gdGhpcy5fc2RrLl9sLmlzVG9vbEFsbG93ZWQoaWRlbnRpZmllcilcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGNvbnRyb2wgd2l0aCB0aGUgdG9vbCBpZGVudGlmaWVyIGlzIGVuYWJsZWRcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgaWRlbnRpZmllclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNUb29sRW5hYmxlZCAoaWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmVkaXRvci50b29scy5pbmRleE9mKGlkZW50aWZpZXIpICE9PSAtMVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1heGltdW0gbWVnYSBwaXhlbHNcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TWF4TWVnYXBpeGVscyAoKSB7XG4gICAgY29uc3QgeyBtYXhNZWdhUGl4ZWxzIH0gPSB0aGlzLl9vcHRpb25zLmVkaXRvclxuICAgIHJldHVybiBVdGlscy5pc01vYmlsZSgpID8gbWF4TWVnYVBpeGVscy5tb2JpbGUgOiBtYXhNZWdhUGl4ZWxzLmRlc2t0b3BcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE1JU0MgUFVCTElDIEFQSVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvdXRwdXQgc3ByaXRlJ3MgY3VycmVudCBkaW1lbnNpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jb3Jwb3JhdGVTcHJpdGVTY2FsZSA9IGZhbHNlXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIGdldE91dHB1dERpbWVuc2lvbnMgKGluY29ycG9yYXRlU3ByaXRlU2NhbGUgPSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzLl9zZGsuZ2V0T3V0cHV0RGltZW5zaW9ucyhpbmNvcnBvcmF0ZVNwcml0ZVNjYWxlKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG91dHB1dCB0ZXh0dXJlJ3MgY3VycmVudCBkaW1lbnNpb25zXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGluY29ycG9yYXRlU3ByaXRlU2NhbGUgPSBmYWxzZVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBnZXRPdXRwdXRUZXh0dXJlRGltZW5zaW9ucyAoaW5jb3Jwb3JhdGVTcHJpdGVTY2FsZSA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nkay5nZXRPdXRwdXRUZXh0dXJlRGltZW5zaW9ucyhpbmNvcnBvcmF0ZVNwcml0ZVNjYWxlKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpbmFsIGRpbWVuc2lvbnMgdGhhdCB0aGUgaW5wdXQgaW1hZ2Ugd291bGQgaGF2ZVxuICAgKiBhZnRlciBhbGwgZXhpc3Rpbmcgb3BlcmF0aW9ucyBoYXZlIGJlZW4gYXBwbGllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGluY29ycG9yYXRlU3ByaXRlU2NhbGUgPSBmYWxzZVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBnZXRGaW5hbERpbWVuc2lvbnMgKGluY29ycG9yYXRlU3ByaXRlU2NhbGUgPSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzLl9zZGsuZ2V0RmluYWxEaW1lbnNpb25zKGluY29ycG9yYXRlU3ByaXRlU2NhbGUpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2FudmFzIGRpbWVuc2lvbnNcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gc3VidHJhY3RQYWRkaW5nID0gdHJ1ZVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBnZXRDYW52YXNEaW1lbnNpb25zIChzdWJ0cmFjdFBhZGRpbmcgPSB0cnVlKSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fc2RrLmdldENhbnZhcygpXG4gICAgY29uc3QgZGltZW5zaW9ucyA9IG5ldyBWZWN0b3IyKGNhbnZhcy5vZmZzZXRXaWR0aCwgY2FudmFzLm9mZnNldEhlaWdodClcbiAgICBpZiAoc3VidHJhY3RQYWRkaW5nKSB7XG4gICAgICBkaW1lbnNpb25zLnN1YnRyYWN0KFxuICAgICAgICB0aGlzLl9wYWRkaW5nWzFdICsgdGhpcy5fcGFkZGluZ1szXSxcbiAgICAgICAgdGhpcy5fcGFkZGluZ1swXSArIHRoaXMuX3BhZGRpbmdbMl1cbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGRpbWVuc2lvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBnaXZlbiBpbWFnZVxuICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkVYSUZ9IFtleGlmXVxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gW2RpbWVuc2lvbnNdXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0SW1hZ2UgKGltYWdlID0gdGhpcy5fb3B0aW9ucy5lZGl0b3IuaW1hZ2UsIGV4aWYgPSBudWxsLCBkaW1lbnNpb25zID0gbnVsbCkge1xuICAgIC8vIEludmFsaWRhdGUgY2FjaGVzXG4gICAgdGhpcy5fc2RrLnNldEFsbE9wZXJhdGlvbnNUb0RpcnR5KClcblxuICAgIHRoaXMuX29wdGlvbnMuZWRpdG9yLmltYWdlID0gaW1hZ2VcbiAgICB0aGlzLl9zZGsuc2V0SW1hZ2UoaW1hZ2UsIGV4aWYsIGRpbWVuc2lvbnMpXG5cbiAgICB0aGlzLnpvb20uc2V0KCdhdXRvJylcblxuICAgIHRoaXMuZW1pdCgnbmV3LWltYWdlJylcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvcnRzIGFuIGltYWdlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZG93bmxvYWQgPSBmYWxzZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgZXhwb3J0IChkb3dubG9hZCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuX3dhdGVybWFya09wZXJhdGlvbikge1xuICAgICAgdGhpcy5fd2F0ZXJtYXJrT3BlcmF0aW9uLnNldEVuYWJsZWQoZmFsc2UpXG4gICAgfVxuXG4gICAgLy8gSW52YWxpZGF0ZSBjYWNoZXNcbiAgICB0aGlzLl9zZGsuc2V0QWxsT3BlcmF0aW9uc1RvRGlydHkoKVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnMuZWRpdG9yLmV4cG9ydFxuICAgIGNvbnN0IGV4cG9ydGVyID0gbmV3IEV4cG9ydGVyKHRoaXMuX3Nkaywgb3B0aW9ucywgZG93bmxvYWQpXG4gICAgcmV0dXJuIGV4cG9ydGVyLmV4cG9ydCgpXG4gICAgICAudGhlbigob3V0cHV0KSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXhwb3J0Jywgb3V0cHV0KVxuICAgICAgICB0aGlzLl9tZWRpYXRvci5lbWl0KENvbnN0YW50cy5FVkVOVFMuRVhQT1JULCBvdXRwdXQsIHRoaXMpXG5cbiAgICAgICAgaWYgKHRoaXMuX3dhdGVybWFya09wZXJhdGlvbikge1xuICAgICAgICAgIHRoaXMuX3dhdGVybWFya09wZXJhdGlvbi5zZXRFbmFibGVkKHRydWUpXG4gICAgICAgICAgdGhpcy5fc2RrLnJlbmRlcigpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnZhbGlkYXRlIGNhY2hlc1xuICAgICAgICB0aGlzLl9zZGsuc2V0QWxsT3BlcmF0aW9uc1RvRGlydHkoKVxuXG4gICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgIH0pXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBTRVJJQUxJWkFUSU9OXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBzZXJpYWxpemVycyBhbmQgZGVzZXJpYWxpemVyc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRTZXJpYWxpemVycyAoKSB7XG4gICAgdGhpcy5fc2VyaWFsaXplcnMgPSB7XG4gICAgICAnMS4wLjAnOiByZXF1aXJlKCdzaGFyZWQvc2VyaWFsaXphdGlvbi8xLjAuMCcpLmRlZmF1bHQsXG4gICAgICAnMS4wLjEnOiByZXF1aXJlKCdzaGFyZWQvc2VyaWFsaXphdGlvbi8xLjAuMScpLmRlZmF1bHQsXG4gICAgICAnMi4wLjAnOiByZXF1aXJlKCdzaGFyZWQvc2VyaWFsaXphdGlvbi8yLjAuMCcpLmRlZmF1bHQsXG4gICAgICAnMi4wLjEnOiByZXF1aXJlKCdzaGFyZWQvc2VyaWFsaXphdGlvbi8yLjAuMScpLmRlZmF1bHQsXG4gICAgICAnMy4wLjAnOiByZXF1aXJlKCdzaGFyZWQvc2VyaWFsaXphdGlvbi8zLjAuMCcpLmRlZmF1bHQsXG4gICAgICAnMy4xLjAnOiByZXF1aXJlKCdzaGFyZWQvc2VyaWFsaXphdGlvbi8zLjEuMCcpLmRlZmF1bHRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZWRpdG9yIHN0YXRlIGZvciB0aGUgZ2l2ZW4gdmVyc2lvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgPSB7fVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHZlcnNpb24gPSAnMy4xLjAnXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBzZXJpYWxpemUgKG9wdGlvbnMgPSB7fSwgdmVyc2lvbiA9ICczLjEuMCcpIHtcbiAgICBjb25zdCBTZXJpYWxpemVyID0gdGhpcy5fc2VyaWFsaXplcnNbdmVyc2lvbl1cbiAgICBpZiAoIVNlcmlhbGl6ZXIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYE5vIHNlcmlhbGl6ZXIgZm9yIHZlcnNpb24gJHt2ZXJzaW9ufSBmb3VuZC5gKSlcbiAgICB9XG4gICAgY29uc3Qgc2VyaWFsaXplciA9IG5ldyBTZXJpYWxpemVyKHRoaXMpXG4gICAgcmV0dXJuIHNlcmlhbGl6ZXIuc2VyaWFsaXplKG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBkYXRhXG4gICAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgZGVzZXJpYWxpemUgKGRhdGEpIHtcbiAgICBjb25zdCBTZXJpYWxpemVyID0gdGhpcy5fc2VyaWFsaXplcnNbZGF0YS52ZXJzaW9uXVxuICAgIGlmICghU2VyaWFsaXplcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgTm8gc2VyaWFsaXplciBmb3IgdmVyc2lvbiAke2RhdGEudmVyc2lvbn0gZm91bmQuYCkpXG4gICAgfVxuICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgU2VyaWFsaXplcih0aGlzKVxuICAgIHJldHVybiBzZXJpYWxpemVyLmRlc2VyaWFsaXplKGRhdGEpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuem9vbS5zZXQoJ2F1dG8nKVxuICAgICAgfSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSByZW5kZXJpbmcgb2Zmc2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlPZmZzZXQgKCkge1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX29mZnNldC5jbG9uZSgpXG5cbiAgICBvZmZzZXQueCAtPSB0aGlzLl9wYWRkaW5nWzFdIC8gMlxuICAgIG9mZnNldC54ICs9IHRoaXMuX3BhZGRpbmdbM10gLyAyXG5cbiAgICBvZmZzZXQueSAtPSB0aGlzLl9wYWRkaW5nWzJdIC8gMlxuICAgIG9mZnNldC55ICs9IHRoaXMuX3BhZGRpbmdbMF0gLyAyXG5cbiAgICB0aGlzLl9zZGsuc2V0T2Zmc2V0KG9mZnNldClcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIHJlbmRlciBsb29wXG4gICAqL1xuICBzdGFydCAoKSB7XG4gICAgdGhpcy56b29tLnNldCgnYXV0bycpXG4gICAgdGhpcy5fYW5pbWF0aW9uRnJhbWVSZXF1ZXN0ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3RpY2spXG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgdGhlIHJlbmRlciBsb29wXG4gICAqL1xuICBzdG9wICgpIHtcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2VcbiAgICBpZiAodGhpcy5fYW5pbWF0aW9uRnJhbWVSZXF1ZXN0KSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9hbmltYXRpb25GcmFtZVJlcXVlc3QpXG4gICAgICB0aGlzLl9yZW5kZXJDYWxsYmFja3MgPSBbXVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBhIHJlbmRlciwgYWRkcyBgY2FsbGJhY2tgIHRvIHRoZSByZW5kZXIgY2FsbGJhY2tzXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAqL1xuICByZW5kZXIgKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fcmVuZGVyUmVxdWVzdGVkID0gdHJ1ZVxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9mZnNldCB0byB0aGUgZ2l2ZW4gb25lXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBvZmZzZXRcbiAgICovXG4gIHNldE9mZnNldCAob2Zmc2V0KSB7XG4gICAgdGhpcy5fb2Zmc2V0ID0gdGhpcy5fY2xhbXBPZmZzZXQob2Zmc2V0KVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAqIEByZXR1cm5zIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBnZXRPZmZzZXQgKCkge1xuICAgIHJldHVybiB0aGlzLl9vZmZzZXRcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcyBzdXJlIHRoZSBpbWFnZSBzdGF5cyBpbnNpZGUgdGhlIHZpZXdwb3J0XG4gICAqL1xuICBmaXhPZmZzZXQgKCkge1xuICAgIHRoaXMuc2V0T2Zmc2V0KHRoaXMuX3Nkay5nZXRPZmZzZXQoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXhlcyB0aGUgZ2l2ZW4gb2Zmc2V0IHRvIG1ha2Ugc3VyZSB0aGUgaW1hZ2Ugc3RheXMgaW5zaWRlIHRoZSB2aWV3cG9ydFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NsYW1wT2Zmc2V0IChvZmZzZXQpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3Nkay5nZXRSZW5kZXJlcigpXG4gICAgY29uc3QgcmVuZGVyZXJEaW1lbnNpb25zID0gbmV3IFZlY3RvcjIocmVuZGVyZXIuZ2V0V2lkdGgoKSwgcmVuZGVyZXIuZ2V0SGVpZ2h0KCkpXG4gICAgY29uc3Qgb3V0cHV0RGltZW5zaW9ucyA9IHRoaXMuX3Nkay5nZXRPdXRwdXREaW1lbnNpb25zKGZhbHNlKVxuXG4gICAgY29uc3QgbWluT2Zmc2V0ID0gcmVuZGVyZXJEaW1lbnNpb25zLmNsb25lKClcbiAgICAgIC5zdWJ0cmFjdChvdXRwdXREaW1lbnNpb25zKVxuICAgICAgLmRpdmlkZSgyKVxuICAgICAgLmNsYW1wKG51bGwsIG5ldyBWZWN0b3IyKDAsIDApKVxuXG4gICAgY29uc3QgbWF4T2Zmc2V0ID0gb3V0cHV0RGltZW5zaW9ucy5jbG9uZSgpXG4gICAgICAuc3VidHJhY3QocmVuZGVyZXJEaW1lbnNpb25zKVxuICAgICAgLmRpdmlkZSgyKVxuICAgICAgLmNsYW1wKG5ldyBWZWN0b3IyKDAsIDApLCBudWxsKVxuXG4gICAgY29uc3QgbmV3T2Zmc2V0ID0gb2Zmc2V0LmNsb25lKClcbiAgICAgIC5jbGFtcChtaW5PZmZzZXQsIG1heE9mZnNldClcbiAgICAgIC5yb3VuZCgpXG5cbiAgICByZXR1cm4gbmV3T2Zmc2V0XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBhbmltYXRpb24gZnJhbWUgaXMgYmVpbmcgcHJvY2Vzc2VkLiBSZW5kZXJzIHRoZVxuICAgKiBjYW52YXMgaWYgbmVjZXNzYXJ5LCByZXF1ZXN0cyBhbm90aGVyIGFuaW1hdGlvbiBmcmFtZSBjYWxsYmFja3NcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90aWNrICgpIHtcbiAgICBpZiAodGhpcy5fcmVuZGVyUmVxdWVzdGVkKSB7XG4gICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLl9yZW5kZXJDYWxsYmFja3Muc2xpY2UoMClcbiAgICAgIHRoaXMuX3JlbmRlckNhbGxiYWNrcyA9IFtdXG5cbiAgICAgIHRoaXMuX3JlbmRlcigpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICBjYWxsYmFja3MuZm9yRWFjaCgocikgPT4gcigpKVxuICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkZyYW1lUmVxdWVzdCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl90aWNrKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICBMb2cuZXJyb3IoJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIHJlbmRlcmluZzogJyArIGUubWVzc2FnZSlcbiAgICAgICAgfSlcbiAgICAgIHRoaXMuX3JlbmRlclJlcXVlc3RlZCA9IGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FuaW1hdGlvbkZyYW1lUmVxdWVzdCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl90aWNrKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhIHJlbmRlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlciAoKSB7XG4gICAgaWYgKCF0aGlzLl9yZWFkeSkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cbiAgICB0aGlzLl9hcHBseU9mZnNldCgpXG5cbiAgICByZXR1cm4gdGhpcy5fc2RrLnJlbmRlcigpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuX2xhc3RPdXRwdXRCb3VuZHMgPSB0aGlzLl9zZGsuZ2V0U3ByaXRlKCkuZ2V0Qm91bmRzKClcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KCdyZW5kZXItZXJyb3InLCBlKVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgZXZlcnl0aGluZ1xuICAgKi9cbiAgcmVzZXQgKCkge1xuICAgIHRoaXMuX3Nkay5yZXNldCgpXG5cbiAgICB0aGlzLmhpc3RvcnkucmVzZXQoKVxuICAgIHRoaXMub3BlcmF0aW9ucy5yZXNldCgpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBESVNQT1NBTFxuXG4gIC8qKlxuICAgKiBDbGVhbnMgdGhpcyBpbnN0YW5jZSB1cFxuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG4gICAgdGhpcy5zdG9wKClcblxuICAgIHRoaXMuX3Nkay5kaXNwb3NlKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEdFVFRFUlMgLyBTRVRURVJTXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgRWRpdG9yIGlzIHJlYWR5IHRvIHJlbmRlclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNSZWFkeSAoKSB7IHJldHVybiB0aGlzLl9yZWFkeSB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5CYXNlUmVuZGVyZXJ9XG4gICAqL1xuICBnZXRSZW5kZXJlciAoKSB7IHJldHVybiB0aGlzLl9zZGsuZ2V0UmVuZGVyZXIoKSB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFNES1xuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNES31cbiAgICovXG4gIGdldFNESyAoKSB7IHJldHVybiB0aGlzLl9zZGsgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbnB1dCBpbWFnZSBkaW1lbnNpb25zXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIGdldElucHV0RGltZW5zaW9ucyAoKSB7IHJldHVybiB0aGlzLl9zZGsuZ2V0SW5wdXREaW1lbnNpb25zKGZhbHNlKSB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhZGRpbmcgdmFsdWVzXG4gICAqIEByZXR1cm4ge051bWJlcltdfVxuICAgKi9cbiAgZ2V0UGFkZGluZyAoKSB7IHJldHVybiB0aGlzLl9wYWRkaW5nIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcGFkZGluZyAodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0KVxuICAgKiBAcGFyYW0ge051bWJlcltdfSBwYWRkaW5nXG4gICAqL1xuICBzZXRQYWRkaW5nIChwYWRkaW5nKSB7XG4gICAgaWYgKCFwYWRkaW5nKSB7XG4gICAgICB0aGlzLl9wYWRkaW5nID0gWzAsIDAsIDAsIDBdXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BhZGRpbmcgPSBwYWRkaW5nXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGltYWdlXG4gICAqIEByZXR1cm4ge0ltYWdlfVxuICAgKi9cbiAgZ2V0SW1hZ2UgKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmVkaXRvci5pbWFnZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbnNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0T3B0aW9ucyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBVSVxuICAgKiBAcmV0dXJuIHtSZWFjdFVJfVxuICAgKi9cbiAgZ2V0VUkgKCkge1xuICAgIHJldHVybiB0aGlzLl91aVxuICB9XG5cbiAgZ2V0TWVkaWF0b3IgKCkge1xuICAgIHJldHVybiB0aGlzLl9tZWRpYXRvclxuICB9XG5cbiAgLyoqXG4gICAqIEJyb2FkY2FzdHMgYSB0cmFuc2Zvcm0gdG8gYWxsIG9wZXJhdGlvbnMgdGhhdCBuZWVkIHRvIGJlIGNoYW5nZWRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5UcmFuc2Zvcm1PcGVyYXRpb259IHRyYW5zZm9ybU9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGJyb2FkY2FzdFRyYW5zZm9ybSAodHJhbnNmb3JtT3BlcmF0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtQ2hhbmdlID0gbmV3IFNESy5PcGVyYXRpb25zLlRyYW5zZm9ybU9wZXJhdGlvbi5UcmFuc2Zvcm1DaGFuZ2UodHJhbnNmb3JtT3BlcmF0aW9uLCBvcHRpb25zKVxuICAgIGNvbnN0IHRyYW5zZm9ybWFibGVPcGVyYXRpb25zID0gW1xuICAgICAgJ3Nwcml0ZScsICdzZWxlY3RpdmUtYmx1cicsICdyYWRpYWwtZm9jdXMnLCAnbWlycm9yZWQtZm9jdXMnLCAnbGluZWFyLWZvY3VzJywgJ2JsdXInXG4gICAgXVxuICAgIHRyYW5zZm9ybWFibGVPcGVyYXRpb25zLmZvckVhY2goKGlkZW50aWZpZXIpID0+IHtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMub3BlcmF0aW9ucy5nZXQoaWRlbnRpZmllcilcbiAgICAgIGlmICghb3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgb3BlcmF0aW9uLnRyYW5zZm9ybSh0cmFuc2Zvcm1DaGFuZ2UpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBCcm9hZGNhc3RzIGEgZmxpcCB0byBhbGwgb3BlcmF0aW9ucyB0aGF0IG5lZWQgdG8gYmUgY2hhbmdlZFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpcmVjdGlvblxuICAgKi9cbiAgYnJvYWRjYXN0RmxpcCAoZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgZmxpcHBhYmxlT3BlcmF0aW9ucyA9IFsnbWlycm9yZWQtZm9jdXMnLCAncmFkaWFsLWZvY3VzJywgJ3Nwcml0ZScsICdzZWxlY3RpdmUtYmx1ciddXG4gICAgZmxpcHBhYmxlT3BlcmF0aW9ucy5mb3JFYWNoKChpZGVudGlmaWVyKSA9PiB7XG4gICAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLm9wZXJhdGlvbnMuZ2V0KGlkZW50aWZpZXIpXG4gICAgICBpZiAoIW9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIG9wZXJhdGlvbi5mbGlwKGRpcmVjdGlvbilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEJyb2FkY2FzdHMgYSByb3RhdGlvbiB0byBhbGwgb3BlcmF0aW9ucyB0aGF0IG5lZWQgdG8gYmUgY2hhbmdlZFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGRlZ3JlZXNcbiAgICovXG4gIGJyb2FkY2FzdFJvdGF0ZSAoZGVncmVlcykge1xuICAgIGNvbnN0IGZsaXBwYWJsZU9wZXJhdGlvbnMgPSBbJ3RyYW5zZm9ybScsICdtaXJyb3JlZC1mb2N1cycsICdyYWRpYWwtZm9jdXMnLCAnc3ByaXRlJywgJ3NlbGVjdGl2ZS1ibHVyJ11cbiAgICBmbGlwcGFibGVPcGVyYXRpb25zLmZvckVhY2goKGlkZW50aWZpZXIpID0+IHtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMub3BlcmF0aW9ucy5nZXQoaWRlbnRpZmllcilcbiAgICAgIGlmICghb3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgb3BlcmF0aW9uLnJvdGF0ZShkZWdyZWVzKVxuICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRWRpdG9yXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvZWRpdG9yLmpzIiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgUGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5Db250cm9sc1xuICovXG5leHBvcnQgeyBkZWZhdWx0IGFzIGFkanVzdG1lbnRzIH0gZnJvbSAnLi9hZGp1c3RtZW50cydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdHJhbnNmb3JtIH0gZnJvbSAnLi90cmFuc2Zvcm0nXG5leHBvcnQgeyBkZWZhdWx0IGFzIGZpbHRlciB9IGZyb20gJy4vZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmb2N1cyB9IGZyb20gJy4vZm9jdXMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIHN0aWNrZXIgfSBmcm9tICcuL3N0aWNrZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIHRleHQgfSBmcm9tICcuL3RleHQnXG5leHBvcnQgeyBkZWZhdWx0IGFzIGJydXNoIH0gZnJvbSAnLi9icnVzaCdcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc2VsZWN0aXZlQmx1ciB9IGZyb20gJy4vc2VsZWN0aXZlLWJsdXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIGZyYW1lIH0gZnJvbSAnLi9mcmFtZSdcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvaW5kZXguanMiLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgQ2F0ZWdvcnlEcm9wZG93bk92ZXJsYXlDb21wb25lbnQgZnJvbSAnLi9vdmVybGF5LWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2F0ZWdvcnlEcm9wZG93bkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25CdXR0b25DbGljaydcbiAgICApXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgb3ZlcmxheVZpc2libGU6IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGNvbG9yIHBpY2tlciBidXR0b24gaGFzIGJlZW4gY2xpY2tlZFxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQnV0dG9uQ2xpY2sgKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICB0aGlzLnNldFN0YXRlKHsgb3ZlcmxheVZpc2libGU6ICF0aGlzLnN0YXRlLm92ZXJsYXlWaXNpYmxlIH0pXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgbGV0IE92ZXJsYXkgPSBudWxsXG5cbiAgICBpZiAodGhpcy5zdGF0ZS5vdmVybGF5VmlzaWJsZSkge1xuICAgICAgT3ZlcmxheSA9ICg8Q2F0ZWdvcnlEcm9wZG93bk92ZXJsYXlDb21wb25lbnRcbiAgICAgICAgaXRlbXM9e3RoaXMucHJvcHMuaXRlbXN9XG4gICAgICAgIHNlbGVjdGVkSXRlbT17dGhpcy5wcm9wcy5zZWxlY3RlZEl0ZW19XG4gICAgICAgIG9uQ2hhbmdlPXt0aGlzLnByb3BzLm9uQ2hhbmdlfSAvPilcbiAgICB9XG5cbiAgICBjb25zdCBjbGFzc05hbWUgPSB0aGlzLnN0YXRlLm92ZXJsYXlWaXNpYmxlID8gJ2lzLWFjdGl2ZScgOiBudWxsXG5cbiAgICByZXR1cm4gKDxiZW0gc3BlY2lmaWVyPSckYjpjb250cm9scyc+XG4gICAgICA8ZGl2IGJlbT0nJGU6Y2F0ZWdvcnlEcm9wZG93bicgY2xhc3NOYW1lPXtjbGFzc05hbWV9IG9uQ2xpY2s9e3RoaXMuX29uQnV0dG9uQ2xpY2t9PlxuICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMucHJvcHMuc2VsZWN0ZWRJdGVtLmljb259IC8+XG4gICAgICAgIDxkaXYgYmVtPSdlOmxhYmVsJz57dGhpcy5wcm9wcy5zZWxlY3RlZEl0ZW0ubGFiZWx9PC9kaXY+XG4gICAgICAgIHtPdmVybGF5fVxuICAgICAgPC9kaXY+XG4gICAgPC9iZW0+KVxuICB9XG59XG5cbkNhdGVnb3J5RHJvcGRvd25Db21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY2F0ZWdvcnktZHJvcGRvd24vY2F0ZWdvcnktZHJvcGRvd24tY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9udFByZXZpZXdDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudERpZE1vdW50KClcbiAgICB0aGlzLl9yZW5kZXJDYW52YXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIGFmdGVyIHRoaXMgY29tcG9uZW50IGhhcyBiZWVuIHVwZGF0ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZFVwZGF0ZSAoKSB7XG4gICAgdGhpcy5fcmVuZGVyQ2FudmFzKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIENBTlZBUyBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY3VycmVudCBmb250IGZhbWlseSBvbnRvIHRoZSBjYW52YXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJDYW52YXMgKCkge1xuICAgIGNvbnN0IHsgY2FudmFzIH0gPSB0aGlzLnJlZnNcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgc2RrID0gZWRpdG9yLmdldFNESygpXG5cbiAgICBjb25zdCBwaXhlbFJhdGlvID0gc2RrLmdldFBpeGVsUmF0aW8oKVxuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5vZmZzZXRXaWR0aCAqIHBpeGVsUmF0aW9cbiAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLm9mZnNldEhlaWdodCAqIHBpeGVsUmF0aW9cblxuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGAke2NhbnZhcy5vZmZzZXRXaWR0aH1weGBcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gYCR7Y2FudmFzLm9mZnNldEhlaWdodH1weGBcblxuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAncmVkJ1xuICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcblxuICAgIGNvbnRleHQuZm9udCA9IGAke3RoaXMucHJvcHMuZm9udFN0eWxlIHx8ICcnfSAke3RoaXMucHJvcHMuZm9udFdlaWdodCB8fCAnJ30gJHsyNCAqIHBpeGVsUmF0aW99cHggJHt0aGlzLnByb3BzLmZvbnRGYW1pbHl9YFxuICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ21pZGRsZSdcbiAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAnd2hpdGUnXG5cbiAgICBjb250ZXh0LmZpbGxUZXh0KCdBYmMnLCBjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMilcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICByZXR1cm4gKDxjYW52YXMgYmVtPSdiOmZvbnRGYW1pbHkgZTpjYW52YXMnIHJlZj0nY2FudmFzJyAvPilcbiAgfVxufVxuXG5Gb250UHJldmlld0NvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy90ZXh0L2ZvbnQtcHJldmlldy1jb21wb25lbnQuanN4IiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBPcHRpb25UeXBlLCBDb25maWd1cmFibGUgfSBmcm9tICdwaG90b2VkaXRvcnNkaydcblxuY29uc3QgRk9OVF9XRUlHSFRTID0ge1xuICAxMDA6ICdFeHRyYSBMaWdodCcsXG4gIDIwMDogJ0xpZ2h0JyxcbiAgMzAwOiAnQm9vaycsXG4gIDQwMDogJ1JlZ3VsYXInLFxuICA1MDA6ICdNZWRpdW0nLFxuICA2MDA6ICdTZW1pYm9sZCcsXG4gIDcwMDogJ0JvbGQnLFxuICA4MDA6ICdCbGFjaycsXG4gIDkwMDogJ0V4dHJhIEJsYWNrJyxcbiAgYm9sZDogJ0JvbGQnLFxuICBub3JtYWw6ICdSZWd1bGFyJ1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb250VmFyaWF0aW9uIGV4dGVuZHMgQ29uZmlndXJhYmxlIHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhYmVsIGZvciB0aGlzIHZhcmlhdGlvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXRMYWJlbCAoKSB7XG4gICAgbGV0IGxhYmVsID0gRk9OVF9XRUlHSFRTW3RoaXMuX29wdGlvbnMuZm9udFdlaWdodF1cblxuICAgIHN3aXRjaCAodGhpcy5fb3B0aW9ucy5mb250U3R5bGUpIHtcbiAgICAgIGNhc2UgJ2l0YWxpYyc6XG4gICAgICAgIGxhYmVsICs9ICcgSXRhbGljJ1xuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIHJldHVybiBsYWJlbFxuICB9XG59XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBhdmFpbGFibGUgb3B0aW9ucyBmb3IgdGhlIEZvbnRWYXJpYXRpb24gY2xhc3NcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAaWdub3JlXG4gKi9cbkZvbnRWYXJpYXRpb24ucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIGlkZW50aWZpZXI6IHsgdHlwZTogT3B0aW9uVHlwZS5TVFJJTkcsIHJlcXVpcmVkOiB0cnVlIH0sXG4gIGZvbnRGYW1pbHk6IHsgdHlwZTogT3B0aW9uVHlwZS5TVFJJTkcsIHJlcXVpcmVkOiB0cnVlIH0sXG4gIGZvbnRXZWlnaHQ6IHsgdHlwZTogT3B0aW9uVHlwZS5BTEwsIGRlZmF1bHQ6IDQwMCB9LFxuICBmb250U3R5bGU6IHsgdHlwZTogT3B0aW9uVHlwZS5TVFJJTkcsIGRlZmF1bHQ6ICdub3JtYWwnIH0sXG4gIHRleHRNZXRyaWNzOiB7IHR5cGU6IE9wdGlvblR5cGUuT0JKRUNULCBkZWZhdWx0OiBudWxsIH0sXG4gIHByb3ZpZGVyOiB7IHR5cGU6IE9wdGlvblR5cGUuU1RSSU5HLCBhdmFpbGFibGU6IFsnZ29vZ2xlJywgJ2ZpbGUnXSB9LFxuICBmaWxlUGF0aDogeyB0eXBlOiBPcHRpb25UeXBlLlNUUklORyB9LFxuICBkZWZhdWx0OiB7IHR5cGU6IE9wdGlvblR5cGUuQk9PTEVBTiwgZGVmYXVsdDogZmFsc2UgfSxcbiAgZm9udDogeyB0eXBlOiBPcHRpb25UeXBlLk9CSkVDVCB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9hc3NldHMvZm9udC12YXJpYXRpb24uanMiLCIvKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBVdGlscywgU2hhcmVkQ29uc3RhbnRzIH0gZnJvbSAnZ2xvYmFscydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRnJhbWVNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IgKHVpLCBvcHRpb25zKSB7XG4gICAgdGhpcy5fdWkgPSB1aVxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG5cbiAgICB0aGlzLl9jYXRlZ29yaWVzQnlJZCA9IHt9XG4gICAgdGhpcy5fY2F0ZWdvcmllcyA9IFtdXG4gICAgdGhpcy5fZnJhbWVzQnlJZCA9IHt9XG5cbiAgICB0aGlzLl9hZGRDYXRlZ29yaWVzKFNoYXJlZENvbnN0YW50cy5ERUZBVUxUUy5GUkFNRV9DQVRFR09SSUVTKVxuXG4gICAgY29uc3QgeyBjYXRlZ29yaWVzLCByZXBsYWNlQ2F0ZWdvcmllcyB9ID0gdGhpcy5fb3B0aW9uc1xuICAgIGlmICh0aGlzLl9vcHRpb25zLmNhdGVnb3JpZXMpIHtcbiAgICAgIHRoaXMuX2FkZENhdGVnb3JpZXMoY2F0ZWdvcmllcywgcmVwbGFjZUNhdGVnb3JpZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUFsbENhdGVnb3J5KClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNhdGVnb3JpZXNcbiAgICogQHBhcmFtIHtPYmplY3RbXX0gY2F0ZWdvcmllc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlcGxhY2UgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FkZENhdGVnb3JpZXMgKGNhdGVnb3JpZXMsIHJlcGxhY2UgPSBmYWxzZSkge1xuICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICB0aGlzLl9jYXRlZ29yaWVzID0gY2F0ZWdvcmllcy5zbGljZSgwKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jYXRlZ29yaWVzID0gVXRpbHMubWVyZ2VDYXRlZ29yaWVzKFxuICAgICAgICB0aGlzLl9jYXRlZ29yaWVzLFxuICAgICAgICBjYXRlZ29yaWVzLFxuICAgICAgICAnZnJhbWVzJ1xuICAgICAgKVxuICAgIH1cblxuICAgIC8vIEJ1aWxkIGNhdCBpZCA9PiBjYXRlZ29yeSBoYXNoXG4gICAgdGhpcy5fY2F0ZWdvcmllc0J5SWQgPSB7fVxuICAgIHRoaXMuX2NhdGVnb3JpZXMuZm9yRWFjaCgoYykgPT4geyB0aGlzLl9jYXRlZ29yaWVzQnlJZFtjLmlkZW50aWZpZXJdID0gYyB9KVxuXG4gICAgLy8gRmlsdGVyIGZyYW1lc1xuICAgIGNvbnN0IHsgYXZhaWxhYmxlRnJhbWVzIH0gPSB0aGlzLl9vcHRpb25zXG4gICAgaWYgKGF2YWlsYWJsZUZyYW1lcykge1xuICAgICAgdGhpcy5fY2F0ZWdvcmllcy5mb3JFYWNoKGMgPT4ge1xuICAgICAgICBjLmZyYW1lcyA9IGMuZnJhbWVzLmZpbHRlcihmID0+IGF2YWlsYWJsZUZyYW1lcy5pbmRleE9mKGYuaWRlbnRpZmllcikgIT09IC0xKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBCdWlsZCBmcmFtZSBpZCA9PiBmcmFtZSBoYXNoXG4gICAgdGhpcy5fY2F0ZWdvcmllcy5mb3JFYWNoKGMgPT4ge1xuICAgICAgYy5mcmFtZXMuZm9yRWFjaChzID0+IHtcbiAgICAgICAgdGhpcy5fZnJhbWVzQnlJZFtzLmlkZW50aWZpZXJdID0gc1xuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5fdXBkYXRlQWxsQ2F0ZWdvcnkoKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGBhbGxgIGNhdGVnb3J5IHdoaWNoIGNvbnRhaW5zIGFsbCBmcmFtZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVBbGxDYXRlZ29yeSAoKSB7XG4gICAgdGhpcy5fYWxsQ2F0ZWdvcnkgPSB7XG4gICAgICBpZGVudGlmaWVyOiAnYWxsJyxcbiAgICAgIGRlZmF1bHROYW1lOiAnQWxsJyxcbiAgICAgIGZyYW1lczogdGhpcy5fY2F0ZWdvcmllc1xuICAgICAgICAubWFwKChjKSA9PiBjLmZyYW1lcylcbiAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKVxuICAgIH1cbiAgICB0aGlzLl9jYXRlZ29yaWVzQnlJZC5hbGwgPSB0aGlzLl9hbGxDYXRlZ29yeVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZyYW1lcyBmb3IgdGhlIGNhdGVnb3J5IHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBjYXRlZ29yeU5hbWVcbiAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAqL1xuICBnZXRGcmFtZXNGb3JDYXRlZ29yeSAoY2F0ZWdvcnlOYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9jYXRlZ29yaWVzQnlJZFtjYXRlZ29yeU5hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZnJhbWUgY2F0ZWdvcnkgJyR7Y2F0ZWdvcnlOYW1lfSdgKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2F0ZWdvcmllc0J5SWRbY2F0ZWdvcnlOYW1lXS5mcmFtZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmcmFtZSB3aXRoIHRoZSBnaXZlbiBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gaWRlbnRpZmllclxuICAgKi9cbiAgZ2V0RnJhbWVCeUlkZW50aWZpZXIgKGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fZnJhbWVzQnlJZFtpZGVudGlmaWVyXVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNhdGVnb3JpZXNcbiAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAqL1xuICBnZXRDYXRlZ29yaWVzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2F0ZWdvcmllc1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNhdGVnb3J5IG9iamVjdCBmb3IgdGhlIGdpdmVuIGlkXG4gICAqIEBwYXJhbSAge1N0cmluZ30gaWRcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0Q2F0ZWdvcnkgKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhdGVnb3JpZXNCeUlkW2lkXVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9tYW5hZ2Vycy9mcmFtZS1tYW5hZ2VyLmpzIiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgU0RLIH0gZnJvbSAnZ2xvYmFscydcbmNvbnN0IHsgT3B0aW9uVHlwZSB9ID0gU0RLXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZyYW1lIGV4dGVuZHMgU0RLLkNvbmZpZ3VyYWJsZSB7XG4gIGNvbnN0cnVjdG9yICh1aSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucylcblxuICAgIHRoaXMuX2xvYWRlZCA9IGZhbHNlXG4gICAgdGhpcy5fbG9hZGluZyA9IGZhbHNlXG4gICAgdGhpcy5fdWkgPSB1aVxuICAgIHRoaXMuX2ZyYW1lID0gU0RLLlV0aWxzLmRlZXBDbG9uZSh0aGlzLl9vcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBpbWFnZXMgb2YgdGhpcyBmcmFtZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgbG9hZCAoKSB7XG4gICAgaWYgKHRoaXMuX2xvYWRlZCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgaWYgKHRoaXMuX2xvYWRpbmcpIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0NhbGxlZCBGcmFtZSNsb2FkIHdoaWxlIGl0XFwncyBhbHJlYWR5IGxvYWRpbmcnKSlcblxuICAgIHRoaXMuX2xvYWRpbmcgPSB0cnVlXG4gICAgY29uc3QgeyBpbWFnZUdyb3VwcyB9ID0gdGhpcy5fZnJhbWVcblxuICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgWyd0b3AnLCAnbGVmdCcsICdyaWdodCcsICdib3R0b20nXS5mb3JFYWNoKChncm91cE5hbWUpID0+IHtcbiAgICAgIGlmICghKGdyb3VwTmFtZSBpbiBpbWFnZUdyb3VwcykpIHJldHVyblxuXG4gICAgICBjb25zdCBncm91cCA9IGltYWdlR3JvdXBzW2dyb3VwTmFtZV07XG4gICAgICBbJ3N0YXJ0JywgJ21pZCcsICdlbmQnXS5mb3JFYWNoKChwYXJ0TmFtZSkgPT4ge1xuICAgICAgICBpZiAoIShwYXJ0TmFtZSBpbiBncm91cCkpIHJldHVyblxuXG4gICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fbG9hZFBhcnQoZ3JvdXBOYW1lLCBwYXJ0TmFtZSkpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuX2xvYWRlZCA9IHRydWVcbiAgICAgICAgdGhpcy5fbG9hZGluZyA9IGZhbHNlXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIHRoaXMuX2xvYWRlZCA9IGZhbHNlXG4gICAgICAgIHRoaXMuX2xvYWRpbmcgPSBmYWxzZVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyB0aGUgZ2l2ZW4gcGFydCBvZiB0aGUgZ2l2ZW4gZ3JvdXBcbiAgICogQHBhcmFtICB7U3RyaW5nfSBncm91cE5hbWVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBwYXJ0TmFtZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2xvYWRQYXJ0IChncm91cE5hbWUsIHBhcnROYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHsgaW1hZ2VHcm91cHMgfSA9IHRoaXMuX2ZyYW1lXG5cbiAgICAgIGxldCBwYXJ0ID0gaW1hZ2VHcm91cHNbZ3JvdXBOYW1lXVtwYXJ0TmFtZV1cbiAgICAgIGxldCBpbWFnZVVybCA9IHBhcnRcbiAgICAgIC8vIGBwYXJ0YCBjYW4gYWxzbyBiZSBhbiBvYmplY3QgY29udGFpbmluZyBgbW9kZWAgYW5kIGBpbWFnZWBcbiAgICAgIGlmICh0eXBlb2YgcGFydCAhPT0gJ3N0cmluZycgJiYgJ2ltYWdlJyBpbiBwYXJ0KSB7XG4gICAgICAgIGltYWdlVXJsID0gcGFydC5pbWFnZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBpbWFnZSA9IG5ldyB3aW5kb3cuSW1hZ2UoKVxuICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuX2ZyYW1lLmltYWdlR3JvdXBzW2dyb3VwTmFtZV1bcGFydE5hbWVdLmltYWdlID0gaW1hZ2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9mcmFtZS5pbWFnZUdyb3Vwc1tncm91cE5hbWVdW3BhcnROYW1lXSA9IGltYWdlXG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKGltYWdlKVxuICAgICAgfSlcbiAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBpbWFnZSBhdCAke2ltYWdlVXJsfWApKVxuICAgICAgfSlcbiAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gdGhpcy5fdWkuZ2V0RWRpdG9yKCkuZ2V0Q3Jvc3NPcmlnaW4oKVxuICAgICAgaW1hZ2Uuc3JjID0gdGhpcy5fdWkuZ2V0QXNzZXRQYXRoKGltYWdlVXJsKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZnJhbWVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0RnJhbWUgKCkge1xuICAgIHJldHVybiB0aGlzLl9mcmFtZVxuICB9XG59XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBhdmFpbGFibGUgb3B0aW9ucyBmb3IgdGhlIEZyYW1lIGNsYXNzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGlnbm9yZVxuICovXG5GcmFtZS5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgaWRlbnRpZmllcjogeyB0eXBlOiBPcHRpb25UeXBlLlNUUklORywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgZGVmYXVsdE5hbWU6IHsgdHlwZTogT3B0aW9uVHlwZS5TVFJJTkcgfSxcbiAgdGh1bWJuYWlsOiB7IHR5cGU6IE9wdGlvblR5cGUuU1RSSU5HIH0sXG4gIHRpbnRhYmxlOiB7IHR5cGU6IE9wdGlvblR5cGUuQk9PTEVBTiwgZGVmYXVsdDogZmFsc2UgfSxcbiAgbGF5b3V0TW9kZToge1xuICAgIHR5cGU6IE9wdGlvblR5cGUuU1RSSU5HLFxuICAgIGRlZmF1bHQ6ICdob3Jpem9udGFsLWluc2lkZScsXG4gICAgYXZhaWxhYmxlOiBbJ2hvcml6b250YWwtaW5zaWRlJywgJ3ZlcnRpY2FsLWluc2lkZSddXG4gIH0sXG4gIGltYWdlR3JvdXBzOiB7IHR5cGU6IE9wdGlvblR5cGUuT0JKRUNULCByZXF1aXJlZDogdHJ1ZSB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvZnJhbWUuanMiLCIvKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFNES1V0aWxzLCBJbWFnZUZvcm1hdCwgTG9nIH0gZnJvbSAnZ2xvYmFscydcbmNvbnN0IFRXSUNFX1BJID0gTWF0aC5QSSAqIDJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgdjEwMFNlcmlhbGl6ZXIge1xuICBjb25zdHJ1Y3RvciAoZWRpdG9yKSB7XG4gICAgdGhpcy5fZWRpdG9yID0gZWRpdG9yXG5cbiAgICB0aGlzLl9zZXJpYWxpemVPcGVyYXRpb25zID0gdGhpcy5fc2VyaWFsaXplT3BlcmF0aW9ucy5iaW5kKHRoaXMpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBTRVJJQUxJWkFUSU9OXG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIGVkaXRvciBzdGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyA9IHt9XG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBzZXJpYWxpemUgKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX29wdGlvbnMgPSBTREtVdGlscy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICBpbWFnZTogdHJ1ZVxuICAgIH0pXG5cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgdmVyc2lvbjogdGhpcy5jb25zdHJ1Y3Rvci52ZXJzaW9uXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZUlucHV0SW1hZ2UoZGF0YSlcbiAgICAgIC50aGVuKHRoaXMuX3NlcmlhbGl6ZU9wZXJhdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgaW5wdXQgaW1hZ2UgYXMgYmFzZTY0IGFuZCBhdHRhY2hlcyBpdCB0byBgZGF0YWBcbiAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VyaWFsaXplSW5wdXRJbWFnZSAoZGF0YSkge1xuICAgIGNvbnN0IGltYWdlID0gdGhpcy5fZWRpdG9yLmdldEltYWdlKClcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGltYWdlXG5cbiAgICBpZiAoIXRoaXMuX29wdGlvbnMuaW1hZ2UpIHtcbiAgICAgIGRhdGEuaW5wdXRJbWFnZSA9IHsgd2lkdGgsIGhlaWdodCB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRhdGEpXG4gICAgfVxuXG4gICAgY29uc3QgY2FudmFzID0gU0RLVXRpbHMuY3JlYXRlQ2FudmFzKClcbiAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aFxuICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHRcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMClcblxuICAgIGNvbnN0IGRhdGFVcmwgPSBjYW52YXMudG9EYXRhVVJMKEltYWdlRm9ybWF0LlBORylcbiAgICBkYXRhLmlucHV0SW1hZ2UgPSB7XG4gICAgICB0eXBlOiBJbWFnZUZvcm1hdC5QTkcsXG4gICAgICBkYXRhOiBkYXRhVXJsLnJlcGxhY2UoL15kYXRhOmltYWdlXFwvKC4qPyk7YmFzZTY0LC8sICcnKSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBvcGVyYXRpb25zIGFuZCBhdHRhY2hlcyB0aGVtIHRvIGBkYXRhYFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGFcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXJpYWxpemVPcGVyYXRpb25zIChkYXRhKSB7XG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IFtdXG4gICAgY29uc3Qgc3RhY2sgPSB0aGlzLl9lZGl0b3Iub3BlcmF0aW9ucy5nZXRTdGFjaygpXG4gICAgc3RhY2suZm9yRWFjaCgob3BlcmF0aW9uKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5fc2VyaWFsaXplT3BlcmF0aW9uKG9wZXJhdGlvbiwgb3BlcmF0aW9ucylcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIG9wZXJhdGlvbnMucHVzaChkYXRhKVxuICAgICAgfVxuICAgIH0pXG4gICAgZGF0YS5vcGVyYXRpb25zID0gb3BlcmF0aW9ucy5maWx0ZXIobyA9PiBvKSAvLyBSZW1vdmUgcG9zc2libGUgYG51bGxgIG9wZXJhdGlvbnNcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRhdGEpXG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbltdfSBvcGVyYXRpb25zXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXJpYWxpemVPcGVyYXRpb24gKG9wZXJhdGlvbiwgb3BlcmF0aW9ucykge1xuICAgIHN3aXRjaCAob3BlcmF0aW9uLmNvbnN0cnVjdG9yLmlkZW50aWZpZXIpIHtcbiAgICAgIGNhc2UgJ3RyYW5zZm9ybSc6XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemVUcmFuc2Zvcm1PcGVyYXRpb24ob3BlcmF0aW9uKVxuICAgICAgY2FzZSAnb3JpZW50YXRpb24nOlxuICAgICAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXplT3JpZW50YXRpb25PcGVyYXRpb24ob3BlcmF0aW9uKVxuICAgICAgY2FzZSAnZmlsdGVyJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZUZpbHRlck9wZXJhdGlvbihvcGVyYXRpb24pXG4gICAgICBjYXNlICdhZGp1c3RtZW50cyc6XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemVBZGp1c3RtZW50c09wZXJhdGlvbihvcGVyYXRpb24pXG4gICAgICBjYXNlICdzcHJpdGUnOlxuICAgICAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXplU3ByaXRlT3BlcmF0aW9uKG9wZXJhdGlvbiwgb3BlcmF0aW9ucylcbiAgICAgIGNhc2UgJ3JhZGlhbC1mb2N1cyc6XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemVSYWRpYWxGb2N1c09wZXJhdGlvbihvcGVyYXRpb24pXG4gICAgICBjYXNlICdtaXJyb3JlZC1mb2N1cyc6XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemVMaW5lYXJGb2N1c09wZXJhdGlvbihvcGVyYXRpb24pXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBMb2cud2FybihgVW5hYmxlIHRvIHNlcmlhbGl6ZSBvcGVyYXRpb24gb2YgdHlwZSAke29wZXJhdGlvbi5jb25zdHJ1Y3Rvci5pZGVudGlmaWVyfWApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIGdpdmVuIHRyYW5zZm9ybSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9uLlRyYW5zZm9ybU9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXJpYWxpemVUcmFuc2Zvcm1PcGVyYXRpb24gKG9wZXJhdGlvbikge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBvcGVyYXRpb24uc2VyaWFsaXplT3B0aW9ucyhbJ3N0YXJ0JywgJ2VuZCcsICdyb3RhdGlvbiddLCB0cnVlKVxuICAgIG9wdGlvbnMucm90YXRpb24gPSAob3B0aW9ucy5yb3RhdGlvbiArIFRXSUNFX1BJKSAlIFRXSUNFX1BJXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdjcm9wJyxcbiAgICAgIG9wdGlvbnNcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gb3JpZW50YXRpb24gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbi5PcmllbnRhdGlvbk9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXJpYWxpemVPcmllbnRhdGlvbk9wZXJhdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdvcmllbnRhdGlvbicsXG4gICAgICBvcHRpb25zOiBvcGVyYXRpb24uc2VyaWFsaXplT3B0aW9ucyhbXG4gICAgICAgICdmbGlwVmVydGljYWxseScsXG4gICAgICAgICdmbGlwSG9yaXpvbnRhbGx5JyxcbiAgICAgICAgJ3JvdGF0aW9uJ1xuICAgICAgXSwgdHJ1ZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gZmlsdGVyIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLkZpbHRlck9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXJpYWxpemVGaWx0ZXJPcGVyYXRpb24gKG9wZXJhdGlvbikge1xuICAgIGlmIChvcGVyYXRpb24uZ2V0SWRlbnRpZmllcigpID09PSAnaWRlbnRpdHknKSByZXR1cm4gbnVsbFxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdmaWx0ZXInLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBpbnRlbnNpdHk6IG9wZXJhdGlvbi5nZXRJbnRlbnNpdHkoKSxcbiAgICAgICAgbmFtZTogb3BlcmF0aW9uLmdldElkZW50aWZpZXIoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBhZGp1c3RtZW50cyBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5BZGp1c3RtZW50c09wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXJpYWxpemVBZGp1c3RtZW50c09wZXJhdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgY29uc3QgeyBhdmFpbGFibGVPcHRpb25zIH0gPSBvcGVyYXRpb25cblxuICAgIGNvbnN0IG9wdGlvbk5hbWVzID0gW1xuICAgICAgJ2JyaWdodG5lc3MnLCAnc2F0dXJhdGlvbicsICdjb250cmFzdCcsICdleHBvc3VyZScsICdzaGFkb3dzJywgJ2hpZ2hsaWdodHMnLCAnY2xhcml0eSdcbiAgICBdXG4gICAgY29uc3Qgb3B0aW9ucyA9IHt9XG4gICAgb3B0aW9uTmFtZXMuZm9yRWFjaChvcHRpb25OYW1lID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbiA9IGF2YWlsYWJsZU9wdGlvbnNbb3B0aW9uTmFtZV1cbiAgICAgIGNvbnN0IHZhbHVlID0gb3BlcmF0aW9uLmdldE9wdGlvbihvcHRpb25OYW1lKVxuICAgICAgY29uc3QgeyBtaW5WYWx1ZSwgbWlkVmFsdWUsIG1heFZhbHVlIH0gPSBvcHRpb25cbiAgICAgIG9wdGlvbnNbb3B0aW9uTmFtZV0gPSB2YWx1ZSA8PSBtaWRWYWx1ZVxuICAgICAgICA/ICh2YWx1ZSAtIG1pblZhbHVlKSAvIChtaWRWYWx1ZSAtIG1pblZhbHVlKSAtIDFcbiAgICAgICAgOiAodmFsdWUgLSBtaWRWYWx1ZSkgLyAobWF4VmFsdWUgLSBtaWRWYWx1ZSlcbiAgICB9KVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnYWRqdXN0bWVudHMnLFxuICAgICAgb3B0aW9uc1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBzcHJpdGUgb3BlcmF0aW9uXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXJpYWxpemVTcHJpdGVPcGVyYXRpb24gKG9wZXJhdGlvbiwgb3BlcmF0aW9ucykge1xuICAgIGNvbnN0IHNwcml0ZU9wZXJhdGlvbnMgPSBvcGVyYXRpb25zLmZpbHRlcihvID0+IG8udHlwZSA9PT0gJ3Nwcml0ZScpXG4gICAgbGV0IHNwcml0ZU9wZXJhdGlvblxuICAgIGxldCByZXR1cm5PcGVyYXRpb24gPSB0cnVlXG4gICAgaWYgKHNwcml0ZU9wZXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgICBzcHJpdGVPcGVyYXRpb24gPSBzcHJpdGVPcGVyYXRpb25zLnBvcCgpXG4gICAgICByZXR1cm5PcGVyYXRpb24gPSBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBzcHJpdGUgb3BlcmF0aW9uIGV4aXN0cywgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgc3ByaXRlT3BlcmF0aW9uID0ge1xuICAgICAgICB0eXBlOiAnc3ByaXRlJyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHNwcml0ZXM6IFtdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBvcGVyYXRpb24uZ2V0U3ByaXRlcygpXG4gICAgICAuZm9yRWFjaCgoc3ByaXRlKSA9PiB7XG4gICAgICAgIGxldCBzcHJpdGVJdGVtID0gbnVsbFxuICAgICAgICBpZiAoc3ByaXRlIGluc3RhbmNlb2Ygb3BlcmF0aW9uLmNvbnN0cnVjdG9yLlN0aWNrZXJTcHJpdGUpIHtcbiAgICAgICAgICBzcHJpdGVJdGVtID0gdGhpcy5fc2VyaWFsaXplU3RpY2tlcihvcGVyYXRpb24sIHNwcml0ZSlcbiAgICAgICAgfSBlbHNlIGlmIChzcHJpdGUgaW5zdGFuY2VvZiBvcGVyYXRpb24uY29uc3RydWN0b3IuVGV4dFNwcml0ZSkge1xuICAgICAgICAgIHNwcml0ZUl0ZW0gPSB0aGlzLl9zZXJpYWxpemVUZXh0KG9wZXJhdGlvbiwgc3ByaXRlKVxuICAgICAgICB9IGVsc2UgaWYgKHNwcml0ZSBpbnN0YW5jZW9mIG9wZXJhdGlvbi5jb25zdHJ1Y3Rvci5CcnVzaFNwcml0ZSkge1xuICAgICAgICAgIHNwcml0ZUl0ZW0gPSB0aGlzLl9zZXJpYWxpemVCcnVzaChvcGVyYXRpb24sIHNwcml0ZSlcbiAgICAgICAgfSBlbHNlIGlmIChzcHJpdGUgaW5zdGFuY2VvZiBvcGVyYXRpb24uY29uc3RydWN0b3IuVGV4dERlc2lnblNwcml0ZSkge1xuICAgICAgICAgIHNwcml0ZUl0ZW0gPSB0aGlzLl9zZXJpYWxpemVUZXh0RGVzaWduICYmIHRoaXMuX3NlcmlhbGl6ZVRleHREZXNpZ24ob3BlcmF0aW9uLCBzcHJpdGUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3ByaXRlSXRlbSkge1xuICAgICAgICAgIHNwcml0ZU9wZXJhdGlvbi5vcHRpb25zLnNwcml0ZXMucHVzaChzcHJpdGVJdGVtKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgaWYgKHJldHVybk9wZXJhdGlvbikge1xuICAgICAgcmV0dXJuIHNwcml0ZU9wZXJhdGlvblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBzdGlja2VyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uLlN0aWNrZXJTcHJpdGV9IHNwcml0ZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VyaWFsaXplU3RpY2tlciAob3BlcmF0aW9uLCBzcHJpdGUpIHtcbiAgICBjb25zdCBhZGp1c3RtZW50cyA9IHNwcml0ZS5nZXRBZGp1c3RtZW50cygpXG5cbiAgICBjb25zdCBvcHRpb25zID0gc3ByaXRlLnNlcmlhbGl6ZU9wdGlvbnMoW1xuICAgICAgJ2lkZW50aWZpZXInLCAncG9zaXRpb24nLCAnZGltZW5zaW9ucycsICdmbGlwVmVydGljYWxseScsICdmbGlwSG9yaXpvbnRhbGx5JywgJ3JvdGF0aW9uJ1xuICAgIF0sIHRydWUpXG5cbiAgICBvcHRpb25zLm5hbWUgPSBvcHRpb25zLmlkZW50aWZpZXJcbiAgICBkZWxldGUgb3B0aW9ucy5pZGVudGlmaWVyXG5cbiAgICBvcHRpb25zLnJvdGF0aW9uID0gKG9wdGlvbnMucm90YXRpb24gKyBUV0lDRV9QSSkgJSBUV0lDRV9QSVxuXG4gICAgY29uc3QgYWRqdXN0bWVudHNPcHRpb25zID0gYWRqdXN0bWVudHMuYXZhaWxhYmxlT3B0aW9uc1xuICAgIG9wdGlvbnMuYWRqdXN0bWVudHMgPSB7XG4gICAgICBicmlnaHRuZXNzOiBhZGp1c3RtZW50cy5nZXRCcmlnaHRuZXNzKCkgLSBhZGp1c3RtZW50c09wdGlvbnMuYnJpZ2h0bmVzcy5kZWZhdWx0LFxuICAgICAgc2F0dXJhdGlvbjogYWRqdXN0bWVudHMuZ2V0U2F0dXJhdGlvbigpIC0gYWRqdXN0bWVudHNPcHRpb25zLnNhdHVyYXRpb24uZGVmYXVsdCxcbiAgICAgIGNvbnRyYXN0OiBhZGp1c3RtZW50cy5nZXRDb250cmFzdCgpIC0gYWRqdXN0bWVudHNPcHRpb25zLmNvbnRyYXN0LmRlZmF1bHRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3N0aWNrZXInLFxuICAgICAgb3B0aW9uc1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBnaXZlbiB0ZXh0IHNwcml0ZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbi5UZXh0U3ByaXRlfSBzcHJpdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlcmlhbGl6ZVRleHQgKG9wZXJhdGlvbiwgc3ByaXRlKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHNwcml0ZS5zZXJpYWxpemVPcHRpb25zKFtcbiAgICAgICdmb250U2l6ZScsICdsaW5lSGVpZ2h0JywgJ2ZvbnRGYW1pbHknLCAnZm9udFdlaWdodCcsICdhbGlnbm1lbnQnLFxuICAgICAgJ2NvbG9yJywgJ2JhY2tncm91bmRDb2xvcicsXG4gICAgICAncG9zaXRpb24nLCAncm90YXRpb24nLFxuICAgICAgJ3RleHQnLCAnbWF4V2lkdGgnXG4gICAgXSwgdHJ1ZSlcbiAgICBvcHRpb25zLnJvdGF0aW9uID0gKG9wdGlvbnMucm90YXRpb24gKyBUV0lDRV9QSSkgJSBUV0lDRV9QSVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgIG9wdGlvbnNcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gYnJ1c2ggc3ByaXRlXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uLkJydXNoU3ByaXRlfSBzcHJpdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlcmlhbGl6ZUJydXNoIChvcGVyYXRpb24sIHNwcml0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnYnJ1c2gnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBwYXRoczogc3ByaXRlLmdldFBhdGhzKClcbiAgICAgICAgICAubWFwKChwYXRoKSA9PiB0aGlzLl9zZXJpYWxpemVQYXRoKHBhdGgpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBwYXRoXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uLkJydXNoU3ByaXRlLlBhdGh9IHBhdGhcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlcmlhbGl6ZVBhdGggKHBhdGgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gcGF0aC5nZXRCcnVzaCgpLnNlcmlhbGl6ZU9wdGlvbnMoWydjb2xvcicsICdzaXplJ10sIHRydWUpXG5cbiAgICBvcHRpb25zLnBvaW50cyA9IHBhdGguZ2V0Q29udHJvbFBvaW50cygpLm1hcCgocG9pbnQpID0+XG4gICAgICBwb2ludC5nZXRQb3NpdGlvbigpLnRvT2JqZWN0KClcbiAgICApXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBnaXZlbiByYWRpYWwgZm9jdXMgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuUmFkaWFsRm9jdXNPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VyaWFsaXplUmFkaWFsRm9jdXNPcGVyYXRpb24gKG9wZXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnZm9jdXMnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICB0eXBlOiAncmFkaWFsJyxcbiAgICAgICAgb3B0aW9uczogb3BlcmF0aW9uLnNlcmlhbGl6ZU9wdGlvbnMoWydwb3NpdGlvbicsICdyYWRpdXMnLCAnZ3JhZGllbnRSYWRpdXMnLCAnYmx1clJhZGl1cyddLCB0cnVlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBsaW5lYXIgZm9jdXMgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuTWlycm9yZWRGb2N1c09wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXJpYWxpemVMaW5lYXJGb2N1c09wZXJhdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdmb2N1cycsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInLFxuICAgICAgICBvcHRpb25zOiBvcGVyYXRpb24uc2VyaWFsaXplT3B0aW9ucyhbJ3N0YXJ0JywgJ2VuZCcsICdibHVyUmFkaXVzJywgJ3NpemUnLCAnZ3JhZGllbnRTaXplJ10sIHRydWUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGlucHV0IGRpbWVuc2lvbnMgZm9yIHRoZSBnaXZlbiBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldElucHV0RGltZW5zaW9uc0Zvck9wZXJhdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgbGV0IG9wZXJhdGlvbkZvdW5kID0gZmFsc2VcbiAgICBsZXQgaW5wdXREaW1lbnNpb25zID0gdGhpcy5fZWRpdG9yLmdldElucHV0RGltZW5zaW9ucygpXG5cbiAgICB0aGlzLl9lZGl0b3Iub3BlcmF0aW9ucy5nZXRTdGFjaygpXG4gICAgICAuZm9yRWFjaCgob3ApID0+IHtcbiAgICAgICAgaWYgKG9wID09PSBvcGVyYXRpb24pIG9wZXJhdGlvbkZvdW5kID0gdHJ1ZVxuICAgICAgICBpZiAob3BlcmF0aW9uRm91bmQpIHJldHVyblxuICAgICAgICBpbnB1dERpbWVuc2lvbnMgPSBvcC5nZXROZXdEaW1lbnNpb25zKGlucHV0RGltZW5zaW9ucylcbiAgICAgIH0pXG5cbiAgICByZXR1cm4gaW5wdXREaW1lbnNpb25zXG4gIH1cbn1cblxudjEwMFNlcmlhbGl6ZXIudmVyc2lvbiA9ICcxLjAuMCdcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvanMvc2hhcmVkL3NlcmlhbGl6YXRpb24vMS4wLjAvc2VyaWFsaXplci5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgU0RLLCBWZWN0b3IyLCBDb2xvciwgU0RLVXRpbHMsIExvZyB9IGZyb20gJ2dsb2JhbHMnXG5pbXBvcnQgRmlsdGVyTWFuYWdlciBmcm9tICdzaGFyZWQvbWFuYWdlcnMvZmlsdGVyLW1hbmFnZXInXG5pbXBvcnQgU3RpY2tlck1hbmFnZXIgZnJvbSAnc2hhcmVkL21hbmFnZXJzL3N0aWNrZXItbWFuYWdlcidcbmltcG9ydCBCcnVzaE1hbmFnZXIgZnJvbSAnc2hhcmVkL21hbmFnZXJzL2JydXNoLW1hbmFnZXInXG5pbXBvcnQgRm9udE1hbmFnZXIgZnJvbSAnc2hhcmVkL21hbmFnZXJzL2ZvbnQtbWFuYWdlcidcbmltcG9ydCBGb250TG9hZGVyIGZyb20gJ2xpYi9mb250LWxvYWRlcidcblxubGV0IEJydXNoXG5pZiAodHlwZW9mIFNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgQnJ1c2ggPSBTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb24uQnJ1c2hTcHJpdGVcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgdjEwMERlc2VyaWFsaXplciB7XG4gIGNvbnN0cnVjdG9yIChlZGl0b3IsIGRhdGEpIHtcbiAgICB0aGlzLl9lZGl0b3IgPSBlZGl0b3JcbiAgICB0aGlzLl91aSA9IHRoaXMuX2VkaXRvci5nZXRVSSgpXG4gICAgdGhpcy5fZGF0YSA9IGRhdGFcblxuICAgIHRoaXMuX2ZpbHRlck1hbmFnZXIgPSBuZXcgRmlsdGVyTWFuYWdlcih0aGlzLl91aSwgdGhpcy5fZ2V0T3B0aW9ucygnZmlsdGVyJykpXG4gICAgdGhpcy5fc3RpY2tlck1hbmFnZXIgPSBuZXcgU3RpY2tlck1hbmFnZXIodGhpcy5fdWksIHRoaXMuX2dldE9wdGlvbnMoJ3N0aWNrZXInKSlcbiAgICB0aGlzLl9icnVzaE1hbmFnZXIgPSBuZXcgQnJ1c2hNYW5hZ2VyKHRoaXMuX3VpLCB0aGlzLl9nZXRPcHRpb25zKCdicnVzaCcpKVxuICAgIHRoaXMuX2ZvbnRNYW5hZ2VyID0gbmV3IEZvbnRNYW5hZ2VyKHRoaXMuX3VpLCB0aGlzLl9nZXRPcHRpb25zKCd0ZXh0JykpXG4gIH1cblxuICBfZ2V0T3B0aW9ucyAoY29udHJvbCkge1xuICAgIGNvbnN0IHsgY29udHJvbHMgfSA9IHRoaXMuX2VkaXRvclxuICAgIGxldCBkZWZhdWx0T3B0aW9ucyA9IHt9XG4gICAgaWYgKGNvbnRyb2xzICYmIGNvbnRyb2xzLmdldChjb250cm9sKSkge1xuICAgICAgZGVmYXVsdE9wdGlvbnMgPSBjb250cm9scy5nZXQoY29udHJvbCkuZGVmYXVsdE9wdGlvbnNcbiAgICB9XG5cbiAgICBjb25zdCBlZGl0b3JPcHRpb25zID0gdGhpcy5fZWRpdG9yLmdldE9wdGlvbnMoKVxuICAgIHJldHVybiBTREtVdGlscy5kZWVwRGVmYXVsdHMoe30sIGVkaXRvck9wdGlvbnMuZWRpdG9yLmNvbnRyb2xzT3B0aW9uc1tjb250cm9sXSB8fCB7fSwgZGVmYXVsdE9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBkYXRhXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBkZXNlcmlhbGl6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlVmVyc2lvbigpXG4gICAgICAudGhlbigoKSA9PiB0aGlzLl9kZXNlcmlhbGl6ZUlucHV0SW1hZ2UoKSlcbiAgICAgIC50aGVuKCgpID0+IHRoaXMuX2Rlc2VyaWFsaXplT3BlcmF0aW9ucygpKVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGUgdmVyc2lvblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgX3ZhbGlkYXRlVmVyc2lvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2RhdGEudmVyc2lvbiAhPT0gdGhpcy5jb25zdHJ1Y3Rvci52ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBJbnZhbGlkIHZlcnNpb24gJHt0aGlzLl9kYXRhLnZlcnNpb259LCBleHBlY3RlZCAke3RoaXMuY29uc3RydWN0b3IudmVyc2lvbn1gKSlcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBpbnB1dCBpbWFnZSAoaWYgcHJlc2VudClcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXNlcmlhbGl6ZUlucHV0SW1hZ2UgKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB7IGRhdGEsIHR5cGUgfSA9IHRoaXMuX2RhdGEuaW5wdXRJbWFnZVxuICAgICAgaWYgKGRhdGEgJiYgdHlwZSkge1xuICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyB3aW5kb3cuSW1hZ2UoKVxuICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2VkaXRvci5zZXRJbWFnZShpbWFnZSlcbiAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgfSlcbiAgICAgICAgaW1hZ2Uuc3JjID0gYGRhdGE6JHt0eXBlfTtiYXNlNjQsJHtkYXRhfWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBvcGVyYXRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBfZGVzZXJpYWxpemVPcGVyYXRpb25zICgpIHtcbiAgICBjb25zdCBvcGVyYXRpb25zID0gdGhpcy5fZGF0YS5vcGVyYXRpb25zXG4gICAgY29uc3QgaW5zdGFuY2VzID0gW11cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3BlcmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgb3BlcmF0aW9uID0gb3BlcmF0aW9uc1tpXVxuICAgICAgY29uc3QgaW5zdGFuY2UgPSBhd2FpdCB0aGlzLl9kZXNlcmlhbGl6ZU9wZXJhdGlvbihvcGVyYXRpb24pXG4gICAgICBpbnN0YW5jZXMucHVzaChpbnN0YW5jZSlcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2VzXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXNlcmlhbGl6ZU9wZXJhdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgc3dpdGNoIChvcGVyYXRpb24udHlwZSkge1xuICAgICAgY2FzZSAnY3JvcCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZUNyb3BPcGVyYXRpb24ob3BlcmF0aW9uKVxuICAgICAgY2FzZSAnb3JpZW50YXRpb24nOlxuICAgICAgICByZXR1cm4gdGhpcy5fZGVzZXJpYWxpemVPcmllbnRhdGlvbk9wZXJhdGlvbihvcGVyYXRpb24pXG4gICAgICBjYXNlICdmaWx0ZXInOlxuICAgICAgICByZXR1cm4gdGhpcy5fZGVzZXJpYWxpemVGaWx0ZXJPcGVyYXRpb24ob3BlcmF0aW9uKVxuICAgICAgY2FzZSAnYWRqdXN0bWVudHMnOlxuICAgICAgICByZXR1cm4gdGhpcy5fZGVzZXJpYWxpemVBZGp1c3RtZW50c09wZXJhdGlvbihvcGVyYXRpb24pXG4gICAgICBjYXNlICdzcHJpdGUnOlxuICAgICAgICByZXR1cm4gdGhpcy5fZGVzZXJpYWxpemVTcHJpdGVPcGVyYXRpb24ob3BlcmF0aW9uKVxuICAgICAgY2FzZSAnZm9jdXMnOlxuICAgICAgICByZXR1cm4gdGhpcy5fZGVzZXJpYWxpemVGb2N1c09wZXJhdGlvbihvcGVyYXRpb24pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplcyB0aGUgZ2l2ZW4gY3JvcCBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcGVyYXRpb25cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXNlcmlhbGl6ZUNyb3BPcGVyYXRpb24gKG9wZXJhdGlvbikge1xuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gb3BlcmF0aW9uXG4gICAgbGV0IHsgcm90YXRpb24gfSA9IG9wdGlvbnNcbiAgICBjb25zdCBzdGFydCA9IFZlY3RvcjIuZnJvbU9iamVjdChvcHRpb25zLnN0YXJ0KVxuICAgIGNvbnN0IGVuZCA9IFZlY3RvcjIuZnJvbU9iamVjdChvcHRpb25zLmVuZClcblxuICAgIC8vIE5vcm1hbGl6ZSByb3RhdGlvblxuICAgIGlmIChyb3RhdGlvbiA+IE1hdGguUEkpIHtcbiAgICAgIHJvdGF0aW9uIC09IE1hdGguUEkgKiAyXG4gICAgfVxuXG4gICAgY29uc3QgY3JvcE9wdGlvbnMgPSB7IHN0YXJ0LCBlbmQgfVxuICAgIGlmICh0eXBlb2Ygcm90YXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjcm9wT3B0aW9ucy5yb3RhdGlvbiA9IHJvdGF0aW9uXG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNmb3JtT3BlcmF0aW9uID0gdGhpcy5fZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ3RyYW5zZm9ybScpXG4gICAgdGhpcy5fZWRpdG9yLmJyb2FkY2FzdFRyYW5zZm9ybSh0cmFuc2Zvcm1PcGVyYXRpb24sIGNyb3BPcHRpb25zKVxuICAgIHRyYW5zZm9ybU9wZXJhdGlvbi5zZXQoY3JvcE9wdGlvbnMpXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cmFuc2Zvcm1PcGVyYXRpb24pXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBvcmllbnRhdGlvbiBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcGVyYXRpb25cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXNlcmlhbGl6ZU9yaWVudGF0aW9uT3BlcmF0aW9uIChvcGVyYXRpb24pIHtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IG9wZXJhdGlvblxuICAgIGNvbnN0IG9yaWVudGF0aW9uT3BlcmF0aW9uID0gdGhpcy5fZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ29yaWVudGF0aW9uJylcbiAgICBpZiAoIW9yaWVudGF0aW9uT3BlcmF0aW9uKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICBvcmllbnRhdGlvbk9wZXJhdGlvbi5zZXQob3B0aW9ucylcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9yaWVudGF0aW9uT3BlcmF0aW9uKVxuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplcyB0aGUgZ2l2ZW4gZmlsdGVyIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wZXJhdGlvblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Rlc2VyaWFsaXplRmlsdGVyT3BlcmF0aW9uIChvcGVyYXRpb24pIHtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IG9wZXJhdGlvblxuXG4gICAgaWYgKCF0aGlzLl9maWx0ZXJNYW5hZ2VyLmdldEZpbHRlckJ5SWRlbnRpZmllcihvcHRpb25zLm5hbWUpKSB7XG4gICAgICBMb2cud2FybignRGVzZXJpYWxpemVyJywgYFVua25vd24gZmlsdGVyIFxcYCR7b3B0aW9ucy5uYW1lfVxcYGApXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZmlsdGVyTWFuYWdlci5pbnN0YW50aWF0ZUZpbHRlcldpdGhJZGVudGlmaWVyKG9wdGlvbnMubmFtZSlcbiAgICAgIC50aGVuKGZpbHRlciA9PiB7XG4gICAgICAgIGNvbnN0IGZpbHRlck9wZXJhdGlvbiA9IHRoaXMuX2VkaXRvci5vcGVyYXRpb25zLmdldE9yQ3JlYXRlKCdmaWx0ZXInKVxuICAgICAgICBmaWx0ZXJPcGVyYXRpb24uc2V0KHtcbiAgICAgICAgICBpZGVudGlmaWVyOiBvcHRpb25zLm5hbWUsXG4gICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgIGludGVuc2l0eTogb3B0aW9ucy5pbnRlbnNpdHlcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIGZpbHRlck9wZXJhdGlvblxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZXMgdGhlIGdpdmVuIGFkanVzdG1lbnRzIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wZXJhdGlvblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Rlc2VyaWFsaXplQWRqdXN0bWVudHNPcGVyYXRpb24gKG9wZXJhdGlvbikge1xuICAgIGNvbnN0IHsgQWRqdXN0bWVudHNPcGVyYXRpb24gfSA9IFNESy5PcGVyYXRpb25zXG4gICAgY29uc3QgeyBvcHRpb25zIH0gPSBvcGVyYXRpb25cblxuICAgIGNvbnN0IGtub3duT3B0aW9ucyA9IFsnYnJpZ2h0bmVzcycsICdzYXR1cmF0aW9uJywgJ2NvbnRyYXN0JywgJ2V4cG9zdXJlJywgJ3NoYWRvd3MnLCAnaGlnaGxpZ2h0cycsICdjbGFyaXR5J11cblxuICAgIGNvbnN0IG9wZXJhdGlvbk9wdGlvbnMgPSB7fVxuXG4gICAga25vd25PcHRpb25zLmZvckVhY2gob3B0aW9uTmFtZSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnNbb3B0aW9uTmFtZV0gPT09ICd1bmRlZmluZWQnKSByZXR1cm5cblxuICAgICAgY29uc3QgeyBtaW5WYWx1ZSwgbWlkVmFsdWUsIG1heFZhbHVlIH0gPSBBZGp1c3RtZW50c09wZXJhdGlvbi5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9uc1tvcHRpb25OYW1lXVxuICAgICAgbGV0IHZhbHVlID0gb3B0aW9uc1tvcHRpb25OYW1lXVxuXG4gICAgICB2YWx1ZSA9IHZhbHVlIDwgMFxuICAgICAgICA/IChtaWRWYWx1ZSArIChtaWRWYWx1ZSAtIG1pblZhbHVlKSAqIHZhbHVlKVxuICAgICAgICA6IChtaWRWYWx1ZSArIChtYXhWYWx1ZSAtIG1pZFZhbHVlKSAqIHZhbHVlKVxuICAgICAgb3BlcmF0aW9uT3B0aW9uc1tvcHRpb25OYW1lXSA9IHZhbHVlXG4gICAgfSlcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ2FkanVzdG1lbnRzJywgb3BlcmF0aW9uT3B0aW9ucykpXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBzcHJpdGUgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3BlcmF0aW9uXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVzZXJpYWxpemVTcHJpdGVPcGVyYXRpb24gKG9wZXJhdGlvbikge1xuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gb3BlcmF0aW9uXG4gICAgY29uc3Qgc3ByaXRlT3BlcmF0aW9uID0gdGhpcy5fZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ3Nwcml0ZScpXG4gICAgaWYgKCFzcHJpdGVPcGVyYXRpb24pIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXG4gICAgY29uc3QgcHJvbWlzZXMgPSBvcHRpb25zLnNwcml0ZXMubWFwKChzcHJpdGUpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZVNwcml0ZShzcHJpdGVPcGVyYXRpb24sIHNwcml0ZSlcbiAgICB9KS5maWx0ZXIocCA9PiBwKVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcylcbiAgICAgIC50aGVuKChzcHJpdGVzKSA9PiB7XG4gICAgICAgIHNwcml0ZU9wZXJhdGlvbi5zZXRTcHJpdGVzKHNwcml0ZXMuZmlsdGVyKHMgPT4gcykpXG4gICAgICAgIHJldHVybiBzcHJpdGVPcGVyYXRpb25cbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBzcHJpdGVcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb259IHNwcml0ZU9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbi5TcHJpdGV9IHNwcml0ZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Rlc2VyaWFsaXplU3ByaXRlIChzcHJpdGVPcGVyYXRpb24sIHNwcml0ZSkge1xuICAgIHN3aXRjaCAoc3ByaXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0aWNrZXInOlxuICAgICAgICByZXR1cm4gdGhpcy5fZGVzZXJpYWxpemVTdGlja2VyKHNwcml0ZU9wZXJhdGlvbiwgc3ByaXRlKVxuICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZVRleHQoc3ByaXRlT3BlcmF0aW9uLCBzcHJpdGUpXG4gICAgICBjYXNlICdicnVzaCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZUJydXNoKHNwcml0ZU9wZXJhdGlvbiwgc3ByaXRlKVxuICAgICAgY2FzZSAndGV4dGRlc2lnbic6XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZVRleHREZXNpZ24gJiYgdGhpcy5fZGVzZXJpYWxpemVUZXh0RGVzaWduKHNwcml0ZU9wZXJhdGlvbiwgc3ByaXRlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZXMgdGhlIGdpdmVuIHN0aWNrZXIgZm9yIHRoZSBnaXZlbiBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHNwcml0ZVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbi5TdGlja2VyU3ByaXRlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Rlc2VyaWFsaXplU3RpY2tlciAob3BlcmF0aW9uLCBzcHJpdGUpIHtcbiAgICBjb25zdCB7IFNwcml0ZU9wZXJhdGlvbiB9ID0gU0RLLk9wZXJhdGlvbnNcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHNwcml0ZVxuXG4gICAgY29uc3Qgc3RpY2tlciA9IHRoaXMuX3N0aWNrZXJNYW5hZ2VyLmdldFN0aWNrZXJCeUlkZW50aWZpZXIob3B0aW9ucy5uYW1lKVxuICAgIGNvbnN0IHVybCA9IHRoaXMuX3N0aWNrZXJNYW5hZ2VyLmdldFVSTEZvclN0aWNrZXIoc3RpY2tlcilcbiAgICBpZiAoIXN0aWNrZXIpIHtcbiAgICAgIExvZy53YXJuKCdEZXNlcmlhbGl6ZXInLCBgVW5rbm93biBzdGlja2VyICcke29wdGlvbnMubmFtZX0nLiBTa2lwcGluZyBzcHJpdGUuYClcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgd2luZG93LkltYWdlKClcbiAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFkanVzdG1lbnRzID0gU3ByaXRlT3BlcmF0aW9uLlN0aWNrZXJTcHJpdGUucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMuYWRqdXN0bWVudHMuc3RydWN0dXJlXG4gICAgICAgIGNvbnN0IHsgcm90YXRpb24sIGZsaXBIb3Jpem9udGFsbHksIGZsaXBWZXJ0aWNhbGx5IH0gPSBvcHRpb25zXG4gICAgICAgIGNvbnN0IHN0aWNrZXJPcHRpb25zID0ge1xuICAgICAgICAgIGlkZW50aWZpZXI6IG9wdGlvbnMubmFtZSxcbiAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICBwb3NpdGlvbjogVmVjdG9yMi5mcm9tT2JqZWN0KG9wdGlvbnMucG9zaXRpb24pLFxuICAgICAgICAgIGRpbWVuc2lvbnM6IFZlY3RvcjIuZnJvbU9iamVjdChvcHRpb25zLmRpbWVuc2lvbnMpLFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGZsaXBIb3Jpem9udGFsbHksXG4gICAgICAgICAgZmxpcFZlcnRpY2FsbHksXG4gICAgICAgICAgYWRqdXN0bWVudHM6IHt9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWRqdXN0bWVudHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgWydicmlnaHRuZXNzJywgJ2NvbnRyYXN0JywgJ3NhdHVyYXRpb24nXS5mb3JFYWNoKG9wdGlvbiA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWRqdXN0bWVudHNbb3B0aW9uXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgc3RpY2tlck9wdGlvbnMuYWRqdXN0bWVudHNbb3B0aW9uXSA9IG9wdGlvbnMuYWRqdXN0bWVudHNbb3B0aW9uXSArIGFkanVzdG1lbnRzW29wdGlvbl0uZGVmYXVsdFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKG9wZXJhdGlvbi5jcmVhdGVTdGlja2VyKHN0aWNrZXJPcHRpb25zKSlcbiAgICAgIH0pXG4gICAgICBpbWFnZS5jcm9zc09yaWdpbiA9IHRoaXMuX2VkaXRvci5nZXRDcm9zc09yaWdpbigpXG4gICAgICBpbWFnZS5zcmMgPSB0aGlzLl9lZGl0b3IuZ2V0VUkoKS5nZXRBc3NldFBhdGgodXJsKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiB0ZXh0IGZvciB0aGUgZ2l2ZW4gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSB0ZXh0XG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uLlRleHRTcHJpdGV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVzZXJpYWxpemVUZXh0IChvcGVyYXRpb24sIHRleHQpIHtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRleHRcbiAgICBjb25zdCB7IGZvbnRTaXplLCBsaW5lSGVpZ2h0LCBmb250RmFtaWx5LCBmb250V2VpZ2h0LCBhbGlnbm1lbnQsIHJvdGF0aW9uLCBtYXhXaWR0aCwgY29sb3IsIGJhY2tncm91bmRDb2xvciB9ID0gb3B0aW9uc1xuXG4gICAgY29uc3QgZm9udExvYWRlciA9IG5ldyBGb250TG9hZGVyKHRoaXMuX3VpKVxuICAgIGxldCBmb250ID0gdGhpcy5fZm9udE1hbmFnZXIuZ2V0Rm9udEJ5Rm9udEZhbWlseShmb250RmFtaWx5KVxuICAgIGlmICghZm9udCkgZm9udCA9IHRoaXMuX2ZvbnRNYW5hZ2VyLmdldERlZmF1bHRGb250KClcbiAgICBmb250TG9hZGVyLnNldEZvbnRzKFtmb250XSlcbiAgICByZXR1cm4gZm9udExvYWRlci5sb2FkKClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIG9wZXJhdGlvbi5jcmVhdGVUZXh0KHtcbiAgICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgICBsaW5lSGVpZ2h0LFxuICAgICAgICAgIGZvbnRGYW1pbHksXG4gICAgICAgICAgZm9udFdlaWdodCxcbiAgICAgICAgICBhbGlnbm1lbnQsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgICAgdGV4dDogb3B0aW9ucy50ZXh0LFxuICAgICAgICAgIGNvbG9yOiBDb2xvci5mcm9tQXJyYXkoY29sb3IpLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogQ29sb3IuZnJvbUFycmF5KGJhY2tncm91bmRDb2xvciksXG4gICAgICAgICAgcG9zaXRpb246IFZlY3RvcjIuZnJvbU9iamVjdChvcHRpb25zLnBvc2l0aW9uKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZXMgdGhlIGdpdmVuIGJydXNoIGZvciB0aGUgZ2l2ZW4gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBicnVzaFxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbi5CcnVzaFNwcml0ZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXNlcmlhbGl6ZUJydXNoIChvcGVyYXRpb24sIGJydXNoKSB7XG4gICAgY29uc3QgeyBvcHRpb25zIH0gPSBicnVzaFxuICAgIGNvbnN0IHsgcGF0aHMgfSA9IG9wdGlvbnNcblxuICAgIGNvbnN0IGJydXNoU3ByaXRlID0gb3BlcmF0aW9uLmNyZWF0ZUJydXNoKClcbiAgICBwYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICB0aGlzLl9kZXNlcmlhbGl6ZUJydXNoUGF0aChicnVzaFNwcml0ZSwgcGF0aClcbiAgICB9KVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYnJ1c2hTcHJpdGUpXG4gIH1cblxuICBfZGVzZXJpYWxpemVCcnVzaFBhdGggKGJydXNoU3ByaXRlLCBwYXRoKSB7XG4gICAgY29uc3QgeyBwb2ludHMgfSA9IHBhdGhcblxuICAgIGNvbnN0IGJydXNoSW5zdGFuY2UgPSB0aGlzLl9jcmVhdGVCcnVzaEZvclBhdGgocGF0aClcbiAgICBjb25zdCBwYXRoT2JqZWN0ID0gYnJ1c2hTcHJpdGUuY3JlYXRlUGF0aChicnVzaEluc3RhbmNlKVxuICAgIHBhdGhPYmplY3Quc2V0Q2xvc2VkKHRydWUpXG4gICAgcG9pbnRzLmZvckVhY2goKHBvaW50KSA9PiB7XG4gICAgICBwYXRoT2JqZWN0LmFkZENvbnRyb2xQb2ludChcbiAgICAgICAgVmVjdG9yMi5mcm9tT2JqZWN0KHBvaW50KVxuICAgICAgKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGJydXNoIGZhY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbi5TcHJpdGVzLkJydXNoU3ByaXRlLlBhdGh9IHBhdGhcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb24uU3ByaXRlcy5CcnVzaFNwcml0ZS5CcnVzaH1cbiAgICovXG4gIF9jcmVhdGVCcnVzaEZvclBhdGggKHBhdGgpIHtcbiAgICBjb25zdCB7IGNvbG9yLCBzaXplIH0gPSBwYXRoXG4gICAgY29uc3QgY29sb3JPYmplY3QgPSBDb2xvci5mcm9tQXJyYXkoY29sb3IpXG5cbiAgICBjb25zdCBicnVzaE9wdGlvbnMgPSB7XG4gICAgICBjb2xvcjogY29sb3JPYmplY3QsXG4gICAgICBzaXplXG4gICAgfVxuXG4gICAgY29uc3QgcmF3QnJ1c2ggPSB0aGlzLl9icnVzaE1hbmFnZXIuZ2V0Rmlyc3RCcnVzaCgpXG4gICAgaWYgKHJhd0JydXNoLnByb3RvdHlwZSAmJiByYXdCcnVzaC5wcm90b3R5cGUgaW5zdGFuY2VvZiBCcnVzaCkge1xuICAgICAgLy8gQ3VzdG9tIEJydXNoIGluc3RhbmNlLCB1c2VkIGZvciBzcGVjaWFsIGJydXNoZXMgc3VjaCBhcyByYWRpYWwgYnJ1c2gsIHdoaWNoIGhhc1xuICAgICAgLy8gYW4gYWRkaXRpb25hbCBoYXJkbmVzcyBvcHRpb25cbiAgICAgIGNvbnN0IEJydXNoQ2xhc3MgPSByYXdCcnVzaFxuICAgICAgcmV0dXJuIG5ldyBCcnVzaENsYXNzKGJydXNoT3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgX2JydXNoID0gU0RLVXRpbHMuZXh0ZW5kKHt9LCByYXdCcnVzaClcbiAgICAgIGRlbGV0ZSBfYnJ1c2guaW1hZ2VcblxuICAgICAgY2xhc3MgQnJ1c2hDbGFzcyBleHRlbmRzIEJydXNoIHt9XG4gICAgICBCcnVzaENsYXNzLmlkZW50aWZpZXIgPSByYXdCcnVzaC5pZGVudGlmaWVyXG5cbiAgICAgIC8vIFBsYWluIEpTIG9iamVjdCwgdXNlZCBmb3Igc2ltcGxlIGltYWdlIGJydXNoZXNcbiAgICAgIHJldHVybiBuZXcgQnJ1c2hDbGFzcyhTREtVdGlscy5leHRlbmQoe30sIF9icnVzaCwgYnJ1c2hPcHRpb25zKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBmb2N1cyBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcGVyYXRpb25cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXNlcmlhbGl6ZUZvY3VzT3BlcmF0aW9uIChvcGVyYXRpb24pIHtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IG9wZXJhdGlvbi5vcHRpb25zXG4gICAgc3dpdGNoIChvcGVyYXRpb24ub3B0aW9ucy50eXBlKSB7XG4gICAgICBjYXNlICdyYWRpYWwnOlxuICAgICAge1xuICAgICAgICBjb25zdCB7IHBvc2l0aW9uLCByYWRpdXMsIGdyYWRpZW50UmFkaXVzLCBibHVyUmFkaXVzIH0gPSBvcHRpb25zXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ3JhZGlhbC1mb2N1cycsIHtcbiAgICAgICAgICBwb3NpdGlvbjogVmVjdG9yMi5mcm9tT2JqZWN0KHBvc2l0aW9uKSxcbiAgICAgICAgICByYWRpdXMsXG4gICAgICAgICAgZ3JhZGllbnRSYWRpdXMsXG4gICAgICAgICAgYmx1clJhZGl1c1xuICAgICAgICB9KSlcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2xpbmVhcic6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCwgc2l6ZSwgZ3JhZGllbnRTaXplLCBibHVyUmFkaXVzIH0gPSBvcHRpb25zXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ21pcnJvcmVkLWZvY3VzJywge1xuICAgICAgICAgIHN0YXJ0OiBWZWN0b3IyLmZyb21PYmplY3Qoc3RhcnQpLFxuICAgICAgICAgIGVuZDogVmVjdG9yMi5mcm9tT2JqZWN0KGVuZCksXG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICBncmFkaWVudFNpemUsXG4gICAgICAgICAgYmx1clJhZGl1c1xuICAgICAgICB9KSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5wdXQgZGltZW5zaW9ucyBmb3IgdGhlIGdpdmVuIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0SW5wdXREaW1lbnNpb25zRm9yT3BlcmF0aW9uIChvcGVyYXRpb24pIHtcbiAgICBsZXQgb3BlcmF0aW9uRm91bmQgPSBmYWxzZVxuICAgIGxldCBpbnB1dERpbWVuc2lvbnMgPSB0aGlzLl9lZGl0b3IuZ2V0SW5wdXREaW1lbnNpb25zKClcblxuICAgIHRoaXMuX2VkaXRvci5vcGVyYXRpb25zLmdldFN0YWNrKClcbiAgICAgIC5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgICBpZiAob3AgPT09IG9wZXJhdGlvbikgb3BlcmF0aW9uRm91bmQgPSB0cnVlXG4gICAgICAgIGlmIChvcGVyYXRpb25Gb3VuZCkgcmV0dXJuXG4gICAgICAgIGlucHV0RGltZW5zaW9ucyA9IG9wLmdldE5ld0RpbWVuc2lvbnMoaW5wdXREaW1lbnNpb25zKVxuICAgICAgfSlcblxuICAgIHJldHVybiBpbnB1dERpbWVuc2lvbnNcbiAgfVxufVxuXG52MTAwRGVzZXJpYWxpemVyLnZlcnNpb24gPSAnMS4wLjAnXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9zZXJpYWxpemF0aW9uLzEuMC4wL2Rlc2VyaWFsaXplci5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZvbnRPYnNlcnZlciBmcm9tICcuLi9mb250LW9ic2VydmVyJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlRm9udExvYWRlciB7XG4gIGNvbnN0cnVjdG9yICh1aSkge1xuICAgIHRoaXMuX3VpID0gdWlcbiAgICB0aGlzLl9mb250cyA9IFtdXG4gICAgdGhpcy5fb2JzZXJ2ZXJzID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBmb250IHRvIHRoZSBsaXN0IG9mIGZvbnRzIHRvIGxvYWRcbiAgICogQHBhcmFtIHtPYmplY3R9IHZhcmlhdGlvblxuICAgKi9cbiAgYWRkICh2YXJpYXRpb24pIHtcbiAgICB0aGlzLl9mb250cy5wdXNoKHZhcmlhdGlvbilcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyB0aGUgZm9udHNcbiAgICovXG4gIGxvYWQgKCkge1xuICAgIGlmICh0aGlzLl9mb250cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIHRoaXMuX29ic2VydmVycyA9IFtdXG4gICAgdGhpcy5fZm9udHMuZm9yRWFjaCh2YXJpYXRpb24gPT4ge1xuICAgICAgdGhpcy5fb2JzZXJ2ZXJzLnB1c2gobmV3IEZvbnRPYnNlcnZlcih2YXJpYXRpb24pKVxuICAgIH0pXG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICB0aGlzLl9vYnNlcnZlcnMubWFwKG9ic2VydmVyID0+IG9ic2VydmVyLm9ic2VydmUoKSlcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZXMgdGhlIG9ic2VydmVyc1xuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG4gICAgdGhpcy5fb2JzZXJ2ZXJzLmZvckVhY2gob2JzZXJ2ZXIgPT4gb2JzZXJ2ZXIuZGlzcG9zZSgpKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvZm9udC1sb2FkZXIvbG9hZGVycy9iYXNlLWZvbnQtbG9hZGVyLmpzIiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgUHJldmlvdXNTZXJpYWxpemVyIGZyb20gJy4uLzEuMC4wL3NlcmlhbGl6ZXInXG5cbmNvbnN0IFRXSUNFX1BJID0gTWF0aC5QSSAqIDJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgdjEwMVNlcmlhbGl6ZXIgZXh0ZW5kcyBQcmV2aW91c1NlcmlhbGl6ZXIge1xuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gdHJhbnNmb3JtIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb24uVHJhbnNmb3JtT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlcmlhbGl6ZVRyYW5zZm9ybU9wZXJhdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wZXJhdGlvbi5zZXJpYWxpemVPcHRpb25zKFsnc3RhcnQnLCAnZW5kJywgJ3JvdGF0aW9uJywgJ3RleHR1cmVTY2FsZSddLCB0cnVlKVxuICAgIG9wdGlvbnMucm90YXRpb24gPSAob3B0aW9ucy5yb3RhdGlvbiArIFRXSUNFX1BJKSAlIFRXSUNFX1BJXG4gICAgaWYgKG9wdGlvbnMudGV4dHVyZVNjYWxlICE9PSAxKSB7XG4gICAgICBvcHRpb25zLmRpbWVuc2lvbnMgPSBvcGVyYXRpb24uZ2V0TmV3RGltZW5zaW9ucyhvcGVyYXRpb24uZ2V0SW5wdXREaW1lbnNpb25zKGZhbHNlKSlcbiAgICB9XG5cbiAgICBkZWxldGUgb3B0aW9ucy50ZXh0dXJlU2NhbGVcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2Nyb3AnLFxuICAgICAgb3B0aW9uc1xuICAgIH1cbiAgfVxufVxuXG52MTAxU2VyaWFsaXplci52ZXJzaW9uID0gJzEuMC4xJ1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zaGFyZWQvc2VyaWFsaXphdGlvbi8xLjAuMS9zZXJpYWxpemVyLmpzIiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnZ2xvYmFscydcbmltcG9ydCBQcmV2aW91c0Rlc2VyaWFsaXplciBmcm9tICcuLi8xLjAuMC9kZXNlcmlhbGl6ZXInXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHYxMDFEZXNlcmlhbGl6ZXIgZXh0ZW5kcyBQcmV2aW91c0Rlc2VyaWFsaXplciB7XG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZXMgdGhlIGdpdmVuIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Rlc2VyaWFsaXplT3BlcmF0aW9uIChvcGVyYXRpb24pIHtcbiAgICBpZiAob3BlcmF0aW9uLnR5cGUgPT09ICdzZWxlY3RpdmUtYmx1cicpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZVNlbGVjdGl2ZUJsdXJPcGVyYXRpb24ob3BlcmF0aW9uKVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuX2Rlc2VyaWFsaXplT3BlcmF0aW9uKG9wZXJhdGlvbilcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZXMgdGhlIGdpdmVuIGNyb3Agb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVzZXJpYWxpemVDcm9wT3BlcmF0aW9uIChvcGVyYXRpb24pIHtcbiAgICAvLyBOZXcgaW4gMS4wLjE6IGBkaW1lbnNpb25zYCBvcHRpb25cbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IG9wZXJhdGlvblxuICAgIGxldCB7IHJvdGF0aW9uIH0gPSBvcHRpb25zXG4gICAgY29uc3Qgc3RhcnQgPSBWZWN0b3IyLmZyb21PYmplY3Qob3B0aW9ucy5zdGFydClcbiAgICBjb25zdCBlbmQgPSBWZWN0b3IyLmZyb21PYmplY3Qob3B0aW9ucy5lbmQpXG4gICAgY29uc3QgZGltZW5zaW9ucyA9IG9wdGlvbnMuZGltZW5zaW9ucyA/IFZlY3RvcjIuZnJvbU9iamVjdChvcHRpb25zLmRpbWVuc2lvbnMpIDogbnVsbFxuXG4gICAgLy8gTm9ybWFsaXplIHJvdGF0aW9uXG4gICAgaWYgKHJvdGF0aW9uID4gTWF0aC5QSSkge1xuICAgICAgcm90YXRpb24gLT0gTWF0aC5QSSAqIDJcbiAgICB9XG5cbiAgICBjb25zdCBjcm9wT3B0aW9ucyA9IHtcbiAgICAgIHN0YXJ0LCBlbmRcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJvdGF0aW9uICE9PSAndW5kZWZpbmVkJykgY3JvcE9wdGlvbnMucm90YXRpb24gPSByb3RhdGlvblxuXG4gICAgY29uc3QgdHJhbnNmb3JtT3BlcmF0aW9uID0gdGhpcy5fZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ3RyYW5zZm9ybScpXG4gICAgaWYgKCF0cmFuc2Zvcm1PcGVyYXRpb24pIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXG4gICAgdGhpcy5fZWRpdG9yLmJyb2FkY2FzdFRyYW5zZm9ybSh0cmFuc2Zvcm1PcGVyYXRpb24sIGNyb3BPcHRpb25zKVxuICAgIHRyYW5zZm9ybU9wZXJhdGlvbi5zZXQoY3JvcE9wdGlvbnMpXG5cbiAgICBpZiAoZGltZW5zaW9ucykge1xuICAgICAgY29uc3Qgc2l6ZSA9IGVuZC5jbG9uZSgpLnN1YnRyYWN0KHN0YXJ0KVxuICAgICAgY29uc3QgdHJhbnNmb3JtRGltZW5zaW9ucyA9IHRyYW5zZm9ybU9wZXJhdGlvbi5nZXRJbnB1dERpbWVuc2lvbnMoZmFsc2UpLm11bHRpcGx5KHNpemUpXG4gICAgICB0cmFuc2Zvcm1PcGVyYXRpb24uc2V0VGV4dHVyZVNjYWxlKGRpbWVuc2lvbnMueCAvIHRyYW5zZm9ybURpbWVuc2lvbnMueClcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRyYW5zZm9ybU9wZXJhdGlvbilcbiAgfVxufVxuXG52MTAxRGVzZXJpYWxpemVyLnZlcnNpb24gPSAnMS4wLjEnXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9zZXJpYWxpemF0aW9uLzEuMC4xL2Rlc2VyaWFsaXplci5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgU0RLIH0gZnJvbSAnZ2xvYmFscydcbmNvbnN0IHsgT3ZlcmxheUZpbHRlciB9ID0gU0RLLkVuZ2luZS5GaWx0ZXJzXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgW092ZXJsYXlGaWx0ZXIuQkxFTkRfTU9ERVMuTk9STUFMXTogJ25vcm1hbCcsXG4gIFtPdmVybGF5RmlsdGVyLkJMRU5EX01PREVTLk9WRVJMQVldOiAnb3ZlcmxheScsXG4gIFtPdmVybGF5RmlsdGVyLkJMRU5EX01PREVTLkhBUkRfTElHSFRdOiAnaGFyZCBsaWdodCcsXG4gIFtPdmVybGF5RmlsdGVyLkJMRU5EX01PREVTLlNPRlRfTElHSFRdOiAnc29mdCBsaWdodCcsXG4gIFtPdmVybGF5RmlsdGVyLkJMRU5EX01PREVTLk1VTFRJUExZXTogJ211bHRpcGx5JyxcbiAgW092ZXJsYXlGaWx0ZXIuQkxFTkRfTU9ERVMuREFSS0VOXTogJ2RhcmtlbicsXG4gIFtPdmVybGF5RmlsdGVyLkJMRU5EX01PREVTLkxJR0hURU5dOiAnbGlnaHRlbicsXG4gIFtPdmVybGF5RmlsdGVyLkJMRU5EX01PREVTLlNDUkVFTl06ICdzY3JlZW4nLFxuICBbT3ZlcmxheUZpbHRlci5CTEVORF9NT0RFUy5DT0xPUl9CVVJOXTogJ2NvbG9yIGJ1cm4nXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9zZXJpYWxpemF0aW9uLzIuMC4wL2JsZW5kLW1vZGVzLmpzIiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBTREtVdGlscywgQ29sb3IgfSBmcm9tICdnbG9iYWxzJ1xuaW1wb3J0IFByZXZpb3VzU2VyaWFsaXplciBmcm9tICcuLi8yLjAuMC9zZXJpYWxpemVyJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB2MzAwU2VyaWFsaXplciBleHRlbmRzIFByZXZpb3VzU2VyaWFsaXplciB7XG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBlZGl0b3Igc3RhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgPSB7fVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgc2VyaWFsaXplIChvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gc3VwZXIuc2VyaWFsaXplKG9wdGlvbnMpXG4gICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgZGF0YS5tZXRhID0ge1xuICAgICAgICAgIHBsYXRmb3JtOiAnaHRtbDUnLFxuICAgICAgICAgIHZlcnNpb246IHRoaXMuX2VkaXRvci5nZXRTREsoKS52ZXJzaW9uLFxuICAgICAgICAgIGNyZWF0ZWRBdDogU0RLVXRpbHMuSVNPRGF0ZVN0cmluZyhuZXcgRGF0ZSgpKVxuICAgICAgICB9XG4gICAgICAgIGRhdGEuaW1hZ2UgPSBkYXRhLmlucHV0SW1hZ2VcbiAgICAgICAgZGVsZXRlIGRhdGEuaW5wdXRJbWFnZVxuICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBzdGlja2VyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uLlN0aWNrZXJTcHJpdGV9IHNwcml0ZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VyaWFsaXplU3RpY2tlciAob3BlcmF0aW9uLCBzcHJpdGUpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IHN1cGVyLl9zZXJpYWxpemVTdGlja2VyKG9wZXJhdGlvbiwgc3ByaXRlKVxuICAgIHJlc3BvbnNlLm9wdGlvbnMuYWxwaGEgPSBzcHJpdGUuZ2V0QWxwaGEoKVxuXG4gICAgaWYgKHJlc3BvbnNlLm9wdGlvbnMudGludENvbG9yKSB7XG4gICAgICByZXNwb25zZS5vcHRpb25zLnRpbnRDb2xvciA9IHtcbiAgICAgICAgcmdiYTogcmVzcG9uc2Uub3B0aW9ucy50aW50Q29sb3JcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBnaXZlbiB0ZXh0IHNwcml0ZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbi5UZXh0U3ByaXRlfSBzcHJpdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlcmlhbGl6ZVRleHQgKG9wZXJhdGlvbiwgc3ByaXRlKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBzdXBlci5fc2VyaWFsaXplVGV4dChvcGVyYXRpb24sIHNwcml0ZSlcbiAgICByZXNwb25zZS5vcHRpb25zLmNvbG9yID0ge1xuICAgICAgcmdiYTogcmVzcG9uc2Uub3B0aW9ucy5jb2xvclxuICAgIH1cbiAgICByZXNwb25zZS5vcHRpb25zLmJhY2tncm91bmRDb2xvciA9IHtcbiAgICAgIHJnYmE6IHJlc3BvbnNlLm9wdGlvbnMuYmFja2dyb3VuZENvbG9yXG4gICAgfVxuICAgIHJlc3BvbnNlLm9wdGlvbnMuZmxpcEhvcml6b250YWxseSA9IGZhbHNlXG4gICAgcmVzcG9uc2Uub3B0aW9ucy5mbGlwVmVydGljYWxseSA9IGZhbHNlXG4gICAgZGVsZXRlIHJlc3BvbnNlLm9wdGlvbnMuZm9udFdlaWdodFxuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIGdpdmVuIHBhdGhcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb24uQnJ1c2hTcHJpdGUuUGF0aH0gcGF0aFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VyaWFsaXplUGF0aCAocGF0aCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gc3VwZXIuX3NlcmlhbGl6ZVBhdGgocGF0aClcblxuICAgIGRlbGV0ZSByZXNwb25zZS5oYXJkbmVzc1xuICAgIGRlbGV0ZSByZXNwb25zZS5zaXplXG4gICAgZGVsZXRlIHJlc3BvbnNlLmNvbG9yXG5cbiAgICBjb25zdCBicnVzaCA9IHBhdGguZ2V0QnJ1c2goKVxuICAgIHJlc3BvbnNlLmJydXNoID0gYnJ1c2guc2VyaWFsaXplT3B0aW9ucyhbXG4gICAgICAnaWRlbnRpZmllcicsICdzaXplJywgJ2NvbG9yJ1xuICAgIF0sIHRydWUpXG4gICAgaWYgKHR5cGVvZiByZXNwb25zZS5icnVzaC5pZGVudGlmaWVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZGVsZXRlIHJlc3BvbnNlLmJydXNoLmlkZW50aWZpZXJcbiAgICB9XG4gICAgcmVzcG9uc2UuYnJ1c2guY29sb3IgPSB7XG4gICAgICByZ2JhOiByZXNwb25zZS5icnVzaC5jb2xvclxuICAgIH1cblxuICAgIGNvbnN0IGhhcmRuZXNzID0gYnJ1c2guZ2V0T3B0aW9uKCdoYXJkbmVzcycpXG4gICAgaWYgKGhhcmRuZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVzcG9uc2UuYnJ1c2guaGFyZG5lc3MgPSBoYXJkbmVzc1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBmcmFtZSBvcGVyYXRpb25cbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb24uRnJhbWVPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbltdfSBvcGVyYXRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VyaWFsaXplRnJhbWVPcGVyYXRpb24gKG9wZXJhdGlvbiwgb3BlcmF0aW9ucykge1xuICAgIHN1cGVyLl9zZXJpYWxpemVGcmFtZU9wZXJhdGlvbihvcGVyYXRpb24sIG9wZXJhdGlvbnMpXG5cbiAgICAvLyBGaW5kIHNwcml0ZSBvcGVyYXRpb24gYW5kIGZyYW1lIHNwcml0ZSBmcm9tIHNlcmlhbGl6ZWQgZGF0YVxuICAgIGNvbnN0IHNwcml0ZU9wZXJhdGlvbnMgPSBvcGVyYXRpb25zLmZpbHRlcihvID0+IG8udHlwZSA9PT0gJ3Nwcml0ZScpXG4gICAgbGV0IHNwcml0ZU9wZXJhdGlvblxuICAgIGlmIChzcHJpdGVPcGVyYXRpb25zLmxlbmd0aCkge1xuICAgICAgc3ByaXRlT3BlcmF0aW9uID0gc3ByaXRlT3BlcmF0aW9ucy5wb3AoKVxuICAgICAgY29uc3QgZnJhbWUgPSBzcHJpdGVPcGVyYXRpb24ub3B0aW9ucy5zcHJpdGVzXG4gICAgICAgIC5maWx0ZXIocyA9PiBzLnR5cGUgPT09ICdmcmFtZScpWzBdXG5cbiAgICAgIGNvbnN0IHRpbnRDb2xvciA9IG9wZXJhdGlvbi5nZXRUaW50Q29sb3IoKVxuICAgICAgaWYgKCF0aW50Q29sb3IuZXF1YWxzKG5ldyBDb2xvcigxLCAxLCAxLCAwKSkpIHtcbiAgICAgICAgZnJhbWUub3B0aW9ucy50aW50Q29sb3IgPSB7XG4gICAgICAgICAgcmdiYTogb3BlcmF0aW9uLnNlcmlhbGl6ZU9wdGlvbigndGludENvbG9yJywgdHJ1ZSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvcHRpb25zID0gb3BlcmF0aW9uLnNlcmlhbGl6ZU9wdGlvbnMoW1xuICAgICAgICAnc2NhbGUnLCAnYWxwaGEnXG4gICAgICBdLCB0cnVlKVxuICAgICAgZnJhbWUub3B0aW9ucyA9IFNES1V0aWxzLmV4dGVuZChmcmFtZS5vcHRpb25zLCBvcHRpb25zKVxuICAgICAgZnJhbWUub3B0aW9ucy5zaXplID0gZnJhbWUub3B0aW9ucy5zY2FsZVxuICAgICAgZGVsZXRlIGZyYW1lLm9wdGlvbnMuc2NhbGVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gdHJhbnNmb3JtIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb24uVHJhbnNmb3JtT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlcmlhbGl6ZVRyYW5zZm9ybU9wZXJhdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBzdXBlci5fc2VyaWFsaXplVHJhbnNmb3JtT3BlcmF0aW9uKG9wZXJhdGlvbilcblxuICAgIGlmIChvcGVyYXRpb24uX3JhdGlvKSB7XG4gICAgICByZXNwb25zZS5vcHRpb25zLm1ldGEgPSB7XG4gICAgICAgIGlkZW50aWZpZXI6IG9wZXJhdGlvbi5fcmF0aW8uaWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUgcmVzcG9uc2Uub3B0aW9ucy5zY2FsZVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gYWRqdXN0bWVudHMgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuQWRqdXN0bWVudHNPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VyaWFsaXplQWRqdXN0bWVudHNPcGVyYXRpb24gKG9wZXJhdGlvbikge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gc3VwZXIuX3NlcmlhbGl6ZUFkanVzdG1lbnRzT3BlcmF0aW9uKG9wZXJhdGlvbilcblxuICAgIGNvbnN0IG9wdGlvbk5hbWVzID0gW1xuICAgICAgJ2dhbW1hJywgJ3doaXRlcycsICdibGFja3MnLCAndGVtcGVyYXR1cmUnXG4gICAgXVxuXG4gICAgY29uc3QgeyBhdmFpbGFibGVPcHRpb25zIH0gPSBvcGVyYXRpb25cbiAgICBjb25zdCBvcHRpb25zID0ge31cbiAgICBvcHRpb25OYW1lcy5mb3JFYWNoKG9wdGlvbk5hbWUgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uID0gYXZhaWxhYmxlT3B0aW9uc1tvcHRpb25OYW1lXVxuICAgICAgY29uc3QgdmFsdWUgPSBvcGVyYXRpb24uZ2V0T3B0aW9uKG9wdGlvbk5hbWUpXG4gICAgICBjb25zdCB7IG1pblZhbHVlLCBtaWRWYWx1ZSwgbWF4VmFsdWUgfSA9IG9wdGlvblxuICAgICAgb3B0aW9uc1tvcHRpb25OYW1lXSA9IHZhbHVlIDw9IG1pZFZhbHVlXG4gICAgICAgID8gKHZhbHVlIC0gbWluVmFsdWUpIC8gKG1pZFZhbHVlIC0gbWluVmFsdWUpIC0gMVxuICAgICAgICA6ICh2YWx1ZSAtIG1pZFZhbHVlKSAvIChtYXhWYWx1ZSAtIG1pZFZhbHVlKVxuICAgIH0pXG5cbiAgICByZXNwb25zZS5vcHRpb25zID0ge1xuICAgICAgLi4ucmVzcG9uc2Uub3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9uW119IG9wZXJhdGlvbnNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlcmlhbGl6ZU9wZXJhdGlvbiAob3BlcmF0aW9uLCBvcGVyYXRpb25zKSB7XG4gICAgc3dpdGNoIChvcGVyYXRpb24uY29uc3RydWN0b3IuaWRlbnRpZmllcikge1xuICAgICAgY2FzZSAnbWlycm9yZWQtZm9jdXMnOlxuICAgICAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXplTWlycm9yZWRGb2N1c09wZXJhdGlvbihvcGVyYXRpb24pXG4gICAgICBjYXNlICdsaW5lYXItZm9jdXMnOlxuICAgICAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXplTGluZWFyRm9jdXNPcGVyYXRpb24ob3BlcmF0aW9uKVxuICAgICAgY2FzZSAnYmx1cic6XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemVCbHVyT3BlcmF0aW9uKG9wZXJhdGlvbilcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBzdXBlci5fc2VyaWFsaXplT3BlcmF0aW9uKG9wZXJhdGlvbiwgb3BlcmF0aW9ucylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gbWlycm9yZWQgZm9jdXMgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuTWlycm9yZWRGb2N1c09wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXJpYWxpemVNaXJyb3JlZEZvY3VzT3BlcmF0aW9uIChvcGVyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2ZvY3VzJyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdHlwZTogJ21pcnJvcmVkJyxcbiAgICAgICAgb3B0aW9uczogb3BlcmF0aW9uLnNlcmlhbGl6ZU9wdGlvbnMoWydzdGFydCcsICdlbmQnLCAnYmx1clJhZGl1cycsICdzaXplJywgJ2dyYWRpZW50U2l6ZSddLCB0cnVlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBsaW5lYXIgZm9jdXMgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuTGluZWFyRm9jdXNPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VyaWFsaXplTGluZWFyRm9jdXNPcGVyYXRpb24gKG9wZXJhdGlvbikge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBvcGVyYXRpb24uc2VyaWFsaXplT3B0aW9ucyhbJ2NvbnRyb2xQb2ludDEnLCAnY29udHJvbFBvaW50MicsICdibHVyUmFkaXVzJ10sIHRydWUpXG4gICAgb3B0aW9ucy5zdGFydCA9IG9wdGlvbnMuY29udHJvbFBvaW50MVxuICAgIGRlbGV0ZSBvcHRpb25zLmNvbnRyb2xQb2ludDFcbiAgICBvcHRpb25zLmVuZCA9IG9wdGlvbnMuY29udHJvbFBvaW50MlxuICAgIGRlbGV0ZSBvcHRpb25zLmNvbnRyb2xQb2ludDJcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnZm9jdXMnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBibHVyIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLkJsdXJPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VyaWFsaXplQmx1ck9wZXJhdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdmb2N1cycsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHR5cGU6ICdnYXVzc2lhbicsXG4gICAgICAgIG9wdGlvbnM6IG9wZXJhdGlvbi5zZXJpYWxpemVPcHRpb25zKFsnYmx1clJhZGl1cyddLCB0cnVlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52MzAwU2VyaWFsaXplci52ZXJzaW9uID0gJzMuMC4wJ1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zaGFyZWQvc2VyaWFsaXphdGlvbi8zLjAuMC9zZXJpYWxpemVyLmpzIiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBWZWN0b3IyLCBDb2xvciwgU0RLLCBMb2csIFNES1V0aWxzLCBDb25zdGFudHMgfSBmcm9tICdnbG9iYWxzJ1xuaW1wb3J0IFByZXZpb3VzRGVzZXJpYWxpemVyIGZyb20gJy4uLzIuMC4wL2Rlc2VyaWFsaXplcidcbmltcG9ydCBTdGlja2VyTWFuYWdlciBmcm9tICdzaGFyZWQvbWFuYWdlcnMvc3RpY2tlci1tYW5hZ2VyJ1xuaW1wb3J0IFRleHREZXNpZ25NYW5hZ2VyIGZyb20gJ3NoYXJlZC9tYW5hZ2Vycy90ZXh0LWRlc2lnbi1tYW5hZ2VyJ1xuaW1wb3J0IEltYWdlTG9hZGVyIGZyb20gJ3NoYXJlZC9sb2FkZXJzL2ltYWdlLWxvYWRlcidcbmltcG9ydCBGb250TWFuYWdlciBmcm9tICdzaGFyZWQvbWFuYWdlcnMvZm9udC1tYW5hZ2VyJ1xuXG5sZXQgQnJ1c2hcbmlmICh0eXBlb2YgU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICBCcnVzaCA9IFNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbi5CcnVzaFNwcml0ZS5CcnVzaFxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB2MzAwRGVzZXJpYWxpemVyIGV4dGVuZHMgUHJldmlvdXNEZXNlcmlhbGl6ZXIge1xuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBzdGlja2VyIGZvciB0aGUgZ2l2ZW4gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gc3ByaXRlXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uLlN0aWNrZXJTcHJpdGV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVzZXJpYWxpemVTdGlja2VyIChvcGVyYXRpb24sIHNwcml0ZSkge1xuICAgIGNvbnN0IHsgU3ByaXRlT3BlcmF0aW9uIH0gPSBTREsuT3BlcmF0aW9uc1xuXG4gICAgY29uc3QgeyBvcHRpb25zIH0gPSBzcHJpdGVcbiAgICBjb25zdCBzdGlja2VyID0gdGhpcy5fc3RpY2tlck1hbmFnZXIuZ2V0U3RpY2tlckJ5SWRlbnRpZmllcihvcHRpb25zLmlkZW50aWZpZXIpXG4gICAgaWYgKCFzdGlja2VyKSB7XG4gICAgICBMb2cud2FybignRGVzZXJpYWxpemVyJywgYFVua25vd24gc3RpY2tlciBcXGAke29wdGlvbnMuaWRlbnRpZmllcn1cXGAuIFNraXBwaW5nIHNwcml0ZS5gKVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuICAgIGNvbnN0IHVybCA9IFN0aWNrZXJNYW5hZ2VyLmdldFVSTEZvclN0aWNrZXIoc3RpY2tlciwgJ2Jhc2UnKVxuICAgIGNvbnN0IHJlc29sdmVkVXJsID0gdGhpcy5fZWRpdG9yLmdldFVJKCkuZ2V0QXNzZXRQYXRoKHVybClcbiAgICBjb25zdCBpbnB1dERpbWVuc2lvbnMgPSBvcGVyYXRpb24uZ2V0SW5wdXREaW1lbnNpb25zKGZhbHNlKVxuICAgIHJldHVybiBJbWFnZUxvYWRlci5sb2FkKHJlc29sdmVkVXJsKVxuICAgICAgLnRoZW4oaW1hZ2UgPT4ge1xuICAgICAgICBjb25zdCBhZGp1c3RtZW50cyA9IFNwcml0ZU9wZXJhdGlvbi5TdGlja2VyU3ByaXRlLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zLmFkanVzdG1lbnRzLnN0cnVjdHVyZVxuICAgICAgICBjb25zdCB7IHJvdGF0aW9uLCBmbGlwSG9yaXpvbnRhbGx5LCBmbGlwVmVydGljYWxseSB9ID0gb3B0aW9uc1xuICAgICAgICBjb25zdCBzdGlja2VyT3B0aW9ucyA9IHtcbiAgICAgICAgICBpZGVudGlmaWVyOiBvcHRpb25zLmlkZW50aWZpZXIsXG4gICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgcG9zaXRpb246IFZlY3RvcjIuZnJvbU9iamVjdChvcHRpb25zLnBvc2l0aW9uKSxcbiAgICAgICAgICBkaW1lbnNpb25zOiBWZWN0b3IyLmZyb21PYmplY3Qob3B0aW9ucy5kaW1lbnNpb25zKS5tdWx0aXBseShpbnB1dERpbWVuc2lvbnMubWluKCkpLFxuICAgICAgICAgIHJvdGF0aW9uOiByb3RhdGlvbiB8fCAwLFxuICAgICAgICAgIGZsaXBIb3Jpem9udGFsbHksXG4gICAgICAgICAgZmxpcFZlcnRpY2FsbHksXG4gICAgICAgICAgYWRqdXN0bWVudHM6IHt9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWRqdXN0bWVudHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgWydicmlnaHRuZXNzJywgJ2NvbnRyYXN0JywgJ3NhdHVyYXRpb24nXS5mb3JFYWNoKG9wdGlvbiA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWRqdXN0bWVudHNbb3B0aW9uXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgc3RpY2tlck9wdGlvbnMuYWRqdXN0bWVudHNbb3B0aW9uXSA9IG9wdGlvbnMuYWRqdXN0bWVudHNbb3B0aW9uXSArIGFkanVzdG1lbnRzW29wdGlvbl0uZGVmYXVsdFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudGludENvbG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygc3RpY2tlci50aW50TW9kZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBzdGlja2VyT3B0aW9ucy50aW50Q29sb3IgPSBDb2xvci5mcm9tQXJyYXkob3B0aW9ucy50aW50Q29sb3IucmdiYSlcbiAgICAgICAgICBzdGlja2VyT3B0aW9ucy50aW50TW9kZSA9IHN0aWNrZXIudGludE1vZGVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbHBoYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBzdGlja2VyT3B0aW9ucy5hbHBoYSA9IG9wdGlvbnMuYWxwaGFcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcGVyYXRpb24uY3JlYXRlU3RpY2tlcihzdGlja2VyT3B0aW9ucylcbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiB0cmFuc2Zvcm0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3BlcmF0aW9uRGF0YVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Rlc2VyaWFsaXplVHJhbnNmb3JtT3BlcmF0aW9uIChvcGVyYXRpb25EYXRhKSB7XG4gICAgcmV0dXJuIHN1cGVyLl9kZXNlcmlhbGl6ZVRyYW5zZm9ybU9wZXJhdGlvbihvcGVyYXRpb25EYXRhKVxuICAgICAgLnRoZW4ob3BlcmF0aW9uID0+IHtcbiAgICAgICAgaWYgKCFvcGVyYXRpb24pIHJldHVyblxuXG4gICAgICAgIC8vIFRPRE86IEdldCBjb3JyZWN0IHJhdGlvXG4gICAgICAgIG9wZXJhdGlvbi5fcmF0aW8gPSBudWxsXG4gICAgICAgIHJldHVybiBvcGVyYXRpb25cbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBpbnB1dCBpbWFnZSAoaWYgcHJlc2VudClcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXNlcmlhbGl6ZUlucHV0SW1hZ2UgKCkge1xuICAgIGxldCB7IGRhdGEsIHR5cGUsIHVyaSB9ID0gdGhpcy5fZGF0YS5pbWFnZVxuXG4gICAgaWYgKGRhdGEgJiYgdHlwZSkge1xuICAgICAgdXJpID0gYGRhdGE6JHt0eXBlfTtiYXNlNjQsJHtkYXRhfWBcbiAgICB9XG5cbiAgICBpZiAodXJpKSB7XG4gICAgICByZXR1cm4gSW1hZ2VMb2FkZXIubG9hZCh1cmkpXG4gICAgICAgIC50aGVuKGltYWdlID0+IHtcbiAgICAgICAgICB0aGlzLl9lZGl0b3Iuc2V0SW1hZ2UoaW1hZ2UpXG4gICAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZXMgdGhlIGdpdmVuIGFkanVzdG1lbnRzIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wZXJhdGlvbkRhdGFcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXNlcmlhbGl6ZUFkanVzdG1lbnRzT3BlcmF0aW9uIChvcGVyYXRpb25EYXRhKSB7XG4gICAgY29uc3QgeyBBZGp1c3RtZW50c09wZXJhdGlvbiB9ID0gU0RLLk9wZXJhdGlvbnNcbiAgICByZXR1cm4gc3VwZXIuX2Rlc2VyaWFsaXplQWRqdXN0bWVudHNPcGVyYXRpb24ob3BlcmF0aW9uRGF0YSlcbiAgICAgIC50aGVuKG9wZXJhdGlvbiA9PiB7XG4gICAgICAgIGlmICghb3BlcmF0aW9uKSByZXR1cm4gbnVsbFxuXG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gb3BlcmF0aW9uRGF0YVxuICAgICAgICBjb25zdCBrbm93bk9wdGlvbnMgPSBbJ2dhbW1hJywgJ3doaXRlcycsICdibGFja3MnLCAndGVtcGVyYXR1cmUnXVxuICAgICAgICBjb25zdCBvcGVyYXRpb25PcHRpb25zID0ge31cblxuICAgICAgICBrbm93bk9wdGlvbnMuZm9yRWFjaChvcHRpb25OYW1lID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNbb3B0aW9uTmFtZV0gPT09ICd1bmRlZmluZWQnKSByZXR1cm5cblxuICAgICAgICAgIGNvbnN0IHsgbWluVmFsdWUsIG1pZFZhbHVlLCBtYXhWYWx1ZSB9ID0gQWRqdXN0bWVudHNPcGVyYXRpb24ucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnNbb3B0aW9uTmFtZV1cbiAgICAgICAgICBsZXQgdmFsdWUgPSBvcHRpb25zW29wdGlvbk5hbWVdXG5cbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlIDwgMFxuICAgICAgICAgICAgPyAobWlkVmFsdWUgKyAobWlkVmFsdWUgLSBtaW5WYWx1ZSkgKiB2YWx1ZSlcbiAgICAgICAgICAgIDogKG1pZFZhbHVlICsgKG1heFZhbHVlIC0gbWlkVmFsdWUpICogdmFsdWUpXG4gICAgICAgICAgb3BlcmF0aW9uT3B0aW9uc1tvcHRpb25OYW1lXSA9IHZhbHVlXG4gICAgICAgIH0pXG5cbiAgICAgICAgb3BlcmF0aW9uLnNldChvcGVyYXRpb25PcHRpb25zKVxuXG4gICAgICAgIHJldHVybiBvcGVyYXRpb25cbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBmb2N1cyBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcGVyYXRpb25EYXRhXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVzZXJpYWxpemVGb2N1c09wZXJhdGlvbiAob3BlcmF0aW9uRGF0YSkge1xuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gb3BlcmF0aW9uRGF0YS5vcHRpb25zXG4gICAgc3dpdGNoIChvcGVyYXRpb25EYXRhLm9wdGlvbnMudHlwZSkge1xuICAgICAgY2FzZSAncmFkaWFsJzpcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9kZXNlcmlhbGl6ZUZvY3VzT3BlcmF0aW9uKG9wZXJhdGlvbkRhdGEpXG4gICAgICBjYXNlICdsaW5lYXInOiB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCwgYmx1clJhZGl1cyB9ID0gb3B0aW9uc1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2VkaXRvci5vcGVyYXRpb25zLmdldE9yQ3JlYXRlKCdsaW5lYXItZm9jdXMnLCB7XG4gICAgICAgICAgY29udHJvbFBvaW50MTogVmVjdG9yMi5mcm9tT2JqZWN0KHN0YXJ0KSxcbiAgICAgICAgICBjb250cm9sUG9pbnQyOiBWZWN0b3IyLmZyb21PYmplY3QoZW5kKSxcbiAgICAgICAgICBibHVyUmFkaXVzXG4gICAgICAgIH0pKVxuICAgICAgfVxuICAgICAgY2FzZSAnbWlycm9yZWQnOiB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCwgc2l6ZSwgZ3JhZGllbnRTaXplLCBibHVyUmFkaXVzIH0gPSBvcHRpb25zXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ21pcnJvcmVkLWZvY3VzJywge1xuICAgICAgICAgIHN0YXJ0OiBWZWN0b3IyLmZyb21PYmplY3Qoc3RhcnQpLFxuICAgICAgICAgIGVuZDogVmVjdG9yMi5mcm9tT2JqZWN0KGVuZCksXG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICBncmFkaWVudFNpemUsXG4gICAgICAgICAgYmx1clJhZGl1c1xuICAgICAgICB9KSlcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2dhdXNzaWFuJzoge1xuICAgICAgICBjb25zdCB7IGJsdXJSYWRpdXMgfSA9IG9wdGlvbnNcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9lZGl0b3Iub3BlcmF0aW9ucy5nZXRPckNyZWF0ZSgnYmx1cicsIHtcbiAgICAgICAgICBibHVyUmFkaXVzXG4gICAgICAgIH0pKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZXMgdGhlIGdpdmVuIHRleHQgZm9yIHRoZSBnaXZlbiBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHRleHRcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb24uVGV4dFNwcml0ZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXNlcmlhbGl6ZVRleHQgKG9wZXJhdGlvbiwgdGV4dCkge1xuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGV4dFxuICAgIGNvbnN0IHsgZm9udFNpemUsIGxpbmVIZWlnaHQsIGZvbnRJZGVudGlmaWVyLCBhbGlnbm1lbnQsIHJvdGF0aW9uLCBtYXhXaWR0aCwgY29sb3IsIGJhY2tncm91bmRDb2xvciB9ID0gb3B0aW9uc1xuXG4gICAgY29uc3QgZm9udExvYWRlciA9IHRoaXMuX3VpLmdldEZvbnRMb2FkZXIoKVxuICAgIGxldCB2YXJpYXRpb24gPSB0aGlzLl9mb250TWFuYWdlci5nZXRWYXJpYXRpb25CeUlkZW50aWZpZXIoZm9udElkZW50aWZpZXIpXG4gICAgaWYgKCF2YXJpYXRpb24pIHtcbiAgICAgIHZhcmlhdGlvbiA9IHRoaXMuX2ZvbnRNYW5hZ2VyLmdldERlZmF1bHRWYXJpYXRpb24oKVxuICAgIH0gZWxzZSB7XG4gICAgICBmb250TG9hZGVyLnNldEZvbnRzKFt2YXJpYXRpb24uZ2V0Rm9udCgpXSlcbiAgICB9XG4gICAgcmV0dXJuIGZvbnRMb2FkZXIubG9hZCgpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IG9wZXJhdGlvbi5nZXRJbnB1dERpbWVuc2lvbnMoZmFsc2UpXG5cbiAgICAgICAgLy8gRm9yIHdoYXRldmVyIHJlYXNvbiwgbWF4IHdpZHRoIGlzIHJlbGF0aXZlIHRvIHNob3J0ZXN0IHNpZGUsIHdoaWxlIGZvbnQgc2l6ZSBpc24ndFxuICAgICAgICBjb25zdCBmaXhlZE1heFdpZHRoID0gbWF4V2lkdGggKiBpbnB1dERpbWVuc2lvbnMubWluKCkgLyBpbnB1dERpbWVuc2lvbnMueFxuICAgICAgICByZXR1cm4gb3BlcmF0aW9uLmNyZWF0ZVRleHQoe1xuICAgICAgICAgIGZvbnRTaXplLFxuICAgICAgICAgIGxpbmVIZWlnaHQsXG4gICAgICAgICAgZm9udEZhbWlseTogdmFyaWF0aW9uLmdldEZvbnRGYW1pbHkoKSxcbiAgICAgICAgICBmb250V2VpZ2h0OiB2YXJpYXRpb24uZ2V0Rm9udFdlaWdodCgpLFxuICAgICAgICAgIGZvbnRJZGVudGlmaWVyOiB2YXJpYXRpb24uZ2V0SWRlbnRpZmllcigpLFxuICAgICAgICAgIHRleHRNZXRyaWNzOiB2YXJpYXRpb24uZ2V0VGV4dE1ldHJpY3MoKSxcbiAgICAgICAgICBhbGlnbm1lbnQsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgbWF4V2lkdGg6IGZpeGVkTWF4V2lkdGgsXG4gICAgICAgICAgdGV4dDogb3B0aW9ucy50ZXh0LFxuICAgICAgICAgIGNvbG9yOiBDb2xvci5mcm9tQXJyYXkoY29sb3IucmdiYSksXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBDb2xvci5mcm9tQXJyYXkoYmFja2dyb3VuZENvbG9yLnJnYmEpLFxuICAgICAgICAgIHBvc2l0aW9uOiBWZWN0b3IyLmZyb21PYmplY3Qob3B0aW9ucy5wb3NpdGlvbilcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGJydXNoIGZhY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbi5TcHJpdGVzLkJydXNoU3ByaXRlLlBhdGh9IHBhdGhcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb24uU3ByaXRlcy5CcnVzaFNwcml0ZS5CcnVzaH1cbiAgICovXG4gIF9jcmVhdGVCcnVzaEZvclBhdGggKHBhdGgpIHtcbiAgICBjb25zdCB7IGlkZW50aWZpZXIsIGNvbG9yLCBzaXplLCBoYXJkbmVzcyB9ID0gcGF0aC5icnVzaFxuICAgIGNvbnN0IGNvbG9yT2JqZWN0ID0gQ29sb3IuZnJvbUFycmF5KGNvbG9yLnJnYmEpXG5cbiAgICBjb25zdCBicnVzaE9wdGlvbnMgPSB7XG4gICAgICBjb2xvcjogY29sb3JPYmplY3QsXG4gICAgICBzaXplXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoYXJkbmVzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGJydXNoT3B0aW9ucy5oYXJkbmVzcyA9IGhhcmRuZXNzXG4gICAgfVxuXG4gICAgbGV0IHJhd0JydXNoID0gdGhpcy5fYnJ1c2hNYW5hZ2VyLmdldEJydXNoQnlJZGVudGlmaWVyKGlkZW50aWZpZXIpXG4gICAgaWYgKCFyYXdCcnVzaCkge1xuICAgICAgcmF3QnJ1c2ggPSB0aGlzLl9icnVzaE1hbmFnZXIuZ2V0Rmlyc3RCcnVzaCgpXG4gICAgfVxuXG4gICAgaWYgKHJhd0JydXNoLnByb3RvdHlwZSAmJiByYXdCcnVzaC5wcm90b3R5cGUgaW5zdGFuY2VvZiBCcnVzaCkge1xuICAgICAgLy8gQ3VzdG9tIEJydXNoIGluc3RhbmNlLCB1c2VkIGZvciBzcGVjaWFsIGJydXNoZXMgc3VjaCBhcyByYWRpYWwgYnJ1c2gsIHdoaWNoIGhhc1xuICAgICAgLy8gYW4gYWRkaXRpb25hbCBoYXJkbmVzcyBvcHRpb25cbiAgICAgIGNvbnN0IEJydXNoQ2xhc3MgPSByYXdCcnVzaFxuICAgICAgcmV0dXJuIG5ldyBCcnVzaENsYXNzKGJydXNoT3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgX2JydXNoID0gU0RLVXRpbHMuZXh0ZW5kKHt9LCByYXdCcnVzaClcbiAgICAgIGRlbGV0ZSBfYnJ1c2guaW1hZ2VcblxuICAgICAgY2xhc3MgQnJ1c2hDbGFzcyBleHRlbmRzIEJydXNoIHt9XG4gICAgICBCcnVzaENsYXNzLmlkZW50aWZpZXIgPSByYXdCcnVzaC5pZGVudGlmaWVyXG5cbiAgICAgIC8vIFBsYWluIEpTIG9iamVjdCwgdXNlZCBmb3Igc2ltcGxlIGltYWdlIGJydXNoZXNcbiAgICAgIHJldHVybiBuZXcgQnJ1c2hDbGFzcyhTREtVdGlscy5leHRlbmQoe30sIF9icnVzaCwgYnJ1c2hPcHRpb25zKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBmcmFtZSBzcHJpdGVcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb259XG4gICAqIEBwYXJhbSAge09iamVjdH0gZnJhbWVzcHJpdGVPcGVyYXRpb25cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXNlcmlhbGl6ZUZyYW1lIChzcHJpdGVPcGVyYXRpb24sIGZyYW1lKSB7XG4gICAgcmV0dXJuIHN1cGVyLl9kZXNlcmlhbGl6ZUZyYW1lKHNwcml0ZU9wZXJhdGlvbiwgZnJhbWUpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZyYW1lT3BlcmF0aW9uID0gdGhpcy5fZWRpdG9yLm9wZXJhdGlvbnMuZ2V0KCdmcmFtZScpXG5cbiAgICAgICAgY29uc3QgeyBzaXplLCBhbHBoYSwgdGludENvbG9yIH0gPSBmcmFtZS5vcHRpb25zXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fVxuICAgICAgICBpZiAodHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgb3B0aW9ucy5zY2FsZSA9IHNpemVcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFscGhhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIG9wdGlvbnMuYWxwaGEgPSBhbHBoYVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGludENvbG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIG9wdGlvbnMudGludENvbG9yID0gQ29sb3IuZnJvbUFycmF5KHRpbnRDb2xvci5yZ2JhKVxuICAgICAgICB9XG4gICAgICAgIGZyYW1lT3BlcmF0aW9uLnNldChvcHRpb25zKVxuICAgICAgfSlcbiAgfVxuXG4gIF9kZXNlcmlhbGl6ZVRleHREZXNpZ24gKG9wZXJhdGlvbiwgc3ByaXRlKSB7XG4gICAgY29uc3QgeyBvcHRpb25zIH0gPSBzcHJpdGVcbiAgICBjb25zdCB7IHBvc2l0aW9uLCByb3RhdGlvbiwgZmxpcEhvcml6b250YWxseSwgZmxpcFZlcnRpY2FsbHksXG4gICAgICB0ZXh0LCBjb2xvciwgd2lkdGgsIHNlZWQsIGludmVydGVkLCBpZGVudGlmaWVyIH0gPSBvcHRpb25zXG5cbiAgICBjb25zdCB0ZXh0RGVzaWduTWFuYWdlciA9IG5ldyBUZXh0RGVzaWduTWFuYWdlcih0aGlzLl91aSwgdGhpcy5fZ2V0T3B0aW9ucygndGV4dGRlc2lnbicpKVxuICAgIGNvbnN0IGZvbnRNYW5hZ2VyID0gbmV3IEZvbnRNYW5hZ2VyKHRoaXMuX3VpLCB7IGZvbnRzOiBDb25zdGFudHMuREVGQVVMVFMuVEVYVF9ERVNJR05fRk9OVFMsIHJlcGxhY2VGb250czogdHJ1ZSB9KVxuICAgIGNvbnN0IEFzc2V0TWFuYWdlciA9IG9wZXJhdGlvbi5jb25zdHJ1Y3Rvci5UZXh0RGVzaWduU3ByaXRlLkFzc2V0TWFuYWdlclxuICAgIGNvbnN0IGZvbnRMb2FkZXIgPSB0aGlzLl91aS5nZXRGb250TG9hZGVyKClcblxuICAgIGNvbnN0IExheW91dCA9IHRleHREZXNpZ25NYW5hZ2VyLmdldExheW91dEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKVxuXG4gICAgY29uc3QgbGF5b3V0ID0gbmV3IExheW91dCgpXG5cbiAgICBmb250TG9hZGVyLnNldEZvbnRzKGZvbnRNYW5hZ2VyLmdldEZvbnRzKCkpXG5cbiAgICBBc3NldE1hbmFnZXIuc2V0Rm9udHMoe1xuICAgICAgLi4uQXNzZXRNYW5hZ2VyLmdldEZvbnRzKCksXG4gICAgICAuLi5mb250TWFuYWdlci5nZXRWYXJpYXRpb25zQnlJZGVudGlmaWVyKClcbiAgICB9KVxuXG4gICAgcmV0dXJuIGZvbnRMb2FkZXJcbiAgICAgIC5sb2FkKClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3QgaW1hZ2VzID0gbGF5b3V0LmdldEltYWdlUGF0aHMoKS5tYXAocGF0aCA9PiAoeyBwYXRoLCBmdWxsUGF0aDogdGhpcy5fdWkuZ2V0QXNzZXRQYXRoKHBhdGgpLCBpbWFnZTogbnVsbCB9KSlcbiAgICAgICAgcmV0dXJuIEFzc2V0TWFuYWdlclxuICAgICAgICAgIC5sb2FkSW1hZ2VzKGltYWdlcylcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBsYXlvdXQub25JbWFnZXNMb2FkZWQoKVxuXG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uLmNyZWF0ZVRleHREZXNpZ24oe1xuICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgICAgIGZsaXBIb3Jpem9udGFsbHksXG4gICAgICAgICAgICAgIGZsaXBWZXJ0aWNhbGx5LFxuICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICBjb2xvcjogQ29sb3IuZnJvbUFycmF5KGNvbG9yLnJnYmEpLFxuICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgc2VlZCxcbiAgICAgICAgICAgICAgaW52ZXJ0ZWQsXG4gICAgICAgICAgICAgIGxheW91dFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgfSlcbiAgfVxufVxuXG52MzAwRGVzZXJpYWxpemVyLnZlcnNpb24gPSAnMy4wLjAnXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9zZXJpYWxpemF0aW9uLzMuMC4wL2Rlc2VyaWFsaXplci5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgU0RLLCBTREtVdGlscyB9IGZyb20gJ2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHREZXNpZ25NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IgKHVpLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl91aSA9IHVpXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnNcblxuICAgIHRoaXMuX2RlZmF1bHRMYXlvdXRzID0gU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uLlRleHREZXNpZ25TcHJpdGUuTGF5b3V0c1xuICAgIHRoaXMuX2xheW91dHMgPSBbXVxuICAgIHRoaXMuX2luaXQoKVxuICB9XG5cbiAgX2luaXQgKCkge1xuICAgIGNvbnN0IGF2YWlsYWJsZUxheW91dHMgPSB0aGlzLl9vcHRpb25zLmF2YWlsYWJsZUxheW91dHNcblxuICAgIHRoaXMuX2xheW91dHMgPSBPYmplY3Qua2V5cyh0aGlzLl9kZWZhdWx0TGF5b3V0cykubWFwKGsgPT4gKHtcbiAgICAgIGlkZW50aWZpZXI6IHRoaXMuX2RlZmF1bHRMYXlvdXRzW2tdLmlkZW50aWZpZXIsXG4gICAgICBsYXlvdXQ6IHRoaXMuX2RlZmF1bHRMYXlvdXRzW2tdXG4gICAgfSkpXG5cbiAgICBpZiAoYXZhaWxhYmxlTGF5b3V0cykge1xuICAgICAgdGhpcy5fbGF5b3V0cyA9IHRoaXMuX2xheW91dHMuZmlsdGVyKGl0ZW0gPT4gYXZhaWxhYmxlTGF5b3V0cy5pbmRleE9mKGl0ZW0uaWRlbnRpZmllcikgPj0gMClcbiAgICB9XG4gIH1cblxuICBnZXRMYXlvdXRCeUlkZW50aWZpZXIgKGlkZW50aWZpZXIpIHtcbiAgICBsZXQgaXRlbSA9IFNES1V0aWxzLkFycmF5LmZpbmQodGhpcy5fbGF5b3V0cywgbCA9PiBsLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpXG4gICAgcmV0dXJuIGl0ZW0gJiYgaXRlbS5sYXlvdXRcbiAgfVxuXG4gIGdldExheW91dHMgKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5fbGF5b3V0c11cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zaGFyZWQvbWFuYWdlcnMvdGV4dC1kZXNpZ24tbWFuYWdlci5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qIVxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbnJlcXVpcmUoJy4uLy4uLy4uL2Nzcy9QaG90b0VkaXRvclJlYWN0VUkuc2FzcycpXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi91aScpLmRlZmF1bHRcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2luZGV4LmpzIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvY3NzL1Bob3RvRWRpdG9yUmVhY3RVSS5zYXNzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKiBAbGljZW5zZVxuICovXG5pbXBvcnQge1xuICBTREssIFNES1V0aWxzLCBFdmVudEVtaXR0ZXIsIENvbnN0YW50cywgVXRpbHMsIFJlbmRlclR5cGUsIEJhc2VDb21wb25lbnQsXG4gIFJlYWN0LCBSZWFjdERPTSwgUmVhY3RCRU0sIFNoYXJlZFN0YXRlLCBMb2csIEJhc2U2NFxufSBmcm9tICcuL2dsb2JhbHMnXG5cbmltcG9ydCBBcHBDb21wb25lbnQgZnJvbSAnLi9jb21wb25lbnRzL2FwcC1jb21wb25lbnQnXG5pbXBvcnQgU2Nyb2xsYmFyQ29tcG9uZW50IGZyb20gJy4vY29tcG9uZW50cy9zY3JvbGxiYXItY29tcG9uZW50J1xuaW1wb3J0IENvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4vY29tcG9uZW50cy9jb250cm9scy9jb250cm9scy1jb21wb25lbnQnXG5pbXBvcnQgTW9kYWxNYW5hZ2VyIGZyb20gJy4vbGliL21vZGFsLW1hbmFnZXInXG5pbXBvcnQgSlNPTkxvYWRlciBmcm9tICdzaGFyZWQvbG9hZGVycy9qc29uLWxvYWRlcidcbmltcG9ydCBQcmVsb2FkZXIgZnJvbSAnbGliL3ByZWxvYWRlcidcbmltcG9ydCAqIGFzIFBob3RvUm9sbCBmcm9tICcuL2xpYi9waG90by1yb2xsLydcbmltcG9ydCBCYXNlQ29udHJvbHMgZnJvbSAnLi9jb21wb25lbnRzL2NvbnRyb2xzL2NvbnRyb2xzJ1xuaW1wb3J0ICogYXMgQ29udHJvbHMgZnJvbSAnLi9jb21wb25lbnRzL2NvbnRyb2xzJ1xuaW1wb3J0IFNsaWRlckNvbXBvbmVudCBmcm9tICcuL2NvbXBvbmVudHMvc2xpZGVyLWNvbXBvbmVudCdcbmltcG9ydCBTbGlkZXJPdmVybGF5Q29tcG9uZW50IGZyb20gJy4vY29tcG9uZW50cy9jb250cm9scy9zbGlkZXItb3ZlcmxheS1jb21wb25lbnQnXG5pbXBvcnQgRm9udExvYWRlciBmcm9tICcuL2xpYi9mb250LWxvYWRlcidcblxuY29uc3QgYmQgPSAoc3RyKSA9PiBTREtVdGlscy5ieXRlQXJyYXlUb1N0cmluZyhCYXNlNjQuZGVjb2RlKHN0cikpXG5cbi8qKlxuICogVGhlIFJlYWN0IFVJXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkV2ZW50RW1pdHRlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLlVJXG4gKi9cbmNsYXNzIFJlYWN0VUkgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBVSSBpbnN0YW5jZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtICB7U3RyaW5nfSBvcHRpb25zLmxpY2Vuc2UgLSBZb3VyIGxpY2Vuc2VcbiAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gb3B0aW9ucy5jb250YWluZXIgLSBUaGUgY29udGFpbmVyIHRoYXQgdGhlIFVJIHNob3VsZCBiZSByZW5kZXJlZCB0b1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtvcHRpb25zLnRpdGxlID0gJ1Bob3RvRWRpdG9yIFNESyddXG4gICAqIEBwYXJhbSAge1N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2UgPSAnZW4nXSAtIEN1cnJlbnRseSBgZW5gIGFuZCBgZGVgIGFyZSBzdXBwb3J0ZWRcbiAgICogQHBhcmFtICB7U3RyaW5nfSBbb3B0aW9ucy5sb2dMZXZlbF0gLSBgdHJhY2VgLCBgaW5mb2AsIGB3YXJuYCwgYGVycm9yYCBvciBgbG9nYFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5yZXNwb25zaXZlID0gZmFsc2VdIC0gU2hvdWxkIHRoZSBlZGl0b3IgcmUtcmVuZGVyIG9uIHdpbmRvdyByZXNpemU/XG4gICAqXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVVwbG9hZCA9IHRydWVdIC0gU2hvdWxkIHRoZSB1c2VyIGJlIGFibGUgdG8gdXBsb2FkIHRoZWlyIG93biBwaG90b3M/XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVdlYmNhbSA9IHRydWVdIC0gRW5hYmxlcyB3ZWJjYW0gc3VwcG9ydC4gRGlzYWJsZWQgb24gbW9iaWxlIGRldmljZXMuXG4gICAqXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLnNob3dDbG9zZUJ1dHRvbiA9IGZhbHNlXSAtIFNob3VsZCB0aGUgY2xvc2UgYnV0dG9uIGJlIGRpc3BsYXllZD9cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuc2hvd0hlYWRlciA9IHRydWVdIC0gU2hvdWxkIHRoZSBoZWFkZXIgKHdpdGggdGl0bGUgdGV4dCkgYmUgZGlzcGxheWVkP1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaG91bGQgb25seSBiZSBzZXQgdG8gYGZhbHNlYCBieSBsaWNlbnNlZXMuXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLnNob3dUb3BCYXIgPSB0cnVlXSAtIFNob3VsZCB0aGUgdG9wIGJhciAobmV3IC8gem9vbSAvIHVuZG8gLyBleHBvcnQpIGJlIGRpc3BsYXllZD9cbiAgICogQHBhcmFtICB7U3RyaW5nfSBbb3B0aW9ucy5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnXSAtICdhbm9ueW1vdXMnLCAndXNlLWNyZWRlbnRpYWxzJyBvciAnbm9uZSdcblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zLnBob3RvUm9sbF1cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5QaG90b1JvbGwuUHJvdmlkZXJ9IHByb3ZpZGVyIC0gVGhlIGNsYXNzIHByb3ZpZGluZyBhbGwgZGF0YVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHRoZSBwaG90byByb2xsXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnMuZWRpdG9yXVxuICAgKiBAcGFyYW0gIHtJbWFnZX0gW29wdGlvbnMuZWRpdG9yLmltYWdlXSAtIFRoZSBpbWFnZSB0aGF0IHRoZSB1c2VyIGNhbiBlZGl0XG4gICAqIEBwYXJhbSAge0ltYWdlfSBbb3B0aW9ucy5lZGl0b3Iud2F0ZXJtYXJrSW1hZ2VdIC0gQW4gaW1hZ2UgdGhhdCBzaG91bGQgYmUgcGxhY2VkIG9uIHRvcCBhcyBhIHdhdGVybWFya1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtvcHRpb25zLmVkaXRvci5wcmVmZXJyZWRSZW5kZXJlciA9ICd3ZWJnbCddIC0gYHdlYmdsYCBvciBgY2FudmFzYFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLmVkaXRvci5waXhlbFJhdGlvID0gMV0gLSBJZiBub25lIGlzIGdpdmVuLCBQaG90b0VkaXRvclNESyBhdXRvbWF0aWNhbGx5XG4gICAqICAgZGV0ZWN0cyB0aGUgY3VycmVudCBkZXZpY2UncyBwaXhlbCByYXRpb1xuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5lZGl0b3IuZW5hYmxlRHJhZyA9IHRydWVdIC0gU2hvdWxkIGRyYWdnaW5nIHRoZSBjYW52YXMgYmUgZW5hYmxlZD9cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuZWRpdG9yLmVuYWJsZVpvb20gPSB0cnVlXSAtIFNob3VsZCB6b29taW5nIGJlIGVuYWJsZWQ/XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLmVkaXRvci5zbW9vdGhEb3duc2NhbGluZyA9IGZhbHNlXSAtIFRvZ2dsZXMgc21vb3RoIGRvd25zY2FsaW5nXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLmVkaXRvci5zbW9vdGhVcHNjYWxpbmcgPSBmYWxzZV0gLSBUb2dnbGVzIHNtb290aCB1cHNjYWxpbmdcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuZWRpdG9yLmRpc3BsYXlSZXNpemVNZXNzYWdlID0gdHJ1ZV0gLSBTaG91bGQgYSBtZXNzYWdlIGJlIGRpc3BsYXllZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVuIHRoZSBpbWFnZSBoYXMgYmVlbiBzY2FsZWQgZG93blxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgcGVyZm9ybWFuY2U/XG4gICAqIEBwYXJhbSAgeyhTdHJpbmdbXXxBcnJheVtdKX0gW29wdGlvbnMuZWRpdG9yLmNvbnRyb2xzT3JkZXJdIC0gVGhlIG9yZGVyIGluIHdoaWNoIHRoZSBjb250cm9scyBhcmUgZGlzcGxheWVkLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBdmFpbGFibGUgYXJlIGB0cmFuc2Zvcm1gLCBgZmlsdGVyYCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGFkanVzdG1lbnRzYCwgYHRleHRgLCBgc3RpY2tlcmAsIGBicnVzaGAsIGBmb2N1c2AsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBmcmFtZWAuIENhbiBiZSBncm91cGVkIGluIGFycmF5cyB3aGljaCB3aWxsIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXllZCB3aXRoIHNlcGFyYXRvcnMuXG4gICAqIEBwYXJhbSAge1N0cmluZ1tdfSBbb3B0aW9ucy5lZGl0b3Iub3BlcmF0aW9uc09yZGVyXSAtIFRoZSBvcmRlciBpbiB3aGljaCBvcGVyYXRpb25zIGFyZSBhZGRlZCB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgc3RhY2suIENoYW5naW5nIHRoaXMgbWF5IGFmZmVjdCB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnMuZWRpdG9yLmNvbnRyb2xzT3B0aW9uc10gLSBPcHRpb25zIHRoYXQgYXJlIHBhc3NlZCB0byBzcGVjaWZpYyBjb250cm9scy4gU2VlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgZWFjaCBjb250cm9sIHRvIGxlYXJuIG1vcmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3V0IGF2YWlsYWJsZSB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0W119IFtvcHRpb25zLmVkaXRvci5mb3JjZUNvbnRyb2xzXSAtIEFuIGFycmF5IG9mIG9iamVjdHMgc3BlY2lmeWluZyB0aGUgY29udHJvbHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSB1c2VyIG5lZWRzIHRvIHVzZSBiZWZvcmUgYmVpbmcgYWJsZSB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlIHRoZSBhY3R1YWwgZWRpdG9yLlxuICAgKiBAcGFyYW0ge09iamVjdFtdfSBbb3B0aW9ucy5lZGl0b3IuZm9yY2VDcm9wXSAtIElmIHRydWUsIHRoZSBlZGl0b3Igd2lsbCBsYXVjaCB0byB0aGUgdHJhbnNmb3JtIHRvb2xcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgY3JvcHBpbmcsIGJlZm9yZSBhbnkgb3RoZXIgdG9vbCBpcyBhbGxvd2VkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zLmVkaXRvci5tYXhNZWdhUGl4ZWxzXSAtIE1heGltdW0gYW1vdW50IG9mIG1lZ2FwaXhlbHMgcGVyIGRldmljZSB0eXBlXG4gICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuZWRpdG9yLm1heE1lZ2FQaXhlbHMuZGVza3RvcCA9IDEwXVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLmVkaXRvci5tYXhNZWdhUGl4ZWxzLm1vYmlsZSA9IDVdXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnMuZWRpdG9yLmV4cG9ydF1cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuZWRpdG9yLmV4cG9ydC5zaG93QnV0dG9uID0gdHJ1ZV0gLSBTaG91bGQgdGhlIGBleHBvcnRgIGJ1dHRvbiBiZSBkaXNwbGF5ZWQ/XG4gICAqIEBwYXJhbSAge1N0cmluZ30gW29wdGlvbnMuZWRpdG9yLmV4cG9ydC5mb3JtYXQgPSAnaW1hZ2UvcG5nJ10gLSBUaGUgZXhwb3J0IGZvcm1hdC4gQXZhaWxhYmxlIGZvcm1hdHNcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuUmVuZGVyVHlwZX0gW29wdGlvbnMuZWRpdG9yLmV4cG9ydC50eXBlXSAtIFRoZSBleHBvcnQgdHlwZSAoaW1hZ2Ugb3IgZGF0YSB1cmwpXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLmVkaXRvci5leHBvcnQuZG93bmxvYWRdIC0gU2hvdWxkIHRoZSByZXN1bHQgYmUgcHJlc2VudGVkIGFzIGEgZG93bmxvYWQ/XG4gICAqIEBwYXJhbSAge1N0cmluZ30gW29wdGlvbnMuZWRpdG9yLmV4cG9ydC5maWxlQmFzZW5hbWUgPSAncGhvdG9lZGl0b3JzZGstZXhwb3J0J10gLSBUaGUgYmFzZW5hbWVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgZXhwb3J0ZWQgZmlsZSAoZmlsZSBleHRlbnNpb24gd2lsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGFkZGVkIGF1dG9tYXRpY2FsbHkpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5lZGl0b3IuZXhwb3J0LnF1YWxpdHkgPSAwLjhdIC0gVGhlIGV4cG9ydCBxdWFsaXR5ICgwLi4uMSwgb25seSBzdXBwb3J0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgSlBHIGltYWdlcylcbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucy5hc3NldHNdXG4gICAqIEBwYXJhbSAge1N0cmluZ30gW29wdGlvbnMuYXNzZXRzLmJhc2VVcmwgPSAnL2Fzc2V0cyddIC0gUGF0aCB0aGF0IGlzIHByZXBlbmRlZCB0byBhbGwgYXNzZXQgcGF0aHNcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtvcHRpb25zLmFzc2V0cy5yZXNvbHZlcl0gLSBBIGZ1bmN0aW9uIHJlc29sdmluZyBhIHBhdGggdG8gYW5vdGhlciBwYXRoLlxuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuX21lZGlhdG9yID0gbmV3IEV2ZW50RW1pdHRlcigpXG4gICAgdGhpcy5fZm9udExvYWRlciA9IG5ldyBGb250TG9hZGVyKHRoaXMpXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLl9pbml0T3B0aW9ucygpXG4gICAgdGhpcy5faW5pdExhbmd1YWdlKClcbiAgICB0aGlzLl9pbml0RXZlbnRzKClcbiAgICB0aGlzLl9kaXNwb3NlZCA9IGZhbHNlXG5cbiAgICB0aGlzLl9pc1JlYWR5ID0gZmFsc2VcbiAgICB0aGlzLl9tZWRpYXRvci5vbmNlKENvbnN0YW50cy5FVkVOVFMuRURJVE9SX1JFQURZLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pc1JlYWR5ID0gdHJ1ZVxuICAgIH0pXG5cbiAgICB0aGlzLl9nbG9iYWxTdGF0ZSA9IG5ldyBTaGFyZWRTdGF0ZSgpXG5cbiAgICB0aGlzLl9wcmVsb2FkZXIgPSBuZXcgUHJlbG9hZGVyKHRoaXMsIHRoaXMuX29wdGlvbnMsIHRoaXMuX21lZGlhdG9yKVxuXG4gICAgTG9nLnNldExldmVsKHRoaXMuX29wdGlvbnMubG9nTGV2ZWwpXG5cbiAgICBpZiAoIXRoaXMuX29wdGlvbnMubGljZW5zZSB8fCB0aGlzLl92KCkpIHtcbiAgICAgIHRoaXMucnVuKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFpbiBlbnRyeSBwb2ludCBmb3IgdGhlIFVJXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBydW4gKCkge1xuICAgIHRoaXMuX3JlZ2lzdGVyV2ViRm9udHMoKVxuXG4gICAgLy8gQ29udGFpbmVyIGhhcyB0byBiZSBwb3NpdGlvbjogcmVsYXRpdmVcbiAgICB0aGlzLl9vcHRpb25zLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSdcbiAgICB0aGlzLl9yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIFVJXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyICgpIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSAoPEFwcENvbXBvbmVudFxuICAgICAgdWk9e3RoaXN9XG4gICAgICBtZWRpYXRvcj17dGhpcy5fbWVkaWF0b3J9XG4gICAgICByZWY9e2MgPT4geyB0aGlzLl9jb21wb25lbnQgPSBjIH19XG4gICAgICBnbG9iYWxTdGF0ZT17dGhpcy5fZ2xvYmFsU3RhdGV9XG4gICAgICBvcHRpb25zPXt0aGlzLl9vcHRpb25zfSAvPilcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnJlbmRlclJldHVybnNDb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RET00ucmVuZGVyKGNvbXBvbmVudCwgdGhpcy5fb3B0aW9ucy5jb250YWluZXIpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9ydHMgYW4gaW1hZ2VcbiAgICogQHBhcmFtIHtCb29sZWFufSBkb3dubG9hZCA9IGZhbHNlXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBleHBvcnQgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50LmV4cG9ydCguLi5hcmdzKVxuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIGVkaXRvciBzdGF0ZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgc2VyaWFsaXplICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudC5zZXJpYWxpemUoLi4uYXJncylcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZXMgdGhlIGdpdmVuIGRhdGFcbiAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBkZXNlcmlhbGl6ZSAoZGF0YSkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnQuZGVzZXJpYWxpemUoZGF0YSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZGl0b3JcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5FZGl0b3J9XG4gICAqL1xuICBnZXRFZGl0b3IgKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnQuZ2V0RWRpdG9yKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVkaXRvciBpcyByZWFkeSBmb3IgZG9pbmcgb3BlcmF0aW9ucywgZS5nLixcbiAgICogc2VyaWFsaXppbmcsIGRlc2VyaWFsaXppbmcgYW5kIGV4cG9ydGluZy5cbiAgICpcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBpc1JlYWR5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSZWFkeVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIGEgY2FsbGJhY2sgd2hlbiB0aGUgZWRpdG9yIGlzIHJlYWR5LCBvciBpbW1lZGl0aWFsbHkgaWYgaXQncyBhbHJlYWR5XG4gICAqIGluIGEgcmVhZHkgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqL1xuICBvblJlYWR5IChjYikge1xuICAgIGlmICghdGhpcy5faXNSZWFkeSkge1xuICAgICAgdGhpcy5fbWVkaWF0b3Iub25jZShDb25zdGFudHMuRVZFTlRTLkVESVRPUl9SRUFEWSwgY2IpXG4gICAgICB0aGlzLl9pc1JlYWR5ID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBjYigpXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gSU5JVElBTElaQVRJT05cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRPcHRpb25zICgpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gU0RLVXRpbHMuZGVmYXVsdHModGhpcy5fb3B0aW9ucywge1xuICAgICAgbGFuZ3VhZ2U6ICdlbicsXG4gICAgICB0aXRsZTogJ1Bob3RvRWRpdG9yIFNESycsXG4gICAgICBsb2dMZXZlbDogJ3dhcm4nLFxuICAgICAgY3Jvc3NPcmlnaW46ICdhbm9ueW1vdXMnLFxuXG4gICAgICBwcmVsb2FkZXI6IHRydWUsXG5cbiAgICAgIGVkaXRvcjoge30sXG4gICAgICBhc3NldHM6IHt9LFxuICAgICAgcGhvdG9Sb2xsOiB7fSxcblxuICAgICAgZW5hYmxlVXBsb2FkOiB0cnVlLFxuICAgICAgZW5hYmxlV2ViY2FtOiB0cnVlLFxuXG4gICAgICBzaG93Q2xvc2VCdXR0b246IGZhbHNlLFxuICAgICAgc2hvd0hlYWRlcjogdHJ1ZSxcbiAgICAgIHNob3dUb3BCYXI6IHRydWUsXG4gICAgICByZXNwb25zaXZlOiBmYWxzZVxuICAgIH0pXG5cbiAgICB0aGlzLl9vcHRpb25zLmVkaXRvciA9IFNES1V0aWxzLmRlZmF1bHRzKHRoaXMuX29wdGlvbnMuZWRpdG9yIHx8IHt9LCB7XG4gICAgICBwaXhlbFJhdGlvOiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHx8IDEsXG4gICAgICBwcmVmZXJyZWRSZW5kZXJlcjogJ3dlYmdsJyxcbiAgICAgIGVuYWJsZVpvb206IHRydWUsXG4gICAgICBlbmFibGVEcmFnOiB0cnVlLFxuICAgICAgc21vb3RoRG93bnNjYWxpbmc6IGZhbHNlLFxuICAgICAgc21vb3RoVXBzY2FsaW5nOiBmYWxzZSxcbiAgICAgIGRpc3BsYXlSZXNpemVNZXNzYWdlOiB0cnVlLFxuICAgICAgbWF4TWVnYVBpeGVsczoge30sXG4gICAgICBmb3JjZUNvbnRyb2xzOiBbXSxcbiAgICAgIGZvcmNlQ3JvcDogZmFsc2UsXG4gICAgICB3YXRlcm1hcmtJbWFnZTogbnVsbCxcbiAgICAgIHRvb2xzOiBbXG4gICAgICAgICd0cmFuc2Zvcm0nLCAnZmlsdGVyJywgJ2JyaWdodG5lc3MnLCAnc2F0dXJhdGlvbicsICdjb250cmFzdCcsICdjbGFyaXR5JywgJ2V4cG9zdXJlJywgJ3NoYWRvd3MnLCAnaGlnaGxpZ2h0cycsICdnYW1tYScsICd3aGl0ZXMnLCAnYmxhY2tzJywgJ3RlbXBlcmF0dXJlJywgJ3RleHQnLCAnc3RpY2tlcicsICdicnVzaCcsICdyYWRpYWwtZm9jdXMnLCAnbWlycm9yZWQtZm9jdXMnLCAnZnJhbWUnXG4gICAgICBdLFxuICAgICAgY29udHJvbHNPcmRlcjogW1xuICAgICAgICAndHJhbnNmb3JtJyxcbiAgICAgICAgWydmaWx0ZXInLCAnYWRqdXN0bWVudHMnXSxcbiAgICAgICAgWyd0ZXh0JywgJ3N0aWNrZXInLCAnYnJ1c2gnXSxcbiAgICAgICAgWydzZWxlY3RpdmVCbHVyJywgJ2ZvY3VzJywgJ2ZyYW1lJ11cbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb25zT3JkZXI6IFtcbiAgICAgICAgLy8gRmlyc3QsIGFsbCBvcGVyYXRpb25zIHRoYXQgYWZmZWN0IHRoZSBpbWFnZSBkaW1lbnNpb25zXG4gICAgICAgICdleGlmLW9yaWVudGF0aW9uJywgLy8gQXV0b21hdGljYWxseSBjcmVhdGVkIGJ5IFNES1xuICAgICAgICAnb3JpZW50YXRpb24nLFxuICAgICAgICAndHJhbnNmb3JtJyxcblxuICAgICAgICAvLyBUaGVuIGNvbG9yIG9wZXJhdGlvbnMgKGZpcnN0IGZpbHRlciwgdGhlbiBmaW5lLXR1bmluZylcbiAgICAgICAgJ2ZpbHRlcicsICdhZGp1c3RtZW50cycsXG5cbiAgICAgICAgLy8gVGhlbiBwb3N0LXByb2Nlc3NpbmdcbiAgICAgICAgJ3JhZGlhbC1mb2N1cycsICdtaXJyb3JlZC1mb2N1cycsICdzZWxlY3RpdmUtYmx1cicsXG4gICAgICAgICdzcHJpdGUnLCAnZnJhbWUnLFxuICAgICAgICAnd2F0ZXJtYXJrJ1xuICAgICAgXSxcbiAgICAgIGNvbnRyb2xzT3B0aW9uczoge31cbiAgICB9KVxuXG4gICAgdGhpcy5fb3B0aW9ucy5lZGl0b3IubWF4TWVnYVBpeGVscyA9IFNES1V0aWxzLmRlZmF1bHRzKHRoaXMuX29wdGlvbnMuZWRpdG9yLm1heE1lZ2FQaXhlbHMsIHtcbiAgICAgIG1vYmlsZTogNSxcbiAgICAgIGRlc2t0b3A6IDEwXG4gICAgfSlcblxuICAgIHRoaXMuX29wdGlvbnMuZWRpdG9yLmV4cG9ydCA9IFNES1V0aWxzLmRlZmF1bHRzKHRoaXMuX29wdGlvbnMuZWRpdG9yLmV4cG9ydCB8fCB7fSwge1xuICAgICAgc2hvd0J1dHRvbjogdHJ1ZSxcbiAgICAgIGZvcm1hdDogJ2ltYWdlL3BuZycsXG4gICAgICB0eXBlOiBSZW5kZXJUeXBlLklNQUdFLFxuICAgICAgZG93bmxvYWQ6IHRydWUsXG4gICAgICBmaWxlQmFzZW5hbWU6ICdwaG90b2VkaXRvcnNkay1leHBvcnQnLFxuICAgICAgcXVhbGl0eTogMC44XG4gICAgfSlcblxuICAgIHRoaXMuX29wdGlvbnMucGhvdG9Sb2xsID0gU0RLVXRpbHMuZGVmYXVsdHModGhpcy5fb3B0aW9ucy5waG90b1JvbGwgfHwge30sIHtcbiAgICAgIHByb3ZpZGVyOiBudWxsXG4gICAgfSlcblxuICAgIHRoaXMuX29wdGlvbnMuZXh0ZW5zaW9ucyA9IFNES1V0aWxzLmRlZmF1bHRzKHRoaXMuX29wdGlvbnMuZXh0ZW5zaW9ucyB8fCB7fSwge1xuICAgICAgbGFuZ3VhZ2VzOiB7fSxcbiAgICAgIG9wZXJhdGlvbnM6IFtdLFxuICAgICAgY29udHJvbHM6IFtdXG4gICAgfSlcblxuICAgIHRoaXMuX29wdGlvbnMuYXNzZXRzID0gU0RLVXRpbHMuZGVmYXVsdHModGhpcy5fb3B0aW9ucy5hc3NldHMgfHwge30sIHtcbiAgICAgIGJhc2VVcmw6ICdhc3NldHMnLFxuICAgICAgcmVzb2x2ZXI6IG51bGxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBwcmVzZW5jZSBvZiB0aGUgQVBJIGtleVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3YgKCkge1xuICAgIGlmICghdGhpc1tiZCgnWDI5d2RHbHZibk09JyldW2JkKCdiR2xqWlc1elpRPT0nKV0pIHtcbiAgICAgIC8vIExvZy5lcnJvcignbGljZW5zZScsICdObyBgbGljZW5zZWAgb3B0aW9uIGdpdmVuLicpXG4gICAgICBMb2cuZXJyb3IoYmQoJ1RHbGpaVzV6YVc1bicpLCBiZCgnVG04Z1lHeHBZMlZ1YzJWZ0lHOXdkR2x2YmlCbmFYWmxiaTQ9JykpXG4gICAgICBMb2cuZXJyb3IoYmQoJ1RHbGpaVzV6YVc1bicpLCBiZCgnU1c0Z1kyRnpaU0I1YjNVZ1pHOXVKM1FnYUdGMlpTQmhJR3hwWTJWdWMyVWdlV1YwTENCd2JHVmhjMlVnWTI5dWRHRmpkQ0J2ZFhJZ2MyRnNaWE1nYzNSaFptWWdZWFFnYzJGc1pYTkFjR2h2ZEc5bFpHbDBiM0p6WkdzdVkyOXRJSFJ2SUc5aWRHRnBiaUJoSUd4cFkyVnVjMlVnYjNJZ2JHOW5JR2x1SUhSdklIbHZkWElnWTNWemRHOXRaWElnWkdGemFHSnZZWEprTGc9PScpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIDxzdHlsZT4gYmxvY2sgaW4gPGhlYWQ+IHRoYXQgc3BlY2lmaWVzIHRoZSB3ZWIgZm9udHNcbiAgICogdGhhdCB3ZSB1c2UgaW4gdGhpcyBVSS4gV2UncmUgZG9pbmcgdGhpcyBpbiBKUyBiZWNhdXNlIHRoZSBhc3NldHNcbiAgICogcGF0aCBpcyBkeW5hbWljLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlZ2lzdGVyV2ViRm9udHMgKCkge1xuICAgIGNvbnN0IHJlZ3VsYXJGb250UGF0aCA9IHRoaXMuZ2V0QXNzZXRQYXRoKCdmb250cy9tb250c2VycmF0LXJlZ3VsYXIud29mZicsIHRydWUsIHRydWUpXG4gICAgY29uc3QgbGlnaHRGb250UGF0aCA9IHRoaXMuZ2V0QXNzZXRQYXRoKCdmb250cy9tb250c2VycmF0LWxpZ2h0LndvZmYnLCB0cnVlLCB0cnVlKVxuXG4gICAgY29uc3QgY3NzID0gYFxuICAgICAgLy8gSW5qZWN0ZWQgYnkgUGhvdG9FZGl0b3JTREtcbiAgICAgIEBmb250LWZhY2Uge1xuICAgICAgICBmb250LWZhbWlseTogXCJfX3Blc2RrX01vbnRzZXJyYXRcIjtcbiAgICAgICAgc3JjOiB1cmwoJyR7cmVndWxhckZvbnRQYXRofScpIGZvcm1hdCgnd29mZicpO1xuICAgICAgICBmb250LXdlaWdodDogbm9ybWFsO1xuICAgICAgICBmb250LXN0eWxlOiBub3JtYWw7XG4gICAgICB9XG5cbiAgICAgIEBmb250LWZhY2Uge1xuICAgICAgICBmb250LWZhbWlseTogXCJfX3Blc2RrX01vbnRzZXJyYXRcIjtcbiAgICAgICAgc3JjOiB1cmwoJyR7bGlnaHRGb250UGF0aH0nKSBmb3JtYXQoJ3dvZmYnKTtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDEwMDtcbiAgICAgICAgZm9udC1zdHlsZTogbm9ybWFsO1xuICAgICAgfVxuICAgIGBcblxuICAgIHRoaXMuX3dlYkZvbnRzU3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gICAgdGhpcy5fd2ViRm9udHNTdHlsZS5pbm5lckhUTUwgPSBjc3NcblxuICAgIGNvbnN0IGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdXG4gICAgaGVhZC5hcHBlbmRDaGlsZCh0aGlzLl93ZWJGb250c1N0eWxlKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIENhdGNoZXMgbWVkaWF0b3IgZXZlbnRzIGFuZCBlbWl0cyB0aGVtIGhlcmVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0RXZlbnRzICgpIHtcbiAgICB0aGlzLl9tZWRpYXRvci5waXBlRXZlbnRzKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogVW5waXBlcyB0aGUgdmVudHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kaXNwb3NlRXZlbnRzICgpIHtcbiAgICB0aGlzLl9tZWRpYXRvci51bnBpcGVFdmVudHModGhpcylcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEkxOE5cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGludGVybmF0aW9uYWxpemF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdExhbmd1YWdlICgpIHtcbiAgICB0aGlzLl9sYW5ndWFnZXMgPSBTREtVdGlscy5kZWVwRGVmYXVsdHModGhpcy5fb3B0aW9ucy5leHRlbnNpb25zLmxhbmd1YWdlcywge1xuICAgICAgZGU6IHJlcXVpcmUoJy4vbGFuZy9kZS5qc29uJyksXG4gICAgICBlbjogcmVxdWlyZSgnLi9sYW5nL2VuLmpzb24nKVxuICAgIH0pXG4gICAgdGhpcy5fbGFuZ3VhZ2UgPSB0aGlzLl9sYW5ndWFnZXNbdGhpcy5fb3B0aW9ucy5sYW5ndWFnZV1cbiAgICBpZiAoIXRoaXMuX2xhbmd1YWdlKSB7XG4gICAgICBMb2cuZXJyb3IodGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCBgTGFuZ3VhZ2UgXFxgJHt0aGlzLl9vcHRpb25zLmxhbmd1YWdlfVxcYCBub3QgZm91bmQhYClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gZm9yIGBrZXlgXG4gICAqIEBwYXJhbSAge1N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSAge09iamVjdH0gW2ludGVycG9sYXRpb25PcHRpb25zXVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICB0cmFuc2xhdGUgKGtleSwgaW50ZXJwb2xhdGlvbk9wdGlvbnMpIHtcbiAgICByZXR1cm4gVXRpbHMudHJhbnNsYXRlKHRoaXMuX2xhbmd1YWdlLCBrZXksIGludGVycG9sYXRpb25PcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGltYWdlIHRvIHRoZSBnaXZlbiBvbmVcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VcbiAgICovXG4gIHNldEltYWdlIChpbWFnZSkge1xuICAgIGlmICghdGhpcy5fY29tcG9uZW50KSByZXR1cm5cbiAgICB0aGlzLl9jb21wb25lbnQuc2V0SW1hZ2UoaW1hZ2UpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x2ZWQgYXNzZXQgcGF0aCBmb3IgdGhlIGdpdmVuIGFzc2V0IG5hbWVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBhc3NldFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSB1aUFzc2V0ID0gZmFsc2VcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gZGlzYWJsZVJldGluYSA9IGZhbHNlXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldEFzc2V0UGF0aCAoYXNzZXQsIHVpQXNzZXQgPSBmYWxzZSwgZGlzYWJsZVJldGluYSA9IGZhbHNlKSB7XG4gICAgY29uc3QgeyBiYXNlVXJsLCByZXNvbHZlciB9ID0gdGhpcy5fb3B0aW9ucy5hc3NldHNcbiAgICBsZXQgcGF0aCA9IGAke2Jhc2VVcmx9LyR7YXNzZXR9YFxuXG4gICAgLy8gRG9uJ3QgcHJlcGVuZCBiYXNlVXJsIHRvIGFic29sdXRlIHVybHNcbiAgICBpZiAoYXNzZXQubWF0Y2goLyhmdHB8aHR0cHxodHRwcyk6XFwvXFwvLykpIHtcbiAgICAgIHBhdGggPSBhc3NldFxuICAgIH1cblxuICAgIGlmICh1aUFzc2V0KSB7XG4gICAgICBpZiAoIWRpc2FibGVSZXRpbmEpIHtcbiAgICAgICAgLy8gQXBwZW5kIEAyeCBpZiBkZXZpY2UncyBwaXhlbCByYXRpbyA+IDFcbiAgICAgICAgY29uc3QgcGl4ZWxSYXRpbyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgfHwgMVxuICAgICAgICBpZiAocGl4ZWxSYXRpbyA+IDEpIHtcbiAgICAgICAgICBjb25zdCByZWdleCA9IC9cXC5bXFx3Pz1dKyQvXG4gICAgICAgICAgYXNzZXQgPSBhc3NldC5yZXBsYWNlKHJlZ2V4LCAobWF0Y2gpID0+ICdAMngnICsgbWF0Y2gpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcGF0aCA9IGAke2Jhc2VVcmx9L3VpL3JlYWN0LyR7YXNzZXR9YFxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVzb2x2ZXIgIT09ICd1bmRlZmluZWQnICYmIHJlc29sdmVyICE9PSBudWxsKSB7XG4gICAgICBwYXRoID0gcmVzb2x2ZXIocGF0aClcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZvbnQgbG9hZGVyXG4gICAqIEByZXR1cm4ge0ZvbnRMb2FkZXJ9XG4gICAqL1xuICBnZXRGb250TG9hZGVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udExvYWRlclxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByZWxvYWRlclxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5QcmVsb2FkZXJ9XG4gICAqL1xuICBnZXRQcmVsb2FkZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl9wcmVsb2FkZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGUgVUlcbiAgICovXG4gIGRpc3Bvc2UgKCkge1xuICAgIGlmICh0aGlzLl9kaXNwb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGluc3RhbmNlIG9mIFBob3RvRWRpdG9yU0RLIGlzIGFscmVhZHkgZGlzcG9zZWQuJylcbiAgICB9XG4gICAgdGhpcy5fZGlzcG9zZWQgPSB0cnVlXG5cbiAgICAvLyBSZW1vdmUgd2ViIGZvbnRzIHN0eWxlXG4gICAgdGhpcy5fd2ViRm9udHNTdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX3dlYkZvbnRzU3R5bGUpXG5cbiAgICAvLyBVbm1vdW50IEFwcENvbXBvbmVudFxuICAgIFJlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUodGhpcy5fb3B0aW9ucy5jb250YWluZXIpXG5cbiAgICB0aGlzLl9kaXNwb3NlRXZlbnRzKClcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9ydCBldmVudFxuICpcbiAqIEBldmVudCBQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJI2V4cG9ydFxuICogQHR5cGUge0ltYWdlfFN0cmluZ3xCbG9ifVxuICovXG5cbi8qKlxuICogT3BlcmF0aW9uIGNyZWF0ZWQgZXZlbnRcbiAqXG4gKiBAZXZlbnQgUGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSSNvcGVyYXRpb246Y3JlYXRlZFxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbn1cbiAqL1xuXG4vKipcbiAqIE9wZXJhdGlvbiByZW1vdmVkIGV2ZW50XG4gKlxuICogQGV2ZW50IFBob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkjb3BlcmF0aW9uOnJlbW92ZWRcbiAqIEB0eXBlIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb259XG4gKi9cblxuLyoqXG4gKiBIaXN0b3J5IHVuZG8gZXZlbnRcbiAqXG4gKiBAZXZlbnQgUGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSSNoaXN0b3J5OnVuZG9cbiAqL1xuXG4vKipcbiAqIENvbnRyb2xzIHN3aXRjaGVkIGV2ZW50XG4gKlxuICogQGV2ZW50IFBob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkjY29udHJvbHM6c3dpdGNoZWRcbiAqIEB0eXBlIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xzfVxuICovXG5cbi8qKlxuICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGlzIFVJXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5SZWFjdFVJLnByb3RvdHlwZS5pZGVudGlmaWVyID0gJ3JlYWN0J1xuXG4vLyBFeHBvcnQgZXh0ZW5kYWJsZSBzdHVmZlxuUmVhY3RVSS5CYXNlQ29tcG9uZW50ID0gQmFzZUNvbXBvbmVudFxuUmVhY3RVSS5CYXNlQ29udHJvbHMgPSBCYXNlQ29udHJvbHNcblJlYWN0VUkuQ29udHJvbHNDb21wb25lbnQgPSBDb250cm9sc0NvbXBvbmVudFxuUmVhY3RVSS5SZWFjdCA9IFJlYWN0XG5SZWFjdFVJLlJlYWN0QkVNID0gUmVhY3RCRU1cblJlYWN0VUkuU2hhcmVkU3RhdGUgPSBTaGFyZWRTdGF0ZVxuUmVhY3RVSS5Db25zdGFudHMgPSBDb25zdGFudHNcblJlYWN0VUkuVXRpbHMgPSBVdGlsc1xuUmVhY3RVSS5TY3JvbGxiYXJDb21wb25lbnQgPSBTY3JvbGxiYXJDb21wb25lbnRcblJlYWN0VUkuTW9kYWxNYW5hZ2VyID0gTW9kYWxNYW5hZ2VyXG5SZWFjdFVJLkpTT05Mb2FkZXIgPSBKU09OTG9hZGVyXG5SZWFjdFVJLlBob3RvUm9sbCA9IFBob3RvUm9sbFxuUmVhY3RVSS5Db250cm9scyA9IENvbnRyb2xzXG5SZWFjdFVJLlNsaWRlckNvbXBvbmVudCA9IFNsaWRlckNvbXBvbmVudFxuUmVhY3RVSS5TbGlkZXJPdmVybGF5Q29tcG9uZW50ID0gU2xpZGVyT3ZlcmxheUNvbXBvbmVudFxuXG4vKipcbiAqIFRoZSBQaG90b0VkaXRvclNESyBVSSBjYW4gYWxzbyBiZSBpbnRlZ3JhdGVkIGFzIGEgUmVhY3QuanMgY29tcG9uZW50XG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUlcbiAqL1xuXG5jbGFzcyBSZWFjdENvbXBvbmVudCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICB0aGlzLl91aSA9IG5ldyBSZWFjdFVJKFNES1V0aWxzLmV4dGVuZCh7fSwgdGhpcy5wcm9wcywge1xuICAgICAgY29udGFpbmVyOiB0aGlzLnJlZnMuY29udGFpbmVyXG4gICAgfSkpXG5cbiAgICBpZiAodGhpcy5wcm9wcy5vbkVkaXRvclJlYWR5KSB7XG4gICAgICB0aGlzLl91aS5vblJlYWR5KHRoaXMucHJvcHMub25FZGl0b3JSZWFkeSlcbiAgICB9XG4gIH1cblxuICBnZXQgdWkgKCkge1xuICAgIHJldHVybiB0aGlzLl91aVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3QuRWxlbWVudH1cbiAgICovXG4gIHJlbmRlciAoKSB7XG4gICAgY29uc3QgY29udGFpbmVyU3R5bGUgPSBTREtVdGlscy5leHRlbmQoe30sIHRoaXMucHJvcHMuc3R5bGUgfHwge30pXG4gICAgcmV0dXJuIDxkaXYgc3R5bGU9e2NvbnRhaW5lclN0eWxlfSByZWY9J2NvbnRhaW5lcicgLz5cbiAgfVxufVxuXG5SZWFjdFVJLlJlYWN0Q29tcG9uZW50ID0gUmVhY3RDb21wb25lbnRcblxuLy8gRXh0ZW5kIFBob3RvRWRpdG9yU0RLIG9iamVjdFxuU0RLLlVJID0gU0RLLlVJIHx8IHt9XG5TREsuVUkuUmVhY3RVSSA9IFJlYWN0VUlcblxuZXhwb3J0IGRlZmF1bHQgUmVhY3RVSVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vdWkuanN4IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzYyX187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwge1wicm9vdFwiOlwiUmVhY3RET01cIixcImNvbW1vbmpzMlwiOlwicmVhY3QtZG9tXCIsXCJjb21tb25qc1wiOlwicmVhY3QtZG9tXCIsXCJhbWRcIjpcInJlYWN0LWRvbVwifVxuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAlc2AgcHJvcCBvbiBgJXNgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJyxcbiAgICAgICAgICAgICAgcHJvcEZ1bGxOYW1lLFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJXMgYXQgaW5kZXggJXMuJyxcbiAgICAgICAgICBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlciksXG4gICAgICAgICAgaVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb21cbiAgICAgIC8vIHByb3BzLlxuICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbiAgdmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaW52YXJpYW50KHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICd0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJXNgLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKTtcbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHNoaW0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICBpZiAoc2VjcmV0ID09PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgLy8gSXQgaXMgc3RpbGwgc2FmZSB3aGVuIGNhbGxlZCBmcm9tIFJlYWN0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoXG4gICAgICBmYWxzZSxcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gIH07XG4gIHNoaW0uaXNSZXF1aXJlZCA9IHNoaW07XG4gIGZ1bmN0aW9uIGdldFNoaW0oKSB7XG4gICAgcmV0dXJuIHNoaW07XG4gIH07XG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogc2hpbSxcbiAgICBib29sOiBzaGltLFxuICAgIGZ1bmM6IHNoaW0sXG4gICAgbnVtYmVyOiBzaGltLFxuICAgIG9iamVjdDogc2hpbSxcbiAgICBzdHJpbmc6IHNoaW0sXG4gICAgc3ltYm9sOiBzaGltLFxuXG4gICAgYW55OiBzaGltLFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXG4gICAgZWxlbWVudDogc2hpbSxcbiAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuICAgIG5vZGU6IHNoaW0sXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXG4gICAgb25lT2Y6IGdldFNoaW0sXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgIHNoYXBlOiBnZXRTaGltLFxuICAgIGV4YWN0OiBnZXRTaGltXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBlbXB0eUZ1bmN0aW9uO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJ1xuaW1wb3J0IFJlYWN0QkVNIGZyb20gJy4uL2xpYi9yZWFjdC1iZW0nXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VDb21wb25lbnQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgdGhpcy5fZXZlbnRzID0ge31cbiAgICB0aGlzLl9uZWVkc1N0eWxlRml4ZXMgPSBmYWxzZVxuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25TaGFyZWRTdGF0ZVVwZGF0ZScsXG4gICAgICAnZml4U3R5bGVzJ1xuICAgIClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdPUktBUk9VTkRTXG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIHdoZW5ldmVyIHN0eWxlcyBuZWVkIHRvIGJlIGZpeGVkIGJ5IHRoZSBKYXZhU2NyaXB0LlxuICAgKiBUaGlzIG5lZWRzIHRvIGJlIGRvbmUgdGhhbmtzIHRvIG9sZGVyIEludGVybmV0IEV4cGxvcmVyIGJyb3dzZXJzIHdoaWNoIGhhdmVcbiAgICogYSBidW5jaCBvZiBDU1MgYnVncy5cbiAgICovXG4gIGZpeFN0eWxlcyAoKSB7XG5cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIExJRkVDWUNMRVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICB0aGlzLl9iaW5kRXZlbnRzKClcbiAgICBpZiAodGhpcy5wcm9wcy5zaGFyZWRTdGF0ZSkge1xuICAgICAgdGhpcy5wcm9wcy5zaGFyZWRTdGF0ZS5vbigndXBkYXRlJywgdGhpcy5fb25TaGFyZWRTdGF0ZVVwZGF0ZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbmVlZHNTdHlsZUZpeGVzKSB7XG4gICAgICB0aGlzLmZpeFN0eWxlcygpXG4gICAgICBpZiAodGhpcy5jb250ZXh0Lm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5maXhTdHlsZXMpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBvbmVudCBpcyB1bm1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50ICgpIHtcbiAgICB0aGlzLl91bmJpbmRFdmVudHMoKVxuXG4gICAgaWYgKHRoaXMucHJvcHMuc2hhcmVkU3RhdGUpIHtcbiAgICAgIHRoaXMucHJvcHMuc2hhcmVkU3RhdGUub2ZmKCd1cGRhdGUnLCB0aGlzLl9vblNoYXJlZFN0YXRlVXBkYXRlKVxuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbnRleHQub3B0aW9ucy5yZXNwb25zaXZlICYmIHRoaXMuX25lZWRzU3R5bGVGaXhlcykge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuZml4U3R5bGVzKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGlzIGFib3V0IHRvIHJlY2VpdmUgbmV3IHByb3BlcnRpZXNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBuZXh0UHJvcHNcbiAgICovXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKG5leHRQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMuc2hhcmVkU3RhdGUpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLnNoYXJlZFN0YXRlKSB7XG4gICAgICAgIHRoaXMucHJvcHMuc2hhcmVkU3RhdGUub2ZmKCd1cGRhdGUnLCB0aGlzLl9vblNoYXJlZFN0YXRlVXBkYXRlKVxuICAgICAgfVxuICAgICAgbmV4dFByb3BzLnNoYXJlZFN0YXRlLm9uKCd1cGRhdGUnLCB0aGlzLl9vblNoYXJlZFN0YXRlVXBkYXRlKVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEhFTFBFUiBGVU5DVElPTlNcblxuICAvKipcbiAgICogQmluZHMgdGhlIGluc3RhbmNlIG1ldGhvZHMgd2l0aCB0aGUgZ2l2ZW4gbmFtZXNcbiAgICogdG8gdGhlIGNsYXNzIGNvbnRleHRcbiAgICogQHBhcmFtICB7QXJyYXkuPFN0cmluZz59IC4uLmZuTmFtZXNcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2JpbmRBbGwgKC4uLmZuTmFtZXMpIHtcbiAgICBmbk5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdGhpc1tuYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYF9iaW5kQWxsOiAke3RoaXMuY29uc3RydWN0b3IubmFtZX0uJHtuYW1lfSBpcyBub3QgYSBmdW5jdGlvbi5gKVxuICAgICAgfVxuICAgICAgdGhpc1tuYW1lXSA9IHRoaXNbbmFtZV0uYmluZCh0aGlzKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gZm9yIGBrZXlgXG4gICAqIEBwYXJhbSAge1N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSAge09iamVjdH0gW2ludGVycG9sYXRpb25PcHRpb25zXVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBfdCAoa2V5LCBpbnRlcnBvbGF0aW9uT3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQudWkudHJhbnNsYXRlKGtleSwgaW50ZXJwb2xhdGlvbk9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogQSBoZWxwZXIgbWV0aG9kIGZvciBVSS5oZWxwZXJzLmFzc2V0UGF0aFxuICAgKiBAcGFyYW0gez99IC4uLmFyZ3NcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2dldEFzc2V0UGF0aCAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQudWkuZ2V0QXNzZXRQYXRoKC4uLmFyZ3MpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBTSEFSRUQgU1RBVEVcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgc2hhcmVkIHN0YXRlIGRpZCBjaGFuZ2VcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvbGRTdGF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG5ld1N0YXRlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25TaGFyZWRTdGF0ZVVwZGF0ZSAob2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gICAgdGhpcy5zaGFyZWRTdGF0ZURpZENoYW5nZShuZXdTdGF0ZSlcblxuICAgIGlmICh0aGlzLnNob3VsZFNoYXJlZENvbXBvbmVudFVwZGF0ZShvbGRTdGF0ZSwgbmV3U3RhdGUpKSB7XG4gICAgICB0aGlzLmZvcmNlVXBkYXRlKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIGNoYW5nZSBmcm9tIHRoZSBnaXZlbiBzdGF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9sZFN0YXRlXG4gICAqIEBwYXJhbSAge09iamVjdH0gbmV3U3RhdGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHNob3VsZFNoYXJlZENvbXBvbmVudFVwZGF0ZSAob2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBzaGFyZWQgc3RhdGUgZGlkIGNoYW5nZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbmV3U3RhdGVcbiAgICovXG4gIHNoYXJlZFN0YXRlRGlkQ2hhbmdlIChuZXdTdGF0ZSkge1xuXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZ2l2ZW4gc3RhdGUgb24gdGhlIHNoYXJlZCBzdGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAgICogQHBhcmFtIHtCb29sZWFufSB1cGRhdGVcbiAgICovXG4gIHNldFNoYXJlZFN0YXRlIChzdGF0ZSwgdXBkYXRlKSB7XG4gICAgdGhpcy5wcm9wcy5zaGFyZWRTdGF0ZS5zZXQoc3RhdGUsIHVwZGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzaGFyZWQgc3RhdGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZ2V0U2hhcmVkU3RhdGUgKHByb3ApIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5zaGFyZWRTdGF0ZS5nZXQocHJvcClcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlIG9mIHRoZSBzaGFyZWQgc3RhdGVcbiAgICovXG4gIGZvcmNlU2hhcmVkVXBkYXRlICgpIHtcbiAgICB0aGlzLnByb3BzLnNoYXJlZFN0YXRlLmJyb2FkY2FzdFVwZGF0ZSgpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVCBIQU5ETElOR1xuXG4gIC8qKlxuICAgKiBCaW5kcyB0aGUgZXZlbnRzIGluIF9ldmVudHNcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2JpbmRFdmVudHMgKCkge1xuICAgIGZvciAobGV0IGV2ZW50TmFtZSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbZXZlbnROYW1lXVxuICAgICAgdGhpcy5jb250ZXh0Lm1lZGlhdG9yLm9uKGV2ZW50TmFtZSwgaGFuZGxlcilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVW5iaW5kcyB0aGUgZXZlbnRzIGluIF9ldmVudHNcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3VuYmluZEV2ZW50cyAoKSB7XG4gICAgZm9yIChsZXQgZXZlbnROYW1lIGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1tldmVudE5hbWVdXG4gICAgICB0aGlzLmNvbnRleHQubWVkaWF0b3Iub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgYW4gZXZlbnQgd2l0aCB0aGUgZ2l2ZW4gZXZlbnQgbmFtZSBhbmQgYXJndW1lbnRzIHRocm91Z2hcbiAgICogdGhlIG1lZGlhdG9yXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSAge0FycmF5LjwqPn0gLi4uYXJnc1xuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfZW1pdEV2ZW50IChldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICB0aGlzLmNvbnRleHQubWVkaWF0b3IuZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGVsZW1lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uZWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIHJldHVybiBSZWFjdEJFTS5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhlIFJlYWN0QkVNLmVsZW1lbnQgcmV0dXJuZWQgYnkgYHJlbmRlcldpdGhCRU1gIGludG9cbiAgICogUmVhY3QuRWxlbWVudCBvYmplY3RzIHdpdGggcHJvcGVyIGNsYXNzIG5hbWVzXG4gICAqIEByZXR1cm4ge1JlYWN0LkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXIgKCkge1xuICAgIHJldHVybiBSZWFjdEJFTS50cmFuc2Zvcm0odGhpcy5yZW5kZXJXaXRoQkVNKCkpXG4gIH1cbn1cblxuQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSB7XG4gIGVkaXRvcjogUHJvcFR5cGVzLm9iamVjdCxcbiAgdWk6IFByb3BUeXBlcy5vYmplY3QsXG4gIG9wdGlvbnM6IFByb3BUeXBlcy5vYmplY3QsXG4gIG1lZGlhdG9yOiBQcm9wVHlwZXMub2JqZWN0LFxuICBlZGl0b3JTY3JlZW46IFByb3BUeXBlcy5vYmplY3QsXG4gIGdsb2JhbFN0YXRlOiBQcm9wVHlwZXMub2JqZWN0XG59XG5cbkJhc2VDb21wb25lbnQucHJvcFR5cGVzID0ge1xuICBzaGFyZWRTdGF0ZTogUHJvcFR5cGVzLmFueVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9iYXNlLWNvbXBvbmVudC5qc3giLCIvKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBQaG90b0VkaXRvclNESyBmcm9tICdwaG90b2VkaXRvcnNkaydcbmltcG9ydCBMb2cgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xvZydcbmltcG9ydCBCcm93c2VyIGZyb20gJy4vdXRpbHMvYnJvd3NlcidcbmltcG9ydCBKU09OTG9hZGVyIGZyb20gJy4uLy4uLy4uL3NoYXJlZC9sb2FkZXJzL2pzb24tbG9hZGVyJ1xuY29uc3QgeyBVdGlsczogU0RLVXRpbHMgfSA9IFBob3RvRWRpdG9yU0RLXG5jb25zdCB7IFZlY3RvcjIgfSA9IFBob3RvRWRpdG9yU0RLLk1hdGhcblxuY29uc3QgVUlVdGlscyA9IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGlubmVyIGRpbWVuc2lvbnMgKHNpemUgLSBwYWRkaW5nKSBvZiB0aGUgZ2l2ZW5cbiAgICogRE9NIGVsZW1lbnRcbiAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgKi9cbiAgZ2V0SW5uZXJEaW1lbnNpb25zRm9yRWxlbWVudCAoZWxlbWVudCkge1xuICAgIGxldCBzaXplID0gbmV3IFZlY3RvcjIoZWxlbWVudC5vZmZzZXRXaWR0aCwgZWxlbWVudC5vZmZzZXRIZWlnaHQpXG4gICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpXG4gICAgc2l6ZS54IC09IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy1sZWZ0JyksIDEwKVxuICAgIHNpemUueCAtPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3BhZGRpbmctcmlnaHQnKSwgMTApXG4gICAgc2l6ZS55IC09IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy10b3AnKSwgMTApXG4gICAgc2l6ZS55IC09IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy1ib3R0b20nKSwgMTApXG4gICAgcmV0dXJuIHNpemVcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgeCBhbmQgeSBwb3NpdGlvbiBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAqL1xuICBnZXRFdmVudFBvc2l0aW9uIChlKSB7XG4gICAgbGV0IHggPSBlLmNsaWVudFhcbiAgICBsZXQgeSA9IGUuY2xpZW50WVxuICAgIGlmIChlLnR5cGUuaW5kZXhPZigndG91Y2gnKSAhPT0gLTEpIHtcbiAgICAgIGlmICghZS50b3VjaGVzLmxlbmd0aCkgcmV0dXJuXG5cbiAgICAgIHggPSBlLnRvdWNoZXNbMF0uY2xpZW50WFxuICAgICAgeSA9IGUudG91Y2hlc1swXS5jbGllbnRZXG4gICAgfVxuICAgIHJldHVybiBuZXcgVmVjdG9yMih4LCB5KVxuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2FudmFzIHdpdGggYSB0cmFuc3BhcmVuY3kgcGF0dGVyblxuICAgKiBAcmV0dXJuIHtDYW52YXN9XG4gICAqL1xuICBjcmVhdGVUcmFuc3BhcmVudFBhdHRlcm5DYW52YXMgKCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG5cbiAgICBjYW52YXMud2lkdGggPSAxMFxuICAgIGNhbnZhcy5oZWlnaHQgPSAxMFxuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAnd2hpdGUnXG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAnI2NjY2NjYydcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCAvIDIsIGNhbnZhcy5oZWlnaHQgLyAyKVxuICAgIGNvbnRleHQuZmlsbFJlY3QoXG4gICAgICBjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMixcbiAgICAgIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodFxuICAgIClcblxuICAgIHJldHVybiBjYW52YXNcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIGNhbnZhcy5tc1RvQmxvYlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc3VwcG9ydHNNU0Jsb2IgKCkge1xuICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgIHJldHVybiB0eXBlb2YgY2FudmFzLm1zVG9CbG9iICE9PSAndW5kZWZpbmVkJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGVzIHRoZSBnaXZlbiBrZXkgdXNpbmcgdGhlIGdpdmVuIG9wdGlvbnNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwaHJhc2VzXG4gICAqIEBwYXJhbSAge1N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSAge09iamVjdH0gaW50ZXJwb2xhdGlvbk9wdGlvbnMgPSB7fVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICB0cmFuc2xhdGUgKHBocmFzZXMsIGtleSwgaW50ZXJwb2xhdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIGxldCByZXNwb25zZSA9IHRoaXMuZmV0Y2gocGhyYXNlcywga2V5KVxuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIExvZy5pbmZvKCdVdGlscyN0cmFuc2xhdGUnLCBgVW5hYmxlIHRvIHRyYW5zbGF0ZSBcXGAke2tleX1cXGBgKVxuXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFJlbW92ZSB0aGlzIHBhcnQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiB1cGRhdGVcbiAgICAgIGNvbnN0IG5ld1RvT2xkTG9jYWxpemF0aW9uS2V5TWFwID0gcmVxdWlyZSgnLi9uZXctdG8tb2xkLWxvY2FsaXphdGlvbi1rZXktbWFwLmpzb24nKVxuICAgICAgY29uc3Qgb2xkS2V5ID0gbmV3VG9PbGRMb2NhbGl6YXRpb25LZXlNYXBba2V5XVxuICAgICAgaWYgKG9sZEtleSAhPSBudWxsKSB7XG4gICAgICAgIExvZy53YXJuKCdVdGlscyN0cmFuc2xhdGUnLCBgVHJ5aW5nIHRvIGZpbmQgbG9jYWxpemVkIHN0cmluZyBmb3Igb2xkIGtleTogXFxgJHtvbGRLZXl9XFxgLiBQbGVhc2UgdXBkYXRlIHlvdXIgbG9jYWxpemF0aW9uIHRvIHVzZSB0aGUgbmV3IGtleSBhcyBzb29uIGFzIHBvc3NpYmxlLiBTdXBwb3J0IGZvciB0aGUgb2xkLCBkZXByZWNhdGVkIGtleSB3aWxsIGJlIGRyb3BwZWQgd2l0aCB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIHVwZGF0ZS5gKVxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGUocGhyYXNlcywgb2xkS2V5LCBpbnRlcnBvbGF0aW9uT3B0aW9ucylcbiAgICAgIH1cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gaW50ZXJwb2xhdGlvbk9wdGlvbnMpIHtcbiAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2UucmVwbGFjZShgXFwkeyR7a2V5fX1gLCBpbnRlcnBvbGF0aW9uT3B0aW9uc1trZXldKVxuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgcHJvcGVydHkgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgXG4gICAqIEBwYXJhbSAge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSAge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0gIHs/fSBbZGVmYXVsdFZhbHVlXVxuICAgKiBAcmV0dXJuIHs/fVxuICAgKi9cbiAgZmV0Y2ggKG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgLy8gUmVwbGFjZSBpbmRleGVzIHdpdGggcHJvcGVydHkgYWNjZXNzb3JzXG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFxbKFxcdyspXS9nLCAnLiQxJylcbiAgICAvLyBTdHJpcCBsZWFkaW5nIGRvdCAod2hlbiBwYXRoIGJlZ2lucyB3aXRoIFswXSBmb3IgZXhhbXBsZSlcbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eXFwuLywgJycpXG5cbiAgICBjb25zdCBwYXRoU2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJylcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhTZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2VnbWVudCA9IHBhdGhTZWdtZW50c1tpXVxuICAgICAgb2JqZWN0ID0gb2JqZWN0W3NlZ21lbnRdXG4gICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdFxuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBhZ2VudCByZXByZXNlbnRzIGEgbW9iaWxlIGRldmljZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNNb2JpbGUgKCkge1xuICAgIGNvbnN0IGEgPSBuYXZpZ2F0b3IudXNlckFnZW50IHx8IG5hdmlnYXRvci52ZW5kb3IgfHwgd2luZG93Lm9wZXJhXG4gICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICByZXR1cm4gKC8oYW5kcm9pZHxiYlxcZCt8bWVlZ28pLittb2JpbGV8YXZhbnRnb3xiYWRhXFwvfGJsYWNrYmVycnl8YmxhemVyfGNvbXBhbHxlbGFpbmV8ZmVubmVjfGhpcHRvcHxpZW1vYmlsZXxpcChob25lfG9kKXxpcmlzfGtpbmRsZXxsZ2UgfG1hZW1vfG1pZHB8bW1wfG1vYmlsZS4rZmlyZWZveHxuZXRmcm9udHxvcGVyYSBtKG9ifGluKWl8cGFsbSggb3MpP3xwaG9uZXxwKGl4aXxyZSlcXC98cGx1Y2tlcnxwb2NrZXR8cHNwfHNlcmllcyg0fDYpMHxzeW1iaWFufHRyZW98dXBcXC4oYnJvd3NlcnxsaW5rKXx2b2RhZm9uZXx3YXB8d2luZG93cyBjZXx4ZGF8eGlpbm8vaS50ZXN0KGEpfHwvMTIwN3w2MzEwfDY1OTB8M2dzb3w0dGhwfDUwWzEtNl1pfDc3MHN8ODAyc3xhIHdhfGFiYWN8YWMoZXJ8b298c1xcLSl8YWkoa298cm4pfGFsKGF2fGNhfGNvKXxhbW9pfGFuKGV4fG55fHl3KXxhcHR1fGFyKGNofGdvKXxhcyh0ZXx1cyl8YXR0d3xhdShkaXxcXC1tfHIgfHMgKXxhdmFufGJlKGNrfGxsfG5xKXxiaShsYnxyZCl8YmwoYWN8YXopfGJyKGV8dil3fGJ1bWJ8YndcXC0obnx1KXxjNTVcXC98Y2FwaXxjY3dhfGNkbVxcLXxjZWxsfGNodG18Y2xkY3xjbWRcXC18Y28obXB8bmQpfGNyYXd8ZGEoaXR8bGx8bmcpfGRidGV8ZGNcXC1zfGRldml8ZGljYXxkbW9ifGRvKGN8cClvfGRzKDEyfFxcLWQpfGVsKDQ5fGFpKXxlbShsMnx1bCl8ZXIoaWN8azApfGVzbDh8ZXooWzQtN10wfG9zfHdhfHplKXxmZXRjfGZseShcXC18Xyl8ZzEgdXxnNTYwfGdlbmV8Z2ZcXC01fGdcXC1tb3xnbyhcXC53fG9kKXxncihhZHx1bil8aGFpZXxoY2l0fGhkXFwtKG18cHx0KXxoZWlcXC18aGkocHR8dGEpfGhwKCBpfGlwKXxoc1xcLWN8aHQoYyhcXC18IHxffGF8Z3xwfHN8dCl8dHApfGh1KGF3fHRjKXxpXFwtKDIwfGdvfG1hKXxpMjMwfGlhYyggfFxcLXxcXC8pfGlicm98aWRlYXxpZzAxfGlrb218aW0xa3xpbm5vfGlwYXF8aXJpc3xqYSh0fHYpYXxqYnJvfGplbXV8amlnc3xrZGRpfGtlaml8a2d0KCB8XFwvKXxrbG9ufGtwdCB8a3djXFwtfGt5byhjfGspfGxlKG5vfHhpKXxsZyggZ3xcXC8oa3xsfHUpfDUwfDU0fFxcLVthLXddKXxsaWJ3fGx5bnh8bTFcXC13fG0zZ2F8bTUwXFwvfG1hKHRlfHVpfHhvKXxtYygwMXwyMXxjYSl8bVxcLWNyfG1lKHJjfHJpKXxtaShvOHxvYXx0cyl8bW1lZnxtbygwMXwwMnxiaXxkZXxkb3x0KFxcLXwgfG98dil8enopfG10KDUwfHAxfHYgKXxtd2JwfG15d2F8bjEwWzAtMl18bjIwWzItM118bjMwKDB8Mil8bjUwKDB8Mnw1KXxuNygwKDB8MSl8MTApfG5lKChjfG0pXFwtfG9ufHRmfHdmfHdnfHd0KXxub2soNnxpKXxuenBofG8yaW18b3AodGl8d3YpfG9yYW58b3dnMXxwODAwfHBhbihhfGR8dCl8cGR4Z3xwZygxM3xcXC0oWzEtOF18YykpfHBoaWx8cGlyZXxwbChheXx1Yyl8cG5cXC0yfHBvKGNrfHJ0fHNlKXxwcm94fHBzaW98cHRcXC1nfHFhXFwtYXxxYygwN3wxMnwyMXwzMnw2MHxcXC1bMi03XXxpXFwtKXxxdGVrfHIzODB8cjYwMHxyYWtzfHJpbTl8cm8odmV8em8pfHM1NVxcL3xzYShnZXxtYXxtbXxtc3xueXx2YSl8c2MoMDF8aFxcLXxvb3xwXFwtKXxzZGtcXC98c2UoYyhcXC18MHwxKXw0N3xtY3xuZHxyaSl8c2doXFwtfHNoYXJ8c2llKFxcLXxtKXxza1xcLTB8c2woNDV8aWQpfHNtKGFsfGFyfGIzfGl0fHQ1KXxzbyhmdHxueSl8c3AoMDF8aFxcLXx2XFwtfHYgKXxzeSgwMXxtYil8dDIoMTh8NTApfHQ2KDAwfDEwfDE4KXx0YShndHxsayl8dGNsXFwtfHRkZ1xcLXx0ZWwoaXxtKXx0aW1cXC18dFxcLW1vfHRvKHBsfHNoKXx0cyg3MHxtXFwtfG0zfG01KXx0eFxcLTl8dXAoXFwuYnxnMXxzaSl8dXRzdHx2NDAwfHY3NTB8dmVyaXx2aShyZ3x0ZSl8dmsoNDB8NVswLTNdfFxcLXYpfHZtNDB8dm9kYXx2dWxjfHZ4KDUyfDUzfDYwfDYxfDcwfDgwfDgxfDgzfDg1fDk4KXx3M2MoXFwtfCApfHdlYmN8d2hpdHx3aShnIHxuY3xudyl8d21sYnx3b251fHg3MDB8eWFzXFwtfHlvdXJ8emV0b3x6dGVcXC0vaS50ZXN0KGEuc3Vic3RyKDAsIDQpKSlcbiAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBkZXZpY2Ugc3VwcG9ydHMgdG91Y2ggZXZlbnRzXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIGlzVG91Y2hEZXZpY2UgKCkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW1peGVkLW9wZXJhdG9ycyAqL1xuICAgIHJldHVybiAhISgoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKVxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbWl4ZWQtb3BlcmF0b3JzICovXG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgdGhlIGBzZWxlY3RlZEl0ZW1zYCBmcm9tIGBpdGVtc2AuIGBzZWxlY3RvcmAgaXMgY2FsbGVkIGZvciBldmVyeSBpdGVtLCByZXR1cm4gdmFsdWVcbiAgICogaXMgbWF0Y2hlZCBhZ2FpbnN0IGBzZWxlY3RlZEl0ZW1zYFxuICAgKiBAcGFyYW0gIHtBcnJheX0gaXRlbXNcbiAgICogQHBhcmFtICB7QXJyYXl9IHNlbGVjdGVkSXRlbXNcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtzZWxlY3RvciA9IG51bGxdXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc2VsZWN0IChpdGVtcywgc2VsZWN0ZWRJdGVtcywgc2VsZWN0b3IgPSBudWxsKSB7XG4gICAgaWYgKCFzZWxlY3Rvcikgc2VsZWN0b3IgPSAoaSkgPT4gaVxuXG4gICAgY29uc3QgbmV3SXRlbXMgPSBbXVxuICAgIHNlbGVjdGVkSXRlbXMuZm9yRWFjaCgoc2VsZWN0ZWRJdGVtKSA9PiB7XG4gICAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW1JZGVudGlmaWVyID0gc2VsZWN0b3IoaXRlbSlcbiAgICAgICAgaWYgKGl0ZW1JZGVudGlmaWVyID09PSBzZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgICBuZXdJdGVtcy5wdXNoKGl0ZW0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgICByZXR1cm4gbmV3SXRlbXNcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgZ2l2ZW4gVVJMIHVzaW5nIEpTT04oUClcbiAgICogQHBhcmFtICB7U3RyaW5nfSB1cmxcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIGdldEpTT05QICh1cmwpIHtcbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgSlNPTkxvYWRlcih1cmwpXG4gICAgcmV0dXJuIGxvYWRlci5sb2FkKClcbiAgfSxcblxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBnaXZlbiBgY2F0ZWdvcmllc2AgYXJyYXlcbiAgICogQHBhcmFtICB7T2JqZWN0W119IGNhdGVnb3JpZXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGl0ZW1zUHJvcGVydHlcbiAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAqL1xuICBjbG9uZUNhdGVnb3JpZXMgKGNhdGVnb3JpZXMsIGl0ZW1zUHJvcGVydHkpIHtcbiAgICByZXR1cm4gY2F0ZWdvcmllcy5tYXAoY2F0ZWdvcnkgPT4ge1xuICAgICAgY2F0ZWdvcnkgPSBTREtVdGlscy5jbG9uZShjYXRlZ29yeSlcbiAgICAgIGNhdGVnb3J5W2l0ZW1zUHJvcGVydHldID0gY2F0ZWdvcnlbaXRlbXNQcm9wZXJ0eV0uc2xpY2UoMClcbiAgICAgIHJldHVybiBjYXRlZ29yeVxuICAgIH0pXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1lcmdlcyB0aGUgZ2l2ZW4gYG5ld0NhdGVnb3JpZXNgIGludG8gdGhlIGdpdmVuIGBjYXRlZ29yaWVzYFxuICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gY2F0ZWdvcmllc1xuICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gbmV3Q2F0ZWdvcmllc1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGl0ZW1zUHJvcGVydHlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG1lcmdlQ2F0ZWdvcmllcyAoY2F0ZWdvcmllcywgbmV3Q2F0ZWdvcmllcywgaXRlbXNQcm9wZXJ0eSkge1xuICAgIGNhdGVnb3JpZXMgPSB0aGlzLmNsb25lQ2F0ZWdvcmllcyhjYXRlZ29yaWVzLCBpdGVtc1Byb3BlcnR5KVxuXG4gICAgbGV0IGV4aXN0aW5nQ2F0ZWdvcnkgPSBudWxsXG4gICAgbmV3Q2F0ZWdvcmllcy5mb3JFYWNoKChuZXdDYXRlZ29yeSkgPT4ge1xuICAgICAgY2F0ZWdvcmllcy5mb3JFYWNoKChjYXRlZ29yeSkgPT4ge1xuICAgICAgICBpZiAobmV3Q2F0ZWdvcnkuaWRlbnRpZmllciA9PT0gY2F0ZWdvcnkuaWRlbnRpZmllcikge1xuICAgICAgICAgIGV4aXN0aW5nQ2F0ZWdvcnkgPSBjYXRlZ29yeVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBpZiAoIWV4aXN0aW5nQ2F0ZWdvcnkpIHtcbiAgICAgICAgY2F0ZWdvcmllcy5wdXNoKG5ld0NhdGVnb3J5KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmdDYXRlZ29yeVtpdGVtc1Byb3BlcnR5XSA9IGV4aXN0aW5nQ2F0ZWdvcnlbaXRlbXNQcm9wZXJ0eV1cbiAgICAgICAgICAuY29uY2F0KG5ld0NhdGVnb3J5W2l0ZW1zUHJvcGVydHldKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gY2F0ZWdvcmllc1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY2FtZWxpemVkIHN0eWxlIG9iamVjdCBmb3IgdGhlIGdpdmVuIERPTUVsZW1lbnRcbiAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gZWxcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0U3R5bGVPYmplY3QgKGVsKSB7XG4gICAgY29uc3Qgc3R5bGVQcm9wZXJ0aWVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpXG4gICAgbGV0IHN0eWxlT2JqZWN0ID0ge31cbiAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiBzdHlsZVByb3BlcnRpZXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVQcm9wZXJ0aWVzLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpXG4gICAgICBjb25zdCBjYW1lbGl6ZWRBdHRyID0gcHJvcGVydHkucmVwbGFjZSgvLShbYS16XSkvZywgKGEsIGIpID0+IGIudG9VcHBlckNhc2UoKSlcbiAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgc3R5bGVPYmplY3RbY2FtZWxpemVkQXR0cl0gPSB2YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3R5bGVPYmplY3RcbiAgfSxcblxuICAvKipcbiAgICogRGVib3VuY2VzIHRoZSBnaXZlbiBmdW5jdGlvbiB0byB0cmlnZ2VyIG9ubHkgZXZlcnkgc28gb2Z0ZW5cbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gICAqIEBwYXJhbSAge051bWJlcn0gICB3YWl0XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59XG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cbiAgZGVib3VuY2UgKGZuLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dFxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBhcmdzID0gYXJndW1lbnRzXG4gICAgICB2YXIgbGF0ZXIgPSAoKSA9PiB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsXG4gICAgICAgIGlmICghaW1tZWRpYXRlKSBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgfVxuICAgICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXRcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpXG4gICAgICBpZiAoY2FsbE5vdykgZm4uYXBwbHkodGhpcywgYXJncylcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBuYXRpdmUgc2Nyb2xsYmFyIHdpZHRoIGZvciB0aGUgY3VycmVudCBicm93c2VyXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldFNjcm9sbGJhcldpZHRoICgpIHtcbiAgICBjb25zdCBvdXRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgb3V0ZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nXG4gICAgb3V0ZXIuc3R5bGUud2lkdGggPSAnMTAwcHgnXG4gICAgb3V0ZXIuc3R5bGUubXNPdmVyZmxvd1N0eWxlID0gJ3Njcm9sbGJhcidcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG91dGVyKVxuXG4gICAgY29uc3Qgd2lkdGhOb1Njcm9sbCA9IG91dGVyLm9mZnNldFdpZHRoXG4gICAgb3V0ZXIuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJ1xuXG4gICAgY29uc3QgaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIGlubmVyLnN0eWxlLndpZHRoID0gJzEwMCUnXG4gICAgb3V0ZXIuYXBwZW5kQ2hpbGQoaW5uZXIpXG5cbiAgICBjb25zdCB3aWR0aFdpdGhTY3JvbGwgPSBpbm5lci5vZmZzZXRXaWR0aFxuICAgIG91dGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob3V0ZXIpXG5cbiAgICByZXR1cm4gd2lkdGhOb1Njcm9sbCAtIHdpZHRoV2l0aFNjcm9sbFxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnaXZlbiBzdHJpbmcgd2l0aCB0aGUgZmlyc3QgY2hhcmFjdGVyIHVwcGVyY2FzZWRcbiAgICogQHBhcmFtICB7U3RyaW5nfSBzdHJcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgY2FwaXRhbGl6ZSAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxuICB9LFxuXG4gIEJyb3dzZXJcbn1cblxuZXhwb3J0IGRlZmF1bHQgVUlVdGlsc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL3V0aWxzLmpzIiwiLyogZ2xvYmFsIEhUTUxFbGVtZW50LCBXRUJQQUNLICovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBCYXNlNjQgZnJvbSAnLi9iYXNlNjQnXG5pbXBvcnQgQXJyYXlVdGlscyBmcm9tICcuL2FycmF5LXV0aWxzJ1xuLyoqXG4gKiBQcm92aWRlcyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgaW50ZXJuYWwgdXNlXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNES1xuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgVXRpbHMge1xuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYW4gQXJyYXlcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgb2JqZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNBcnJheSAob2JqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBBcnJheV0nXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gb2JqZWN0IGlzIGEgcGxhaW4gb2JqZWN0IChpLmUuLCBhIGxpdGVyYWwgb2JqZWN0KSBvciBub3QuXG4gICAqIEBwYXJhbSB7YW55fSBvYmplY3RcbiAgICogQHJldHVybnMgQm9vbGVhblxuICAgKi9cbiAgc3RhdGljIGlzUGxhaW5PYmplY3QgKG9iamVjdCkge1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0JyB8fCAhb2JqZWN0KSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRQcm90b3R5cGVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbGV0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdClcbiAgICAgIHJldHVybiBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBwcm90byA9PT0gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBhZ2VudCByZXByZXNlbnRzIGEgbW9iaWxlIGRldmljZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzTW9iaWxlICgpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZVxuXG4gICAgY29uc3QgYSA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgbmF2aWdhdG9yLnZlbmRvciB8fCB3aW5kb3cub3BlcmFcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgIHJldHVybiAoLyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2R8YWQpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWluby9pLnRlc3QoYSl8fC8xMjA3fDYzMTB8NjU5MHwzZ3NvfDR0aHB8NTBbMS02XWl8Nzcwc3w4MDJzfGEgd2F8YWJhY3xhYyhlcnxvb3xzXFwtKXxhaShrb3xybil8YWwoYXZ8Y2F8Y28pfGFtb2l8YW4oZXh8bnl8eXcpfGFwdHV8YXIoY2h8Z28pfGFzKHRlfHVzKXxhdHR3fGF1KGRpfFxcLW18ciB8cyApfGF2YW58YmUoY2t8bGx8bnEpfGJpKGxifHJkKXxibChhY3xheil8YnIoZXx2KXd8YnVtYnxid1xcLShufHUpfGM1NVxcL3xjYXBpfGNjd2F8Y2RtXFwtfGNlbGx8Y2h0bXxjbGRjfGNtZFxcLXxjbyhtcHxuZCl8Y3Jhd3xkYShpdHxsbHxuZyl8ZGJ0ZXxkY1xcLXN8ZGV2aXxkaWNhfGRtb2J8ZG8oY3xwKW98ZHMoMTJ8XFwtZCl8ZWwoNDl8YWkpfGVtKGwyfHVsKXxlcihpY3xrMCl8ZXNsOHxleihbNC03XTB8b3N8d2F8emUpfGZldGN8Zmx5KFxcLXxfKXxnMSB1fGc1NjB8Z2VuZXxnZlxcLTV8Z1xcLW1vfGdvKFxcLnd8b2QpfGdyKGFkfHVuKXxoYWllfGhjaXR8aGRcXC0obXxwfHQpfGhlaVxcLXxoaShwdHx0YSl8aHAoIGl8aXApfGhzXFwtY3xodChjKFxcLXwgfF98YXxnfHB8c3x0KXx0cCl8aHUoYXd8dGMpfGlcXC0oMjB8Z298bWEpfGkyMzB8aWFjKCB8XFwtfFxcLyl8aWJyb3xpZGVhfGlnMDF8aWtvbXxpbTFrfGlubm98aXBhcXxpcmlzfGphKHR8dilhfGpicm98amVtdXxqaWdzfGtkZGl8a2VqaXxrZ3QoIHxcXC8pfGtsb258a3B0IHxrd2NcXC18a3lvKGN8ayl8bGUobm98eGkpfGxnKCBnfFxcLyhrfGx8dSl8NTB8NTR8XFwtW2Etd10pfGxpYnd8bHlueHxtMVxcLXd8bTNnYXxtNTBcXC98bWEodGV8dWl8eG8pfG1jKDAxfDIxfGNhKXxtXFwtY3J8bWUocmN8cmkpfG1pKG84fG9hfHRzKXxtbWVmfG1vKDAxfDAyfGJpfGRlfGRvfHQoXFwtfCB8b3x2KXx6eil8bXQoNTB8cDF8diApfG13YnB8bXl3YXxuMTBbMC0yXXxuMjBbMi0zXXxuMzAoMHwyKXxuNTAoMHwyfDUpfG43KDAoMHwxKXwxMCl8bmUoKGN8bSlcXC18b258dGZ8d2Z8d2d8d3QpfG5vayg2fGkpfG56cGh8bzJpbXxvcCh0aXx3dil8b3Jhbnxvd2cxfHA4MDB8cGFuKGF8ZHx0KXxwZHhnfHBnKDEzfFxcLShbMS04XXxjKSl8cGhpbHxwaXJlfHBsKGF5fHVjKXxwblxcLTJ8cG8oY2t8cnR8c2UpfHByb3h8cHNpb3xwdFxcLWd8cWFcXC1hfHFjKDA3fDEyfDIxfDMyfDYwfFxcLVsyLTddfGlcXC0pfHF0ZWt8cjM4MHxyNjAwfHJha3N8cmltOXxybyh2ZXx6byl8czU1XFwvfHNhKGdlfG1hfG1tfG1zfG55fHZhKXxzYygwMXxoXFwtfG9vfHBcXC0pfHNka1xcL3xzZShjKFxcLXwwfDEpfDQ3fG1jfG5kfHJpKXxzZ2hcXC18c2hhcnxzaWUoXFwtfG0pfHNrXFwtMHxzbCg0NXxpZCl8c20oYWx8YXJ8YjN8aXR8dDUpfHNvKGZ0fG55KXxzcCgwMXxoXFwtfHZcXC18diApfHN5KDAxfG1iKXx0MigxOHw1MCl8dDYoMDB8MTB8MTgpfHRhKGd0fGxrKXx0Y2xcXC18dGRnXFwtfHRlbChpfG0pfHRpbVxcLXx0XFwtbW98dG8ocGx8c2gpfHRzKDcwfG1cXC18bTN8bTUpfHR4XFwtOXx1cChcXC5ifGcxfHNpKXx1dHN0fHY0MDB8djc1MHx2ZXJpfHZpKHJnfHRlKXx2ayg0MHw1WzAtM118XFwtdil8dm00MHx2b2RhfHZ1bGN8dngoNTJ8NTN8NjB8NjF8NzB8ODB8ODF8ODN8ODV8OTgpfHczYyhcXC18ICl8d2ViY3x3aGl0fHdpKGcgfG5jfG53KXx3bWxifHdvbnV8eDcwMHx5YXNcXC18eW91cnx6ZXRvfHp0ZVxcLS9pLnRlc3QoYS5zdWJzdHIoMCwgNCkpKVxuICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2V0aGVyIHRoZSBwbGF0Zm9ybSB0YXJnZXQgaXMgYSBicm93c2VyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNCcm93c2VyICgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3ZXRoZXIgdGhlIHBsYXRmb3JtIHRhcmdldCBpcyBOb2RlanNcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc05vZGUgKCkge1xuICAgIHJldHVybiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpICYmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnaXZlbiBvYmplY3QncyB2YWx1ZXMgYXMgYW4gYXJyYXlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcmV0dXJucyB7QXJyYXk8Kj59XG4gICAqL1xuICBzdGF0aWMgdmFsdWVzIChvYmplY3QpIHtcbiAgICB2YXIgdmFsdWVzID0gW11cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICB2YWx1ZXMucHVzaChvYmplY3Rba2V5XSlcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlc1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgRE9NIGVsZW1lbnRcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgb1xuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgc3RhdGljIGlzRE9NRWxlbWVudCAobykge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICdvYmplY3QnID8gbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50XG4gICAgICAgIDogbyAmJiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgbyAhPT0gbnVsbCAmJiBvLm5vZGVUeXBlID09PSAxICYmIHR5cGVvZiBvLm5vZGVOYW1lID09PSAnc3RyaW5nJ1xuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGggZ2l2ZW4gZXZlbnQgaXMgYSB0b3VjaCBldmVudFxuICAgKiBAcGFyYW0gIHtFdmVudH0gIGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1RvdWNoRXZlbnQgKGUpIHtcbiAgICByZXR1cm4gKGUudHlwZS5pbmRleE9mKCd0b3VjaCcpICE9PSAtMSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemVzIHRoZSBnaXZlbiB2ZWN0b3IgdG8gZml0IGluc2lkZSB0aGUgZ2l2ZW4gbWF4IHNpemUgd2hpbGUgbWFpbnRhaW5pbmdcbiAgICogdGhlIGFzcGVjdCByYXRpb1xuICAgKiBAcGFyYW0gIHtWZWN0b3IyfSB2ZWN0b3JcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gbWF4XG4gICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAqL1xuICBzdGF0aWMgcmVzaXplVmVjdG9yVG9GaXQgKHZlY3RvciwgbWF4KSB7XG4gICAgY29uc3Qgc2NhbGUgPSBNYXRoLm1pbihtYXgueCAvIHZlY3Rvci54LCBtYXgueSAvIHZlY3Rvci55KVxuICAgIGNvbnN0IG5ld1NpemUgPSB2ZWN0b3IuY2xvbmUoKVxuICAgICAgLm11bHRpcGx5KHNjYWxlKVxuICAgIHJldHVybiBuZXdTaXplXG4gIH1cblxuICBzdGF0aWMgcmVzaXplVmVjdG9yVG9GaWxsICh2ZWN0b3IsIGNvbnRhaW5lcikge1xuICAgIGNvbnN0IHZlY3RvclJhdGlvID0gdmVjdG9yLnggLyB2ZWN0b3IueVxuICAgIGNvbnN0IGNvbnRhaW5lclJhdGlvID0gY29udGFpbmVyLnggLyBjb250YWluZXIueVxuICAgIGlmICh2ZWN0b3JSYXRpbyA+IGNvbnRhaW5lclJhdGlvKSB7XG4gICAgICByZXR1cm4gY29udGFpbmVyLmNsb25lKClcbiAgICAgICAgLnNldChjb250YWluZXIueSAqIHZlY3RvclJhdGlvLCBjb250YWluZXIueSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbnRhaW5lci5jbG9uZSgpXG4gICAgICAgIC5zZXQoY29udGFpbmVyLngsIGNvbnRhaW5lci54IC8gdmVjdG9yUmF0aW8pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIHZhbHVlIGlzIGV4dGVuZGFibGUgLyBjYW4gaGF2ZSBrZXlzXG4gICAqIEBwYXJhbSAgeyp9ICB2YWxcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0V4dGVuZGFibGUgKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgIT09IG51bGwgJiZcbiAgICAgICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKVxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgKiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byB1bmRlZmluZWQuIE9uY2UgYVxuICAgKiBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IC4uLnNvdXJjZXNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzIChvYmplY3QsIC4uLnNvdXJjZXMpIHtcbiAgICAvLyBTaGFsbG93IGNsb25lXG4gICAgbGV0IG5ld09iamVjdCA9IHt9XG4gICAgZm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuICAgICAgbmV3T2JqZWN0W2tleV0gPSBvYmplY3Rba2V5XVxuICAgIH1cblxuICAgIC8vIENsb25lIHNvdXJjZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaV1cbiAgICAgIGZvciAobGV0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdPYmplY3Rba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBuZXdPYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3T2JqZWN0XG4gIH1cblxuICAvKipcbiAgICogRG9lcyBhIGRlZXAgbWVyZ2UgYmV0d2VlbiBhIHNldCBvZiBvYmplY3RzLCBmcm9tIGxlZnQgdG8gcmlnaHQuIFRoZSBtZXJnZSBpc1xuICAgKiBkZWVwIGluIHRoZSBzZW5zZSB0aGF0IGl0IGdvZXMgcmVjdXJzZXZpbGV5IHRyb3VnaCB0aGUgb2JqZWN0cyBvd25cbiAgICogcHJvcGVydGllcy4gV2hlbiBpdCBlbmNvdW50ZXJzIGFuIGFycmF5LCBpdCBvbmx5IGRvZXMgYSBzaGFsbG93IGNvcHkgb2YgaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gICAqIEBwYXJhbSB7T2JqZWN0W119IHNvdXJjZXNcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBkZWVwTWVyZ2UgKGRlc3QsIC4uLnNvdXJjZXMpIHtcbiAgICAvLyBkZWVwIG1lcmdlIGJldHdlZW4gdHdvIG9iamVjdHMgb25seVxuICAgIGNvbnN0IF9kZWVwTWVyZ2UgPSAoZGVzdCwgc291cmNlKSA9PiB7XG4gICAgICAvLyBJZiB0aGUgc291cmNlIGlzIHVuZGVmaW5lZCwgcmV0dXJuIGEgY29weSBvZiBkZXN0XG4gICAgICBpZiAoc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIF9kZWVwTWVyZ2UobnVsbCwgZGVzdClcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHNvdXJjZSBpcyBhbiBhcnJheSwgcmV0dXJuIGEgc2hhbGxvdyBjb3B5XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiBbLi4uc291cmNlXVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgc291cmNlIGlzIG5vdCBhIHBsYWluIG9iamVjdCwganVzdCByZXR1cm4gaXRcbiAgICAgIGlmICghVXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2VcbiAgICAgIH1cblxuICAgICAgLy8gSWYgZGVzdCBpcyBhbiBub3QgYSBwbGFpbiBvYmplY3QsIHJldHVybiBhIHNoYWxsb3cgY29weSBvZiB0aGUgc291cmNlXG4gICAgICBpZiAoIVV0aWxzLmlzUGxhaW5PYmplY3QoZGVzdCkpIHtcbiAgICAgICAgcmV0dXJuIHsuLi5zb3VyY2V9XG4gICAgICB9XG5cbiAgICAgIC8vIFNoYWxsb3ctY29weSB0aGUgb3JpZ2luYWwgb2JqZWN0XG4gICAgICBsZXQgcmVzdWx0ID0gey4uLmRlc3R9XG5cbiAgICAgIC8vIEdvIHRyb3VnaCBlYWNoIHNvdXJjZSBrZXlcbiAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBzb3VyY2Vba2V5XVxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtrZXldID0gX2RlZXBNZXJnZShkZXN0W2tleV0sIHZhbHVlKVxuICAgICAgfSlcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlcy5yZWR1Y2UoX2RlZXBNZXJnZSwgZGVzdClcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICogb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyBhbmQgdGhlaXIgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG9cbiAgICogdW5kZWZpbmVkLiBPbmNlIGEgcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlIHNvZiB0aGUgc2FtZSBwcm9wZXJ0eVxuICAgKiBhcmUgaWdub3JlZC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtICB7T2JqZWN0fSAuLi5zb3VyY2VzXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBkZWVwRGVmYXVsdHMgKG9iamVjdCwgLi4uc291cmNlcykge1xuICAgIGNvbnN0IHJldmVyc2VkU291cmNlcyA9IFsuLi5zb3VyY2VzXS5yZXZlcnNlKClcbiAgICByZXR1cm4gVXRpbHMuZGVlcE1lcmdlKC4uLnJldmVyc2VkU291cmNlcywgb2JqZWN0KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBkZWVwIGNsb25lIG9mIHRoZSBnaXZlbiBvYmplY3RcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgICBvYmplY3RcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGRlZXBDbG9uZSAob2JqZWN0KSB7XG4gICAgbGV0IG5ld09iamVjdCA9IHt9XG4gICAgZm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuICAgICAgaWYgKFV0aWxzLmlzRXh0ZW5kYWJsZShvYmplY3Rba2V5XSkpIHtcbiAgICAgICAgbmV3T2JqZWN0W2tleV0gPSBVdGlscy5kZWVwQ2xvbmUob2JqZWN0W2tleV0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdPYmplY3Rba2V5XSA9IG9iamVjdFtrZXldXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdPYmplY3RcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBkZWVwIHByb3BlcnR5IGluc2lkZSBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nW119IHBhdGggLSBFaXRoZXIgYSBzdHJpbmcgd2l0aCB0aGUgcHJvcCdzXG4gICAqICBuYW1lLCBvciBhbiBhcnJheSBvZiBwcm9wIG5hbWVzIGFuZC9vciBmdW5jdGlvbnMgZGVzY3JpYmluZyBhIHBhdGggaW4gYVxuICAgKiAgbmVzdGVkIG9iamVjdC4gQW55IGZ1bmN0aW9uIHBhc3NlZCBpbiB0aGUgYXJyYXkgc2hvdWxkIGZ1bmN0aW9uIGFzIGEgZ2V0dGVyXG4gICAqICBmb3IgYSBwcm9wLlxuICAgKlxuICAgKiBAcmV0dXJucyB7KGFueXx1bmRlZmluZWQpfSAtIFRoZSBwcm9wJ3MgdmFsdWUsIG9yIHVuZGVmaW5lZCBpZiB0aGUgcHJvcCBpc1xuICAgKiBub3QgZm91bmRcbiAgICovXG4gIHN0YXRpYyBnZXREZWVwUHJvcGVydHkgKG9iamVjdCwgcGF0aCkge1xuICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBvYmplY3RbcGF0aF1cbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICAvLyBXaGVuIHdlIGhhdmUgYSBnZXR0ZXIgZnVuY3Rpb24gaW5zaWRlIHRoZSBhcnJheSwgY2FsbCBpdCBhcyBhIGdldHRlcixcbiAgICAvLyBpZ25vcmluZyBhbnkgdHlwZSBlcnJvcnMgdGhyb3duIGJ5IGl0IChqdXN0IHJldHVybiB1bmRlZmluZWQuKVxuICAgIGNvbnN0IGNhbGxQcm9wTmFtZSA9IChvYmplY3QsIHByb3BOYW1lKSA9PiB7XG4gICAgICBsZXQgdmFsdWVcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbHVlID0gcHJvcE5hbWUob2JqZWN0KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgVHlwZUVycm9yKSkge1xuICAgICAgICAgIHRocm93IGVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aC5yZWR1Y2UoKG9iamVjdCwgcHJvcE5hbWUpID0+XG4gICAgICBvYmplY3RcbiAgICAgICAgPyAodHlwZW9mIHByb3BOYW1lID09PSAnZnVuY3Rpb24nID8gY2FsbFByb3BOYW1lKG9iamVjdCwgcHJvcE5hbWUpIDogb2JqZWN0W3Byb3BOYW1lXSlcbiAgICAgICAgOiBudWxsXG4gICAgICAsIG9iamVjdClcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICogb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzXG4gICAqIHNvdXJjZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IC4uLnNvdXJjZXNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGV4dGVuZCAob2JqZWN0LCAuLi5zb3VyY2VzKSB7XG4gICAgLy8gU2hhbGxvdyBjbG9uZVxuICAgIGxldCBuZXdPYmplY3QgPSB7fVxuICAgIGZvciAobGV0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgIG5ld09iamVjdFtrZXldID0gb2JqZWN0W2tleV1cbiAgICB9XG5cbiAgICAvLyBFeHRlbmQgc291cmNlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc291cmNlID0gc291cmNlc1tpXVxuICAgICAgZm9yIChsZXQga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBuZXdPYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld09iamVjdFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIHRoZSBnaXZlbiBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGNsb25lIChvYmplY3QpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe30sIG9iamVjdClcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQmxvYiBVUkkgZnJvbSB0aGUgZ2l2ZW4gRGF0YSBVUklcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVCbG9iVVJJRnJvbURhdGFVUkkgKGRhdGEpIHtcbiAgICBjb25zdCByb290ID0gKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSA/IGdsb2JhbCA6IHdpbmRvd1xuICAgIGlmICghcm9vdC5CbG9iIHx8ICFyb290LlVSTCB8fCAhQXJyYXlCdWZmZXIgfHwgIVVpbnQ4QXJyYXkpIHtcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfVxuXG4gICAgY29uc3QgcmF3RGF0YSA9IEJhc2U2NC5kZWNvZGUoZGF0YS5zcGxpdCgnLCcpWzFdKVxuICAgIGNvbnN0IG1pbWVTdHJpbmcgPSBkYXRhLnNwbGl0KCcsJylbMF0uc3BsaXQoJzonKVsxXS5zcGxpdCgnOycpWzBdXG5cbiAgICAvLyB3cml0ZSB0aGUgYnl0ZXMgb2YgdGhlIHN0cmluZyB0byBhbiBBcnJheUJ1ZmZlclxuICAgIGNvbnN0IGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHJhd0RhdGEubGVuZ3RoKVxuICAgIGNvbnN0IGludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXdEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnRBcnJheVtpXSA9IHJhd0RhdGFbaV1cbiAgICB9XG5cbiAgICAvLyB3cml0ZSB0aGUgQXJyYXlCdWZmZXIgdG8gYSBibG9iLCBhbmQgeW91J3JlIGRvbmVcbiAgICBjb25zdCBibG9iID0gbmV3IHJvb3QuQmxvYihbYXJyYXlCdWZmZXJdLCB7XG4gICAgICB0eXBlOiBtaW1lU3RyaW5nXG4gICAgfSlcbiAgICByZXR1cm4gcm9vdC5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgVVVJRFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0VVVJRCAoKSB7XG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICAgIGxldCByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMFxuICAgICAgbGV0IHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpXG4gICAgICByZXR1cm4gdi50b1N0cmluZygxNilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjYW52YXMgRE9NIGVsZW1lbnQgKGJyb3dzZXIpIG9yIGEgbm9kZS1jYW52YXMgY2FudmFzIChub2RlKVxuICAgKiBAcmV0dXJuIHtDYW52YXN9XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQ2FudmFzICgpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICB9XG4gIHN0YXRpYyBjb252ZXJ0SHRtbEltYWdlVG9SR0JBQ2FudmFzIChodG1sSW1hZ2UpIHtcbiAgICAvLyBXb3JrYXJvdW5kIGZybyBub24tUkdCIGltYWdlc1xuICAgIGNvbnN0IGNhbnZhcyA9IFV0aWxzLmNyZWF0ZUNhbnZhcygpXG4gICAgY2FudmFzLndpZHRoID0gaHRtbEltYWdlLndpZHRoXG4gICAgY2FudmFzLmhlaWdodCA9IGh0bWxJbWFnZS5oZWlnaHRcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICBjb250ZXh0LmRyYXdJbWFnZShodG1sSW1hZ2UsIDAsIDAsIGh0bWxJbWFnZS53aWR0aCwgaHRtbEltYWdlLmhlaWdodClcblxuICAgIHJldHVybiBjYW52YXNcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBkaW1lbnNpb25zIGFyZSBQT1RcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSAgZGltZW5zaW9uc1xuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzUG93ZXJPZlR3byAoZGltZW5zaW9ucykge1xuICAgIHJldHVybiAoZGltZW5zaW9ucy54ICYgKGRpbWVuc2lvbnMueCAtIDEpKSA9PT0gMCAmJlxuICAgICAgKGRpbWVuc2lvbnMueSAmIChkaW1lbnNpb25zLnkgLSAxKSkgPT09IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuZXh0IGxvd2VzdCBwb3dlciBvZiB0d28gb2YgdGhlIGdpdmVuIG51bWJlclxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHhcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIG5leHRMb3dlc3RQT1QgKHgpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDMyOyBpIDw8PSAxKSB7XG4gICAgICB4ID0geCB8IHggPj4gaVxuICAgIH1cbiAgICByZXR1cm4geCAtICh4ID4+IDEpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIHR3byBvZiB0aGUgZ2l2ZW4gbnVtYmVyXG4gICAqIEBwYXJhbSAge051bWJlcn0geFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBzdGF0aWMgbmV4dEhpZ2hlc3RQT1QgKHgpIHtcbiAgICB4LS1cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDMyOyBpIDw8PSAxKSB7XG4gICAgICB4ID0geCB8IHggPj4gaVxuICAgIH1cbiAgICByZXR1cm4geCArIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgYXJyYXkgaXRlbSBhdCBgb2xkSW5kZXhgIHRvIGBuZXdJbmRleGBcbiAgICogQHBhcmFtICB7QXJyYXl9IGFyclxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG9sZEluZGV4XG4gICAqIEBwYXJhbSAge051bWJlcn0gbmV3SW5kZXhcbiAgICovXG4gIHN0YXRpYyBtb3ZlQXJyYXlJdGVtIChhcnIsIG9sZEluZGV4LCBuZXdJbmRleCkge1xuICAgIGlmIChuZXdJbmRleCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICBsZXQgayA9IG5ld0luZGV4IC0gYXJyLmxlbmd0aFxuICAgICAgd2hpbGUgKChrLS0pICsgMSkge1xuICAgICAgICBhcnIucHVzaCh1bmRlZmluZWQpXG4gICAgICB9XG4gICAgfVxuICAgIGFyci5zcGxpY2UobmV3SW5kZXgsIDAsIGFyci5zcGxpY2Uob2xkSW5kZXgsIDEpWzBdKVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIHN1cmUgdGhlIGdpdmVuIGNhbnZhcyBoYXMgdGhlIGdpdmVuIGRpbWVuc2lvbnMuIElmIG5vdCwgaXQgZG9lcyBub3QgY2hhbmdlIHRoZVxuICAgKiBjYW52YXMgZGltZW5zaW9ucy5cbiAgICogQHBhcmFtICB7Q2FudmFzfSBjYW52YXNcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBkaW1lbnNpb25zXG4gICAqL1xuICBzdGF0aWMgZW5zdXJlQ2FudmFzRGltZW5zaW9ucyAoY2FudmFzLCBkaW1lbnNpb25zKSB7XG4gICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gZGltZW5zaW9ucy54IHx8XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgIT09IGRpbWVuc2lvbnMueSkge1xuICAgICAgY2FudmFzLndpZHRoID0gZGltZW5zaW9ucy54XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gZGltZW5zaW9ucy55XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBnaXZlbiBhcnJheSBvZiBieXRlcyB0byBhIHN0cmluZ1xuICAgKiBAcGFyYW0gIHtOdW1iZXJbXX0gYnl0ZUFycmF5XG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBieXRlQXJyYXlUb1N0cmluZyAoYnl0ZUFycmF5KSB7XG4gICAgcmV0dXJuIGJ5dGVBcnJheS5tYXAoKGJ5dGUpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpLmpvaW4oJycpXG4gIH1cblxuICAvKipcbiAgICogQ2xhbXBzIHRoZSBnaXZlbiBgbnVtYmVyYCBpbnRvIGBtaW5gIGFuZCBgbWF4YFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG51bWJlclxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG1pblxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG1heFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBzdGF0aWMgY2xhbXAgKG51bWJlciwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihudW1iZXIsIG1heCkpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBzdHJpbmcgbWF0Y2hlcyB0aGUgZ2l2ZW4gd2lsZGNhcmRcbiAgICogQHBhcmFtICB7U3RyaW5nfSBzdHJcbiAgICogQHBhcmFtICB7U3RyaW5nfSBydWxlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgd2lsZENhcmRNYXRjaCAoc3RyLCBydWxlKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcnVsZS5zcGxpdCgnKicpLmpvaW4oJy4qJykgKyAnJCcpLnRlc3Qoc3RyKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggZmxpcHBlZCB2YWx1ZXMgYW5kIGtleXNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvYmpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGZsaXBPYmplY3QgKG9iaikge1xuICAgIGNvbnN0IG5ld09iaiA9IHt9XG4gICAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgICAgbmV3T2JqW29ialtrZXldXSA9IGtleVxuICAgIH1cbiAgICByZXR1cm4gbmV3T2JqXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBnaXZlbiBvcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGNsb25lT3B0aW9ucyAob3B0aW9ucykge1xuICAgIGNvbnN0IG5ld09wdGlvbnMgPSB7fVxuICAgIGZvciAobGV0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICBsZXQgdmFsdWUgPSBvcHRpb25zW2tleV1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKClcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUuY2xvbmUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5jbG9uZSgpXG4gICAgICB9XG4gICAgICBuZXdPcHRpb25zW2tleV0gPSB2YWx1ZVxuICAgIH1cbiAgICByZXR1cm4gbmV3T3B0aW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdpdmVuIGRhdGUgYXMgUkZDIDMzMzlcbiAgICogQHBhcmFtIHtEYXRlfSBkYXRlXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBJU09EYXRlU3RyaW5nIChkYXRlKSB7XG4gICAgZnVuY3Rpb24gcGFkIChuKSB7IHJldHVybiBuIDwgMTAgPyAnMCcgKyBuIDogbiB9XG4gICAgcmV0dXJuIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArICctJyArXG4gICAgICBwYWQoZGF0ZS5nZXRVVENNb250aCgpICsgMSkgKyAnLScgK1xuICAgICAgcGFkKGRhdGUuZ2V0VVRDRGF0ZSgpKSArICdUJyArXG4gICAgICBwYWQoZGF0ZS5nZXRVVENIb3VycygpKSArICc6JyArXG4gICAgICBwYWQoZGF0ZS5nZXRVVENNaW51dGVzKCkpICsgJzonICtcbiAgICAgIHBhZChkYXRlLmdldFVUQ1NlY29uZHMoKSkgKyAnWidcbiAgfVxuXG4gIHN0YXRpYyBnZXRDcm9zc09yaWdpblZhbHVlIChjcm9zc09yaWdpbikge1xuICAgIGlmICghY3Jvc3NPcmlnaW4pIHtcbiAgICAgIHJldHVybiAnYW5vbnltb3VzJ1xuICAgIH1cblxuICAgIGlmIChjcm9zc09yaWdpbiA9PT0gJ25vbmUnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgcmV0dXJuIGNyb3NzT3JpZ2luXG4gIH1cblxuICAvKipcbiAgICogU2hhbGxvdyBlcXVhbCBjb21wYXJlIHR3byBvYmplY3RzXG4gICAqIEBwYXJhbSB7Kn0gb2JqQVxuICAgKiBAcGFyYW0geyp9IG9iakJcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgc2hhbGxvd0VxdWFsIChvYmpBLCBvYmpCKSB7XG4gICAgaWYgKG9iakEgPT09IG9iakIpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8XG4gICAgICAgIHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKVxuICAgIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpXG5cbiAgICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICAgIHZhciBiSGFzT3duUHJvcGVydHkgPSBoYXNPd25Qcm9wZXJ0eS5iaW5kKG9iakIpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFiSGFzT3duUHJvcGVydHkoa2V5c0FbaV0pIHx8IG9iakFba2V5c0FbaV1dICE9PSBvYmpCW2tleXNBW2ldXSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zICd2YWx1ZScgaWYgY29uZGl0aW9uIGlzIG1ldCBlbHNlIHJldHVybnMgJ3VuZGVmaW5lZCdcbiAgICogQHBhcmFtIHtCb29sZWFufSBjb25kaXRpb25cbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHN0YXRpYyBlbmFibGVJZiAoY29uZGl0aW9uLCB2YWx1ZSkge1xuICAgIHJldHVybiBjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAgVGhyb3dzIGFuIGVycm9yIGlmIGNvbmRpdGlvbiBpcyBub3QgbWV0XG4gICAgQHBhcmFtIHtCb29sZWFufSBjb25kaXRpb25cbiAgICovXG4gIHN0YXRpYyBpbnZhcmlhbnQgKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXhlY3R1ZXMgYWxsIFByb21pc2VzIGluIGFuIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgUHJvbWlzZSB3aGljaFxuICAgKiB3aWxsIGZ1bGZpbGwgd2l0aCBhbiBhcnJheSBvZiB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IGFsbCBwcm9taXNlcyBpblxuICAgKiB0aGUgY2FzZSBhbGwgb2YgdGhlbSBhcmUgcmVzb2x2ZWQsIG9yLCB3aXRoIG9uZSBvciBtb3JlIGFyZSByZWplY3RlZCxcbiAgICogcmVqZWN0cyB3aXRoIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHRoZSBlcnJvciB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8UHJvbWlzZT59IHByb21pc2VzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5Pn1cbiAgICovXG4gIHN0YXRpYyBleGVjdXRlUHJvbWlzZXMgKHByb21pc2VzKSB7XG4gICAgbGV0IGNvdW50ID0gcHJvbWlzZXMubGVuZ3RoXG4gICAgbGV0IGNvdW50ZXIgPSAwXG5cbiAgICBsZXQgdmFsdWVzID0gW11cbiAgICBsZXQgZXJyb3JzID0gW11cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBvbkZpbm5pc2ggPSAoKSA9PiB7XG4gICAgICAgIGNvdW50ZXIrK1xuICAgICAgICBpZiAoY291bnRlciA+PSBjb3VudCkge1xuICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWVzKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3JzKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvblN1Y2Nlc3MgPSB2YWx1ZSA9PiB7XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgICBvbkZpbm5pc2goKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvbkVycm9yID0gdmFsdWUgPT4ge1xuICAgICAgICBlcnJvcnMucHVzaCh2YWx1ZSlcbiAgICAgICAgb25GaW5uaXNoKClcbiAgICAgIH1cblxuICAgICAgcHJvbWlzZXMuZm9yRWFjaChwcm9taXNlID0+IHtcbiAgICAgICAgcHJvbWlzZS50aGVuKG9uU3VjY2VzcykuY2F0Y2gob25FcnJvcilcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuICBzdGF0aWMgQXJyYXkgPSBBcnJheVV0aWxzIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn1cblxuZXhwb3J0IGRlZmF1bHQgVXRpbHNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvanMvc2RrL2NvcmUvbGliL3V0aWxzLmpzIiwiLypcbiAqIEV4dHJhY3RlZCBmcm9tIE1pbmlmeUpwZWcgKENvcHlyaWdodCAoYykgMjAxNCBIaXJvYWtpIE1hdG9iYSwgTUlUIExpY2Vuc2UpOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2hNYXRvYmEvTWluaWZ5SnBlZ1xuICogQGxpY2Vuc2VcbiAqL1xuXG5jb25zdCBLRVlfU1RSID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89J1xuXG4vKipcbiAqIFByb3ZpZGVzIEJhc2U2NCBlbmNvZGUgYW5kIGRlY29kZSBtZXRob2RzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGlnbm9yZVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgQmFzZTY0ID0ge1xuICAvKipcbiAgICogRW5jb2RlcyB0aGUgZ2l2ZW4gaW5wdXQgaW50byBhIEJhc2U2NCBzdHJpbmdcbiAgICogQHBhcmFtICB7U3RyaW5nfSBpbnB1dFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBlbmNvZGUgKGlucHV0KSB7XG4gICAgbGV0IG91dHB1dCA9ICcnXG4gICAgbGV0IGNocjEsIGNocjIsIGNocjNcbiAgICBsZXQgZW5jMSwgZW5jMiwgZW5jMywgZW5jNFxuICAgIGxldCBpID0gMFxuXG4gICAgZG8ge1xuICAgICAgY2hyMSA9IGlucHV0W2krK11cbiAgICAgIGNocjIgPSBpbnB1dFtpKytdXG4gICAgICBjaHIzID0gaW5wdXRbaSsrXVxuXG4gICAgICBlbmMxID0gY2hyMSA+PiAyXG4gICAgICBlbmMyID0gKChjaHIxICYgMykgPDwgNCkgfCAoY2hyMiA+PiA0KVxuICAgICAgZW5jMyA9ICgoY2hyMiAmIDE1KSA8PCAyKSB8IChjaHIzID4+IDYpXG4gICAgICBlbmM0ID0gY2hyMyAmIDYzXG5cbiAgICAgIGlmIChpc05hTihjaHIyKSkge1xuICAgICAgICBlbmMzID0gZW5jNCA9IDY0XG4gICAgICB9IGVsc2UgaWYgKGlzTmFOKGNocjMpKSB7XG4gICAgICAgIGVuYzQgPSA2NFxuICAgICAgfVxuXG4gICAgICBvdXRwdXQgPSBvdXRwdXQgK1xuICAgICAgICAgS0VZX1NUUi5jaGFyQXQoZW5jMSkgK1xuICAgICAgICAgS0VZX1NUUi5jaGFyQXQoZW5jMikgK1xuICAgICAgICAgS0VZX1NUUi5jaGFyQXQoZW5jMykgK1xuICAgICAgICAgS0VZX1NUUi5jaGFyQXQoZW5jNClcbiAgICAgIGNocjEgPSBjaHIyID0gY2hyMyA9ICcnXG4gICAgICBlbmMxID0gZW5jMiA9IGVuYzMgPSBlbmM0ID0gJydcbiAgICB9IHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKVxuXG4gICAgcmV0dXJuIG91dHB1dFxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWNvZGVzIHRoZSBnaXZlbiBCYXNlNjQgc3RyaW5nXG4gICAqIEBwYXJhbSAge1N0cmluZ30gaW5wdXRcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZGVjb2RlIChpbnB1dCkge1xuICAgIGxldCBjaHIxLCBjaHIyLCBjaHIzXG4gICAgbGV0IGVuYzEsIGVuYzIsIGVuYzMsIGVuYzRcbiAgICBsZXQgaSA9IDBcbiAgICBsZXQgYnVmID0gW11cblxuICAgIC8vIHJlbW92ZSBhbGwgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgQS1aLCBhLXosIDAtOSwgKywgLywgb3IgPVxuICAgIHZhciBiYXNlNjR0ZXN0ID0gL1teQS1aYS16MC05Ky89XS9nXG4gICAgaWYgKGJhc2U2NHRlc3QuZXhlYyhpbnB1dCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgd2VyZSBpbnZhbGlkIGJhc2U2NCBjaGFyYWN0ZXJzIGluIHRoZSBpbnB1dCB0ZXh0LlxcbicgK1xuICAgICAgICAgICAgJ1ZhbGlkIGJhc2U2NCBjaGFyYWN0ZXJzIGFyZSBBLVosIGEteiwgMC05LCBcXCcrXFwnLCBcXCcvXFwnLGFuZCBcXCc9XFwnXFxuJyArXG4gICAgICAgICAgICAnRXhwZWN0IGVycm9ycyBpbiBkZWNvZGluZy4nKVxuICAgIH1cbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05Ky89XS9nLCAnJylcblxuICAgIGRvIHtcbiAgICAgIGVuYzEgPSBLRVlfU1RSLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpXG4gICAgICBlbmMyID0gS0VZX1NUUi5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKVxuICAgICAgZW5jMyA9IEtFWV9TVFIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSlcbiAgICAgIGVuYzQgPSBLRVlfU1RSLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpXG5cbiAgICAgIGNocjEgPSAoZW5jMSA8PCAyKSB8IChlbmMyID4+IDQpXG4gICAgICBjaHIyID0gKChlbmMyICYgMTUpIDw8IDQpIHwgKGVuYzMgPj4gMilcbiAgICAgIGNocjMgPSAoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzRcblxuICAgICAgYnVmLnB1c2goY2hyMSlcblxuICAgICAgaWYgKGVuYzMgIT09IDY0KSB7XG4gICAgICAgIGJ1Zi5wdXNoKGNocjIpXG4gICAgICB9XG4gICAgICBpZiAoZW5jNCAhPT0gNjQpIHtcbiAgICAgICAgYnVmLnB1c2goY2hyMylcbiAgICAgIH1cblxuICAgICAgY2hyMSA9IGNocjIgPSBjaHIzID0gJydcbiAgICAgIGVuYzEgPSBlbmMyID0gZW5jMyA9IGVuYzQgPSAnJ1xuICAgIH0gd2hpbGUgKGkgPCBpbnB1dC5sZW5ndGgpXG5cbiAgICByZXR1cm4gYnVmXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZTY0XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3Nkay9jb3JlL2xpYi9iYXNlNjQuanMiLCIvKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmNsYXNzIEFycmF5VXRpbHMge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBpbiBhbiBhcnJheVxuICAgKiBAcGFyYW0ge0FycmF5PEE+fSBhcnJcbiAgICogQHJldHVybnMge0F9XG4gICAqL1xuICBzdGF0aWMgaGVhZCAoYXJyKSB7XG4gICAgcmV0dXJuIGFyclswXVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIGFycmF5IGV4Y2x1ZGluZyB0aGUgZmlyc3QgZWxlbWVudFxuICAgKiBAcGFyYW0ge0FycmF5PEE+fSBhcnJcbiAgICogQHJldHVybnMge0FycmF5PEE+fVxuICAgKi9cbiAgc3RhdGljIHRhaWwgKGFycikge1xuICAgIHJldHVybiBhcnIuc2xpY2UoMSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheTxBPn0gYXJyXG4gICAqIEByZXR1cm5zIHtBfVxuICAgKi9cbiAgc3RhdGljIGxhc3QgKGFycikge1xuICAgIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHNoYWxsb3cgY29weSBvZiB0aGUgYXJyYXkgZXhjbHVkaW5nIHRoZSBsYXN0IGVsZW1lbnRcbiAgICogQHBhcmFtIHtBcnJheTxBPn0gYXJyXG4gICAqIEByZXR1cm5zIHtBcnJheTxBPn1cbiAgICovXG4gIHN0YXRpYyBpbml0IChhcnIpIHtcbiAgICByZXR1cm4gYXJyLnNsaWNlKDAsIGFyci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIGFycmF5IHdpdGggdGhlIGVsZW1lbnRzIHRoYSBwYXNzXG4gICAqIHRoZSB0ZXN0IGZ1bmN0aW9uIHJlbW92ZWQuXG4gICAqIEBwYXJhbSB7QXJyYXk8QT59IGFyclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gQSB0ZXN0IGZ1bmN0aW9uXG4gICAqL1xuICBzdGF0aWMgcmVtb3ZlIChhcnIsIGZ1bmMpIHtcbiAgICByZXR1cm4gYXJyLmZpbHRlcigodiwgaSwgYXJyKSA9PiAhZnVuYyh2LCBpLCBhcnIpKVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBpbmRleCBmaXJzdCBlbGVtZW50IG9mIHRoZSBBcnJheSB0byB3aGljaCB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gcmV0dXJuc1xuICAgKiBhIHRydWUgdmFsdWUuIElmIHRoZSBlbGVtZW50IGlzIG5vdCBmb3VuZCBpdCByZXR1cm5zIC0xLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBzdGF0aWMgZmluZEluZGV4IChhcnJheSwgZnVuYykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChmdW5jKGFycmF5W2ldKSkge1xuICAgICAgICByZXR1cm4gaVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBBcnJheSB0byB3aGljaCB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gcmV0dXJuc1xuICAgKiBhIHRydWUgdmFsdWUgYW5kIHJldHVybnMgaXQuIE90aGVyd2lzZSBpdCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICAgKiBAcmV0dXJucyB7YW55fVxuICAgKi9cbiAgc3RhdGljIGZpbmQgKGFycmF5LCBmdW5jKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGZ1bmMoYXJyYXlbaV0pKSB7XG4gICAgICAgIHJldHVybiBhcnJheVtpXVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGF0dGVucyB0aGUgZ2l2ZW4gbXVsdGlkaW1lbnNpb25hbCBhcnJheVxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBmbGF0dGVuIChhcnJheSkge1xuICAgIHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24gKGZsYXQsIHRvRmxhdHRlbikge1xuICAgICAgcmV0dXJuIGZsYXQuY29uY2F0KEFycmF5LmlzQXJyYXkodG9GbGF0dGVuKSA/IEFycmF5VXRpbHMuZmxhdHRlbih0b0ZsYXR0ZW4pIDogdG9GbGF0dGVuKVxuICAgIH0sIFtdKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW5kIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWJlcnMgZ29pbmcgZnJvbSBgc3RhcnRgIChpbmNsdXNpdmUpIHRvXG4gICAqIGBlbmRgIChleGNsdXNpdmUpXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gICAqIEByZXR1cm5zIEFycmF5XG4gICAqL1xuICBzdGF0aWMgcmFuZ2UgKHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgYXJyID0gW11cblxuICAgIGlmIChlbmQgPiBzdGFydCkge1xuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgYXJyLnB1c2goaSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJyXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBjb25zaXN0aW5nIG9mIHRoZSB2YWx1ZSBgdmFsYCByZXBlYXRlZCBgbmAgdGltZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSB2YWxcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5cbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIHJlcGVhdCAodmFsLCBuKSB7XG4gICAgbGV0IGFyciA9IFtdXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgYXJyW2ldID0gdmFsXG4gICAgfVxuXG4gICAgcmV0dXJuIGFyclxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgd2hpY2ggaXMgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGVxdWFsbHkgcG9zaXRpb25lZCBpdGVtcyBpbiBib3RoIGFycmF5cyxcbiAgICogZS5nLCB6aXAoWzEsIDIsIDNdLCBbNCwgNSwgNl0pID0gW1sxLCA0XSwgWzIsIDVdLCBbMywgNl1dXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFcbiAgICogQHBhcmFtIHtBcnJheX0gYlxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgemlwIChhLCBiKSB7XG4gICAgbGV0IGxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aClcbiAgICBsZXQgYXJyID0gW11cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFycltpXSA9IFthW2ldLCBiW2ldXVxuICAgIH1cblxuICAgIHJldHVybiBhcnJcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBcnJheVV0aWxzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3Nkay9jb3JlL2xpYi9hcnJheS11dGlscy5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQge1xuICBnZXRJRVZlcnNpb24gKCkge1xuICAgIGNvbnN0IHsgdXNlckFnZW50LCBhcHBWZXJzaW9uIH0gPSBuYXZpZ2F0b3JcbiAgICBpZiAoYXBwVmVyc2lvbi5pbmRleE9mKCdNU0lFJykgIT09IC0xKSB7XG4gICAgICByZXR1cm4gYXBwVmVyc2lvbi5tYXRjaCgvTVNJRVxccys/KFswLTldKykvaSlbMV1cbiAgICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdUcmlkZW50JykgIT09IC0xKSB7XG4gICAgICByZXR1cm4gdXNlckFnZW50Lm1hdGNoKC9ydjooWzAtOV0rKS9pKVsxXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0sXG5cbiAgaXNJRTEwICgpIHtcbiAgICBjb25zdCB2ZXJzaW9uID0gdGhpcy5nZXRJRVZlcnNpb24oKVxuICAgIHJldHVybiB2ZXJzaW9uICE9PSBmYWxzZSAmJiB2ZXJzaW9uID09PSAxMFxuICB9LFxuXG4gIGlzSUUxMSAoKSB7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRoaXMuZ2V0SUVWZXJzaW9uKClcbiAgICByZXR1cm4gdmVyc2lvbiAhPT0gZmFsc2UgJiYgdmVyc2lvbiA9PT0gMTFcbiAgfSxcblxuICBpc0lFbHRlICh2ZXJzaW9uKSB7XG4gICAgY29uc3QgYnJvd3NlclZlcnNpb24gPSB0aGlzLmdldElFVmVyc2lvbigpXG4gICAgaWYgKGJyb3dzZXJWZXJzaW9uID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuIGJyb3dzZXJWZXJzaW9uIDw9IHZlcnNpb25cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL3V0aWxzL2Jyb3dzZXIuanMiLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4vKiFcbiAqIE5hdGl2ZSBQcm9taXNlIE9ubHlcbiAqIHYwLjguMC1hIChjKSBLeWxlIFNpbXBzb25cbiAqIE1JVCBMaWNlbnNlOiBodHRwOi8vZ2V0aWZ5Lm1pdC1saWNlbnNlLm9yZ1xuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBwcm9taXNlRmFjdG9yeSA9IGZ1bmN0aW9uIERFRigpe1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgYnVpbHRJblByb3AsIGN5Y2xlLCBzY2hlZHVsaW5nX3F1ZXVlLFxuICAgIFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcbiAgICB0aW1lciA9ICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9IFwidW5kZWZpbmVkXCIpID9cbiAgICAgIGZ1bmN0aW9uIHRpbWVyKGZuKSB7IHJldHVybiBzZXRJbW1lZGlhdGUoZm4pOyB9IDpcbiAgICAgIHNldFRpbWVvdXRcbiAgO1xuXG4gIC8vIGRhbW1pdCwgSUU4LlxuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSxcInhcIix7fSk7XG4gICAgYnVpbHRJblByb3AgPSBmdW5jdGlvbiBidWlsdEluUHJvcChvYmosbmFtZSx2YWwsY29uZmlnKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaixuYW1lLHtcbiAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogY29uZmlnICE9PSBmYWxzZVxuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBjYXRjaCAoZXJyKSB7XG4gICAgYnVpbHRJblByb3AgPSBmdW5jdGlvbiBidWlsdEluUHJvcChvYmosbmFtZSx2YWwpIHtcbiAgICAgIG9ialtuYW1lXSA9IHZhbDtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE5vdGU6IHVzaW5nIGEgcXVldWUgaW5zdGVhZCBvZiBhcnJheSBmb3IgZWZmaWNpZW5jeVxuICBzY2hlZHVsaW5nX3F1ZXVlID0gKGZ1bmN0aW9uIFF1ZXVlKCkge1xuICAgIHZhciBmaXJzdCwgbGFzdCwgaXRlbTtcblxuICAgIGZ1bmN0aW9uIEl0ZW0oZm4sc2VsZikge1xuICAgICAgdGhpcy5mbiA9IGZuO1xuICAgICAgdGhpcy5zZWxmID0gc2VsZjtcbiAgICAgIHRoaXMubmV4dCA9IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQoZm4sc2VsZikge1xuICAgICAgICBpdGVtID0gbmV3IEl0ZW0oZm4sc2VsZik7XG4gICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgbGFzdC5uZXh0ID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmaXJzdCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgbGFzdCA9IGl0ZW07XG4gICAgICAgIGl0ZW0gPSB2b2lkIDA7XG4gICAgICB9LFxuICAgICAgZHJhaW46IGZ1bmN0aW9uIGRyYWluKCkge1xuICAgICAgICB2YXIgZiA9IGZpcnN0O1xuICAgICAgICBmaXJzdCA9IGxhc3QgPSBjeWNsZSA9IHZvaWQgMDtcblxuICAgICAgICB3aGlsZSAoZikge1xuICAgICAgICAgIGYuZm4uY2FsbChmLnNlbGYpO1xuICAgICAgICAgIGYgPSBmLm5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKGZuLHNlbGYpIHtcbiAgICBzY2hlZHVsaW5nX3F1ZXVlLmFkZChmbixzZWxmKTtcbiAgICBpZiAoIWN5Y2xlKSB7XG4gICAgICBjeWNsZSA9IHRpbWVyKHNjaGVkdWxpbmdfcXVldWUuZHJhaW4pO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb21pc2UgZHVjayB0eXBpbmdcbiAgZnVuY3Rpb24gaXNUaGVuYWJsZShvKSB7XG4gICAgdmFyIF90aGVuLCBvX3R5cGUgPSB0eXBlb2YgbztcblxuICAgIGlmIChvICE9IG51bGwgJiZcbiAgICAgIChcbiAgICAgICAgb190eXBlID09IFwib2JqZWN0XCIgfHwgb190eXBlID09IFwiZnVuY3Rpb25cIlxuICAgICAgKVxuICAgICkge1xuICAgICAgX3RoZW4gPSBvLnRoZW47XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgX3RoZW4gPT0gXCJmdW5jdGlvblwiID8gX3RoZW4gOiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGFpbi5sZW5ndGg7IGkrKykge1xuICAgICAgbm90aWZ5SXNvbGF0ZWQoXG4gICAgICAgIHRoaXMsXG4gICAgICAgICh0aGlzLnN0YXRlID09PSAxKSA/IHRoaXMuY2hhaW5baV0uc3VjY2VzcyA6IHRoaXMuY2hhaW5baV0uZmFpbHVyZSxcbiAgICAgICAgdGhpcy5jaGFpbltpXVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5jaGFpbi5sZW5ndGggPSAwO1xuICB9XG5cbiAgLy8gTk9URTogVGhpcyBpcyBhIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGlzb2xhdGVcbiAgLy8gdGhlIGB0cnkuLmNhdGNoYCBzbyB0aGF0IG90aGVyIGNvZGUgY2FuIGJlXG4gIC8vIG9wdGltaXplZCBiZXR0ZXJcbiAgZnVuY3Rpb24gbm90aWZ5SXNvbGF0ZWQoc2VsZixjYixjaGFpbikge1xuICAgIHZhciByZXQsIF90aGVuO1xuICAgIHRyeSB7XG4gICAgICBpZiAoY2IgPT09IGZhbHNlKSB7XG4gICAgICAgIGNoYWluLnJlamVjdChzZWxmLm1zZyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGNiID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0ID0gc2VsZi5tc2c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0ID0gY2IuY2FsbCh2b2lkIDAsc2VsZi5tc2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldCA9PT0gY2hhaW4ucHJvbWlzZSkge1xuICAgICAgICAgIGNoYWluLnJlamVjdChUeXBlRXJyb3IoXCJQcm9taXNlLWNoYWluIGN5Y2xlXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfdGhlbiA9IGlzVGhlbmFibGUocmV0KSkge1xuICAgICAgICAgIF90aGVuLmNhbGwocmV0LGNoYWluLnJlc29sdmUsY2hhaW4ucmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjaGFpbi5yZXNvbHZlKHJldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgY2hhaW4ucmVqZWN0KGVycik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZShtc2cpIHtcbiAgICB2YXIgX3RoZW4sIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gYWxyZWFkeSB0cmlnZ2VyZWQ/XG4gICAgaWYgKHNlbGYudHJpZ2dlcmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi50cmlnZ2VyZWQgPSB0cnVlO1xuXG4gICAgLy8gdW53cmFwXG4gICAgaWYgKHNlbGYuZGVmKSB7XG4gICAgICBzZWxmID0gc2VsZi5kZWY7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChfdGhlbiA9IGlzVGhlbmFibGUobXNnKSkge1xuICAgICAgICBzY2hlZHVsZShmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciBkZWZfd3JhcHBlciA9IG5ldyBNYWtlRGVmV3JhcHBlcihzZWxmKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgX3RoZW4uY2FsbChtc2csXG4gICAgICAgICAgICAgIGZ1bmN0aW9uICRyZXNvbHZlJCgpeyByZXNvbHZlLmFwcGx5KGRlZl93cmFwcGVyLGFyZ3VtZW50cyk7IH0sXG4gICAgICAgICAgICAgIGZ1bmN0aW9uICRyZWplY3QkKCl7IHJlamVjdC5hcHBseShkZWZfd3JhcHBlcixhcmd1bWVudHMpOyB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QuY2FsbChkZWZfd3JhcHBlcixlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWxmLm1zZyA9IG1zZztcbiAgICAgICAgc2VsZi5zdGF0ZSA9IDE7XG4gICAgICAgIGlmIChzZWxmLmNoYWluLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzY2hlZHVsZShub3RpZnksc2VsZik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgcmVqZWN0LmNhbGwobmV3IE1ha2VEZWZXcmFwcGVyKHNlbGYpLGVycik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVqZWN0KG1zZykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGFscmVhZHkgdHJpZ2dlcmVkP1xuICAgIGlmIChzZWxmLnRyaWdnZXJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbGYudHJpZ2dlcmVkID0gdHJ1ZTtcblxuICAgIC8vIHVud3JhcFxuICAgIGlmIChzZWxmLmRlZikge1xuICAgICAgc2VsZiA9IHNlbGYuZGVmO1xuICAgIH1cblxuICAgIHNlbGYubXNnID0gbXNnO1xuICAgIHNlbGYuc3RhdGUgPSAyO1xuICAgIGlmIChzZWxmLmNoYWluLmxlbmd0aCA+IDApIHtcbiAgICAgIHNjaGVkdWxlKG5vdGlmeSxzZWxmKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpdGVyYXRlUHJvbWlzZXMoQ29uc3RydWN0b3IsYXJyLHJlc29sdmVyLHJlamVjdGVyKSB7XG4gICAgZm9yICh2YXIgaWR4PTA7IGlkeDxhcnIubGVuZ3RoOyBpZHgrKykge1xuICAgICAgKGZ1bmN0aW9uIElJRkUoaWR4KXtcbiAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShhcnJbaWR4XSlcbiAgICAgICAgLnRoZW4oXG4gICAgICAgICAgZnVuY3Rpb24gJHJlc29sdmVyJChtc2cpe1xuICAgICAgICAgICAgcmVzb2x2ZXIoaWR4LG1zZyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWplY3RlclxuICAgICAgICApO1xuICAgICAgfSkoaWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBNYWtlRGVmV3JhcHBlcihzZWxmKSB7XG4gICAgdGhpcy5kZWYgPSBzZWxmO1xuICAgIHRoaXMudHJpZ2dlcmVkID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBNYWtlRGVmKHNlbGYpIHtcbiAgICB0aGlzLnByb21pc2UgPSBzZWxmO1xuICAgIHRoaXMuc3RhdGUgPSAwO1xuICAgIHRoaXMudHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgdGhpcy5jaGFpbiA9IFtdO1xuICAgIHRoaXMubXNnID0gdm9pZCAwO1xuICB9XG5cbiAgZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fX05QT19fICE9PSAwKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBwcm9taXNlXCIpO1xuICAgIH1cblxuICAgIC8vIGluc3RhbmNlIHNoYWRvd2luZyB0aGUgaW5oZXJpdGVkIFwiYnJhbmRcIlxuICAgIC8vIHRvIHNpZ25hbCBhbiBhbHJlYWR5IFwiaW5pdGlhbGl6ZWRcIiBwcm9taXNlXG4gICAgdGhpcy5fX05QT19fID0gMTtcblxuICAgIHZhciBkZWYgPSBuZXcgTWFrZURlZih0aGlzKTtcblxuICAgIHRoaXNbXCJ0aGVuXCJdID0gZnVuY3Rpb24gdGhlbihzdWNjZXNzLGZhaWx1cmUpIHtcbiAgICAgIHZhciBvID0ge1xuICAgICAgICBzdWNjZXNzOiB0eXBlb2Ygc3VjY2VzcyA9PSBcImZ1bmN0aW9uXCIgPyBzdWNjZXNzIDogdHJ1ZSxcbiAgICAgICAgZmFpbHVyZTogdHlwZW9mIGZhaWx1cmUgPT0gXCJmdW5jdGlvblwiID8gZmFpbHVyZSA6IGZhbHNlXG4gICAgICB9O1xuICAgICAgLy8gTm90ZTogYHRoZW4oLi4pYCBpdHNlbGYgY2FuIGJlIGJvcnJvd2VkIHRvIGJlIHVzZWQgYWdhaW5zdFxuICAgICAgLy8gYSBkaWZmZXJlbnQgcHJvbWlzZSBjb25zdHJ1Y3RvciBmb3IgbWFraW5nIHRoZSBjaGFpbmVkIHByb21pc2UsXG4gICAgICAvLyBieSBzdWJzdGl0dXRpbmcgYSBkaWZmZXJlbnQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICBvLnByb21pc2UgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihmdW5jdGlvbiBleHRyYWN0Q2hhaW4ocmVzb2x2ZSxyZWplY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgcmVqZWN0ICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgby5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgby5yZWplY3QgPSByZWplY3Q7XG4gICAgICB9KTtcbiAgICAgIGRlZi5jaGFpbi5wdXNoKG8pO1xuXG4gICAgICBpZiAoZGVmLnN0YXRlICE9PSAwKSB7XG4gICAgICAgIHNjaGVkdWxlKG5vdGlmeSxkZWYpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gby5wcm9taXNlO1xuICAgIH07XG4gICAgdGhpc1tcImNhdGNoXCJdID0gZnVuY3Rpb24gJGNhdGNoJChmYWlsdXJlKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHZvaWQgMCxmYWlsdXJlKTtcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yLmNhbGwoXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgZnVuY3Rpb24gcHVibGljUmVzb2x2ZShtc2cpe1xuICAgICAgICAgIHJlc29sdmUuY2FsbChkZWYsbXNnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gcHVibGljUmVqZWN0KG1zZykge1xuICAgICAgICAgIHJlamVjdC5jYWxsKGRlZixtc2cpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICByZWplY3QuY2FsbChkZWYsZXJyKTtcbiAgICB9XG4gIH1cblxuICB2YXIgUHJvbWlzZVByb3RvdHlwZSA9IGJ1aWx0SW5Qcm9wKHt9LFwiY29uc3RydWN0b3JcIixQcm9taXNlLFxuICAgIC8qY29uZmlndXJhYmxlPSovZmFsc2VcbiAgKTtcblxuICAvLyBOb3RlOiBBbmRyb2lkIDQgY2Fubm90IHVzZSBgT2JqZWN0LmRlZmluZVByb3BlcnR5KC4uKWAgaGVyZVxuICBQcm9taXNlLnByb3RvdHlwZSA9IFByb21pc2VQcm90b3R5cGU7XG5cbiAgLy8gYnVpbHQtaW4gXCJicmFuZFwiIHRvIHNpZ25hbCBhbiBcInVuaW5pdGlhbGl6ZWRcIiBwcm9taXNlXG4gIGJ1aWx0SW5Qcm9wKFByb21pc2VQcm90b3R5cGUsXCJfX05QT19fXCIsMCxcbiAgICAvKmNvbmZpZ3VyYWJsZT0qL2ZhbHNlXG4gICk7XG5cbiAgYnVpbHRJblByb3AoUHJvbWlzZSxcInJlc29sdmVcIixmdW5jdGlvbiBQcm9taXNlJHJlc29sdmUobXNnKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgIC8vIHNwZWMgbWFuZGF0ZWQgY2hlY2tzXG4gICAgLy8gbm90ZTogYmVzdCBcImlzUHJvbWlzZVwiIGNoZWNrIHRoYXQncyBwcmFjdGljYWwgZm9yIG5vd1xuICAgIGlmIChtc2cgJiYgdHlwZW9mIG1zZyA9PSBcIm9iamVjdFwiICYmIG1zZy5fX05QT19fID09PSAxKSB7XG4gICAgICByZXR1cm4gbXNnO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSxyZWplY3Qpe1xuICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgcmVqZWN0ICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShtc2cpO1xuICAgIH0pO1xuICB9KTtcblxuICBidWlsdEluUHJvcChQcm9taXNlLFwicmVqZWN0XCIsZnVuY3Rpb24gUHJvbWlzZSRyZWplY3QobXNnKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcbiAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlamVjdCAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChtc2cpO1xuICAgIH0pO1xuICB9KTtcblxuICBidWlsdEluUHJvcChQcm9taXNlLFwiYWxsXCIsZnVuY3Rpb24gUHJvbWlzZSRhbGwoYXJyKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgIC8vIHNwZWMgbWFuZGF0ZWQgY2hlY2tzXG4gICAgaWYgKFRvU3RyaW5nLmNhbGwoYXJyKSAhPSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgIHJldHVybiBDb25zdHJ1Y3Rvci5yZWplY3QoVHlwZUVycm9yKFwiTm90IGFuIGFycmF5XCIpKTtcbiAgICB9XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBDb25zdHJ1Y3Rvci5yZXNvbHZlKFtdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcbiAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlamVjdCAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoLCBtc2dzID0gQXJyYXkobGVuKSwgY291bnQgPSAwO1xuXG4gICAgICBpdGVyYXRlUHJvbWlzZXMoQ29uc3RydWN0b3IsYXJyLGZ1bmN0aW9uIHJlc29sdmVyKGlkeCxtc2cpIHtcbiAgICAgICAgbXNnc1tpZHhdID0gbXNnO1xuICAgICAgICBpZiAoKytjb3VudCA9PT0gbGVuKSB7XG4gICAgICAgICAgcmVzb2x2ZShtc2dzKTtcbiAgICAgICAgfVxuICAgICAgfSxyZWplY3QpO1xuICAgIH0pO1xuICB9KTtcblxuICBidWlsdEluUHJvcChQcm9taXNlLFwicmFjZVwiLGZ1bmN0aW9uIFByb21pc2UkcmFjZShhcnIpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgLy8gc3BlYyBtYW5kYXRlZCBjaGVja3NcbiAgICBpZiAoVG9TdHJpbmcuY2FsbChhcnIpICE9IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgcmV0dXJuIENvbnN0cnVjdG9yLnJlamVjdChUeXBlRXJyb3IoXCJOb3QgYW4gYXJyYXlcIikpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSxyZWplY3Qpe1xuICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgcmVqZWN0ICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixmdW5jdGlvbiByZXNvbHZlcihpZHgsbXNnKXtcbiAgICAgICAgcmVzb2x2ZShtc2cpO1xuICAgICAgfSxyZWplY3QpO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gUHJvbWlzZTtcbn1cblxudmFyIHJvb3QgPSB0eXBlb2YgZ2xvYmFsID09PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbFxuY29uc3QgX1Byb21pc2UgPSAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnID8gUHJvbWlzZSA6IHByb21pc2VGYWN0b3J5KCkpXG5yb290LlByb21pc2UgPSByb290LlByb21pc2UgfHwgX1Byb21pc2VcbmV4cG9ydCBkZWZhdWx0IF9Qcm9taXNlXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC92ZW5kb3IvcHJvbWlzZS5qcyIsInZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9ub2RlX21vZHVsZXMvdXJsL3VybC5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0ge1wicGVzZGsuYWRqdXN0bWVudHMudGV4dC5icmlnaHRuZXNzXCI6XCJjb250cm9scy5hZGp1c3RtZW50cy5icmlnaHRuZXNzXCIsXCJwZXNkay5hZGp1c3RtZW50cy50ZXh0LmNsYXJpdHlcIjpcImNvbnRyb2xzLmFkanVzdG1lbnRzLmNsYXJpdHlcIixcInBlc2RrLmFkanVzdG1lbnRzLnRleHQuY29udHJhc3RcIjpcImNvbnRyb2xzLmFkanVzdG1lbnRzLmNvbnRyYXN0XCIsXCJwZXNkay5hZGp1c3RtZW50cy50ZXh0LmV4cG9zdXJlXCI6XCJjb250cm9scy5hZGp1c3RtZW50cy5leHBvc3VyZVwiLFwicGVzZGsuYWRqdXN0bWVudHMudGV4dC5nYW1tYVwiOlwiY29udHJvbHMuYWRqdXN0bWVudHMuZ2FtbWFcIixcInBlc2RrLmFkanVzdG1lbnRzLnRleHQuaGlnaGxpZ2h0c1wiOlwiY29udHJvbHMuYWRqdXN0bWVudHMuaGlnaGxpZ2h0c1wiLFwicGVzZGsuYWRqdXN0bWVudHMudGV4dC5zYXR1cmF0aW9uXCI6XCJjb250cm9scy5hZGp1c3RtZW50cy5zYXR1cmF0aW9uXCIsXCJwZXNkay5hZGp1c3RtZW50cy50ZXh0LnNoYWRvd3NcIjpcImNvbnRyb2xzLmFkanVzdG1lbnRzLnNoYWRvd3NcIixcInBlc2RrLmFkanVzdG1lbnRzLnRpdGxlLm5hbWVcIjpcImNvbnRyb2xzLm92ZXJ2aWV3LmFkanVzdG1lbnRzXCIsXCJwZXNkay5icnVzaC50ZXh0LnNpemVcIjpcImNvbnRyb2xzLmJydXNoLnNpemVcIixcInBlc2RrLmJydXNoLnRpdGxlLm5hbWVcIjpcImNvbnRyb2xzLm92ZXJ2aWV3LmJydXNoXCIsXCJwZXNkay5jYW1lcmEudGV4dC53ZWJjYW1VbmF2YWlsYWJsZVwiOlwiZXJyb3JzLndlYmNhbVVuYXZhaWxhYmxlLnRleHRcIixcInBlc2RrLmNhbWVyYS50aXRsZS5oZWFkbGluZVwiOlwid2ViY2FtLmhlYWRsaW5lXCIsXCJwZXNkay5jb21tb24uYnV0dG9uLmJhY2tcIjpcImdlbmVyaWMuYmFja1wiLFwicGVzZGsuY29tbW9uLmJ1dHRvbi5jYW5jZWxcIjpcImdlbmVyaWMuY2FuY2VsXCIsXCJwZXNkay5jb21tb24udGV4dC5jb2xvclwiOlwiZ2VuZXJpYy5jb2xvclwiLFwicGVzZGsuY29tbW9uLnRleHQuaW1hZ2VMb2FkRmFpbGVkXCI6XCJlcnJvcnMuaW1hZ2VMb2FkRmFpbGVkLnRleHRcIixcInBlc2RrLmNvbW1vbi50ZXh0LmxvYWRpbmdcIjpcImxvYWRpbmcubG9hZGluZ1wiLFwicGVzZGsuY29tbW9uLnRpdGxlLmVycm9yXCI6XCJlcnJvcnMudGl0bGVcIixcInBlc2RrLmNvbW1vbi50aXRsZS5pbWFnZUxvYWRGYWlsZWRcIjpcImVycm9ycy5pbWFnZUxvYWRGYWlsZWQudGl0bGVcIixcInBlc2RrLmVkaXRvci5idXR0b24uYmFja2dyb3VuZEltYWdlXCI6XCJlZGl0b3IuYmFja2dyb3VuZEltYWdlXCIsXCJwZXNkay5lZGl0b3IuYnV0dG9uLmV4cG9ydFwiOlwiZWRpdG9yLmV4cG9ydFwiLFwicGVzZGsuZWRpdG9yLmJ1dHRvbi5uZXdcIjpcImVkaXRvci5uZXdcIixcInBlc2RrLmVkaXRvci5idXR0b24udW5kb1wiOlwiZWRpdG9yLnVuZG9cIixcInBlc2RrLmVkaXRvci50ZXh0LmV4cG9ydGluZ1wiOlwibG9hZGluZy5leHBvcnRpbmdcIixcInBlc2RrLmVkaXRvci50ZXh0LmltYWdlUmVzaXplZF9tYXhEaW1lbnNpb25zXCI6XCJ3YXJuaW5nLmltYWdlUmVzaXplZF9tYXhEaW1lbnNpb25zLnRleHRcIixcInBlc2RrLmVkaXRvci50ZXh0LmltYWdlUmVzaXplZF9tYXhNZWdhUGl4ZWxzXCI6XCJ3YXJuaW5nLmltYWdlUmVzaXplZF9tYXhNZWdhUGl4ZWxzLnRleHRcIixcInBlc2RrLmVkaXRvci50ZXh0LmludmFsaWRGaWxlVHlwZVwiOlwiZXJyb3JzLmludmFsaWRGaWxlVHlwZS50ZXh0XCIsXCJwZXNkay5lZGl0b3IudGV4dC5yZW5kZXJpbmdFcnJvclwiOlwiZXJyb3IucmVuZGVyaW5nRXJyb3IudGV4dFwiLFwicGVzZGsuZWRpdG9yLnRleHQucmVzaXppbmdcIjpcImxvYWRpbmcucmVzaXppbmdcIixcInBlc2RrLmVkaXRvci50aXRsZS5pbWFnZVJlc2l6ZWRfbWF4RGltZW5zaW9uc1wiOlwid2FybmluZ3MuaW1hZ2VSZXNpemVkX21heERpbWVuc2lvbnMudGl0bGVcIixcInBlc2RrLmVkaXRvci50aXRsZS5pbWFnZVJlc2l6ZWRfbWF4TWVnYVBpeGVsc1wiOlwid2FybmluZ3MuaW1hZ2VSZXNpemVkX21heE1lZ2FQaXhlbHMudGl0bGVcIixcInBlc2RrLmVkaXRvci50aXRsZS5yZW5kZXJpbmdFcnJvclwiOlwiZXJyb3JzLnJlbmRlcmluZ0Vycm9yLnRpdGxlXCIsXCJwZXNkay5lZGl0b3IudGl0bGUuem9vbVwiOlwiZWRpdG9yLnpvb21cIixcInBlc2RrLmZpbHRlci5hc3NldC5hbGxcIjpcImNvbnRyb2xzLmZpbHRlci5jYXRlZ29yaWVzLmFsbFwiLFwicGVzZGsuZmlsdGVyLmFzc2V0LmlkZW50aXR5XCI6XCJjb250cm9scy5maWx0ZXIuZmlsdGVycy5pZGVudGl0eVwiLFwicGVzZGsuZmlsdGVyLmFzc2V0LmltZ2x5X2ZpbHRlcnNfYW5hbG9nXCI6XCJjb250cm9scy5maWx0ZXIuY2F0ZWdvcmllcy5pbWdseV9maWx0ZXJzX2FuYWxvZ1wiLFwicGVzZGsuZmlsdGVyLmFzc2V0LmltZ2x5X2ZpbHRlcnNfYndcIjpcImNvbnRyb2xzLmZpbHRlci5jYXRlZ29yaWVzLmltZ2x5X2ZpbHRlcnNfYndcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9maWx0ZXJzX3JldHJvXCI6XCJjb250cm9scy5maWx0ZXIuY2F0ZWdvcmllcy5pbWdseV9maWx0ZXJzX3JldHJvXCIsXCJwZXNkay5maWx0ZXIuYXNzZXQuaW1nbHlfZmlsdGVyc19zcGVjaWFsXCI6XCJjb250cm9scy5maWx0ZXIuY2F0ZWdvcmllcy5pbWdseV9maWx0ZXJzX3NwZWNpYWxcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9maWx0ZXJzX3N1bW1lclwiOlwiY29udHJvbHMuZmlsdGVyLmNhdGVnb3JpZXMuaW1nbHlfZmlsdGVyc19zdW1tZXJcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9maWx0ZXJzX3dpbnRlclwiOlwiY29udHJvbHMuZmlsdGVyLmNhdGVnb3JpZXMuaW1nbHlfZmlsdGVyc193aW50ZXJcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfYWQxOTIwXCI6XCJjb250cm9scy5maWx0ZXIuZmlsdGVycy5pbWdseV9sdXRfYWQxOTIwXCIsXCJwZXNkay5maWx0ZXIuYXNzZXQuaW1nbHlfbHV0X2FuY2llbnRcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF9hbmNpZW50XCIsXCJwZXNkay5maWx0ZXIuYXNzZXQuaW1nbHlfbHV0X2JsZWFjaGVkXCI6XCJjb250cm9scy5maWx0ZXIuZmlsdGVycy5pbWdseV9sdXRfYmxlYWNoZWRcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfYmxlYWNoZWRibHVlXCI6XCJjb250cm9scy5maWx0ZXIuZmlsdGVycy5pbWdseV9sdXRfYmxlYWNoZWRibHVlXCIsXCJwZXNkay5maWx0ZXIuYXNzZXQuaW1nbHlfbHV0X2JsdWVzXCI6XCJjb250cm9scy5maWx0ZXIuZmlsdGVycy5pbWdseV9sdXRfYmx1ZXNcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfYmx1ZXNoYWRvd3NcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF9ibHVlc2hhZG93c1wiLFwicGVzZGsuZmlsdGVyLmFzc2V0LmltZ2x5X2x1dF9icmVlemVcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF9icmVlemVcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfYndcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF9id1wiLFwicGVzZGsuZmlsdGVyLmFzc2V0LmltZ2x5X2x1dF9jZWxzaXVzXCI6XCJjb250cm9scy5maWx0ZXIuZmlsdGVycy5pbWdseV9sdXRfY2Vsc2l1c1wiLFwicGVzZGsuZmlsdGVyLmFzc2V0LmltZ2x5X2x1dF9jaGVzdFwiOlwiY29udHJvbHMuZmlsdGVyLmZpbHRlcnMuaW1nbHlfbHV0X2NoZXN0XCIsXCJwZXNkay5maWx0ZXIuYXNzZXQuaW1nbHlfbHV0X2NsYXNzaWNcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF9jbGFzc2ljXCIsXCJwZXNkay5maWx0ZXIuYXNzZXQuaW1nbHlfbHV0X2NvbG9yZnVsXCI6XCJjb250cm9scy5maWx0ZXIuZmlsdGVycy5pbWdseV9sdXRfY29sb3JmdWxcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfY29vbFwiOlwiY29udHJvbHMuZmlsdGVyLmZpbHRlcnMuaW1nbHlfbHV0X2Nvb2xcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfY290dG9uY2FuZHlcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF9jb3R0b25jYW5keVwiLFwicGVzZGsuZmlsdGVyLmFzc2V0LmltZ2x5X2x1dF9jcmVhbXlcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF9jcmVhbXlcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfZWlnaHRpZXNcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF9laWdodGllc1wiLFwicGVzZGsuZmlsdGVyLmFzc2V0LmltZ2x5X2x1dF9lbGRlclwiOlwiY29udHJvbHMuZmlsdGVyLmZpbHRlcnMuaW1nbHlfbHV0X2VsZGVyXCIsXCJwZXNkay5maWx0ZXIuYXNzZXQuaW1nbHlfbHV0X2V2ZW5pbmdcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF9ldmVuaW5nXCIsXCJwZXNkay5maWx0ZXIuYXNzZXQuaW1nbHlfbHV0X2ZhbGxcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF9mYWxsXCIsXCJwZXNkay5maWx0ZXIuYXNzZXQuaW1nbHlfbHV0X2ZpeGllXCI6XCJjb250cm9scy5maWx0ZXIuZmlsdGVycy5pbWdseV9sdXRfZml4aWVcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfZm9vZFwiOlwiY29udHJvbHMuZmlsdGVyLmZpbHRlcnMuaW1nbHlfbHV0X2Zvb2RcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfZnJpZGdlXCI6XCJjb250cm9scy5maWx0ZXIuZmlsdGVycy5pbWdseV9sdXRfZnJpZGdlXCIsXCJwZXNkay5maWx0ZXIuYXNzZXQuaW1nbHlfbHV0X2Zyb250XCI6XCJjb250cm9scy5maWx0ZXIuZmlsdGVycy5pbWdseV9sdXRfZnJvbnRcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfZ2xhbVwiOlwiY29udHJvbHMuZmlsdGVyLmZpbHRlcnMuaW1nbHlfbHV0X2dsYW1cIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfZ29iYmxpblwiOlwiY29udHJvbHMuZmlsdGVyLmZpbHRlcnMuaW1nbHlfbHV0X2dvYmJsaW5cIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfaGlnaGNhcmJcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF9oaWdoY2FyYlwiLFwicGVzZGsuZmlsdGVyLmFzc2V0LmltZ2x5X2x1dF9oaWdoY29udHJhc3RcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF9oaWdoY29udHJhc3RcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfazFcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF9rMVwiLFwicGVzZGsuZmlsdGVyLmFzc2V0LmltZ2x5X2x1dF9rMlwiOlwiY29udHJvbHMuZmlsdGVyLmZpbHRlcnMuaW1nbHlfbHV0X2syXCIsXCJwZXNkay5maWx0ZXIuYXNzZXQuaW1nbHlfbHV0X2s2XCI6XCJjb250cm9scy5maWx0ZXIuZmlsdGVycy5pbWdseV9sdXRfazZcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfa2R5bmFtaWNcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF9rZHluYW1pY1wiLFwicGVzZGsuZmlsdGVyLmFzc2V0LmltZ2x5X2x1dF9rZWVuXCI6XCJjb250cm9scy5maWx0ZXIuZmlsdGVycy5pbWdseV9sdXRfa2VlblwiLFwicGVzZGsuZmlsdGVyLmFzc2V0LmltZ2x5X2x1dF9sZW5pblwiOlwiY29udHJvbHMuZmlsdGVyLmZpbHRlcnMuaW1nbHlfbHV0X2xlbmluXCIsXCJwZXNkay5maWx0ZXIuYXNzZXQuaW1nbHlfbHV0X2xpdGhvXCI6XCJjb250cm9scy5maWx0ZXIuZmlsdGVycy5pbWdseV9sdXRfbGl0aG9cIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfbG9tbzEwMFwiOlwiY29udHJvbHMuZmlsdGVyLmZpbHRlcnMuaW1nbHlfbHV0X2xvbW8xMDBcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfbHVjaWRcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF9sdWNpZFwiLFwicGVzZGsuZmlsdGVyLmFzc2V0LmltZ2x5X2x1dF9tZWxsb3dcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF9tZWxsb3dcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfbmVhdFwiOlwiY29udHJvbHMuZmlsdGVyLmZpbHRlcnMuaW1nbHlfbHV0X25lYXRcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfbm9ncmVlblwiOlwiY29udHJvbHMuZmlsdGVyLmZpbHRlcnMuaW1nbHlfbHV0X25vZ3JlZW5cIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfb3JjaGlkXCI6XCJjb250cm9scy5maWx0ZXIuZmlsdGVycy5pbWdseV9sdXRfb3JjaGlkXCIsXCJwZXNkay5maWx0ZXIuYXNzZXQuaW1nbHlfbHV0X3BhbGVcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF9wYWxlXCIsXCJwZXNkay5maWx0ZXIuYXNzZXQuaW1nbHlfbHV0X3BpdGNoZWRcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF9waXRjaGVkXCIsXCJwZXNkay5maWx0ZXIuYXNzZXQuaW1nbHlfbHV0X3BsYXRlXCI6XCJjb250cm9scy5maWx0ZXIuZmlsdGVycy5pbWdseV9sdXRfcGxhdGVcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfcG9sYTY2OVwiOlwiY29udHJvbHMuZmlsdGVyLmZpbHRlcnMuaW1nbHlfbHV0X3BvbGE2NjlcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfcG9sYXN4XCI6XCJjb250cm9scy5maWx0ZXIuZmlsdGVycy5pbWdseV9sdXRfcG9sYXN4XCIsXCJwZXNkay5maWx0ZXIuYXNzZXQuaW1nbHlfbHV0X3BybzQwMFwiOlwiY29udHJvbHMuZmlsdGVyLmZpbHRlcnMuaW1nbHlfbHV0X3BybzQwMFwiLFwicGVzZGsuZmlsdGVyLmFzc2V0LmltZ2x5X2x1dF9xdW96aVwiOlwiY29udHJvbHMuZmlsdGVyLmZpbHRlcnMuaW1nbHlfbHV0X3F1b3ppXCIsXCJwZXNkay5maWx0ZXIuYXNzZXQuaW1nbHlfbHV0X3NlcGlhaGlnaFwiOlwiY29udHJvbHMuZmlsdGVyLmZpbHRlcnMuaW1nbHlfbHV0X3NlcGlhaGlnaFwiLFwicGVzZGsuZmlsdGVyLmFzc2V0LmltZ2x5X2x1dF9zZXR0bGVkXCI6XCJjb250cm9scy5maWx0ZXIuZmlsdGVycy5pbWdseV9sdXRfc2V0dGxlZFwiLFwicGVzZGsuZmlsdGVyLmFzc2V0LmltZ2x5X2x1dF9zZXZlbnRpZXNcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF9zZXZlbnRpZXNcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfc2luXCI6XCJjb250cm9scy5maWx0ZXIuZmlsdGVycy5pbWdseV9sdXRfc2luXCIsXCJwZXNkay5maWx0ZXIuYXNzZXQuaW1nbHlfbHV0X3NvZnRcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF9zb2Z0XCIsXCJwZXNkay5maWx0ZXIuYXNzZXQuaW1nbHlfbHV0X3N0ZWVsXCI6XCJjb250cm9scy5maWx0ZXIuZmlsdGVycy5pbWdseV9sdXRfc3RlZWxcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfc3VtbWVyXCI6XCJjb250cm9scy5maWx0ZXIuZmlsdGVycy5pbWdseV9sdXRfc3VtbWVyXCIsXCJwZXNkay5maWx0ZXIuYXNzZXQuaW1nbHlfbHV0X3N1bnNldFwiOlwiY29udHJvbHMuZmlsdGVyLmZpbHRlcnMuaW1nbHlfbHV0X3N1bnNldFwiLFwicGVzZGsuZmlsdGVyLmFzc2V0LmltZ2x5X2x1dF90ZW5kZXJcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF90ZW5kZXJcIixcInBlc2RrLmZpbHRlci5hc3NldC5pbWdseV9sdXRfdGV4YXNcIjpcImNvbnRyb2xzLmZpbHRlci5maWx0ZXJzLmltZ2x5X2x1dF90ZXhhc1wiLFwicGVzZGsuZmlsdGVyLmFzc2V0LmltZ2x5X2x1dF90d2lsaWdodFwiOlwiY29udHJvbHMuZmlsdGVyLmZpbHRlcnMuaW1nbHlfbHV0X3R3aWxpZ2h0XCIsXCJwZXNkay5maWx0ZXIuYXNzZXQuaW1nbHlfbHV0X3dpbnRlclwiOlwiY29udHJvbHMuZmlsdGVyLmZpbHRlcnMuaW1nbHlfbHV0X3dpbnRlclwiLFwicGVzZGsuZmlsdGVyLmFzc2V0LmltZ2x5X2x1dF94NDAwXCI6XCJjb250cm9scy5maWx0ZXIuZmlsdGVycy5pbWdseV9sdXRfeDQwMFwiLFwicGVzZGsuZmlsdGVyLnRleHQuaW50ZW5zaXR5XCI6XCJjb250cm9scy5maWx0ZXIuaW50ZW5zaXR5XCIsXCJwZXNkay5maWx0ZXIudGl0bGUubmFtZVwiOlwiY29udHJvbHMub3ZlcnZpZXcuZmlsdGVyc1wiLFwicGVzZGsuZm9jdXMuYnV0dG9uLm1pcnJvcmVkXCI6XCJjb250cm9scy5mb2N1cy5taXJyb3JlZFwiLFwicGVzZGsuZm9jdXMuYnV0dG9uLm5vbmVcIjpcImNvbnRyb2xzLmZvY3VzLm5vbmVcIixcInBlc2RrLmZvY3VzLmJ1dHRvbi5yYWRpYWxcIjpcImNvbnRyb2xzLmZvY3VzLnJhZGlhbFwiLFwicGVzZGsuZm9jdXMudGV4dC5ibHVyUmFkaXVzXCI6XCJjb250cm9scy5mb2N1cy5ibHVyUmFkaXVzXCIsXCJwZXNkay5mb2N1cy50aXRsZS5uYW1lXCI6XCJjb250cm9scy5vdmVydmlldy5mb2N1c1wiLFwicGVzZGsuZnJhbWUuYXNzZXQuaW1nbHlfZnJhbWVfYXJ0X2RlY29yXCI6XCJjb250cm9scy5mcmFtZS5mcmFtZXMuaW1nbHlfZnJhbWVfYXJ0X2RlY29yXCIsXCJwZXNkay5mcmFtZS5hc3NldC5pbWdseV9mcmFtZV9ibGFja19wYXNzZXBhcnRvdXRcIjpcImNvbnRyb2xzLmZyYW1lLmZyYW1lcy5pbWdseV9mcmFtZV9ibGFja19wYXNzZXBhcnRvdXRcIixcInBlc2RrLmZyYW1lLmFzc2V0LmltZ2x5X2ZyYW1lX2RpYVwiOlwiY29udHJvbHMuZnJhbWUuZnJhbWVzLmltZ2x5X2ZyYW1lX2RpYVwiLFwicGVzZGsuZnJhbWUuYXNzZXQuaW1nbHlfZnJhbWVfbG93cG9seV9zaGFkb3dcIjpcImNvbnRyb2xzLmZyYW1lLmZyYW1lcy5pbWdseV9mcmFtZV9sb3dwb2x5X3NoYWRvd1wiLFwicGVzZGsuZnJhbWUuYXNzZXQuaW1nbHlfZnJhbWVfd29vZF9wYXNzZXBhcnRvdXRcIjpcImNvbnRyb2xzLmZyYW1lLmZyYW1lcy5pbWdseV9mcmFtZV93b29kX3Bhc3NlcGFydG91dFwiLFwicGVzZGsuZnJhbWUuYnV0dG9uLm5vbmVcIjpcImNvbnRyb2xzLmZyYW1lLm5vRnJhbWVcIixcInBlc2RrLmZyYW1lLnRleHQuc2NhbGVcIjpcImNvbnRyb2xzLmZyYW1lLnNjYWxlXCIsXCJwZXNkay5mcmFtZS50aXRsZS5uYW1lXCI6XCJjb250cm9scy5vdmVydmlldy5mcmFtZVwiLFwicGVzZGsubGlicmFyeS5wbGFjZWhvbGRlci5zZWFyY2hcIjpcInBob3RvUm9sbC5zZWFyY2gucGxhY2Vob2xkZXJcIixcInBlc2RrLmxpYnJhcnkudGV4dC5ub1NlYXJjaFJlc3VsdHNcIjpcInBob3RvUm9sbC5zZWFyY2gubm9TZWFyY2hSZXN1bHRzXCIsXCJwZXNkay5saWJyYXJ5LnRleHQucGhvdG9Sb2xsTG9hZEZhaWxcIjpcImVycm9ycy5waG90b1JvbGxMb2FkRmFpbC50ZXh0XCIsXCJwZXNkay5saWJyYXJ5LnRpdGxlLnBob3RvUm9sbExvYWRGYWlsXCI6XCJlcnJvcnMucGhvdG9Sb2xsTG9hZEZhaWwudGl0bGVcIixcInBlc2RrLmxpYnJhcnkudGl0bGUuc2VhY2hSZXN1bHRzXCI6XCJwaG90b1JvbGwuc2VhcmNoLnJlc3VsdHMuaGVhZGxpbmVcIixcInBlc2RrLnNwbGFzaC5idXR0b24udXBsb2FkXCI6XCJzcGxhc2gudXBsb2FkLmJ1dHRvblwiLFwicGVzZGsuc3BsYXNoLnRleHQucGhvdG9Sb2xsXCI6XCJzcGxhc2gucGhvdG9Sb2xsLmRlc2NyaXB0aW9uXCIsXCJwZXNkay5zcGxhc2gudGV4dC51cGxvYWRcIjpcInNwbGFzaC51cGxvYWQuZGVzY3JpcHRpb25cIixcInBlc2RrLnNwbGFzaC50ZXh0LndlYmNhbVwiOlwic3BsYXNoLndlYmNhbS5kZXNjcmlwdGlvblwiLFwicGVzZGsuc3BsYXNoLnRpdGxlLnBob3RvUm9sbFwiOlwic3BsYXNoLnBob3RvUm9sbC5oZWFkbGluZVwiLFwicGVzZGsuc3BsYXNoLnRpdGxlLndlYmNhbVwiOlwic3BsYXNoLndlYmNhbS5oZWFkbGluZVwiLFwicGVzZGsuc3RpY2tlci5hc3NldC5pbWdseV9zdGlja2VyX2Vtb3RpY29uc1wiOlwiY29udHJvbHMuc3RpY2tlci5jYXRlZ29yaWVzLmltZ2x5X3N0aWNrZXJfZW1vdGljb25zXCIsXCJwZXNkay5zdGlja2VyLmFzc2V0LmltZ2x5X3N0aWNrZXJfc2hhcGVzXCI6XCJjb250cm9scy5zdGlja2VyLmNhdGVnb3JpZXMuaW1nbHlfc3RpY2tlcl9zaGFwZXNcIixcInBlc2RrLnN0aWNrZXIudGl0bGUubG9hZGluZ1N0aWNrZXJzRmFpbGVkXCI6XCJlcnJvcnMubG9hZGluZ1N0aWNrZXJzRmFpbGVkLnRpdGxlXCIsXCJwZXNkay5zdGlja2VyLnRpdGxlLm5hbWVcIjpcImNvbnRyb2xzLm92ZXJ2aWV3LnN0aWNrZXJcIixcInBlc2RrLnRleHQuYnV0dG9uLmFsaWdubWVudFwiOlwiY29udHJvbHMudGV4dC5hbGlnbm1lbnRcIixcInBlc2RrLnRleHQuYnV0dG9uLmJhY2tncm91bmRcIjpcImNvbnRyb2xzLnRleHQuYmFja2dyb3VuZFwiLFwicGVzZGsudGV4dC5idXR0b24uZm9udFwiOlwiY29udHJvbHMudGV4dC5mb250XCIsXCJwZXNkay50ZXh0LmJ1dHRvbi5mb3JlZ3JvdW5kXCI6XCJjb250cm9scy50ZXh0LmZvcmVncm91bmRcIixcInBlc2RrLnRleHQuYnV0dG9uLnNpemVcIjpcImNvbnRyb2xzLnRleHQuc2l6ZVwiLFwicGVzZGsudGV4dC5idXR0b24udGFrZVRvRnJvbnRcIjpcImNvbnRyb2xzLnRleHQudGFrZVRvRnJvbnRcIixcInBlc2RrLnRleHQucGxhY2Vob2xkZXIuZGVmYXVsdFRleHRcIjpcImNvbnRyb2xzLnRleHQuZGVmYXVsdFRleHRcIixcInBlc2RrLnRleHQudGV4dC5sb2FkaW5nRm9udHNGYWlsZWRcIjpcImVycm9ycy5sb2FkaW5nRm9udHNGYWlsZWQudGV4dFwiLFwicGVzZGsudGV4dC50aXRsZS5sb2FkaW5nRm9udHNGYWlsZWRcIjpcImVycm9ycy5sb2FkaW5nRm9udHNGYWlsZWQudGl0bGVcIixcInBlc2RrLnRleHQudGl0bGUubmFtZVwiOlwiY29udHJvbHMub3ZlcnZpZXcudGV4dFwiLFwicGVzZGsudHJhbnNmb3JtLmFzc2V0LmltZ2x5X3RyYW5zZm9ybV9jb21tb25fMTYtOVwiOlwiY29udHJvbHMudHJhbnNmb3JtLnJhdGlvcy5pbWdseV90cmFuc2Zvcm1fY29tbW9uXzE2LTlcIixcInBlc2RrLnRyYW5zZm9ybS5hc3NldC5pbWdseV90cmFuc2Zvcm1fY29tbW9uXzQtM1wiOlwiY29udHJvbHMudHJhbnNmb3JtLnJhdGlvcy5pbWdseV90cmFuc2Zvcm1fY29tbW9uXzQtM1wiLFwicGVzZGsudHJhbnNmb3JtLmFzc2V0LmltZ2x5X3RyYW5zZm9ybV9jb21tb25fY3VzdG9tXCI6XCJjb250cm9scy50cmFuc2Zvcm0ucmF0aW9zLmltZ2x5X3RyYW5zZm9ybV9jb21tb25fY3VzdG9tXCIsXCJwZXNkay50cmFuc2Zvcm0uYXNzZXQuaW1nbHlfdHJhbnNmb3JtX2NvbW1vbl9zcXVhcmVcIjpcImNvbnRyb2xzLnRyYW5zZm9ybS5yYXRpb3MuaW1nbHlfdHJhbnNmb3JtX2NvbW1vbl9zcXVhcmVcIixcInBlc2RrLnRyYW5zZm9ybS5hc3NldC5pbWdseV90cmFuc2Zvcm1fZmFjZWJvb2tfYWRcIjpcImNvbnRyb2xzLnRyYW5zZm9ybS5yYXRpb3MuaW1nbHlfdHJhbnNmb3JtX2ZhY2Vib29rX2FkXCIsXCJwZXNkay50cmFuc2Zvcm0uYXNzZXQuaW1nbHlfdHJhbnNmb3JtX2ZhY2Vib29rX2NvdmVyXCI6XCJjb250cm9scy50cmFuc2Zvcm0ucmF0aW9zLmltZ2x5X3RyYW5zZm9ybV9mYWNlYm9va19jb3ZlclwiLFwicGVzZGsudHJhbnNmb3JtLmFzc2V0LmltZ2x5X3RyYW5zZm9ybV9mYWNlYm9va19wb3N0XCI6XCJjb250cm9scy50cmFuc2Zvcm0ucmF0aW9zLmltZ2x5X3RyYW5zZm9ybV9mYWNlYm9va19wb3N0XCIsXCJwZXNkay50cmFuc2Zvcm0uYXNzZXQuaW1nbHlfdHJhbnNmb3JtX2ZhY2Vib29rX3Byb2ZpbGVcIjpcImNvbnRyb2xzLnRyYW5zZm9ybS5yYXRpb3MuaW1nbHlfdHJhbnNmb3JtX2ZhY2Vib29rX3Byb2ZpbGVcIixcInBlc2RrLnRyYW5zZm9ybS5idXR0b24ubm9uZVwiOlwiY29udHJvbHMudHJhbnNmb3JtLm5vbmVcIixcInBlc2RrLnRyYW5zZm9ybS50ZXh0LnJvdGF0aW9uXCI6XCJjb250cm9scy50cmFuc2Zvcm0ucm90YXRpb25cIixcInBlc2RrLnRyYW5zZm9ybS50aXRsZS5uYW1lXCI6XCJjb250cm9scy5vdmVydmlldy50cmFuc2Zvcm1cIn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9uZXctdG8tb2xkLWxvY2FsaXphdGlvbi1rZXktbWFwLmpzb25cbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgUGhvdG9FZGl0b3JTREsgZnJvbSAncGhvdG9lZGl0b3JzZGsnXG5cbmNvbnN0IGZvbnRzID0gW1xuICB7XG4gICAgZm9udEZhbWlseTogJ0FsZW8nLFxuICAgIHZhcmlhdGlvbnM6IFtcbiAgICAgIHtcbiAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2ZvbnRfYWxlb19ib2xkJyxcbiAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgICBwcm92aWRlcjogJ2ZpbGUnLFxuICAgICAgICBmaWxlUGF0aDogJ2ZvbnRzL2ltZ2x5X2ZvbnRfYWxlb19ib2xkLndvZmYnLFxuICAgICAgICB0ZXh0TWV0cmljczoge1xuICAgICAgICAgIHVuaXRzUGVyRW06IDIwNDgsXG4gICAgICAgICAgYXNjZW5kZXI6IDE5MTksXG4gICAgICAgICAgZGVzY2VuZGVyOiAtNDA5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBmb250RmFtaWx5OiAnQW1hdGljIFNDJyxcbiAgICB2YXJpYXRpb25zOiBbXG4gICAgICB7XG4gICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9mb250X2FtYXRpY3NjJyxcbiAgICAgICAgZm9udFdlaWdodDogJ25vcm1hbCcsXG4gICAgICAgIHByb3ZpZGVyOiAnZmlsZScsXG4gICAgICAgIGZpbGVQYXRoOiAnZm9udHMvaW1nbHlfZm9udF9hbWF0aWNzYy53b2ZmJyxcbiAgICAgICAgdGV4dE1ldHJpY3M6IHtcbiAgICAgICAgICB1bml0c1BlckVtOiAyMDQ4LFxuICAgICAgICAgIGFzY2VuZGVyOiAyMzMyLFxuICAgICAgICAgIGRlc2NlbmRlcjogLTU4M1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgZm9udEZhbWlseTogJ0Jlcm5pZXInLFxuICAgIHZhcmlhdGlvbnM6IFtcbiAgICAgIHtcbiAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2ZvbnRfYmVybmllcl9yZWd1bGFyJyxcbiAgICAgICAgZm9udFdlaWdodDogJ25vcm1hbCcsXG4gICAgICAgIHByb3ZpZGVyOiAnZmlsZScsXG4gICAgICAgIGZpbGVQYXRoOiAnZm9udHMvaW1nbHlfZm9udF9iZXJuaWVyX3JlZ3VsYXIud29mZicsXG4gICAgICAgIHRleHRNZXRyaWNzOiB7XG4gICAgICAgICAgdW5pdHNQZXJFbTogMjA0OCxcbiAgICAgICAgICBhc2NlbmRlcjogMjAwNyxcbiAgICAgICAgICBkZXNjZW5kZXI6IC01NTJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIGZvbnRGYW1pbHk6ICdDaGVxdWUnLFxuICAgIHZhcmlhdGlvbnM6IFtcbiAgICAgIHtcbiAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2ZvbnRfY2hlcXVlX3JlZ3VsYXInLFxuICAgICAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgICAgICAgcHJvdmlkZXI6ICdmaWxlJyxcbiAgICAgICAgZmlsZVBhdGg6ICdmb250cy9pbWdseV9mb250X2NoZXF1ZV9yZWd1bGFyLndvZmYnLFxuICAgICAgICB0ZXh0TWV0cmljczoge1xuICAgICAgICAgIHVuaXRzUGVyRW06IDIwNDgsXG4gICAgICAgICAgYXNjZW5kZXI6IDE4NTMsXG4gICAgICAgICAgZGVzY2VuZGVyOiAtNDk1XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBmb250RmFtaWx5OiAnT3BlbiBTYW5zJyxcbiAgICB2YXJpYXRpb25zOiBbXG4gICAgICB7XG4gICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9mb250X29wZW5fc2Fuc19ib2xkJyxcbiAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgICBwcm92aWRlcjogJ2ZpbGUnLFxuICAgICAgICBmaWxlUGF0aDogJ2ZvbnRzL2ltZ2x5X2ZvbnRfb3Blbl9zYW5zX2JvbGQud29mZicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIHRleHRNZXRyaWNzOiB7XG4gICAgICAgICAgdW5pdHNQZXJFbTogMjA0OCxcbiAgICAgICAgICBhc2NlbmRlcjogMjE4OSxcbiAgICAgICAgICBkZXNjZW5kZXI6IC02NDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIGZvbnRGYW1pbHk6ICdHYWdhbGluJyxcbiAgICB2YXJpYXRpb25zOiBbXG4gICAgICB7XG4gICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9mb250X2dhZ2FsaW5fcmVndWxhcicsXG4gICAgICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuICAgICAgICBwcm92aWRlcjogJ2ZpbGUnLFxuICAgICAgICBmaWxlUGF0aDogJ2ZvbnRzL2ltZ2x5X2ZvbnRfZ2FnYWxpbl9yZWd1bGFyLndvZmYnLFxuICAgICAgICB0ZXh0TWV0cmljczoge1xuICAgICAgICAgIHVuaXRzUGVyRW06IDIwNDgsXG4gICAgICAgICAgYXNjZW5kZXI6IDE5ODcsXG4gICAgICAgICAgZGVzY2VuZGVyOiAtNjI4XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBmb250RmFtaWx5OiAnSGFnaW4nLFxuICAgIHZhcmlhdGlvbnM6IFtcbiAgICAgIHtcbiAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2ZvbnRfaGFnaW5fY2Fwc190aGluJyxcbiAgICAgICAgZm9udFdlaWdodDogMjAwLFxuICAgICAgICBwcm92aWRlcjogJ2ZpbGUnLFxuICAgICAgICBmaWxlUGF0aDogJ2ZvbnRzL2ltZ2x5X2ZvbnRfaGFnaW5fY2Fwc190aGluLndvZmYnLFxuICAgICAgICB0ZXh0TWV0cmljczoge1xuICAgICAgICAgIHVuaXRzUGVyRW06IDIwNDgsXG4gICAgICAgICAgYXNjZW5kZXI6IDE5NjQsXG4gICAgICAgICAgZGVzY2VuZGVyOiAtNDgyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBmb250RmFtaWx5OiAnSW50cm8nLFxuICAgIHZhcmlhdGlvbnM6IFtcbiAgICAgIHtcbiAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2ZvbnRfaW50cm9faW5saW5lJyxcbiAgICAgICAgZm9udFdlaWdodDogJ25vcm1hbCcsXG4gICAgICAgIHByb3ZpZGVyOiAnZmlsZScsXG4gICAgICAgIGZpbGVQYXRoOiAnZm9udHMvaW1nbHlfZm9udF9pbnRyb19pbmxpbmUud29mZicsXG4gICAgICAgIHRleHRNZXRyaWNzOiB7XG4gICAgICAgICAgdW5pdHNQZXJFbTogMjA0OCxcbiAgICAgICAgICBhc2NlbmRlcjogMTk0NCxcbiAgICAgICAgICBkZXNjZW5kZXI6IC01NDhcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIGZvbnRGYW1pbHk6ICdMb2JzdGVyJyxcbiAgICB2YXJpYXRpb25zOiBbXG4gICAgICB7XG4gICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9mb250X2xvYnN0ZXInLFxuICAgICAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgICAgICAgcHJvdmlkZXI6ICdmaWxlJyxcbiAgICAgICAgZmlsZVBhdGg6ICdmb250cy9pbWdseV9mb250X2xvYnN0ZXIud29mZicsXG4gICAgICAgIHRleHRNZXRyaWNzOiB7XG4gICAgICAgICAgdW5pdHNQZXJFbTogMjA0OCxcbiAgICAgICAgICBhc2NlbmRlcjogMjA0OCxcbiAgICAgICAgICBkZXNjZW5kZXI6IC01NTJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIGZvbnRGYW1pbHk6ICdOZXhhJyxcbiAgICB2YXJpYXRpb25zOiBbXG4gICAgICB7XG4gICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9mb250X25leGFfc2NyaXB0JyxcbiAgICAgICAgZm9udFdlaWdodDogJ25vcm1hbCcsXG4gICAgICAgIHByb3ZpZGVyOiAnZmlsZScsXG4gICAgICAgIGZpbGVQYXRoOiAnZm9udHMvaW1nbHlfZm9udF9uZXhhX3NjcmlwdC53b2ZmJyxcbiAgICAgICAgdGV4dE1ldHJpY3M6IHtcbiAgICAgICAgICB1bml0c1BlckVtOiAyMDQ4LFxuICAgICAgICAgIGFzY2VuZGVyOiAxODM1LFxuICAgICAgICAgIGRlc2NlbmRlcjogLTY2M1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgZm9udEZhbWlseTogJ09zdHJpY2gnLFxuICAgIHZhcmlhdGlvbnM6IFtcbiAgICAgIHtcbiAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2ZvbnRfb3N0cmljaF9zYW5zX2JsYWNrJyxcbiAgICAgICAgZm9udFdlaWdodDogODAwLFxuICAgICAgICBwcm92aWRlcjogJ2ZpbGUnLFxuICAgICAgICBmaWxlUGF0aDogJ2ZvbnRzL2ltZ2x5X2ZvbnRfb3N0cmljaF9zYW5zX2JsYWNrLndvZmYnLFxuICAgICAgICB0ZXh0TWV0cmljczoge1xuICAgICAgICAgIHVuaXRzUGVyRW06IDIwNDgsXG4gICAgICAgICAgYXNjZW5kZXI6IDE1MTMsXG4gICAgICAgICAgZGVzY2VuZGVyOiAtMjM1XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9mb250X29zdHJpY2hfc2Fuc19ib2xkJyxcbiAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgICBwcm92aWRlcjogJ2ZpbGUnLFxuICAgICAgICBmaWxlUGF0aDogJ2ZvbnRzL2ltZ2x5X2ZvbnRfb3N0cmljaF9zYW5zX2JvbGQud29mZicsXG4gICAgICAgIHRleHRNZXRyaWNzOiB7XG4gICAgICAgICAgdW5pdHNQZXJFbTogMjA0OCxcbiAgICAgICAgICBhc2NlbmRlcjogMTUxMyxcbiAgICAgICAgICBkZXNjZW5kZXI6IC0yMzVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIGZvbnRGYW1pbHk6ICdQYW50b24nLFxuICAgIHZhcmlhdGlvbnM6IFtcbiAgICAgIHtcbiAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2ZvbnRfcGFudG9uX2JsYWNrX2l0YWxpY19jYXBzJyxcbiAgICAgICAgZm9udFdlaWdodDogODAwLFxuICAgICAgICBmb250U3R5bGU6ICdpdGFsaWMnLFxuICAgICAgICBwcm92aWRlcjogJ2ZpbGUnLFxuICAgICAgICBmaWxlUGF0aDogJ2ZvbnRzL2ltZ2x5X2ZvbnRfcGFudG9uX2JsYWNraXRhbGljX2NhcHMud29mZicsXG4gICAgICAgIHRleHRNZXRyaWNzOiB7XG4gICAgICAgICAgdW5pdHNQZXJFbTogMjA0OCxcbiAgICAgICAgICBhc2NlbmRlcjogMjAzMyxcbiAgICAgICAgICBkZXNjZW5kZXI6IC01NzJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2ZvbnRfcGFudG9uX2xpZ2h0X2l0YWxpY19jYXBzJyxcbiAgICAgICAgZm9udFdlaWdodDogMjAwLFxuICAgICAgICBmb250U3R5bGU6ICdpdGFsaWMnLFxuICAgICAgICBwcm92aWRlcjogJ2ZpbGUnLFxuICAgICAgICBmaWxlUGF0aDogJ2ZvbnRzL2ltZ2x5X2ZvbnRfcGFudG9uX2xpZ2h0aXRhbGljX2NhcHMud29mZicsXG4gICAgICAgIHRleHRNZXRyaWNzOiB7XG4gICAgICAgICAgdW5pdHNQZXJFbTogMjA0OCxcbiAgICAgICAgICBhc2NlbmRlcjogMTk2MSxcbiAgICAgICAgICBkZXNjZW5kZXI6IC01NTZcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIGZvbnRGYW1pbHk6ICdQZXJmb2dyYW1hJyxcbiAgICB2YXJpYXRpb25zOiBbXG4gICAgICB7XG4gICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV9mb250X3BlcmZvZ3JhbWEnLFxuICAgICAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgICAgICAgcHJvdmlkZXI6ICdmaWxlJyxcbiAgICAgICAgZmlsZVBhdGg6ICdmb250cy9pbWdseV9mb250X3BlcmZvZ3JhbWEud29mZicsXG4gICAgICAgIHRleHRNZXRyaWNzOiB7XG4gICAgICAgICAgdW5pdHNQZXJFbTogMjA0OCxcbiAgICAgICAgICBhc2NlbmRlcjogMTk4MixcbiAgICAgICAgICBkZXNjZW5kZXI6IC04NDJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIGZvbnRGYW1pbHk6ICdUcmFzaGhhbmQnLFxuICAgIHZhcmlhdGlvbnM6IFtcbiAgICAgIHtcbiAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X2ZvbnRfdHJhc2hfaGFuZCcsXG4gICAgICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuICAgICAgICBwcm92aWRlcjogJ2ZpbGUnLFxuICAgICAgICBmaWxlUGF0aDogJ2ZvbnRzL2ltZ2x5X2ZvbnRfdHJhc2hfaGFuZC53b2ZmJyxcbiAgICAgICAgdGV4dE1ldHJpY3M6IHtcbiAgICAgICAgICB1bml0c1BlckVtOiAyMDQ4LFxuICAgICAgICAgIGFzY2VuZGVyOiAxNTU0LFxuICAgICAgICAgIGRlc2NlbmRlcjogLTY2M1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXVxuICB9XG5dXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgRVZFTlRTOiB7XG4gICAgUkVOREVSOiAncmVuZGVyJyxcbiAgICBFWFBPUlQ6ICdleHBvcnQnLFxuICAgIEVESVRPUl9SRUFEWTogJ2VkaXRvcjpyZWFkeScsXG4gICAgQ0xPU0U6ICdjbG9zZScsXG4gICAgWk9PTV9ET05FOiAnem9vbTpkb25lJyxcbiAgICBPUEVSQVRJT05fQ1JFQVRFRDogJ29wZXJhdGlvbjpjcmVhdGVkJyxcbiAgICBPUEVSQVRJT05fVVBEQVRFRDogJ29wZXJhdGlvbjp1cGRhdGVkJyxcbiAgICBPUEVSQVRJT05fUkVNT1ZFRDogJ29wZXJhdGlvbjpyZW1vdmVkJyxcbiAgICBGRUFUVVJFU19ESVNBQkxFRDogJ2VkaXRvcjpmZWF0dXJlczpkaXNhYmxlZCcsXG4gICAgRkVBVFVSRVNfRU5BQkxFRDogJ2VkaXRvcjpmZWF0dXJlczplbmFibGVkJyxcbiAgICBGRUFUVVJFU19VUERBVEVEOiAnZWRpdG9yOmZlYXR1cmVzOnVwZGF0ZWQnLFxuICAgIENPTE9SUElDS0VSX09QRU46ICdjb2xvcnBpY2tlcjpvcGVuJyxcbiAgICBISVNUT1JZX1VQREFURUQ6ICdoaXN0b3J5OnVwZGF0ZScsXG4gICAgSElTVE9SWV9CRUZPUkVfVU5ETzogJ2hpc3Rvcnk6YmVmb3JlX3VuZG8nLFxuICAgIEhJU1RPUllfVU5ETzogJ2hpc3Rvcnk6dW5kbycsXG4gICAgV0lORE9XX1JFU0laRTogJ3dpbmRvdzpyZXNpemUnLFxuICAgIENPTlRST0xTX1NXSVRDSEVEOiAnY29udHJvbHM6c3dpdGNoZWQnLFxuICAgIFRSQU5TRk9STV9SRUFQUExZX1JBVElPOiAndHJhbnNmb3JtOnJlYXBwbHlfcmF0aW8nXG4gIH0sXG4gIERFRkFVTFRTOiB7XG4gICAgVFJBTlNGT1JNX1JBVElPUzogW1xuICAgICAgW1xuICAgICAgICB7XG4gICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X3RyYW5zZm9ybV9jb21tb25fY3VzdG9tJyxcbiAgICAgICAgICBkZWZhdWx0TmFtZTogJ0N1c3RvbScsXG4gICAgICAgICAgcmF0aW86ICcqJyxcbiAgICAgICAgICBzZWxlY3RlZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X3RyYW5zZm9ybV9jb21tb25fc3F1YXJlJyxcbiAgICAgICAgICBkZWZhdWx0TmFtZTogJ1NxdWFyZScsXG4gICAgICAgICAgcmF0aW86IDFcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV90cmFuc2Zvcm1fY29tbW9uXzQtMycsXG4gICAgICAgICAgZGVmYXVsdE5hbWU6ICc0OjMnLFxuICAgICAgICAgIHJhdGlvOiAxLjMzXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfdHJhbnNmb3JtX2NvbW1vbl8xNi05JyxcbiAgICAgICAgICBkZWZhdWx0TmFtZTogJzE2OjknLFxuICAgICAgICAgIHJhdGlvOiAxLjc3XG4gICAgICAgIH1cbiAgICAgIF0sIFtcbiAgICAgICAge1xuICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV90cmFuc2Zvcm1fZmFjZWJvb2tfcHJvZmlsZScsXG4gICAgICAgICAgZGVmYXVsdE5hbWU6ICdGQiBQcm9maWxlJyxcbiAgICAgICAgICByYXRpbzogMSAvIDFcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlkZW50aWZpZXI6ICdpbWdseV90cmFuc2Zvcm1fZmFjZWJvb2tfYWQnLFxuICAgICAgICAgIGRlZmF1bHROYW1lOiAnRkIgQWQnLFxuICAgICAgICAgIGRpbWVuc2lvbnM6IG5ldyBQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjIoMTIwMCwgNjI3KVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWRlbnRpZmllcjogJ2ltZ2x5X3RyYW5zZm9ybV9mYWNlYm9va19wb3N0JyxcbiAgICAgICAgICBkZWZhdWx0TmFtZTogJ0ZCIFBvc3QnLFxuICAgICAgICAgIGRpbWVuc2lvbnM6IG5ldyBQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjIoOTQwLCA3ODgpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZGVudGlmaWVyOiAnaW1nbHlfdHJhbnNmb3JtX2ZhY2Vib29rX2NvdmVyJyxcbiAgICAgICAgICBkZWZhdWx0TmFtZTogJ0ZCIENvdmVyJyxcbiAgICAgICAgICBkaW1lbnNpb25zOiBuZXcgUGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyKDg1MSwgMzE1KVxuICAgICAgICB9XG4gICAgICBdXG4gICAgXSxcbiAgICBCUlVTSEVTOiBbXG4gICAgICBQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbi5CcnVzaFNwcml0ZS5CcnVzaGVzLlJhZGlhbEJydXNoXG4gICAgXSxcbiAgICBGT05UUzogZm9udHNcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL2NvbnN0YW50cy5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IFBob3RvRWRpdG9yU0RLIGZyb20gJ3Bob3RvZWRpdG9yc2RrJ1xuY29uc3QgeyBFdmVudEVtaXR0ZXIsIFV0aWxzLCBMb2cgfSA9IFBob3RvRWRpdG9yU0RLXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYXJlZFN0YXRlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKHN0YXRlID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fc3RhdGUgPSBzdGF0ZVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdpdmVuIHN0YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdTdGF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVwZGF0ZSA9IHRydWVcbiAgICovXG4gIHNldCAobmV3U3RhdGUgPSB7fSwgdXBkYXRlID0gdHJ1ZSkge1xuICAgIGlmICh0eXBlb2YgbmV3U3RhdGUgIT09ICdvYmplY3QnKSB7XG4gICAgICBMb2cud2FybignU2hhcmVkU3RhdGUjc2V0IGV4cGVjdHMgYW4gb2JqZWN0IGFzIGZpcnN0IHBhcmFtZXRlcicpXG4gICAgfVxuXG4gICAgY29uc3Qgb2xkU3RhdGUgPSBVdGlscy5leHRlbmQoe30sIHRoaXMuX3N0YXRlKVxuICAgIHRoaXMuX3N0YXRlID0gVXRpbHMuZXh0ZW5kKHRoaXMuX3N0YXRlLCBuZXdTdGF0ZSlcblxuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIHRoaXMuYnJvYWRjYXN0VXBkYXRlKG9sZFN0YXRlLCB0aGlzLl9zdGF0ZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhdGUgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICAgKi9cbiAgZ2V0IChwcm9wKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlW3Byb3BdXG4gIH1cblxuICAvKipcbiAgICogQnJvYWRjYXN0cyBhbiB1cGRhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9sZFN0YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdTdGF0ZVxuICAgKi9cbiAgYnJvYWRjYXN0VXBkYXRlIChvbGRTdGF0ZSwgbmV3U3RhdGUgPSB7fSkge1xuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgb2xkU3RhdGUsIG5ld1N0YXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgc3RhdGVcbiAgICovXG4gIGNsZWFyICgpIHtcbiAgICB0aGlzLl9zdGF0ZSA9IHt9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9zaGFyZWQtc3RhdGUuanMiLCIvKlxuICogaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cbiAqIGh0dHA6Ly9teS5vcGVyYS5jb20vZW1vbGxlci9ibG9nLzIwMTEvMTIvMjAvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1lci1hbmltYXRpbmdcbiAqIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbCBieSBFcmlrIE3DtmxsZXIuIGZpeGVzIGZyb20gUGF1bCBJcmlzaCBhbmQgVGlubyBaaWpkZWxcbiAqIE1JVCBsaWNlbnNlXG4gKiBAbGljZW5zZVxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIHN0YW5kYXJkL25vLWNhbGxiYWNrLWxpdGVyYWwgKi9cblxuY29uc3Qgcm9vdCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93XG5sZXQgckFGID0gcm9vdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbmxldCBjQUYgPSByb290LmNhbmNlbEFuaW1hdGlvbkZyYW1lXG5cbmxldCBsYXN0VGltZSA9IDBcbmNvbnN0IHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddXG5mb3IgKGxldCB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICFyQUY7ICsreCkge1xuICByQUYgPSByb290W3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ11cbiAgY0FGID0gcm9vdFt2ZW5kb3JzW3hdICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHwgcm9vdFt2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddXG59XG5cbi8qIEJpbmQgdG8gcm9vdCBpcyBuZWNlc3NhcnkgYXMgdGhlIGNvbnRleHQgbXVzdCBiZSB2YWxpZCAqL1xuaWYgKHJBRikgeyByQUYgPSByQUYuYmluZChyb290KSB9XG5pZiAoY0FGKSB7IGNBRiA9IGNBRi5iaW5kKHJvb3QpIH1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmICghckFGKSB7XG4gIHJBRiA9IGZ1bmN0aW9uIChjYWxsYmFjaywgZWxlbWVudCkge1xuICAgIGNvbnN0IGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICBjb25zdCB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpXG4gICAgY29uc3QgaWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKSB9LCB0aW1lVG9DYWxsKVxuICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsXG4gICAgcmV0dXJuIGlkXG4gIH1cbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmICghY0FGKSB7XG4gIGNBRiA9IGZ1bmN0aW9uIChpZCkge1xuICAgIGNsZWFyVGltZW91dChpZClcbiAgfVxufVxuXG5leHBvcnQge1xuICByQUYgYXMgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLFxuICBjQUYgYXMgY2FuY2VsQW5pbWF0aW9uRnJhbWVcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvanMvc2hhcmVkL2FzeW5jL2FuaW1hdGlvbi1mcmFtZS5qcyIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0LCBQcm9wVHlwZXMsIFJlYWN0QkVNLCBQcm9taXNlLCBDb25zdGFudHMgfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IExvYWRpbmdTY3JlZW5Db21wb25lbnQgZnJvbSAnLi9zY3JlZW5zL2xvYWRpbmcvbG9hZGluZy1zY3JlZW4tY29tcG9uZW50J1xuaW1wb3J0IFNwbGFzaFNjcmVlbkNvbXBvbmVudCBmcm9tICcuL3NjcmVlbnMvc3BsYXNoL3NwbGFzaC1zY3JlZW4tY29tcG9uZW50J1xuaW1wb3J0IFBob3RvUm9sbFNjcmVlbkNvbXBvbmVudCBmcm9tICcuL3NjcmVlbnMvcGhvdG8tcm9sbC9waG90by1yb2xsLXNjcmVlbi1jb21wb25lbnQnXG5pbXBvcnQgV2ViY2FtU2NyZWVuQ29tcG9uZW50IGZyb20gJy4vc2NyZWVucy93ZWJjYW0vd2ViY2FtLXNjcmVlbi1jb21wb25lbnQnXG5pbXBvcnQgRWRpdG9yU2NyZWVuQ29tcG9uZW50IGZyb20gJy4vc2NyZWVucy9lZGl0b3IvZWRpdG9yLXNjcmVlbi1jb21wb25lbnQnXG5pbXBvcnQgRW1wdHlTY3JlZW5Db21wb25lbnQgZnJvbSAnLi9zY3JlZW5zL3NjcmVlbi1jb21wb25lbnQnXG5pbXBvcnQgTW9kYWxDb250YWluZXJDb21wb25lbnQgZnJvbSAnLi9tb2RhbC1jb250YWluZXItY29tcG9uZW50J1xuaW1wb3J0IE1vZGFsTWFuYWdlciBmcm9tICcuLi9saWIvbW9kYWwtbWFuYWdlcidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXBwQ29tcG9uZW50IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fc2NyZWVucyA9IHtcbiAgICAgIGxvYWRpbmc6IExvYWRpbmdTY3JlZW5Db21wb25lbnQsXG4gICAgICBzcGxhc2g6IFNwbGFzaFNjcmVlbkNvbXBvbmVudCxcbiAgICAgIHBob3RvUm9sbDogUGhvdG9Sb2xsU2NyZWVuQ29tcG9uZW50LFxuICAgICAgd2ViY2FtOiBXZWJjYW1TY3JlZW5Db21wb25lbnQsXG4gICAgICBlZGl0b3I6IEVkaXRvclNjcmVlbkNvbXBvbmVudCxcbiAgICAgIGVtcHR5OiBFbXB0eVNjcmVlbkNvbXBvbmVudFxuICAgIH1cblxuICAgIGxldCBpbml0aWFsU2NyZWVuXG4gICAgaWYgKHRoaXMucHJvcHMub3B0aW9ucy5wcmVsb2FkZXIpIHtcbiAgICAgIGluaXRpYWxTY3JlZW4gPSAnbG9hZGluZydcbiAgICB9XG5cbiAgICB0aGlzLl9zY3JlZW5BZnRlckxvYWRpbmcgPSAnc3BsYXNoJ1xuICAgIGlmICh0aGlzLnByb3BzLm9wdGlvbnMuZWRpdG9yLmltYWdlKSB7XG4gICAgICB0aGlzLl9zY3JlZW5BZnRlckxvYWRpbmcgPSAnZWRpdG9yJ1xuICAgIH1cblxuICAgIGlmICghaW5pdGlhbFNjcmVlbikge1xuICAgICAgaW5pdGlhbFNjcmVlbiA9IHRoaXMuX3NjcmVlbkFmdGVyTG9hZGluZ1xuICAgIH1cblxuICAgIHRoaXMuX3NjcmVlbkVsZW1lbnRzID0ge31cblxuICAgIHRoaXMuX2lzUmVhZHkgPSBmYWxzZVxuXG4gICAgdGhpcy5fcHJldmlvdXNTY3JlZW5zU3RhY2sgPSBbXVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBhY3RpdmVTY3JlZW46IHRoaXMuX3NjcmVlbnNbaW5pdGlhbFNjcmVlbl0sXG4gICAgICBhY3RpdmVTY3JlZW5OYW1lOiBpbml0aWFsU2NyZWVuLFxuICAgICAgc2NyZWVuczoge1xuICAgICAgICBbaW5pdGlhbFNjcmVlbl06IHRoaXMuX3NjcmVlbnNbaW5pdGlhbFNjcmVlbl1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBhcHAgaGFzIGEgcHJldmlvdXMgc2NyZWVuIG9uIHRoZSBzdGFja1xuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaGFzUHJldmlvdXNTY3JlZW4gKCkge1xuICAgIHJldHVybiAhIXRoaXMuX3ByZXZpb3VzU2NyZWVuc1N0YWNrLmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByZXZpb3VzIHNjcmVlblxuICAgKiBAcmV0dXJuIHtTY3JlZW59XG4gICAqL1xuICBnZXRQcmV2aW91c1NjcmVlbiAoKSB7XG4gICAgY29uc3Qgc3RhY2sgPSB0aGlzLl9wcmV2aW91c1NjcmVlbnNTdGFja1xuICAgIHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAxXVxuICB9XG5cbiAgLyoqXG4gICAqIFN3aXRjaGVzIHRvIHRoZSBzY3JlZW4gd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWVcbiAgICovXG4gIHN3aXRjaFRvU2NyZWVuIChuYW1lKSB7XG4gICAgbGV0IFNjcmVlbiA9IG51bGxcbiAgICBpZiAobmFtZSA9PT0gJ2JhY2snKSB7XG4gICAgICBTY3JlZW4gPSB0aGlzLl9wcmV2aW91c1NjcmVlbnNTdGFjay5wb3AoKVxuICAgICAgaWYgKCFTY3JlZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gc3dpdGNoIHRvIHByZXZpb3VzIHNjcmVlbiAtIG5vIHByZXZpb3VzIHNjcmVlbiBmb3VuZC4nKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmFtZSA9PT0gJ3Bvc3QtbG9hZGluZycpIG5hbWUgPSB0aGlzLl9zY3JlZW5BZnRlckxvYWRpbmdcblxuICAgICAgU2NyZWVuID0gdGhpcy5fc2NyZWVuc1tuYW1lXVxuICAgICAgaWYgKCFTY3JlZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHNjcmVlbiBcXGAke25hbWV9XFxgYClcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcHJldmlvdXNTY3JlZW5zU3RhY2sucHVzaCh0aGlzLnN0YXRlLmFjdGl2ZVNjcmVlbilcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc3RhdGUuc2NyZWVuc1tuYW1lXSkge1xuICAgICAgdGhpcy5zdGF0ZS5zY3JlZW5zW25hbWVdID0gU2NyZWVuXG4gICAgfVxuXG4gICAgLy8gUmV0YWluIGVkaXRvciBjb21wb25lbnRcbiAgICBpZiAodGhpcy5zdGF0ZS5hY3RpdmVTY3JlZW5OYW1lICE9PSAnZWRpdG9yJykge1xuICAgICAgZGVsZXRlIHRoaXMuc3RhdGUuc2NyZWVuc1t0aGlzLnN0YXRlLmFjdGl2ZVNjcmVlbk5hbWVdXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgYWN0aXZlU2NyZWVuOiBTY3JlZW4sIGFjdGl2ZVNjcmVlbk5hbWU6IG5hbWUgfSwgKCkgPT4ge1xuICAgICAgICByZXNvbHZlKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGFuIGltYWdlIGlzIHJlYWR5IGZvciBlZGl0aW5nXG4gICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVzZXRFZGl0b3JcbiAgICovXG4gIHNldEltYWdlIChpbWFnZSwgcmVzZXRFZGl0b3IpIHtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXMucHJvcHNcbiAgICBvcHRpb25zLmVkaXRvci5pbWFnZSA9IGltYWdlXG5cbiAgICBjb25zdCBmaXJzdEVkaXRvckxhdW5jaCA9ICF0aGlzLl9zY3JlZW5FbGVtZW50cy5lZGl0b3JTY3JlZW5cbiAgICB0aGlzLnN3aXRjaFRvU2NyZWVuKCdlZGl0b3InKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoIWZpcnN0RWRpdG9yTGF1bmNoKSB7XG4gICAgICAgICAgdGhpcy5fc2NyZWVuRWxlbWVudHMuZWRpdG9yU2NyZWVuLnNldEltYWdlKGltYWdlLCByZXNldEVkaXRvcilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvcnRzIGFuIGltYWdlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZG93bmxvYWQgPSBmYWxzZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgZXhwb3J0ICguLi5hcmdzKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuYWN0aXZlU2NyZWVuICE9PSB0aGlzLl9zY3JlZW5zLmVkaXRvcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVW5hYmxlIHRvIGV4cG9ydDogQWN0aXZlIHNjcmVlbiBpcyBub3QgdGhlIGVkaXRvciBzY3JlZW4uJykpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhdGUuc2NyZWVucy5lZGl0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY3JlZW5FbGVtZW50cy5lZGl0b3JTY3JlZW4uZXhwb3J0KC4uLmFyZ3MpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVkaXRvclxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkVkaXRvcn1cbiAgICovXG4gIGdldEVkaXRvciAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuYWN0aXZlU2NyZWVuICE9PSB0aGlzLl9zY3JlZW5zLmVkaXRvcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVW5hYmxlIHRvIGdldCBlZGl0b3I6IEFjdGl2ZSBzY3JlZW4gaXMgbm90IHRoZSBlZGl0b3Igc2NyZWVuLicpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXRlLnNjcmVlbnMuZWRpdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2NyZWVuRWxlbWVudHMuZWRpdG9yU2NyZWVuLmdldEVkaXRvcigpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIGVkaXRvciBzdGF0ZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgc2VyaWFsaXplICguLi5hcmdzKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLnNjcmVlbnMuZWRpdG9yKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdFZGl0b3Igc2NyZWVuIHVuYXZhaWxhYmxlJykpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zY3JlZW5FbGVtZW50cy5lZGl0b3JTY3JlZW4uc2VyaWFsaXplKC4uLmFyZ3MpXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBkYXRhXG4gICAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgZGVzZXJpYWxpemUgKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuc2NyZWVucy5lZGl0b3IpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0VkaXRvciBzY3JlZW4gdW5hdmFpbGFibGUnKSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NjcmVlbkVsZW1lbnRzLmVkaXRvclNjcmVlbi5kZXNlcmlhbGl6ZShkYXRhKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbnRleHQgcGFzc2VkIHRvIGFsbCBjaGlsZHJlblxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRDaGlsZENvbnRleHQgKCkge1xuICAgIHJldHVybiB7XG4gICAgICB1aTogdGhpcy5wcm9wcy51aSxcbiAgICAgIG9wdGlvbnM6IHRoaXMucHJvcHMub3B0aW9ucyxcbiAgICAgIG1lZGlhdG9yOiB0aGlzLnByb3BzLm1lZGlhdG9yLFxuICAgICAgZ2xvYmFsU3RhdGU6IHRoaXMucHJvcHMuZ2xvYmFsU3RhdGVcbiAgICB9XG4gIH1cblxuICBfb25TY3JlZW5Nb3VudGVkID0gKG5hbWUsIGVsKSA9PiB7XG4gICAgdGhpcy5fc2NyZWVuRWxlbWVudHNbYCR7bmFtZX1TY3JlZW5gXSA9IGVsXG5cbiAgICBpZiAobmFtZSA9PT0gJ2VkaXRvcicgJiYgIXRoaXMuX2lzUmVhZHkpIHtcbiAgICAgIHRoaXMuX2lzUmVhZHkgPSB0cnVlXG4gICAgICB0aGlzLnByb3BzLm1lZGlhdG9yLmVtaXQoQ29uc3RhbnRzLkVWRU5UUy5FRElUT1JfUkVBRFkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGV4aXN0aW5nIHNjcmVlbnNcbiAgICogQHJldHVybiB7U2NyZWVuQ29tcG9uZW50W119XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyU2NyZWVucyAoKSB7XG4gICAgbGV0IHJlbmRlcmVkU2NyZWVucyA9IFtdXG5cbiAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuc3RhdGUuc2NyZWVucykge1xuICAgICAgY29uc3QgU2NyZWVuID0gdGhpcy5zdGF0ZS5zY3JlZW5zW25hbWVdXG4gICAgICBjb25zdCB2aXNpYmxlID0gdGhpcy5zdGF0ZS5hY3RpdmVTY3JlZW4gPT09IFNjcmVlblxuICAgICAgcmVuZGVyZWRTY3JlZW5zLnB1c2goXG4gICAgICAgIDxTY3JlZW4gcmVmPXtlbCA9PiB0aGlzLl9vblNjcmVlbk1vdW50ZWQobmFtZSwgZWwpfSBhcHA9e3RoaXN9IHZpc2libGU9e3Zpc2libGV9IC8+XG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbmRlcmVkU2NyZWVuc1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3QuQ29tcG9uZW50fVxuICAgKi9cbiAgcmVuZGVyICgpIHtcbiAgICByZXR1cm4gUmVhY3RCRU0udHJhbnNmb3JtKDxkaXYgYmVtPSdiOmVkaXRvcic+XG4gICAgICA8TW9kYWxDb250YWluZXJDb21wb25lbnRcbiAgICAgICAgbW9kYWxNYW5hZ2VyPXtNb2RhbE1hbmFnZXIuaW5zdGFuY2V9IC8+XG5cbiAgICAgIHt0aGlzLl9yZW5kZXJTY3JlZW5zKCl9XG4gICAgPC9kaXY+KVxuICB9XG59XG5cbkFwcENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgdWk6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgbWVkaWF0b3I6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgb3B0aW9uczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBnbG9iYWxTdGF0ZTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59XG5cbkFwcENvbXBvbmVudC5wcm9wVHlwZXMgPSB7XG4gIHVpOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIG1lZGlhdG9yOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIG9wdGlvbnM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgZ2xvYmFsU3RhdGU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9hcHAtY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5pbXBvcnQgeyBCYXNlQ29tcG9uZW50LCBSZWFjdEJFTSwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBTY3JlZW5Db21wb25lbnQgZnJvbSAnLi4vc2NyZWVuLWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9hZGluZ1NjcmVlbkNvbXBvbmVudCBleHRlbmRzIFNjcmVlbkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuc3RhdGUgPSB7IHByb2dyZXNzOiAwIH1cblxuICAgIHRoaXMuX3ByZWxvYWRlciA9IHRoaXMuY29udGV4dC51aS5nZXRQcmVsb2FkZXIoKVxuICAgIHRoaXMuX3ByZWxvYWRlci5vbigncHJvZ3Jlc3MnLCAocHJvZ3Jlc3MpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUucHJvZ3Jlc3MgPSBwcm9ncmVzc1xuICAgIH0pXG4gICAgdGhpcy5fcHJlbG9hZGVyLm9uKCdkb25lJywgKCkgPT4ge1xuICAgICAgdGhpcy5wcm9wcy5hcHAuc3dpdGNoVG9TY3JlZW4oJ3Bvc3QtbG9hZGluZycpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICBzdXBlci5jb21wb25lbnREaWRNb3VudCgpXG4gICAgY29uc3QgeyBkZXZpY2VQaXhlbFJhdGlvIH0gPSB3aW5kb3dcbiAgICB0aGlzLl9jYW52YXMgPSB0aGlzLnJlZnMuY2FudmFzXG4gICAgdGhpcy5fY2FudmFzLndpZHRoID0gdGhpcy5fY2FudmFzLm9mZnNldFdpZHRoICogZGV2aWNlUGl4ZWxSYXRpb1xuICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSB0aGlzLl9jYW52YXMub2Zmc2V0SGVpZ2h0ICogZGV2aWNlUGl4ZWxSYXRpb1xuICAgIHRoaXMuX2NvbnRleHQgPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuXG4gICAgdGhpcy5fcHJlbG9hZGVySW1hZ2UgPSBuZXcgd2luZG93LkltYWdlKClcbiAgICB0aGlzLl9wcmVsb2FkZXJJbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgdGhpcy5fcHJlbG9hZGVyLmxvYWQoKVxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3RpY2spXG4gICAgfSlcbiAgICB0aGlzLl9wcmVsb2FkZXJJbWFnZS5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnXG4gICAgdGhpcy5fcHJlbG9hZGVySW1hZ2Uuc3JjID0gdGhpcy5jb250ZXh0LnVpLmdldEFzc2V0UGF0aCgncHJlbG9hZGVyLnBuZycsIHRydWUpXG5cbiAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZVxuICAgIHRoaXMuX3RpY2sgPSB0aGlzLl90aWNrLmJpbmQodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGlzIGFib3V0IHRvIGJlIHVubW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVubW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudFdpbGxVbm1vdW50KClcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2VcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RpY2sgKCkge1xuICAgIHRoaXMuX3JlbmRlckxvYWRpbmdJbmRpY2F0b3IoKVxuICAgIGlmICh0aGlzLl9ydW5uaW5nKSB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fdGljaylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogKFJlLSlSZW5kZXJzIHRoZSBsb2FkaW5nIGluZGljYXRvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckxvYWRpbmdJbmRpY2F0b3IgKCkge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5fY2FudmFzXG4gICAgY29uc3QgY3R4ID0gdGhpcy5fY29udGV4dFxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodClcblxuICAgIGN0eC5zYXZlKClcbiAgICBjdHguYmVnaW5QYXRoKClcbiAgICBjdHgubW92ZVRvKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMilcbiAgICBjdHguYXJjKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgd2lkdGggLyAyLCAtTWF0aC5QSSAqIDAuNSwgTWF0aC5QSSAqIDIgKiB0aGlzLnN0YXRlLnByb2dyZXNzIC0gTWF0aC5QSSAqIDAuNSwgZmFsc2UpXG4gICAgY3R4LmxpbmVUbyh3aWR0aCAvIDIsIGhlaWdodCAvIDIpXG4gICAgY3R4LmNsaXAoKVxuICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICB0aGlzLl9wcmVsb2FkZXJJbWFnZSxcbiAgICAgIDAsIDAsIHRoaXMuX3ByZWxvYWRlckltYWdlLndpZHRoLCB0aGlzLl9wcmVsb2FkZXJJbWFnZS5oZWlnaHQsXG4gICAgICAwLCAwLCB3aWR0aCwgaGVpZ2h0XG4gICAgKVxuICAgIGN0eC5yZXN0b3JlKClcblxuICAgIGN0eC5zYXZlKClcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjA1XG4gICAgY3R4LmRyYXdJbWFnZShcbiAgICAgIHRoaXMuX3ByZWxvYWRlckltYWdlLFxuICAgICAgMCwgMCwgdGhpcy5fcHJlbG9hZGVySW1hZ2Uud2lkdGgsIHRoaXMuX3ByZWxvYWRlckltYWdlLmhlaWdodCxcbiAgICAgIDAsIDAsIHdpZHRoLCBoZWlnaHRcbiAgICApXG4gICAgY3R4LnJlc3RvcmUoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBzY3JlZW5cbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJTY3JlZW4gKCkge1xuICAgIHJldHVybiAoPGRpdiBiZW09JyRiOmxvYWRpbmdTY3JlZW4nPlxuICAgICAgPGRpdiBiZW09J2U6Y29udGFpbmVyJz5cbiAgICAgICAgPGNhbnZhcyBiZW09J2U6Y2FudmFzJyByZWY9J2NhbnZhcycgLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PilcbiAgfVxufVxuXG5Mb2FkaW5nU2NyZWVuQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL3NjcmVlbnMvbG9hZGluZy9sb2FkaW5nLXNjcmVlbi1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cbmltcG9ydCB7IENvbnN0YW50cywgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi9nbG9iYWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWFkZXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fYmluZEFsbCgnX29uQ2xvc2VDbGljaycpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIGNsb3NlIGJ1dHRvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ2xvc2VDbGljayAoKSB7XG4gICAgdGhpcy5jb250ZXh0Lm1lZGlhdG9yLmVtaXQoQ29uc3RhbnRzLkVWRU5UUy5DTE9TRSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBsZXQgY2xvc2VCdXR0b25cbiAgICBpZiAodGhpcy5jb250ZXh0Lm9wdGlvbnMuc2hvd0Nsb3NlQnV0dG9uKSB7XG4gICAgICBjbG9zZUJ1dHRvbiA9ICg8ZGl2IGJlbT0nJGU6Y2xvc2UnIG9uQ2xpY2s9e3RoaXMuX29uQ2xvc2VDbGlja30+XG4gICAgICAgIDxpbWcgYmVtPSdlOmltYWdlJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aCgnY2xvc2UucG5nJywgdHJ1ZSl9IC8+XG4gICAgICA8L2Rpdj4pXG4gICAgfVxuXG4gICAgcmV0dXJuICg8ZGl2IGJlbT0nJGI6aGVhZGVyJz5cbiAgICAgIDxkaXYgYmVtPSdlOmxhYmVsJz57dGhpcy5jb250ZXh0Lm9wdGlvbnMudGl0bGV9PC9kaXY+XG4gICAgICB7Y2xvc2VCdXR0b259XG4gICAgPC9kaXY+KVxuICB9XG59XG5cbkhlYWRlckNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9oZWFkZXItY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5pbXBvcnQgeyBCYXNlQ29tcG9uZW50LCBSZWFjdEJFTSwgVXRpbHMgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IFNjcmVlbkNvbXBvbmVudCBmcm9tICcuLi9zY3JlZW4tY29tcG9uZW50J1xuaW1wb3J0IFNwbGFzaFNjcmVlblVwbG9hZENvbXBvbmVudCBmcm9tICcuL3VwbG9hZC1jb21wb25lbnQnXG5pbXBvcnQgU3BsYXNoU2NyZWVuV2ViY2FtQ29tcG9uZW50IGZyb20gJy4vd2ViY2FtLWNvbXBvbmVudCdcbmltcG9ydCBTcGxhc2hTY3JlZW5QaG90b1JvbGxDb21wb25lbnQgZnJvbSAnLi9waG90by1yb2xsLWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BsYXNoU2NyZWVuQ29tcG9uZW50IGV4dGVuZHMgU2NyZWVuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uV2ViY2FtQ2xpY2snLFxuICAgICAgJ19vblBob3RvUm9sbENsaWNrJyxcbiAgICAgICdfb25JbWFnZSdcbiAgICApXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgUGhvdG9Sb2xsQ29tcG9uZW50IGhhcyByZWNlaXZlZCBhIGNsaWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25QaG90b1JvbGxDbGljayAoKSB7XG4gICAgdGhpcy5wcm9wcy5hcHAuc3dpdGNoVG9TY3JlZW4oJ3Bob3RvUm9sbCcpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgV2ViY2FtQ29tcG9uZW50IGhhcyByZWNlaXZlZCBhIGNsaWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25XZWJjYW1DbGljayAoKSB7XG4gICAgdGhpcy5wcm9wcy5hcHAuc3dpdGNoVG9TY3JlZW4oJ3dlYmNhbScpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgVXBsb2FkQ29tcG9uZW50IGhhcyByZWNlaXZlZCBhbiBpbWFnZSBmaWxlXG4gICAqIEBwYXJhbSAge2ltYWdlfSBpbWFnZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uSW1hZ2UgKGltYWdlKSB7XG4gICAgdGhpcy5wcm9wcy5hcHAuc2V0SW1hZ2UoaW1hZ2UpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBNSVNDXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgd2ViY2FtIGlzIGF2YWlsYWJsZSBmb3IgdGhlIGdpdmVuIGRldmljZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2lzV2ViY2FtQXZhaWxhYmxlICgpIHtcbiAgICByZXR1cm4gIVV0aWxzLmlzTW9iaWxlKCkgJiYgdGhpcy5jb250ZXh0Lm9wdGlvbnMuZW5hYmxlV2ViY2FtICE9PSBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgcGhvdG8gcm9sbCBpcyBhdmFpbGFibGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pc1Bob3RvUm9sbEF2YWlsYWJsZSAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5jb250ZXh0Lm9wdGlvbnMucGhvdG9Sb2xsLnByb3ZpZGVyXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIHNjcmVlblxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclNjcmVlbiAoKSB7XG4gICAgY29uc3QgaXRlbXMgPSBbXVxuICAgIGxldCB0b3RhbFJvd3MgPSAwXG5cbiAgICBjb25zdCB1cGxvYWRBdmFpbGFibGUgPSB0aGlzLmNvbnRleHQub3B0aW9ucy5lbmFibGVVcGxvYWRcbiAgICBpZiAodXBsb2FkQXZhaWxhYmxlKSB0b3RhbFJvd3MrK1xuXG4gICAgY29uc3Qgd2ViY2FtQXZhaWxhYmxlID0gdGhpcy5faXNXZWJjYW1BdmFpbGFibGUoKVxuICAgIGlmICh3ZWJjYW1BdmFpbGFibGUpIHRvdGFsUm93cysrXG5cbiAgICBjb25zdCBwaG90b1JvbGxBdmFpbGFibGUgPSB0aGlzLl9pc1Bob3RvUm9sbEF2YWlsYWJsZSgpXG4gICAgaWYgKHBob3RvUm9sbEF2YWlsYWJsZSkgdG90YWxSb3dzKytcblxuICAgIGlmICh1cGxvYWRBdmFpbGFibGUpIHtcbiAgICAgIGl0ZW1zLnB1c2goPFNwbGFzaFNjcmVlblVwbG9hZENvbXBvbmVudFxuICAgICAgICBvbkltYWdlPXt0aGlzLl9vbkltYWdlfVxuICAgICAgICB0b3RhbFJvd3M9e3RvdGFsUm93c30gLz4pXG4gICAgfVxuXG4gICAgaWYgKHdlYmNhbUF2YWlsYWJsZSkge1xuICAgICAgaXRlbXMucHVzaCg8U3BsYXNoU2NyZWVuV2ViY2FtQ29tcG9uZW50XG4gICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uV2ViY2FtQ2xpY2t9XG4gICAgICAgIHRvdGFsUm93cz17dG90YWxSb3dzfSAvPilcbiAgICB9XG5cbiAgICBpZiAocGhvdG9Sb2xsQXZhaWxhYmxlKSB7XG4gICAgICBpdGVtcy5wdXNoKDxTcGxhc2hTY3JlZW5QaG90b1JvbGxDb21wb25lbnRcbiAgICAgICAgb25DbGljaz17dGhpcy5fb25QaG90b1JvbGxDbGlja31cbiAgICAgICAgdG90YWxSb3dzPXt0b3RhbFJvd3N9IC8+KVxuICAgIH1cblxuICAgIHJldHVybiAoPGRpdiBiZW09JyRiOnNwbGFzaFNjcmVlbic+XG4gICAgICA8ZGl2IGJlbT0nZTpjb250YWluZXInPlxuICAgICAgICB7aXRlbXN9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuU3BsYXNoU2NyZWVuQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL3NjcmVlbnMvc3BsYXNoL3NwbGFzaC1zY3JlZW4tY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFByb3BUeXBlcywgUmVhY3RCRU0gfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IE1vZGFsTWFuYWdlciBmcm9tICdsaWIvbW9kYWwtbWFuYWdlcidcbmltcG9ydCBSb3dDb21wb25lbnQgZnJvbSAnLi9yb3ctY29tcG9uZW50J1xuaW1wb3J0IEJ1dHRvbkNvbXBvbmVudCBmcm9tICcuLi8uLi9idXR0b24tY29tcG9uZW50J1xuaW1wb3J0IEludmlzaWJsZVVwbG9hZENvbXBvbmVudCBmcm9tICcuLi8uLi9zaGFyZWQvaW52aXNpYmxlLXVwbG9hZC1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVwbG9hZENvbXBvbmVudCBleHRlbmRzIFJvd0NvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzLl9tb2RpZmllciA9ICd1cGxvYWQnXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbkltYWdlJyxcbiAgICAgICdfb25EcmFnRW50ZXInLCAnX29uRHJhZ092ZXInLCAnX29uRHJhZ0xlYXZlJywgJ19vbkRyb3AnXG4gICAgKVxuXG4gICAgdGhpcy5fZHJhZ0NvdW50ZXIgPSAwXG4gICAgdGhpcy5zdGF0ZSA9IHsgZHJhZ0FyZWFIb3ZlcmVkOiBmYWxzZSB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgY2VsbCBlbWl0cyBhIGBkcmFnRW50ZXJgIGV2ZW50LiBIaWdobGlnaHRzXG4gICAqIHRoZSBjZWxsXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkRyYWdFbnRlciAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgdGhpcy5fZHJhZ0NvdW50ZXIrK1xuICAgIHRoaXMuc2V0U3RhdGUoeyBkcmFnQXJlYUhvdmVyZWQ6IHRydWUgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBjZWxsIGVtaXRzIGEgYGRyYWdPdmVyYCBldmVudC4gV2UgbmVlZCB0b1xuICAgKiBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciB0byBnZXQgYSBkcm9wIGV2ZW50LlxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uRHJhZ092ZXIgKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBjZWxsIGVtaXRzIGEgYGRyYWdMZWF2ZWAgZXZlbnRcbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkRyYWdMZWF2ZSAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgdGhpcy5fZHJhZ0NvdW50ZXItLVxuICAgIGlmICh0aGlzLl9kcmFnQ291bnRlciA9PT0gMCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGRyYWdBcmVhSG92ZXJlZDogZmFsc2UgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgY2VsbCBlbWl0cyBhIGBkcm9wYCBFdmVudFxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uRHJvcCAoZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlID0gZS5uYXRpdmVFdmVudFxuICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGRyYWdBcmVhSG92ZXJlZDogZmFsc2UgfSwgKCkgPT4ge1xuICAgICAgaWYgKCFlLmRhdGFUcmFuc2ZlcikgcmV0dXJuXG5cbiAgICAgIGlmICghZS5kYXRhVHJhbnNmZXIuZmlsZXNbMF0udHlwZS5tYXRjaCgvXmltYWdlXFwvL2kpKSB7XG4gICAgICAgIHJldHVybiBNb2RhbE1hbmFnZXIuaW5zdGFuY2UuZGlzcGxheUVycm9yKFxuICAgICAgICAgIHRoaXMuX3QoJ3Blc2RrLmNvbW1vbi50aXRsZS5lcnJvcicpLFxuICAgICAgICAgIHRoaXMuX3QoJ3Blc2RrLmVkaXRvci50ZXh0LmludmFsaWRGaWxlVHlwZScsIHsgZmlsZVR5cGU6IGUuZGF0YVRyYW5zZmVyLmZpbGVzWzBdLnR5cGUgfSlcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9oYW5kbGVGaWxlKGUuZGF0YVRyYW5zZmVyLmZpbGVzWzBdKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIGJ1dHRvblxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ2xpY2sgKGUpIHtcbiAgICB0aGlzLnJlZnMudXBsb2FkLm9wZW4oKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW1hZ2UgZnJvbSB0aGUgZ2l2ZW4gZmlsZSBhbmQgcGFzc2VzIGl0IHRvIHRoZSBVSVxuICAgKiBAcGFyYW0gIHtGaWxlfSBmaWxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaGFuZGxlRmlsZSAoZmlsZSkge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyB3aW5kb3cuRmlsZVJlYWRlcigpXG4gICAgcmVhZGVyLm9ubG9hZCA9ICgoKSA9PiB7XG4gICAgICByZXR1cm4gKGUpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGUudGFyZ2V0LnJlc3VsdFxuICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyB3aW5kb3cuSW1hZ2UoKVxuXG4gICAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fb25JbWFnZShpbWFnZSlcbiAgICAgICAgfSlcblxuICAgICAgICBpbWFnZS5zcmMgPSBkYXRhXG4gICAgICB9XG4gICAgfSkoZmlsZSlcbiAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGltYWdlIGhhcyBiZWVuIGNoYW5nZWRcbiAgICogQHBhcmFtICB7SW1hZ2V9IGltYWdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25JbWFnZSAoaW1hZ2UpIHtcbiAgICB0aGlzLnByb3BzLm9uSW1hZ2UgJiZcbiAgICAgIHRoaXMucHJvcHMub25JbWFnZShpbWFnZSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgcm93J3MgY29udGVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckNvbnRlbnQgKCkge1xuICAgIGNvbnN0IGNlbGxQcm9wcyA9IHtcbiAgICAgIG9uRHJhZ0VudGVyOiB0aGlzLl9vbkRyYWdFbnRlcixcbiAgICAgIG9uRHJhZ092ZXI6IHRoaXMuX29uRHJhZ092ZXIsXG4gICAgICBvbkRyYWdMZWF2ZTogdGhpcy5fb25EcmFnTGVhdmUsXG4gICAgICBvbkRyb3A6IHRoaXMuX29uRHJvcFxuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXRlLmRyYWdBcmVhSG92ZXJlZCkge1xuICAgICAgY2VsbFByb3BzLmNsYXNzTmFtZSA9ICdpcy1ob3ZlcmVkJ1xuICAgIH1cblxuICAgIGxldCBjb250ZW50Q2VsbEJFTSA9ICdlOmNvbnRlbnRDZWxsJ1xuICAgIC8vIEBUT0RPIFdlIG5lZWQgc29tZSBjbGFzcyB0aGF0IGltcGxlbWVudHMgd2ViY2FtRW5hYmxlZCgpIGFuZCBwaG90b1JvbGxFbmFibGVkKClcbiAgICBpZiAodGhpcy5jb250ZXh0Lm9wdGlvbnMuZW5hYmxlV2ViY2FtICE9PSBmYWxzZSB8fFxuICAgICAgICB0aGlzLmNvbnRleHQub3B0aW9ucy5waG90b1JvbGwucHJvdmlkZXIgIT09IG51bGwpIHtcbiAgICAgIGNvbnRlbnRDZWxsQkVNICs9ICcgbTp3aXRoQm9yZGVyJ1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGJlbT0nZTpjb250ZW50V3JhcHBlcic+XG4gICAgICAgIDxkaXYgYmVtPSdlOmNvbnRlbnRSb3cnPlxuICAgICAgICAgIDxkaXYgYmVtPXtjb250ZW50Q2VsbEJFTX0gb25DbGljaz17dGhpcy5fb25DbGlja30gey4uLmNlbGxQcm9wc30+XG4gICAgICAgICAgICA8SW52aXNpYmxlVXBsb2FkQ29tcG9uZW50IHJlZj0ndXBsb2FkJyBvbk5ld0ZpbGU9e3RoaXMuX29uSW1hZ2V9IC8+XG4gICAgICAgICAgICA8QnV0dG9uQ29tcG9uZW50IGJlbT0nZTpidXR0b24nIHVwcGVyY2FzZT5cbiAgICAgICAgICAgICAge3RoaXMuX3QoJ3Blc2RrLnNwbGFzaC5idXR0b24udXBsb2FkJyl9XG4gICAgICAgICAgICA8L0J1dHRvbkNvbXBvbmVudD5cbiAgICAgICAgICAgIDxkaXYgYmVtPSdlOmRlc2NyaXB0aW9uJz5cbiAgICAgICAgICAgICAge3RoaXMuX3QoJ3Blc2RrLnNwbGFzaC50ZXh0LnVwbG9hZCcpfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG5cblVwbG9hZENvbXBvbmVudC5wcm9wVHlwZXMgPSB7XG4gIG9uSW1hZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbn1cblxuVXBsb2FkQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IFJvd0NvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvc2NyZWVucy9zcGxhc2gvdXBsb2FkLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBQcm9wVHlwZXMsIFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vZ2xvYmFscydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnV0dG9uQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBsZXQgYmVtU3BlY2lmaWVyID0gJ2I6YnV0dG9uJ1xuICAgIGlmICh0aGlzLnByb3BzLnVwcGVyY2FzZSkge1xuICAgICAgYmVtU3BlY2lmaWVyICs9ICcgbTp1cHBlcmNhc2UnXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b24gYmVtPXtiZW1TcGVjaWZpZXJ9IGNsYXNzTmFtZT17dGhpcy5wcm9wcy5jbGFzc05hbWV9IG9uQ2xpY2s9e3RoaXMucHJvcHMub25DbGlja30+XG4gICAgICAgIHt0aGlzLnByb3BzLmNoaWxkcmVufVxuICAgICAgPC9idXR0b24+XG4gICAgKVxuICB9XG59XG5cbkJ1dHRvbkNvbXBvbmVudC5wcm9wVHlwZXMgPSB7XG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLmFueS5pc1JlcXVpcmVkLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmdcbn1cblxuQnV0dG9uQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2J1dHRvbi1jb21wb25lbnQuanN4IiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdnbG9iYWxzJ1xuaW1wb3J0IE1vZGFsTWFuYWdlciBmcm9tICdzaGFyZWQvbWFuYWdlcnMvbW9kYWwtbWFuYWdlcidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsZUxvYWRlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChpbnB1dCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9pbnB1dCA9IGlucHV0XG4gICAgdGhpcy5fb25GaWxlQ2hhbmdlID0gdGhpcy5fb25GaWxlQ2hhbmdlLmJpbmQodGhpcylcbiAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbkZpbGVDaGFuZ2UpXG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgdGhlIGZpbGUgZGlhbG9nXG4gICAqL1xuICBvcGVuICgpIHtcbiAgICB0aGlzLl9pbnB1dC52YWx1ZSA9IG51bGxcbiAgICB0aGlzLl9pbnB1dC5jbGljaygpXG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgdGhlIGZpbGUgaW50byBhbiBpbWFnZVxuICAgKiBAcGFyYW0gIHtGaWxlfSBmaWxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaGFuZGxlRmlsZSAoZmlsZSkge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyB3aW5kb3cuRmlsZVJlYWRlcigpXG4gICAgcmVhZGVyLm9ubG9hZCA9ICgoKSA9PiB7XG4gICAgICByZXR1cm4gKGUpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGUudGFyZ2V0LnJlc3VsdFxuICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyB3aW5kb3cuSW1hZ2UoKVxuXG4gICAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdmaWxlJywgaW1hZ2UpXG4gICAgICAgIH0pXG5cbiAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlID0+IHtcbiAgICAgICAgICByZXR1cm4gTW9kYWxNYW5hZ2VyLmluc3RhbmNlLmRpc3BsYXlFcnJvcihcbiAgICAgICAgICAgIHRoaXMuX3QoJ2Vycm9ycy50aXRsZScpLFxuICAgICAgICAgICAgdGhpcy5fdCgnZXJyb3JzLmltYWdlTG9hZGluZ0Vycm9yLnRleHQnKVxuICAgICAgICAgIClcbiAgICAgICAgfSlcblxuICAgICAgICBpbWFnZS5zcmMgPSBkYXRhXG4gICAgICB9XG4gICAgfSkoZmlsZSlcbiAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGZpbGUgaW5wdXQgdmFsdWUgY2hhbmdlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uRmlsZUNoYW5nZSAoKSB7XG4gICAgY29uc3QgeyBmaWxlcyB9ID0gdGhpcy5faW5wdXRcbiAgICBpZiAoIWZpbGVzLmxlbmd0aCkgcmV0dXJuXG5cbiAgICB0aGlzLl9oYW5kbGVGaWxlKGZpbGVzWzBdKVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIGFsbCBsaXN0ZW5lcnNcbiAgICovXG4gIGRpc3Bvc2UgKCkge1xuICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uRmlsZUNoYW5nZSlcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zaGFyZWQvbG9hZGVycy9maWxlLWxvYWRlci5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgU0RLVXRpbHMsIEV2ZW50RW1pdHRlciB9IGZyb20gJ2dsb2JhbHMnXG5cbmNsYXNzIE1vZGFsIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKHR5cGUsIHRpdGxlLCB0ZXh0LCBvdmVybGF5ID0gZmFsc2UsIGNsb3NlT25PdmVybGF5Q2xpY2sgPSBmYWxzZSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmlkID0gU0RLVXRpbHMuZ2V0VVVJRCgpXG4gICAgdGhpcy50eXBlID0gdHlwZVxuICAgIHRoaXMudGl0bGUgPSB0aXRsZVxuICAgIHRoaXMudGV4dCA9IHRleHRcbiAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5XG4gICAgdGhpcy5jbG9zZU9uT3ZlcmxheUNsaWNrID0gY2xvc2VPbk92ZXJsYXlDbGlja1xuICAgIHRoaXMudmlzaWJsZSA9IHRydWVcbiAgICB0aGlzLmRhdGEgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZGF0YSB0byB0aGUgZ2l2ZW4gb25lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuICBzZXREYXRhIChkYXRhKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YVxuICAgIHRoaXMuZW1pdCgndXBkYXRlJylcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhpcyBtb2RhbFxuICAgKi9cbiAgY2xvc2UgKCkge1xuICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlXG4gICAgdGhpcy5lbWl0KCdjbG9zZScpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGlzIG1vZGFsXG4gICAqL1xuICByZW1vdmUgKCkge1xuICAgIHRoaXMuZW1pdCgncmVtb3ZlJylcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RhbE1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5fbW9kYWxzID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbG9hZGluZyBtb2RhbFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRpdGxlXG4gICAqIEByZXR1cm4ge01vZGFsfVxuICAgKi9cbiAgZGlzcGxheUxvYWRpbmcgKHRpdGxlLCBvdmVybGF5ID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1vZGFsID0gbmV3IE1vZGFsKCdsb2FkaW5nJywgdGl0bGUsIG51bGwsIG92ZXJsYXkpXG4gICAgdGhpcy5hZGRNb2RhbChtb2RhbClcbiAgICByZXR1cm4gbW9kYWxcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcHJvZ3Jlc3MgbW9kYWxcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0ZXh0XG4gICAqIEByZXR1cm4ge01vZGFsfVxuICAgKi9cbiAgZGlzcGxheVByb2dyZXNzICh0ZXh0LCBwcm9ncmVzcyA9IDApIHtcbiAgICBjb25zdCBtb2RhbCA9IG5ldyBNb2RhbCgncHJvZ3Jlc3MnLCBudWxsLCB0ZXh0KVxuICAgIG1vZGFsLnNldERhdGEoeyBwcm9ncmVzcyB9KVxuICAgIHRoaXMuYWRkTW9kYWwobW9kYWwpXG4gICAgcmV0dXJuIG1vZGFsXG4gIH1cblxuICBkaXNwbGF5SW5wdXQgKHRpdGxlLCB0ZXh0ID0gJycsIG92ZXJsYXkgPSB0cnVlKSB7XG4gICAgY29uc3QgbW9kYWwgPSBuZXcgTW9kYWwoJ2lucHV0JywgdGl0bGUsIG51bGwsIG92ZXJsYXksIHRydWUpXG4gICAgbW9kYWwuc2V0RGF0YSh7IHRleHQgfSlcbiAgICB0aGlzLmFkZE1vZGFsKG1vZGFsKVxuICAgIHJldHVybiBtb2RhbFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB3YXJuaW5nIG1vZGFsXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdGl0bGVcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IG92ZXJsYXkgPSB0cnVlXG4gICAqIEByZXR1cm4ge01vZGFsfVxuICAgKi9cbiAgZGlzcGxheVdhcm5pbmcgKHRpdGxlLCB0ZXh0LCBidXR0b25zID0gWydPSyddLCBvdmVybGF5ID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1vZGFsID0gbmV3IE1vZGFsKCd3YXJuaW5nJywgdGl0bGUsIHRleHQsIG92ZXJsYXkpXG4gICAgbW9kYWwuc2V0RGF0YSh7IGJ1dHRvbnMgfSlcbiAgICB0aGlzLmFkZE1vZGFsKG1vZGFsKVxuICAgIHJldHVybiBtb2RhbFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZXJyb3IgbW9kYWxcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0aXRsZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRleHRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gb3ZlcmxheSA9IHRydWVcbiAgICogQHJldHVybiB7TW9kYWx9XG4gICAqL1xuICBkaXNwbGF5RXJyb3IgKHRpdGxlLCB0ZXh0LCBvdmVybGF5ID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1vZGFsID0gbmV3IE1vZGFsKCdlcnJvcicsIHRpdGxlLCB0ZXh0LCBvdmVybGF5KVxuICAgIHRoaXMuYWRkTW9kYWwobW9kYWwpXG4gICAgcmV0dXJuIG1vZGFsXG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gbW9kYWwgdG8gdGhlIGxpc3Qgb2YgbW9kYWxzXG4gICAqIEBwYXJhbSB7TW9kYWx9IG1vZGFsXG4gICAqL1xuICBhZGRNb2RhbCAobW9kYWwpIHtcbiAgICB0aGlzLl9tb2RhbHMucHVzaChtb2RhbClcbiAgICBtb2RhbC5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScpXG4gICAgfSlcbiAgICBtb2RhbC5vbigncmVtb3ZlJywgKCkgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVNb2RhbChtb2RhbClcbiAgICB9KVxuICAgIG1vZGFsLm9uKCd1cGRhdGUnLCAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScpXG4gICAgfSlcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gbW9kYWwgZnJvbSB0aGUgbGlzdCBvZiBtb2RhbHNcbiAgICogQHBhcmFtICB7TW9kYWx9IG1vZGFsXG4gICAqL1xuICByZW1vdmVNb2RhbCAobW9kYWwpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX21vZGFscy5pbmRleE9mKG1vZGFsKVxuICAgIHRoaXMuX21vZGFscy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1vZGFsc1xuICAgKiBAcmV0dXJuIHtBcnJheS48TW9kYWw+fVxuICAgKi9cbiAgZ2V0TW9kYWxzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kYWxzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb25lIGFuZCBvbmx5IGluc3RhbmNlIG9mIHRoaXMgY2xhc3NcbiAgICogQHJldHVybiB7TW9kYWxNYW5hZ2VyfVxuICAgKi9cbiAgc3RhdGljIGdldCBpbnN0YW5jZSAoKSB7XG4gICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgdGhpcy5faW5zdGFuY2UgPSBuZXcgTW9kYWxNYW5hZ2VyKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvanMvc2hhcmVkL21hbmFnZXJzL21vZGFsLW1hbmFnZXIuanMiLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgVXRpbHMgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IFJvd0NvbXBvbmVudCBmcm9tICcuL3Jvdy1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYmNhbUNvbXBvbmVudCBleHRlbmRzIFJvd0NvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX25lZWRzU3R5bGVGaXhlcyA9IHRydWVcbiAgICB0aGlzLl9tb2RpZmllciA9ICd3ZWJjYW0nXG4gIH1cblxuICAvKipcbiAgICogQSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgc3R5bGVzIG5lZWQgdG8gYmUgZml4ZWQgYnkgdGhlIEphdmFTY3JpcHQuXG4gICAqIFRoaXMgbmVlZHMgdG8gYmUgZG9uZSB0aGFua3MgdG8gb2xkZXIgSW50ZXJuZXQgRXhwbG9yZXIgYnJvd3NlcnMgd2hpY2ggaGF2ZVxuICAgKiBhIGJ1bmNoIG9mIENTUyBidWdzLlxuICAgKi9cbiAgZml4U3R5bGVzICgpIHtcbiAgICBpZiAoVXRpbHMuQnJvd3Nlci5pc0lFbHRlKDExKSkge1xuICAgICAgY29uc3QgeyBjZWxsLCBvdmVybGF5IH0gPSB0aGlzLnJlZnNcbiAgICAgIGNvbnN0IGNlbGxIZWlnaHQgPSBjZWxsLm9mZnNldEhlaWdodFxuICAgICAgb3ZlcmxheS5zdHlsZS5oZWlnaHQgPSBgJHtjZWxsSGVpZ2h0fXB4YFxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgcm93J3MgY29udGVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckNvbnRlbnQgKCkge1xuICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgYmFja2dyb3VuZEltYWdlOiBgdXJsKCR7dGhpcy5fZ2V0QXNzZXRQYXRoKCdzcGxhc2gvd2ViY2FtLnBuZycsIHRydWUsIHRydWUpfSlgXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgYmVtPSdlOmNvbnRlbnRXcmFwcGVyJz5cbiAgICAgICAgPGRpdiBiZW09J2U6Y29udGVudFJvdyc+XG4gICAgICAgICAgPGRpdiBiZW09J2U6Y29udGVudENlbGwnIG9uQ2xpY2s9e3RoaXMuX29uQ2xpY2t9IHN0eWxlPXtzdHlsZX0gcmVmPSdjZWxsJz5cbiAgICAgICAgICAgIDxkaXYgYmVtPSdlOm92ZXJsYXknIHJlZj0nb3ZlcmxheScgLz5cbiAgICAgICAgICAgIDxkaXYgYmVtPSdlOmhlYWRsaW5lJz5cbiAgICAgICAgICAgICAge3RoaXMuX3QoJ3Blc2RrLnNwbGFzaC50aXRsZS53ZWJjYW0nKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBiZW09J2U6ZGVzY3JpcHRpb24nPlxuICAgICAgICAgICAgICB7dGhpcy5fdCgncGVzZGsuc3BsYXNoLnRleHQud2ViY2FtJyl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxuV2ViY2FtQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IFJvd0NvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvc2NyZWVucy9zcGxhc2gvd2ViY2FtLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBVdGlscywgUmVhY3RCRU0gfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IFJvd0NvbXBvbmVudCBmcm9tICcuL3Jvdy1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBob3RvUm9sbENvbXBvbmVudCBleHRlbmRzIFJvd0NvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX25lZWRzU3R5bGVGaXhlcyA9IHRydWVcbiAgICB0aGlzLl9tb2RpZmllciA9ICdwaG90b1JvbGwnXG4gIH1cblxuICAvKipcbiAgICogQSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgc3R5bGVzIG5lZWQgdG8gYmUgZml4ZWQgYnkgdGhlIEphdmFTY3JpcHQuXG4gICAqIFRoaXMgbmVlZHMgdG8gYmUgZG9uZSB0aGFua3MgdG8gb2xkZXIgSW50ZXJuZXQgRXhwbG9yZXIgYnJvd3NlcnMgd2hpY2ggaGF2ZVxuICAgKiBhIGJ1bmNoIG9mIENTUyBidWdzLlxuICAgKi9cbiAgZml4U3R5bGVzICgpIHtcbiAgICBpZiAoVXRpbHMuQnJvd3Nlci5pc0lFbHRlKDExKSkge1xuICAgICAgY29uc3QgeyBjZWxsLCBvdmVybGF5IH0gPSB0aGlzLnJlZnNcbiAgICAgIGNvbnN0IGNlbGxIZWlnaHQgPSBjZWxsLm9mZnNldEhlaWdodFxuICAgICAgb3ZlcmxheS5zdHlsZS5oZWlnaHQgPSBgJHtjZWxsSGVpZ2h0fXB4YFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgcm93J3MgY29udGVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckNvbnRlbnQgKCkge1xuICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgYmFja2dyb3VuZEltYWdlOiBgdXJsKCR7dGhpcy5fZ2V0QXNzZXRQYXRoKCdzcGxhc2gvcGhvdG8tcm9sbC5wbmcnLCB0cnVlLCB0cnVlKX0pYFxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGJlbT0nZTpjb250ZW50V3JhcHBlcic+XG4gICAgICAgIDxkaXYgYmVtPSdlOmNvbnRlbnRSb3cnPlxuICAgICAgICAgIDxkaXYgYmVtPSdlOmNvbnRlbnRDZWxsJyBvbkNsaWNrPXt0aGlzLl9vbkNsaWNrfSBzdHlsZT17c3R5bGV9IHJlZj0nY2VsbCc+XG4gICAgICAgICAgICA8ZGl2IGJlbT0nZTpvdmVybGF5JyByZWY9J292ZXJsYXknIC8+XG4gICAgICAgICAgICA8ZGl2IGJlbT0nZTpoZWFkbGluZSc+XG4gICAgICAgICAgICAgIHt0aGlzLl90KCdwZXNkay5zcGxhc2gudGl0bGUucGhvdG9Sb2xsJyl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgYmVtPSdlOmRlc2NyaXB0aW9uJz5cbiAgICAgICAgICAgICAge3RoaXMuX3QoJ3Blc2RrLnNwbGFzaC50ZXh0LnBob3RvUm9sbCcpfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG5cblBob3RvUm9sbENvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBSb3dDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL3NjcmVlbnMvc3BsYXNoL3Bob3RvLXJvbGwtY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFByb3BUeXBlcywgUmVhY3RCRU0sIFNES1V0aWxzIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBTY3JlZW5Db21wb25lbnQgZnJvbSAnLi4vc2NyZWVuLWNvbXBvbmVudCdcbmltcG9ydCBUb3BCYXJDb250cm9sc0NvbXBvbmVudCBmcm9tICcuL3RvcC1iYXIvdG9wLWJhci1jb21wb25lbnQnXG5pbXBvcnQgT3ZlcnZpZXdDb21wb25lbnQgZnJvbSAnLi9vdmVydmlldy1jb21wb25lbnQnXG5pbXBvcnQgUGhvdG9MaXN0Q29tcG9uZW50IGZyb20gJy4vcGhvdG8tbGlzdC1jb21wb25lbnQnXG5pbXBvcnQgU2VhcmNoUmVzdWx0c0NvbXBvbmVudCBmcm9tICcuL3NlYXJjaC1yZXN1bHRzLWNvbXBvbmVudCdcbmltcG9ydCBNb2RhbE1hbmFnZXIgZnJvbSAnLi4vLi4vLi4vbGliL21vZGFsLW1hbmFnZXInXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBob3RvUm9sbFNjcmVlbkNvbXBvbmVudCBleHRlbmRzIFNjcmVlbkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBzZWN0aW9uOiAnb3ZlcnZpZXcnLFxuICAgICAgc2VjdGlvbnNIaXN0b3J5OiBbXVxuICAgIH1cblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uTGlicmFyeUNsaWNrZWQnLFxuICAgICAgJ19vblNlYXJjaFN1Z2dlc3Rpb25DbGlja2VkJyxcbiAgICAgICdfb25QaG90b0NsaWNrZWQnLFxuICAgICAgJ19vbkZpbGVVcGxvYWQnLFxuICAgICAgJ19vbldlYmNhbUNsaWNrJyxcbiAgICAgICdfb25CYWNrQ2xpY2tlZCcsXG4gICAgICAnX29uU2VhcmNoJ1xuICAgIClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFNFQ1RJT05TXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgcGhvdG8gcm9sbCBzY3JlZW4gaGFzIGEgcHJldmlvdXMgc2VjdGlvblxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBoYXNQcmV2aW91c1NlY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXRoaXMuc3RhdGUuc2VjdGlvbnNIaXN0b3J5Lmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIFN3aXRjaGVzIHRvIHRoZSBnaXZlbiBzZWN0aW9uXG4gICAqIEBwYXJhbSAge1N0cmluZ30gc2VjdGlvblxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBhbGxvd1NjcmVlblN3aXRjaCA9IHRydWVcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gYWRkVG9TdGFjayA9IHRydWVcbiAgICovXG4gIHN3aXRjaFRvU2VjdGlvbiAoc2VjdGlvbiwgYWxsb3dTY3JlZW5Td2l0Y2ggPSB0cnVlLCBhZGRUb1N0YWNrID0gdHJ1ZSkge1xuICAgIGlmIChzZWN0aW9uID09PSAnYmFjaycpIHtcbiAgICAgIGlmICghdGhpcy5oYXNQcmV2aW91c1NlY3Rpb24oKSkge1xuICAgICAgICBpZiAoYWxsb3dTY3JlZW5Td2l0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5hcHAuc3dpdGNoVG9TY3JlZW4oJ2JhY2snKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN3aXRjaFRvU2VjdGlvbignb3ZlcnZpZXcnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZWN0aW9uID0gdGhpcy5zdGF0ZS5zZWN0aW9uc0hpc3RvcnkucG9wKClcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuc2VjdGlvbiAhPT0gc2VjdGlvbiAmJiBhZGRUb1N0YWNrKSB7XG4gICAgICB0aGlzLnN0YXRlLnNlY3Rpb25zSGlzdG9yeS5wdXNoKHRoaXMuc3RhdGUuc2VjdGlvbilcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHsgc2VjdGlvbiB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYSBsaWJyYXJ5IGhhcyBiZWVuIGNsaWNrZWRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5QaG90b1JvbGwuTGlicmFyeX0gbGlicmFyeVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGF1dG9tYXRpY2FsbHkgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uTGlicmFyeUNsaWNrZWQgKGxpYnJhcnksIGF1dG9tYXRpY2FsbHkgPSBmYWxzZSkge1xuICAgIHRoaXMuc3RhdGUubGlicmFyeSA9IGxpYnJhcnlcbiAgICB0aGlzLnN3aXRjaFRvU2VjdGlvbignbGlicmFyeScsIHRydWUsICFhdXRvbWF0aWNhbGx5KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYSBzZWFyY2ggc3VnZ2VzdGlvbiBoYXMgYmVlbiBjbGlja2VkXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuUGhvdG9Sb2xsLlNlYXJjaFN1Z2dlc3Rpb259IHNlYXJjaFN1Z2dlc3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblNlYXJjaFN1Z2dlc3Rpb25DbGlja2VkIChzZWFyY2hTdWdnZXN0aW9uKSB7XG4gICAgdGhpcy5zdGF0ZS5zZWFyY2hRdWVyeSA9IHNlYXJjaFN1Z2dlc3Rpb24ucXVlcnlcbiAgICB0aGlzLnN3aXRjaFRvU2VjdGlvbignc2VhcmNoJylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGhhcyBjbGlja2VkIGFuZCB0aGUgUGhvdG9Sb2xsIGhhcyBsb2FkZWQgYSBwaG90b1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLlBob3RvUm9sbC5QaG90b30gcGhvdG9cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblBob3RvQ2xpY2tlZCAocGhvdG8pIHtcbiAgICBjb25zdCBsb2FkaW5nTW9kYWwgPSBNb2RhbE1hbmFnZXIuaW5zdGFuY2UuZGlzcGxheUxvYWRpbmcodGhpcy5fdCgncGVzZGsuY29tbW9uLnRleHQubG9hZGluZycpKVxuXG4gICAgY29uc3QgaW1hZ2UgPSBuZXcgd2luZG93LkltYWdlKClcbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgbG9hZGluZ01vZGFsLmNsb3NlKClcbiAgICAgIHRoaXMucHJvcHMuYXBwLnNldEltYWdlKGltYWdlLCB0cnVlKVxuICAgIH0pXG4gICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoKSA9PiB7XG4gICAgICBsb2FkaW5nTW9kYWwuY2xvc2UoKVxuICAgICAgTW9kYWxNYW5hZ2VyLmluc3RhbmNlLmRpc3BsYXlFcnJvcihcbiAgICAgICAgdGhpcy5fdCgncGVzZGsuY29tbW9uLnRpdGxlLmltYWdlTG9hZEZhaWwnKSxcbiAgICAgICAgdGhpcy5fdCgncGVzZGsuY29tbW9uLnRleHQuaW1hZ2VMb2FkRmFpbCcsIHsgcGF0aDogaW1hZ2Uuc3JjIH0pXG4gICAgICApXG4gICAgfSlcbiAgICBpbWFnZS5jcm9zc09yaWdpbiA9IFNES1V0aWxzLmdldENyb3NzT3JpZ2luVmFsdWUodGhpcy5jb250ZXh0Lm9wdGlvbnMuY3Jvc3NPcmlnaW4pXG4gICAgaW1hZ2Uuc3JjID0gcGhvdG8udXJscy5yYXdcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYmFjayBidXR0b25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJhY2tDbGlja2VkICgpIHtcbiAgICB0aGlzLnN3aXRjaFRvU2VjdGlvbignYmFjaycpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhIHNlYXJjaCBpcyB0cmlnZ2VyZWRcbiAgICogQHBhcmFtICB7U3RyaW5nfSBxdWVyeVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uU2VhcmNoIChxdWVyeSkge1xuICAgIGlmICghcXVlcnkudHJpbSgpLmxlbmd0aCkge1xuICAgICAgdGhpcy5zdGF0ZS5zZWFyY2hRdWVyeSA9IG51bGxcbiAgICAgIHJldHVybiB0aGlzLnN3aXRjaFRvU2VjdGlvbignYmFjaycsIGZhbHNlKVxuICAgIH1cblxuICAgIHRoaXMuc3RhdGUuc2VhcmNoUXVlcnkgPSBxdWVyeVxuICAgIHRoaXMuc3dpdGNoVG9TZWN0aW9uKCdzZWFyY2gnKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSB3ZWJjYW0gYnV0dG9uLiBTd2l0Y2hlcyB0byB0aGVcbiAgICogd2ViY2FtIHNjcmVlblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uV2ViY2FtQ2xpY2sgKCkge1xuICAgIHRoaXMucHJvcHMuYXBwLnN3aXRjaFRvU2NyZWVuKCd3ZWJjYW0nKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgaGFzIHNlbGVjdGVkIGEgbmV3IGZpbGVcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VcbiAgICovXG4gIF9vbkZpbGVVcGxvYWQgKGltYWdlKSB7XG4gICAgdGhpcy5wcm9wcy5hcHAuc2V0SW1hZ2UoaW1hZ2UpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBCQUNLIEJVVFRPTlxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGJhY2sgYnV0dG9uIHNob3VsZCBiZSB2aXNpYmxlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaXNCYWNrQnV0dG9uVmlzaWJsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuc2VjdGlvbnNIaXN0b3J5Lmxlbmd0aCAhPT0gMCB8fFxuICAgICAgdGhpcy5wcm9wcy5hcHAuaGFzUHJldmlvdXNTY3JlZW4oKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGNvbnRlbnQgY29tcG9uZW50IGZvciB0aGlzIHNjcmVlblxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckNvbnRlbnQgKCkge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZS5zZWN0aW9uKSB7XG4gICAgICBjYXNlICdzZWFyY2gnOlxuICAgICAgICByZXR1cm4gKDxTZWFyY2hSZXN1bHRzQ29tcG9uZW50XG4gICAgICAgICAgcXVlcnk9e3RoaXMuc3RhdGUuc2VhcmNoUXVlcnl9XG4gICAgICAgICAgb25QaG90b0NsaWNrZWQ9e3RoaXMuX29uUGhvdG9DbGlja2VkfVxuICAgICAgICAgIG9uU2VhcmNoU3VnZ2VzdGlvbkNsaWNrZWQ9e3RoaXMuX29uU2VhcmNoU3VnZ2VzdGlvbkNsaWNrZWR9IC8+KVxuICAgICAgY2FzZSAnbGlicmFyeSc6XG4gICAgICAgIHJldHVybiAoPFBob3RvTGlzdENvbXBvbmVudFxuICAgICAgICAgIGNyb3NzT3JpZ2luPXtTREtVdGlscy5nZXRDcm9zc09yaWdpblZhbHVlKHRoaXMuY29udGV4dC5vcHRpb25zLmNyb3NzT3JpZ2luKX1cbiAgICAgICAgICBsaWJyYXJ5PXt0aGlzLnN0YXRlLmxpYnJhcnl9XG4gICAgICAgICAgb25QaG90b0NsaWNrZWQ9e3RoaXMuX29uUGhvdG9DbGlja2VkfSAvPilcbiAgICAgIGNhc2UgJ292ZXJ2aWV3JzpcbiAgICAgICAgcmV0dXJuICg8T3ZlcnZpZXdDb21wb25lbnRcbiAgICAgICAgICBvbkxpYnJhcnlDbGlja2VkPXt0aGlzLl9vbkxpYnJhcnlDbGlja2VkfVxuICAgICAgICAgIG9uU2VhcmNoU3VnZ2VzdGlvbkNsaWNrZWQ9e3RoaXMuX29uU2VhcmNoU3VnZ2VzdGlvbkNsaWNrZWR9XG4gICAgICAgIC8+KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgc2NyZWVuXG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyU2NyZWVuICgpIHtcbiAgICBjb25zdCBjb250ZW50Q29tcG9uZW50ID0gdGhpcy5fcmVuZGVyQ29udGVudCgpXG5cbiAgICByZXR1cm4gKDxkaXYgYmVtPSckYjpwaG90b1JvbGxTY3JlZW4nPlxuICAgICAgPFRvcEJhckNvbnRyb2xzQ29tcG9uZW50XG4gICAgICAgIG9uQmFja0NsaWNrZWQ9e3RoaXMuX29uQmFja0NsaWNrZWR9XG4gICAgICAgIG9uU2VhcmNoPXt0aGlzLl9vblNlYXJjaH1cbiAgICAgICAgc2VhcmNoUXVlcnk9e3RoaXMuc3RhdGUuc2VhcmNoUXVlcnl9XG4gICAgICAgIG9uRmlsZVVwbG9hZD17dGhpcy5fb25GaWxlVXBsb2FkfVxuICAgICAgICBvbldlYmNhbUNsaWNrPXt0aGlzLl9vbldlYmNhbUNsaWNrfVxuICAgICAgICBiYWNrQnV0dG9uPXt0aGlzLl9pc0JhY2tCdXR0b25WaXNpYmxlKCl9XG4gICAgICAgIGJhY2tCdXR0b25MYWJlbD17dGhpcy5fdCgncGVzZGsuY29tbW9uLmJ1dHRvbi5iYWNrJyl9XG4gICAgICAgIHJlZj0ndG9wQmFyQ29udHJvbHMnIC8+XG4gICAgICB7Y29udGVudENvbXBvbmVudH1cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuLy8gUGhvdG9Sb2xsU2NyZWVuQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzID0ge1xuLy8gICB1aTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuLy8gICBlZGl0b3I6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbi8vICAgbWVkaWF0b3I6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbi8vICAgb3B0aW9uczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuLy8gICBlZGl0b3JTY3JlZW46IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxuLy8gfVxuXG5QaG90b1JvbGxTY3JlZW5Db21wb25lbnQuY29udGV4dFR5cGVzID0gU2NyZWVuQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9zY3JlZW5zL3Bob3RvLXJvbGwvcGhvdG8tcm9sbC1zY3JlZW4tY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBVdGlscyB9IGZyb20gJy4uLy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgVG9wQmFyQ29tcG9uZW50IGZyb20gJy4uLy4uLy4uL3NoYXJlZC90b3AtYmFyL3RvcC1iYXItY29tcG9uZW50J1xuaW1wb3J0IFRvcEJhckJ1dHRvbkNvbXBvbmVudCBmcm9tICcuL3RvcC1iYXItYnV0dG9uLWNvbXBvbmVudCdcbmltcG9ydCBJbnZpc2libGVVcGxvYWRDb21wb25lbnQgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2ludmlzaWJsZS11cGxvYWQtY29tcG9uZW50J1xuaW1wb3J0IFNlYXJjaENvbXBvbmVudCBmcm9tICcuL3RvcC1iYXItc2VhcmNoLWNvbXBvbmVudCdcbmltcG9ydCBUb3BCYXJCYWNrQnV0dG9uIGZyb20gJy4uLy4uLy4uL3NoYXJlZC90b3AtYmFyL2JhY2stYnV0dG9uLWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGhvdG9Sb2xsVG9wQmFyQ29tcG9uZW50IGV4dGVuZHMgVG9wQmFyQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25VcGxvYWRCdXR0b25DbGlja2VkJyxcbiAgICAgICdfb25XZWJjYW1CdXR0b25DbGlja2VkJyxcbiAgICAgICdfb25CYWNrQ2xpY2tlZCcsXG4gICAgICAnX29uU2VhcmNoVmFsdWVDaGFuZ2UnLFxuICAgICAgJ19vbk5ld0ZpbGUnXG4gICAgKVxuXG4gICAgdGhpcy5fb25TZWFyY2hWYWx1ZUNoYW5nZSA9IFV0aWxzLmRlYm91bmNlKHRoaXMuX29uU2VhcmNoVmFsdWVDaGFuZ2UsIDI1MClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYmFjayBidXR0b25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJhY2tDbGlja2VkICgpIHtcbiAgICB0aGlzLnByb3BzLm9uQmFja0NsaWNrZWQgJiZcbiAgICAgIHRoaXMucHJvcHMub25CYWNrQ2xpY2tlZCgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgc2VhcmNoIHZhbHVlIGhhcyBjaGFuZ2VkICh0aGlzIG1ldGhvZCBpcyBkZWJvdW5jZWQpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uU2VhcmNoVmFsdWVDaGFuZ2UgKHZhbHVlKSB7XG4gICAgdGhpcy5wcm9wcy5vblNlYXJjaCAmJlxuICAgICAgdGhpcy5wcm9wcy5vblNlYXJjaCh2YWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgdXBsb2FkIGJ1dHRvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uVXBsb2FkQnV0dG9uQ2xpY2tlZCAoKSB7XG4gICAgdGhpcy5yZWZzLnVwbG9hZC5vcGVuKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgd2ViY2FtIGJ1dHRvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uV2ViY2FtQnV0dG9uQ2xpY2tlZCAoKSB7XG4gICAgdGhpcy5wcm9wcy5vbldlYmNhbUNsaWNrICYmXG4gICAgICB0aGlzLnByb3BzLm9uV2ViY2FtQ2xpY2soKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYSBuZXcgZmlsZSBoYXMgYmVlbiBzZWxlY3RlZFxuICAgKiBAcGFyYW0gIHtGaWxlfSBmaWxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25OZXdGaWxlIChmaWxlKSB7XG4gICAgdGhpcy5wcm9wcy5vbkZpbGVVcGxvYWQgJiZcbiAgICAgIHRoaXMucHJvcHMub25GaWxlVXBsb2FkKGZpbGUpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB3ZWJjYW0gaXMgYXZhaWxhYmxlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaXNXZWJjYW1BdmFpbGFibGUgKCkge1xuICAgIHJldHVybiAhVXRpbHMuaXNNb2JpbGUoKSAmJiB0aGlzLmNvbnRleHQub3B0aW9ucy5lbmFibGVXZWJjYW0gIT09IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgYnV0dG9ucyBvbiB0aGUgcmlnaHRcbiAgICogQHJldHVybiB7QXJyYXkuPFJlYWN0LkNvbXBvbmVudD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyUmlnaHRCdXR0b25zICgpIHtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dFxuICAgIGxldCBidXR0b25zID0gW11cblxuICAgIGlmIChvcHRpb25zLmVuYWJsZVVwbG9hZCkge1xuICAgICAgYnV0dG9ucy5wdXNoKDxUb3BCYXJCdXR0b25Db21wb25lbnRcbiAgICAgICAgaWNvbj17dGhpcy5fZ2V0QXNzZXRQYXRoKCdwaG90by1yb2xsL3VwbG9hZC5wbmcnLCB0cnVlKX1cbiAgICAgICAgb25DbGljaz17dGhpcy5fb25VcGxvYWRCdXR0b25DbGlja2VkfVxuICAgICAgLz4pXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzV2ViY2FtQXZhaWxhYmxlKCkpIHtcbiAgICAgIGJ1dHRvbnMucHVzaCg8VG9wQmFyQnV0dG9uQ29tcG9uZW50XG4gICAgICAgIGljb249e3RoaXMuX2dldEFzc2V0UGF0aCgncGhvdG8tcm9sbC93ZWJjYW0ucG5nJywgdHJ1ZSl9XG4gICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uV2ViY2FtQnV0dG9uQ2xpY2tlZH1cbiAgICAgIC8+KVxuICAgIH1cblxuICAgIHJldHVybiBidXR0b25zXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgbGV0IGJhY2tCdXR0b25cbiAgICBpZiAodGhpcy5wcm9wcy5iYWNrQnV0dG9uKSB7XG4gICAgICBiYWNrQnV0dG9uID0gKDxUb3BCYXJCYWNrQnV0dG9uXG4gICAgICAgIGxhYmVsPXt0aGlzLnByb3BzLmJhY2tCdXR0b25MYWJlbH1cbiAgICAgICAgb25DbGljaz17dGhpcy5fb25CYWNrQ2xpY2tlZH0gLz4pXG4gICAgfVxuICAgIHJldHVybiAoPGRpdiBiZW09JyRiOnRvcEJhciBlOnJvdyc+XG4gICAgICA8ZGl2IGJlbT0nZTpjZWxsJz5cbiAgICAgICAgPGRpdiBiZW09J2U6dGFibGUnPlxuICAgICAgICAgIDxkaXYgYmVtPSdlOmNlbGwgbTpsZWZ0Jz5cbiAgICAgICAgICAgIHtiYWNrQnV0dG9ufVxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPGRpdiBiZW09J2U6Y2VsbCBtOmZ1bGxXaWR0aCc+XG4gICAgICAgICAgICA8U2VhcmNoQ29tcG9uZW50XG4gICAgICAgICAgICAgIHNlYXJjaFF1ZXJ5PXt0aGlzLnByb3BzLnNlYXJjaFF1ZXJ5fVxuICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5fb25TZWFyY2hWYWx1ZUNoYW5nZX0gLz5cbiAgICAgICAgICAgIDxJbnZpc2libGVVcGxvYWRDb21wb25lbnQgb25OZXdGaWxlPXt0aGlzLl9vbk5ld0ZpbGV9IHJlZj0ndXBsb2FkJyAvPlxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPGRpdiBiZW09J2U6Y2VsbCBtOnJpZ2h0Jz5cbiAgICAgICAgICAgIHt0aGlzLl9yZW5kZXJSaWdodEJ1dHRvbnMoKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuUGhvdG9Sb2xsVG9wQmFyQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IFRvcEJhckNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvc2NyZWVucy9waG90by1yb2xsL3RvcC1iYXIvdG9wLWJhci1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi8uLi8uLi9nbG9iYWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb3BCYXJCdXR0b25Db21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIHJldHVybiAoPGJlbSBzcGVjaWZpZXI9JyRiOnRvcEJhcic+XG4gICAgICA8ZGl2IGJlbT0nJGU6aWNvbkJ1dHRvbicgb25DbGljaz17dGhpcy5wcm9wcy5vbkNsaWNrfT5cbiAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXt0aGlzLnByb3BzLmljb259IC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2JlbT4pXG4gIH1cbn1cblxuVG9wQmFyQnV0dG9uQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL3NjcmVlbnMvcGhvdG8tcm9sbC90b3AtYmFyL3RvcC1iYXItYnV0dG9uLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBVdGlscywgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi8uLi8uLi9nbG9iYWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb3BCYXJTZWFyY2hDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25Gb2N1cycsXG4gICAgICAnX29uQmx1cicsXG4gICAgICAnX29uQ2hhbmdlJyxcbiAgICAgICdfb25CYXJDbGljaydcbiAgICApXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgIHBsYWNlaG9sZGVyOiB0aGlzLl90KCdwZXNkay5saWJyYXJ5LnBsYWNlaG9sZGVyLnNlYXJjaCcpLFxuICAgICAgdmFsdWU6IHRoaXMucHJvcHMuc2VhcmNoUXVlcnkgfHwgJydcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBMSUZFQ1lDTEVcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyBhYm91dCB0byByZWNlaXZlIG5ldyBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSAge09iamVjdH0gbmV4dFByb3BzXG4gICAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChuZXh0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLnNlYXJjaFF1ZXJ5IHx8IHRoaXMuc3RhdGUudmFsdWUpIHtcbiAgICAgIHRoaXMuc3RhdGUuYWN0aXZlID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlLmFjdGl2ZSA9IGZhbHNlXG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB2YWx1ZTogbmV4dFByb3BzLnNlYXJjaFF1ZXJ5IHx8ICcnXG4gICAgfSlcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSAoKSB7XG4gICAgdGhpcy5yZWZzLmlucHV0LnZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudERpZE1vdW50KClcbiAgICB0aGlzLl9oaWRkZW5JbnB1dER1bW15ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcblxuICAgIGNvbnN0IHN0eWxlT2JqZWN0ID0gVXRpbHMuZ2V0U3R5bGVPYmplY3QodGhpcy5yZWZzLmlucHV0KVxuICAgIGNvbnN0IG92ZXJyaWRlS2V5cyA9IFtcbiAgICAgICdmb250JyxcbiAgICAgICdsaW5lSGVpZ2h0JyxcbiAgICAgICd0ZXh0QWxpZ24nLFxuICAgICAgJ3RleHRJbmRlbnQnLFxuICAgICAgJ3RleHRUcmFuc2Zvcm0nLFxuICAgICAgJ3RleHREZWNvcmF0aW9uJyxcbiAgICAgICd0ZXh0UmVuZGVyaW5nJyxcbiAgICAgICd0ZXh0U2hhZG93JyxcbiAgICAgICd0ZXh0T3ZlcmZsb3cnLFxuICAgICAgJ3dvcmRTcGFjaW5nJyxcbiAgICAgICdsZXR0ZXJTcGFjaW5nJyxcbiAgICAgICd3aGl0ZVNwYWNlJ1xuICAgIF1cbiAgICBvdmVycmlkZUtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICB0aGlzLl9oaWRkZW5JbnB1dER1bW15LnN0eWxlW2tleV0gPSBzdHlsZU9iamVjdFtrZXldXG4gICAgfSlcblxuICAgIHRoaXMuX2hpZGRlbklucHV0RHVtbXkuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXG4gICAgdGhpcy5faGlkZGVuSW5wdXREdW1teS5zdHlsZS50b3AgPSAnLTk5OTlweCdcbiAgICB0aGlzLl9oaWRkZW5JbnB1dER1bW15LnN0eWxlLmxlZnQgPSAnLTk5OTlweCdcblxuICAgIHRoaXMucmVmcy5yb290LmFwcGVuZENoaWxkKHRoaXMuX2hpZGRlbklucHV0RHVtbXkpXG5cbiAgICB0aGlzLl91cGRhdGVJbnB1dFdpZHRoKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE1JU0NcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgaW5wdXQgd2lkdGggdG8gZml0IHRoZSB0ZXh0IHdpZHRoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlSW5wdXRXaWR0aCAoKSB7XG4gICAgdGhpcy5faGlkZGVuSW5wdXREdW1teS5pbm5lckhUTUwgPSB0aGlzLnN0YXRlLnZhbHVlIHx8IHRoaXMuc3RhdGUucGxhY2Vob2xkZXJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpbnB1dFdpZHRoOiB0aGlzLl9oaWRkZW5JbnB1dER1bW15Lm9mZnNldFdpZHRoICsgNVxuICAgICAgfSlcbiAgICB9LCAwKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHNlYXJjaCBiYXIgaGFzIGJlZW4gY2xpY2tlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQmFyQ2xpY2sgKCkge1xuICAgIHRoaXMucmVmcy5pbnB1dC5mb2N1cygpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgaW5wdXQgZmllbGRzIGlzIGZvY3VzZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkZvY3VzICgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHsgYWN0aXZlOiB0cnVlIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgaW5wdXQgZmllbGQgbG9zZXMgZm9jdXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJsdXIgKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnZhbHVlID09PSAnJyAmJiAhdGhpcy5wcm9wcy5zZWFyY2hRdWVyeSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGFjdGl2ZTogZmFsc2UgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgaW5wdXQgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNoYW5nZSAoZSkge1xuICAgIHRoaXMuc3RhdGUudmFsdWUgPSBlLnRhcmdldC52YWx1ZVxuICAgIHRoaXMuZm9yY2VVcGRhdGUoKVxuXG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZSAmJlxuICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh0aGlzLnN0YXRlLnZhbHVlKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIGxldCBzZWFyY2hCYXJCRU0gPSAnJGU6c2VhcmNoQmFyJ1xuICAgIGxldCBpY29uUGF0aCA9ICdwaG90by1yb2xsL3NlYXJjaC1saWdodC5wbmcnXG4gICAgaWYgKHRoaXMuc3RhdGUuYWN0aXZlKSB7XG4gICAgICBzZWFyY2hCYXJCRU0gKz0gJyBtOmFjdGl2ZSdcbiAgICAgIGljb25QYXRoID0gJ3Bob3RvLXJvbGwvc2VhcmNoLWRhcmsucG5nJ1xuICAgIH1cbiAgICBpY29uUGF0aCA9IHRoaXMuX2dldEFzc2V0UGF0aChpY29uUGF0aCwgdHJ1ZSlcblxuICAgIGNvbnN0IGlucHV0U3R5bGUgPSB7XG4gICAgICB3aWR0aDogdGhpcy5zdGF0ZS5pbnB1dFdpZHRoICsgJ3B4J1xuICAgIH1cblxuICAgIHJldHVybiAoPGJlbSBzcGVjaWZpZXI9JyRiOnBob3RvUm9sbFNjcmVlbic+XG4gICAgICA8ZGl2IGJlbT17c2VhcmNoQmFyQkVNfSByZWY9J3Jvb3QnIG9uQ2xpY2s9e3RoaXMuX29uQmFyQ2xpY2t9PlxuICAgICAgICA8ZGl2IGJlbT0nZTpjb250ZW50Jz5cbiAgICAgICAgICA8ZGl2IGJlbT0nJGU6aWNvbic+XG4gICAgICAgICAgICA8aW1nIHNyYz17aWNvblBhdGh9IGJlbT0nZTppbWFnZScgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTppbnB1dENvbnRhaW5lcic+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgYmVtPSdlOmlucHV0J1xuICAgICAgICAgICAgICByZWY9J2lucHV0J1xuICAgICAgICAgICAgICBwbGFjZWhvbGRlcj17dGhpcy5zdGF0ZS5wbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgb25CbHVyPXt0aGlzLl9vbkJsdXJ9XG4gICAgICAgICAgICAgIG9uRm9jdXM9e3RoaXMuX29uRm9jdXN9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLl9vbkNoYW5nZX1cbiAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPXt0aGlzLnN0YXRlLnZhbHVlfVxuICAgICAgICAgICAgICBzdHlsZT17aW5wdXRTdHlsZX0gLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2JlbT4pXG4gIH1cbn1cblxuVG9wQmFyU2VhcmNoQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL3NjcmVlbnMvcGhvdG8tcm9sbC90b3AtYmFyL3RvcC1iYXItc2VhcmNoLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvcEJhckJhY2tCdXR0b25Db21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIHJldHVybiAoPGJlbSBzcGVjaWZpZXI9JyRiOnRvcEJhcic+XG4gICAgICA8ZGl2IGJlbT0nJGU6YmFja0J1dHRvbicgb25DbGljaz17dGhpcy5wcm9wcy5vbkNsaWNrfT5cbiAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXt0aGlzLl9nZXRBc3NldFBhdGgoJ3RvcC1iYXIvYmFjay5wbmcnLCB0cnVlKX0gLz5cbiAgICAgICAgPGRpdiBiZW09J2U6bGFiZWwnPnt0aGlzLnByb3BzLmxhYmVsfTwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9iZW0+KVxuICB9XG59XG5cblRvcEJhckJhY2tCdXR0b25Db21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvc2hhcmVkL3RvcC1iYXIvYmFjay1idXR0b24tY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFV0aWxzLCBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCwgUHJvbWlzZSB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgTW9kYWxNYW5hZ2VyIGZyb20gJy4uLy4uLy4uL2xpYi9tb2RhbC1tYW5hZ2VyJ1xuaW1wb3J0IExpYnJhcnlDb21wb25lbnQgZnJvbSAnLi9pdGVtcy9saWJyYXJ5LWNvbXBvbmVudCdcbmltcG9ydCBTZWFyY2hTdWdnZXN0aW9uQ29tcG9uZW50IGZyb20gJy4vaXRlbXMvc2VhcmNoLXN1Z2dlc3Rpb24tY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPdmVydmlld0NvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9uZWVkc1N0eWxlRml4ZXMgPSB0cnVlXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGxvYWRpbmc6IHRydWUsXG4gICAgICBsaWJyYXJpZXM6IFtdLFxuICAgICAgc2VhcmNoU3VnZ2VzdGlvbnM6IFtdXG4gICAgfVxuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25MaWJyYXJ5Q2xpY2snLFxuICAgICAgJ19vblNlYXJjaFN1Z2dlc3Rpb25DbGljaydcbiAgICApXG5cbiAgICBjb25zdCBQaG90b1JvbGxQcm92aWRlciA9IHRoaXMuY29udGV4dC5vcHRpb25zLnBob3RvUm9sbC5wcm92aWRlclxuICAgIHRoaXMuX3Byb3ZpZGVyID0gbmV3IFBob3RvUm9sbFByb3ZpZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuZXZlciBzdHlsZXMgbmVlZCB0byBiZSBmaXhlZCBieSB0aGUgSmF2YVNjcmlwdC5cbiAgICogVGhpcyBuZWVkcyB0byBiZSBkb25lIHRoYW5rcyB0byBvbGRlciBJbnRlcm5ldCBFeHBsb3JlciBicm93c2VycyB3aGljaCBoYXZlXG4gICAqIGEgYnVuY2ggb2YgQ1NTIGJ1Z3MuXG4gICAqL1xuICBmaXhTdHlsZXMgKCkge1xuICAgIGlmIChVdGlscy5Ccm93c2VyLmlzSUVsdGUoMTEpKSB7XG4gICAgICBjb25zdCB7IGNlbGwsIGNvbnRhaW5lciB9ID0gdGhpcy5yZWZzXG4gICAgICBpZiAoIShjZWxsICYmIGNvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCBjZWxsSGVpZ2h0ID0gY2VsbC5vZmZzZXRIZWlnaHRcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBgJHtjZWxsSGVpZ2h0fXB4YFxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIExJRkVDWUNMRVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICBzdXBlci5jb21wb25lbnREaWRNb3VudCgpXG5cbiAgICBjb25zdCBtb2RhbCA9IE1vZGFsTWFuYWdlci5pbnN0YW5jZS5kaXNwbGF5TG9hZGluZyh0aGlzLl90KCdwZXNkay5jb21tb24udGV4dC5sb2FkaW5nJykpXG4gICAgdGhpcy5fbG9hZCgpXG4gICAgICAudGhlbigoW2xpYnJhcmllcywgc2VhcmNoU3VnZ2VzdGlvbnNdKSA9PiB7XG4gICAgICAgIG1vZGFsLmNsb3NlKClcbiAgICAgICAgaWYgKGxpYnJhcmllcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB0aGlzLl9vbkxpYnJhcnlDbGljayhsaWJyYXJpZXNbMF0sIHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGxpYnJhcmllcyxcbiAgICAgICAgICAgIHNlYXJjaFN1Z2dlc3Rpb25zXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGEgbGlicmFyeSB3YXMgY2xpY2tlZFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLlBob3RvUm9sbC5MaWJyYXJ5fSBsaWJyYXJ5XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGF1dG9tYXRpY2FsbHkgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uTGlicmFyeUNsaWNrIChsaWJyYXJ5LCBhdXRvbWF0aWNhbGx5ID0gZmFsc2UpIHtcbiAgICB0aGlzLnByb3BzLm9uTGlicmFyeUNsaWNrZWQgJiZcbiAgICAgIHRoaXMucHJvcHMub25MaWJyYXJ5Q2xpY2tlZChsaWJyYXJ5LCBhdXRvbWF0aWNhbGx5KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYSBzZWFyY2ggc3VnZ2VzdGlvbiB3YXMgY2xpY2tlZFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLlBob3RvUm9sbC5TZWFyY2hTdWdnZXN0aW9ufSBzZWFyY2hTdWdnZXN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25TZWFyY2hTdWdnZXN0aW9uQ2xpY2sgKHNlYXJjaFN1Z2dlc3Rpb24pIHtcbiAgICB0aGlzLnByb3BzLm9uU2VhcmNoU3VnZ2VzdGlvbkNsaWNrZWQgJiZcbiAgICAgIHRoaXMucHJvcHMub25TZWFyY2hTdWdnZXN0aW9uQ2xpY2tlZChzZWFyY2hTdWdnZXN0aW9uKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTE9BRElOR1xuXG4gIC8qKlxuICAgKiBMb2FkcyB0aGUgbGlicmFyaWVzIGFuZCBzZWFyY2ggc3VnZ2VzdGlvbnMgKGlmIHByZXNlbnQpXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbG9hZCAoKSB7XG4gICAgbGV0IHByb21pc2VzID0gW1xuICAgICAgdGhpcy5fcHJvdmlkZXIuZ2V0TGlicmFyaWVzKCksXG4gICAgICB0aGlzLl9wcm92aWRlci5nZXRTZWFyY2hTdWdnZXN0aW9ucygpXG4gICAgXVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcylcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBsaWJyYXJ5IGl0ZW1zXG4gICAqIEByZXR1cm4ge1JlYWN0LkNvbXBvbmVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJMaWJyYXJpZXMgKCkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5zdGF0ZS5saWJyYXJpZXMubWFwKChsaWJyYXJ5KSA9PiB7XG4gICAgICByZXR1cm4gKDxMaWJyYXJ5Q29tcG9uZW50XG4gICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uTGlicmFyeUNsaWNrfVxuICAgICAgICBsaWJyYXJ5PXtsaWJyYXJ5fSAvPilcbiAgICB9KVxuICAgIHJldHVybiAoPGxpIGJlbT0nZTppdGVtJz5cbiAgICAgIDxiZW0gc3BlY2lmaWVyPSdiOnBob3RvUm9sbCc+XG4gICAgICAgIDxkaXYgYmVtPSdlOmhlYWRsaW5lJz5Ccm93c2UgbGlicmFyaWVzPC9kaXY+XG4gICAgICAgIDx1bCBiZW09JyRlOmxpYnJhcnlMaXN0Jz5cbiAgICAgICAgICB7aXRlbXN9XG4gICAgICAgIDwvdWw+XG4gICAgICA8L2JlbT5cbiAgICA8L2xpPilcbiAgfVxuXG4gIC8qKlxuICAgKiBSbmRlcnMgdGhlIHNlYXJjaCBzdWdnZXN0aW9uIGl0ZW1zXG4gICAqIEByZXR1cm4ge1JlYWN0LkNvbXBvbmVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJTZWFyY2hTdWdnZXN0aW9ucyAoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLnNlYXJjaFN1Z2dlc3Rpb25zLmxlbmd0aCkgcmV0dXJuIG51bGxcblxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5zdGF0ZS5zZWFyY2hTdWdnZXN0aW9ucy5tYXAoKHNlYXJjaFN1Z2dlc3Rpb24pID0+IHtcbiAgICAgIHJldHVybiAoPFNlYXJjaFN1Z2dlc3Rpb25Db21wb25lbnRcbiAgICAgICAgb25DbGljaz17dGhpcy5fb25TZWFyY2hTdWdnZXN0aW9uQ2xpY2t9XG4gICAgICAgIHNlYXJjaFN1Z2dlc3Rpb249e3NlYXJjaFN1Z2dlc3Rpb259IC8+KVxuICAgIH0pXG5cbiAgICByZXR1cm4gKDxsaSBiZW09J2U6aXRlbSc+XG4gICAgICA8YmVtIHNwZWNpZmllcj0nYjpwaG90b1JvbGwnPlxuICAgICAgICA8ZGl2IGJlbT0nZTpoZWFkbGluZSc+U2VhcmNoIHN1Z2dlc3Rpb25zPC9kaXY+XG4gICAgICAgIDx1bCBiZW09JyRlOmxpYnJhcnlMaXN0Jz5cbiAgICAgICAgICB7aXRlbXN9XG4gICAgICAgIDwvdWw+XG4gICAgICA8L2JlbT5cbiAgICA8L2xpPilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb250ZW50IGZvciB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckNvbnRlbnQgKCkge1xuICAgIHJldHVybiAoPGRpdiBiZW09JyRiOnBob3RvUm9sbCBlOnJvdyBtOmZ1bGxIZWlnaHQnPlxuICAgICAgPGRpdiBiZW09J2U6Y2VsbCcgcmVmPSdjZWxsJz5cbiAgICAgICAgPGRpdiBiZW09J2U6Y29udGFpbmVyJyByZWY9J2NvbnRhaW5lcic+XG4gICAgICAgICAgPGRpdiBiZW09J2U6aW5uZXJDb250YWluZXInPlxuICAgICAgICAgICAgPHVsIGJlbT0nJGU6Z3JvdXBMaXN0Jz5cbiAgICAgICAgICAgICAge3RoaXMuX3JlbmRlckxpYnJhcmllcygpfVxuICAgICAgICAgICAgICB7dGhpcy5fcmVuZGVyU2VhcmNoU3VnZ2VzdGlvbnMoKX1cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5sb2FkaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyQ29udGVudCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiA8ZGl2IC8+XG4gICAgfVxuICB9XG59XG5cbk92ZXJ2aWV3Q29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL3NjcmVlbnMvcGhvdG8tcm9sbC9vdmVydmlldy1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi8uLi8uLi9nbG9iYWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaWJyYXJ5Q29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uQ2xpY2snXG4gICAgKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBsaWJyYXJ5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25DbGljayAoKSB7XG4gICAgdGhpcy5wcm9wcy5vbkNsaWNrICYmXG4gICAgICB0aGlzLnByb3BzLm9uQ2xpY2sodGhpcy5wcm9wcy5saWJyYXJ5KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIGNvbnN0IHsgbGlicmFyeSB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgYmFja2dyb3VuZEltYWdlOiBgdXJsKCR7bGlicmFyeS5jb3ZlckltYWdlfSlgXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxiZW0gc3BlY2lmaWVyPSdiOnBob3RvUm9sbCBlOmxpYnJhcnlMaXN0Jz5cbiAgICAgICAgPGxpIGJlbT0nZTppdGVtJyBzdHlsZT17c3R5bGV9IG9uQ2xpY2s9e3RoaXMuX29uQ2xpY2t9PlxuICAgICAgICAgIDxkaXYgYmVtPSdlOm92ZXJsYXknIC8+XG4gICAgICAgICAgPGRpdiBiZW09J2U6bmFtZSc+e2xpYnJhcnkubmFtZX08L2Rpdj5cbiAgICAgICAgPC9saT5cbiAgICAgIDwvYmVtPlxuICAgIClcbiAgfVxufVxuXG5MaWJyYXJ5Q29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL3NjcmVlbnMvcGhvdG8tcm9sbC9pdGVtcy9saWJyYXJ5LWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uLy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBob3RvQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBjb25zdCB7IHBob3RvIH0gPSB0aGlzLnByb3BzXG4gICAgcmV0dXJuIChcbiAgICAgIDxiZW0gc3BlY2lmaWVyPSdiOnBob3RvUm9sbCBlOnBob3RvTGlzdCc+XG4gICAgICAgIDxsaSBiZW09JyRlOml0ZW0nIG9uQ2xpY2s9e3RoaXMucHJvcHMub25DbGlja30+XG4gICAgICAgICAgPGRpdiBiZW09J2U6b3ZlcmxheScgLz5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTp0aXRsZSc+e3Bob3RvLnRpdGxlfTwvZGl2PlxuICAgICAgICAgIDxpbWcgYmVtPSdlOmltYWdlJyBzcmM9e3Bob3RvLnVybHMudGh1bWJ9IC8+XG4gICAgICAgIDwvbGk+XG4gICAgICA8L2JlbT5cbiAgICApXG4gIH1cbn1cblxuUGhvdG9Db21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvc2NyZWVucy9waG90by1yb2xsL2l0ZW1zL3Bob3RvLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgUGhvdG9MaXN0Q29tcG9uZW50IGZyb20gJy4vcGhvdG8tbGlzdC1jb21wb25lbnQnXG5pbXBvcnQgTm9TZWFyY2hSZXN1bHRzQ29tcG9uZW50IGZyb20gJy4vbm8tc2VhcmNoLXJlc3VsdHMtY29tcG9uZW50J1xuaW1wb3J0IE1vZGFsTWFuYWdlciBmcm9tICcuLi8uLi8uLi9saWIvbW9kYWwtbWFuYWdlcidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VhcmNoUmVzdWx0c0NvbXBvbmVudCBleHRlbmRzIFBob3RvTGlzdENvbXBvbmVudCB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIExJRkVDWUNMRVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IHJlY2VpdmVzIG5ldyBwcm9wc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHByb3BzXG4gICAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChwcm9wcykge1xuICAgIGlmIChwcm9wcy5xdWVyeSAhPT0gdGhpcy5wcm9wcy5xdWVyeSkge1xuICAgICAgdGhpcy5fbG9hZFBob3Rvcyhwcm9wcy5xdWVyeSlcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBNSVNDXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlYWRsaW5lIGZvciB0aGlzIHZpZXdcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEhlYWRsaW5lICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdCgncGVzZGsubGlicmFyeS50aXRsZS5zZWFyY2hSZXN1bHRzJywge1xuICAgICAgcXVlcnk6IHRoaXMucHJvcHMucXVlcnlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBwaG90b3NcbiAgICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbG9hZFBob3RvcyAocXVlcnkgPSB0aGlzLnByb3BzLnF1ZXJ5KSB7XG4gICAgdGhpcy5fdG90YWxQaG90b3NIZWlnaHQgPSAwXG4gICAgY29uc3QgbW9kYWwgPSBNb2RhbE1hbmFnZXIuaW5zdGFuY2UuZGlzcGxheVByb2dyZXNzKHRoaXMuX3QoJ3Blc2RrLmNvbW1vbi50ZXh0LmxvYWRpbmcnKSlcbiAgICBjb25zdCBQaG90b1JvbGxQcm92aWRlciA9IHRoaXMuY29udGV4dC5vcHRpb25zLnBob3RvUm9sbC5wcm92aWRlclxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IFBob3RvUm9sbFByb3ZpZGVyKClcblxuICAgIHByb3ZpZGVyLnNlYXJjaFBob3RvcyhxdWVyeSlcbiAgICAgIC50aGVuKChwaG90b3MpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZWxvYWRQaG90b3MocGhvdG9zLCBtb2RhbClcbiAgICAgIH0pXG4gICAgICAudGhlbigocGhvdG9zKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBwaG90b3MsIGxvYWRpbmc6IGZhbHNlIH0pXG4gICAgICAgIG1vZGFsLmNsb3NlKClcbiAgICAgIH0pXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgJ25vIHJlc3VsdHMgZm91bmQnIHNjcmVlblxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlck5vdEZvdW5kICgpIHtcbiAgICByZXR1cm4gKDxOb1NlYXJjaFJlc3VsdHNDb21wb25lbnRcbiAgICAgIHF1ZXJ5PXt0aGlzLnByb3BzLnF1ZXJ5fVxuICAgICAgb25TZWFyY2hTdWdnZXN0aW9uQ2xpY2tlZD17dGhpcy5wcm9wcy5vblNlYXJjaFN1Z2dlc3Rpb25DbGlja2VkfSAvPilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUubG9hZGluZykge1xuICAgICAgaWYgKHRoaXMuc3RhdGUucGhvdG9zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyTm90Rm91bmQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBob3RvcygpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiA8ZGl2IC8+XG4gICAgfVxuICB9XG59XG5cblNlYXJjaFJlc3VsdHNDb21wb25lbnQuY29udGV4dFR5cGVzID0gUGhvdG9MaXN0Q29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9zY3JlZW5zL3Bob3RvLXJvbGwvc2VhcmNoLXJlc3VsdHMtY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBTZWFyY2hTdWdnZXN0aW9uQ29tcG9uZW50IGZyb20gJy4vaXRlbXMvc2VhcmNoLXN1Z2dlc3Rpb24tY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb1NlYXJjaFJlc3VsdHNDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25TZWFyY2hTdWdnZXN0aW9uQ2xpY2snXG4gICAgKVxuXG4gICAgY29uc3QgUGhvdG9Sb2xsUHJvdmlkZXIgPSB0aGlzLmNvbnRleHQub3B0aW9ucy5waG90b1JvbGwucHJvdmlkZXJcbiAgICB0aGlzLl9wcm92aWRlciA9IG5ldyBQaG90b1JvbGxQcm92aWRlcigpXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgc2VhcmNoU3VnZ2VzdGlvbnM6IFtdXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYSBzZWFyY2ggc3VnZ2VzdGlvbiB3YXMgY2xpY2tlZFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLlBob3RvUm9sbC5TZWFyY2hTdWdnZXN0aW9ufSBzZWFyY2hTdWdnZXN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25TZWFyY2hTdWdnZXN0aW9uQ2xpY2sgKHNlYXJjaFN1Z2dlc3Rpb24pIHtcbiAgICB0aGlzLnByb3BzLm9uU2VhcmNoU3VnZ2VzdGlvbkNsaWNrZWQgJiZcbiAgICAgIHRoaXMucHJvcHMub25TZWFyY2hTdWdnZXN0aW9uQ2xpY2tlZChzZWFyY2hTdWdnZXN0aW9uKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudERpZE1vdW50KClcblxuICAgIHRoaXMuX3Byb3ZpZGVyLmdldFNlYXJjaFN1Z2dlc3Rpb25zKClcbiAgICAgIC50aGVuKChzZWFyY2hTdWdnZXN0aW9ucykgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBzZWFyY2hTdWdnZXN0aW9uc1xuICAgICAgICB9KVxuICAgICAgfSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBtZXNzYWdlICh3aGljaCBjYW4gaW5jbHVkZSBodG1sKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyTWVzc2FnZSAoKSB7XG4gICAgcmV0dXJuIHsgX19odG1sOiB0aGlzLl90KCdwZXNkay5saWJyYXJ5LnRleHQubm9TZWFyY2hSZXN1bHRzJywge1xuICAgICAgcXVlcnk6IHRoaXMucHJvcHMucXVlcnlcbiAgICB9KSB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgc2VhcmNoIHN1Z2dlc3Rpb25zXG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyU2VhcmNoU3VnZ2VzdGlvbnMgKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5zZWFyY2hTdWdnZXN0aW9ucy5sZW5ndGgpIHJldHVybiBudWxsXG5cbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuc3RhdGUuc2VhcmNoU3VnZ2VzdGlvbnMubWFwKChzZWFyY2hTdWdnZXN0aW9uKSA9PiB7XG4gICAgICByZXR1cm4gKDxTZWFyY2hTdWdnZXN0aW9uQ29tcG9uZW50XG4gICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uU2VhcmNoU3VnZ2VzdGlvbkNsaWNrfVxuICAgICAgICBzZWFyY2hTdWdnZXN0aW9uPXtzZWFyY2hTdWdnZXN0aW9ufSAvPilcbiAgICB9KVxuXG4gICAgcmV0dXJuICg8ZGl2PlxuICAgICAgPGRpdiBiZW09J2U6aGVhZGxpbmUnPlNlYXJjaCBzdWdnZXN0aW9uczwvZGl2PlxuICAgICAgPHVsIGJlbT0nJGU6bGlicmFyeUxpc3QnPlxuICAgICAgICB7aXRlbXN9XG4gICAgICA8L3VsPlxuICAgIDwvZGl2PilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICByZXR1cm4gKDxkaXYgYmVtPSckYjpwaG90b1JvbGwgZTpyb3cgbTpmdWxsSGVpZ2h0Jz5cbiAgICAgIDxkaXYgYmVtPSdlOmNlbGwnPlxuICAgICAgICA8ZGl2IGJlbT0nZTpjb250YWluZXInPlxuICAgICAgICAgIDxkaXYgYmVtPSdlOmlubmVyQ29udGFpbmVyJz5cbiAgICAgICAgICAgIDxkaXYgYmVtPSdlOm5vU2VhcmNoUmVzdWx0cycgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3RoaXMuX3JlbmRlck1lc3NhZ2UoKX0gLz5cbiAgICAgICAgICAgIHt0aGlzLl9yZW5kZXJTZWFyY2hTdWdnZXN0aW9ucygpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PilcbiAgfVxufVxuXG5Ob1NlYXJjaFJlc3VsdHNDb21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvc2NyZWVucy9waG90by1yb2xsL25vLXNlYXJjaC1yZXN1bHRzLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuaW1wb3J0IHsgUmVhY3RCRU0sIExvZyB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgU2NyZWVuQ29tcG9uZW50IGZyb20gJy4uL3NjcmVlbi1jb21wb25lbnQnXG5pbXBvcnQgVG9wQmFyQ29tcG9uZW50IGZyb20gJy4uLy4uL3NoYXJlZC90b3AtYmFyL3RvcC1iYXItY29tcG9uZW50J1xuaW1wb3J0IFdlYmNhbUNvbXBvbmVudCBmcm9tICcuL3dlYmNhbS1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYmNhbVNjcmVlbkNvbXBvbmVudCBleHRlbmRzIFNjcmVlbkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fYmluZEFsbCgnX29uQ2FuY2VsJywgJ19vbldlYmNhbVJlYWR5JywgJ19vblNodXR0ZXJDbGlja2VkJylcbiAgICB0aGlzLnN0YXRlID0geyB3ZWJjYW1SZWFkeTogZmFsc2UgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHdlYmNhbSBpcyByZWFkeVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uV2ViY2FtUmVhZHkgKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoeyB3ZWJjYW1SZWFkeTogdHJ1ZSB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBjYW5jZWwgYnV0dG9uIGluIHRoZSB0b3AgYmFyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25DYW5jZWwgKCkge1xuICAgIHRoaXMucHJvcHMuYXBwLnN3aXRjaFRvU2NyZWVuKCdiYWNrJylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBzaHV0dGVyIGJ1dHRvbiBoYXMgYmVlbiBjbGlja2VkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25TaHV0dGVyQ2xpY2tlZCAoKSB7XG4gICAgY29uc3Qgd2ViY2FtID0gdGhpcy5yZWZzLndlYmNhbVxuICAgIHdlYmNhbS5tYWtlUGhvdG8oKVxuICAgICAgLnRoZW4oKGltYWdlKSA9PiB7XG4gICAgICAgIHRoaXMucHJvcHMuYXBwLnNldEltYWdlKGltYWdlKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBMb2cuZXJyb3IoZSlcbiAgICAgIH0pXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIHNjcmVlblxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclNjcmVlbiAoKSB7XG4gICAgcmV0dXJuICg8ZGl2IGJlbT0nJGI6d2ViY2FtU2NyZWVuJz5cbiAgICAgIHsvKiBUT0RPOiBNb3ZlIHRoaXMgdG8gYSBzZXBhcmF0ZSBjb21wb25lbnQgKi99XG4gICAgICA8VG9wQmFyQ29tcG9uZW50XG4gICAgICAgIGxhYmVsPXt0aGlzLl90KCdwZXNkay5jYW1lcmEudGl0bGUuaGVhZGxpbmUnKX0+XG4gICAgICAgIDxiZW0gc3BlY2lmaWVyPSckYjp0b3BCYXInPlxuICAgICAgICAgIDxkaXYgYmVtPSdlOmNhbmNlbEJ1dHRvbicgb25DbGljaz17dGhpcy5fb25DYW5jZWx9PlxuICAgICAgICAgICAge3RoaXMuX3QoJ3Blc2RrLmNvbW1vbi5idXR0b24uY2FuY2VsJyl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBiZW09J2U6bGFiZWwnPlxuICAgICAgICAgICAge3RoaXMuX3QoJ3Blc2RrLmNhbWVyYS50aXRsZS5oZWFkbGluZScpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2JlbT5cbiAgICAgIDwvVG9wQmFyQ29tcG9uZW50PlxuXG4gICAgICA8ZGl2IGJlbT0nJGI6Y2FudmFzIGU6Y29udGFpbmVyIGU6cm93Jz5cbiAgICAgICAgPGRpdiBiZW09J2U6Y29udGFpbmVyIGU6Y2VsbCc+XG4gICAgICAgICAgPFdlYmNhbUNvbXBvbmVudFxuICAgICAgICAgICAgcmVmPSd3ZWJjYW0nXG4gICAgICAgICAgICBvblJlYWR5PXt0aGlzLl9vbldlYmNhbVJlYWR5fVxuICAgICAgICAgICAgb25CYWNrPXt0aGlzLl9vbkNhbmNlbH0gLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdiBiZW09JyRiOmNvbnRyb2xzICRlOmNvbnRhaW5lciBlOnJvdyc+XG4gICAgICAgIDxkaXYgYmVtPSdlOmNlbGwnPlxuICAgICAgICAgIDxiZW0gc3BlY2lmaWVyPSdiOndlYmNhbVNjcmVlbic+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgIGJlbT0nJGU6c2h1dHRlckJ1dHRvbidcbiAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5fb25TaHV0dGVyQ2xpY2tlZH1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXt0aGlzLnN0YXRlLndlYmNhbVJlYWR5ID8gJ2lzLWFjdGl2ZScgOiBmYWxzZX0+XG4gICAgICAgICAgICAgIDxpbWcgYmVtPSdlOmljb24nIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKCdjb250cm9scy93ZWJjYW0vc2h1dHRlci5wbmcnLCB0cnVlKX0gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvYmVtPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PilcbiAgfVxufVxuXG5XZWJjYW1TY3JlZW5Db21wb25lbnQuY29udGV4dFR5cGVzID0gU2NyZWVuQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9zY3JlZW5zL3dlYmNhbS93ZWJjYW0tc2NyZWVuLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBQcm9wVHlwZXMsIFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBNb2RhbE1hbmFnZXIgZnJvbSAnLi4vLi4vLi4vbGliL21vZGFsLW1hbmFnZXInXG5pbXBvcnQgV2ViY2FtVmlkZW9Db21wb25lbnQgZnJvbSAnLi93ZWJjYW0tdmlkZW8tY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJjYW1Db21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbldlYmNhbVJlYWR5JyxcbiAgICAgICdfb25XZWJjYW1FcnJvcidcbiAgICApXG5cbiAgICB0aGlzLnN0YXRlID0geyB3ZWJjYW1SZWFkeTogZmFsc2UgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgY29tcG9uZW50IG5lZWRzIGFuIHVwZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZXh0U3RhdGVcbiAgICovXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZSAobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICAvLyBUaGlzIGNvbXBvbmVudCBuZXZlciB1cGRhdGVzXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgd2ViY2FtIGlzIHJlYWR5IHRvIHNlcnZlIGEgdmlkZW9cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbldlYmNhbVJlYWR5ICgpIHtcbiAgICB0aGlzLnByb3BzLm9uUmVhZHkgJiYgdGhpcy5wcm9wcy5vblJlYWR5KClcbiAgICB0aGlzLnNldFN0YXRlKHsgd2ViY2FtUmVhZHk6IHRydWUgfSlcbiAgfVxuXG4gIF9vbldlYmNhbUVycm9yIChtc2cpIHtcbiAgICBjb25zdCBlcnJvck1vZGFsID0gTW9kYWxNYW5hZ2VyLmluc3RhbmNlLmRpc3BsYXlFcnJvcihcbiAgICAgIHRoaXMuX3QoJ3Blc2RrLmNvbW1vbi50aXRsZS5lcnJvcicpLFxuICAgICAgdGhpcy5fdCgncGVzZGsuY2FtZXJhLnRleHQud2ViY2FtVW5hdmFpbGFibGUnLCB7IGVycm9yOiBtc2cgfSlcbiAgICApXG4gICAgZXJyb3JNb2RhbC5vbignY2xvc2UnLCAoKSA9PiB0aGlzLnByb3BzLm9uQmFjaygpKVxuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBtZXRob2QgdGhhdCBtYWtlcyBhIHBob3RvIGZyb20gdGhlIGN1cnJlbnQgdmlkZW8gc3RyZWFtXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBtYWtlUGhvdG8gKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS53ZWJjYW1SZWFkeSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dlYmNhbS5jYXB0dXJlKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBiZW09JyRiOndlYmNhbScgcmVmPSdjb250YWluZXInPlxuICAgICAgICA8V2ViY2FtVmlkZW9Db21wb25lbnRcbiAgICAgICAgICBmbGFzaFVSTD17dGhpcy5fZ2V0QXNzZXRQYXRoKCdmYWxsYmFjay93ZWJjYW0uc3dmJyl9XG4gICAgICAgICAgcmVmPXtlbCA9PiB7IHRoaXMuX3dlYmNhbSA9IGVsIH19XG4gICAgICAgICAgb25XZWJjYW1FcnJvcj17dGhpcy5fb25XZWJjYW1FcnJvcn1cbiAgICAgICAgICBvbldlYmNhbUF2YWlsYWJsZT17dGhpcy5fb25XZWJjYW1SZWFkeX0gLz5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5XZWJjYW1Db21wb25lbnQucHJvcFR5cGVzID0ge1xuICBvblJlYWR5OiBQcm9wVHlwZXMuZnVuY1xufVxuXG5XZWJjYW1Db21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvc2NyZWVucy93ZWJjYW0vd2ViY2FtLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdC5jcmVhdGVFbGVtZW50ICovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG4vKiBnbG9iYWxzIEltYWdlICovXG5cbmltcG9ydCB7IEJhc2VDb21wb25lbnQsIFByb3BUeXBlcyB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYmNhbVZpZGVvQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuXG4gICAgdGhpcy5fYmluZEFsbCgnX29uTG9hZGVkTWV0YWRhdGEnKVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHdlYmNhbUF2YWlsYWJsZTogZmFsc2UsXG4gICAgICB1c2VGbGFzaEZhbGxiYWNrOiBmYWxzZSxcbiAgICAgIGNvbnRhaW5lcldpZHRoOiBudWxsLFxuICAgICAgY29udGFpbmVySGVpZ2h0OiBudWxsXG4gICAgfVxuXG4gICAgdGhpcy5fZ2V0VXNlck1lZGlhID0gbnVsbFxuICAgIHRoaXMuX3dlYmNhbVN0cmVhbSA9IG51bGxcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICB0aGlzLl9pbml0R2V0VXNlck1lZGlhKClcbiAgICB0aGlzLl9jYWxjdWxhdGVGbGFzaERpbWVuc2lvbnMoKVxuXG4gICAgaWYgKHRoaXMuX2dldFVzZXJNZWRpYSkge1xuICAgICAgdGhpcy5fZ2V0VXNlck1lZGlhKHtcbiAgICAgICAgdmlkZW86IHtcbiAgICAgICAgICBvcHRpb25hbDogW1xuICAgICAgICAgICAge21pbldpZHRoOiAzMjB9LFxuICAgICAgICAgICAge21pbldpZHRoOiA2NDB9LFxuICAgICAgICAgICAge21pbldpZHRoOiAxMDI0fSxcbiAgICAgICAgICAgIHttaW5XaWR0aDogMTI4MH0sXG4gICAgICAgICAgICB7bWluV2lkdGg6IDE5MjB9LFxuICAgICAgICAgICAge21pbldpZHRoOiAyNTYwfVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgYXVkaW86IGZhbHNlXG4gICAgICB9KVxuICAgICAgICAudGhlbihzdHJlYW0gPT4ge1xuICAgICAgICAgIHRoaXMuX3dlYmNhbVN0cmVhbSA9IHN0cmVhbVxuICAgICAgICAgIGNvbnN0IHZpZGVvID0gdGhpcy5fdmlkZW9FbGVtZW50XG5cbiAgICAgICAgICBpZiAoJ3NyY09iamVjdCcgaW4gdmlkZW8pIHtcbiAgICAgICAgICAgIHZpZGVvLnNyY09iamVjdCA9IHN0cmVhbVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aWRlby5zcmMgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uV2ViY2FtRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25XZWJjYW1FcnJvcihlcnJvcilcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkZWxldGVXZWJjYW0gPSBmYWxzZVxuXG4gICAgICAvLyBTYWRseSB3ZSBuZWVkIHRvIHBvbHV0ZSB0aGUgZ2xvYmFsIG5hbWVzcGFjZSBmb3IgZmxhc2gvanMgY29tbXVuaWNhdGlvblxuICAgICAgLy8ga2VlcGluZyBpdCBhdCBhIG1pbmltdW0gaGVyZVxuICAgICAgaWYgKCF3aW5kb3cuV2ViY2FtKSB7XG4gICAgICAgIHdpbmRvdy5XZWJjYW0gPSB7fVxuICAgICAgICBkZWxldGVXZWJjYW0gPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5XZWJjYW0uZmxhc2hOb3RpZnkgPSAodHlwZSwgbXNnKSA9PiB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2NhbWVyYUxpdmUnOlxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHdlYmNhbUF2YWlsYWJsZTogdHJ1ZSB9LFxuICAgICAgICAgICAgICAoKSA9PiB7IHRoaXMucHJvcHMub25XZWJjYW1BdmFpbGFibGUgJiYgdGhpcy5wcm9wcy5vbldlYmNhbUF2YWlsYWJsZSgpIH0pXG4gICAgICAgICAgICBkZWxldGUgd2luZG93LldlYmNhbS5mbGFzaE5vdGlmeVxuICAgICAgICAgICAgaWYgKGRlbGV0ZVdlYmNhbSkge1xuICAgICAgICAgICAgICBkZWxldGUgd2luZG93LldlYmNhbVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uV2ViY2FtRXJyb3IgJiYgdGhpcy5wcm9wcy5vbldlYmNhbUVycm9yKG1zZylcbiAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3cuV2ViY2FtLmZsYXNoTm90aWZ5XG4gICAgICAgICAgICBpZiAoZGVsZXRlV2ViY2FtKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3cuV2ViY2FtXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQgKCkge1xuICAgIHRoaXMuX2Rpc3Bvc2VXZWJjYW0oKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB0aGUgY3VycmVudCBicm93c2VyIGVudmlyb25tZW50IGZvciBtZWRpYURldmljZXMuZ2V0VXNlck1lZGlhIG9mIGZvclxuICAgKiBsZWdhY3kgbmF2aXRhdG9yLmdldFVzZXJNZWRpYSwgYW5kIHNhdmVzIGEgc2hpbSBpbnRvIHRoZSBfZ2V0VXNlck1lZGlhXG4gICAqIHByb3BlcnR5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2ViY2FtVmlkZW9Db21wb25lbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0R2V0VXNlck1lZGlhICgpIHtcbiAgICAvLyBDaGVjayBmb3IgbWVkaWFEZXZpY2VzI2dldFVzZXJNZWRpYVxuICAgIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICAgICAgdGhpcy5fZ2V0VXNlck1lZGlhID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEuYmluZChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIExvb2sgZm9yIGxlZ2FjeSBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhIGltcGxlbWVudGF0aW9uc1xuICAgIGlmICghdGhpcy5fZ2V0VXNlck1lZGlhKSB7XG4gICAgICBjb25zdCBsZWdhY3lHZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3IubXNHZXRVc2VyTWVkaWFcblxuICAgICAgaWYgKGxlZ2FjeUdldFVzZXJNZWRpYSkge1xuICAgICAgICB0aGlzLl9nZXRVc2VyTWVkaWEgPSBvcHRpb25zID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IGxlZ2FjeUdldFVzZXJNZWRpYS5jYWxsKG5hdmlnYXRvciwgb3B0aW9ucywgcmVzb2x2ZSwgcmVqZWN0KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBubyBnZXRVc2VyTWVkaWEgaXMgZm91bmQsIHVzZSBmbGFzaCBmYWxsYmNha1xuICAgIGlmICghdGhpcy5fZ2V0VXNlck1lZGlhKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgdXNlRmxhc2hGYWxsYmFjazogdHJ1ZSB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGUgY3VycmVudCB3ZWJjYW0gc3RyZWFtLCBpZiBhdmFpbGFibGUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXZWJjYW1WaWRlb0NvbXBvbmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Rpc3Bvc2VXZWJjYW0gKCkge1xuICAgIGlmICh0aGlzLl93ZWJjYW1TdHJlYW0pIHtcbiAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX3dlYmNhbVN0cmVhbVxuICAgICAgY29uc3QgdHJhY2sgPSBzdHJlYW0uZ2V0VHJhY2tzKClbMF1cbiAgICAgIGlmICh0cmFjaykge1xuICAgICAgICB0cmFjay5zdG9wKClcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLnN0b3ApIHtcbiAgICAgICAgc3RyZWFtLnN0b3AoKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhc2hXZWJjYW0pIHtcbiAgICAgIHRoaXMuX2ZsYXNoV2ViY2FtLl9yZWxlYXNlQ2FtZXJhKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FwdHVyZXMgdGhlIGN1cnJlbnQgd2ViY2FtIGltYWdlIGluIHRoZSBzdHJlYW0sIGlmIGF2YWlsYWJsZS5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8SW1hZ2U+fVxuICAgKiBAbWVtYmVyb2YgV2ViY2FtVmlkZW9Db21wb25lbnRcbiAgICovXG4gIGNhcHR1cmUgKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS53ZWJjYW1BdmFpbGFibGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dlYmNhbSB2aWRlbyBub3QgYXZhaWxhYmxlJykpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3ZpZGVvRWxlbWVudCAmJiAhdGhpcy5fZmxhc2hXZWJjYW0pIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHZpZGVvID0gdGhpcy5fdmlkZW9FbGVtZW50XG4gICAgICAgIGlmICh2aWRlby5yZWFkeVN0YXRlID09PSAwKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignV2ViY2FtIHZpZGVvIG5vdCBhdmFpbGFibGUnKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHZpZGVvLnZpZGVvV2lkdGhcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdmlkZW8udmlkZW9IZWlnaHRcblxuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHZpZGVvLCAwLCAwKVxuXG4gICAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgd2luZG93LkltYWdlKClcbiAgICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShpbWFnZSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIGltYWdlLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL2pwZWcnKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhc2hXZWJjYW0pIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJhd0RhdGEgPSB0aGlzLl9mbGFzaFdlYmNhbS5fc25hcCgpXG4gICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKClcbiAgICAgICAgaW1hZ2Uub25sb2FkID0gKCkgPT4geyByZXNvbHZlKGltYWdlKSB9XG4gICAgICAgIGltYWdlLnNyYyA9IGBkYXRhOmltYWdlL2pwZWc7YmFzZTY0LCR7cmF3RGF0YX1gXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dlYmNhbSB2aWRlbyBub3QgYXZhaWxhYmxlJykpXG4gIH1cblxuICAvKipcbiAgICogSGFjayB0byBnZXQgYW4gZXN0aW1hdGUgb2YgdGhlIGVkaXRvcidzIHNjcmVlbiBoZWlnaHQgKG9ubHkgZm9yIElFIHdoZXJlXG4gICAqIGhlaWdodDogMTAwJSBpcyBicm9rZW4pLiBKdXN0IGdvZXMgdXAgdGhlIERPTSB0cmVlIHVudGlsIGl0IGZpbmRzIGFuIGVsZW1lbnRcbiAgICogd2hvc2UgaGVpZ2h0IGlzIGxhcmdlciB0aGFuIGEgbWluaW11bSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICAgKiBAcmV0dXJucyB7bnVtYmVyfG51bGx9XG4gICAqIEBtZW1iZXJvZiBXZWJjYW1WaWRlb0NvbXBvbmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldElFSGVpZ2h0IChtaW4gPSAxMDApIHtcbiAgICBsZXQgY3VycmVudCA9IHRoaXMuX2NvbnRhaW5lclxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDAwOyBpKyspIHtcbiAgICAgIGlmIChjdXJyZW50LmNsaWVudEhlaWdodCA+IG1pbikge1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50LmNsaWVudEhlaWdodCA+IG1pbiA/IGN1cnJlbnQuY2xpZW50SGVpZ2h0IDogbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGZsYXNoIHdlYmNhbSB2aWV3cG9ydCwgYW5kIHNldHMgdGhlIHN0YXRlXG4gICAqIGFjY29yZGluZ2x5LlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWVtYmVyb2YgV2ViY2FtVmlkZW9Db21wb25lbnRcbiAgICovXG4gIF9jYWxjdWxhdGVGbGFzaERpbWVuc2lvbnMgKCkge1xuICAgIGNvbnN0IGNvbnRhaW5lckhlaWdodCA9IDAuOSAqICh0aGlzLl9nZXRJRUhlaWdodCgpIHx8IHdpbmRvdy5pbm5lckhlaWdodClcbiAgICBjb25zdCB3aWR0aCA9ICg0IC8gMykgKiBjb250YWluZXJIZWlnaHQgfHwgNjQwXG4gICAgY29uc3QgaGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0IHx8IDQ4MFxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjb250YWluZXJXaWR0aDogd2lkdGgsXG4gICAgICBjb250YWluZXJIZWlnaHQ6IGhlaWdodFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFJlYWN0IENvbXBvbmVudCB3cmFwcGluZyB0aGUgZmxhc2ggd2ViY2FtIG9iamVjdFxuICAgKiBAcmV0dXJucyB7UmVhY3QuQ29tcG9uZW50fVxuICAgKiBAbWVtYmVyb2YgV2ViY2FtVmlkZW9Db21wb25lbnRcbiAgICovXG4gIF9nZXRGbGFzaEZhbGxiYWNrQ29tcG9uZW50ICgpIHtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuc3RhdGUuY29udGFpbmVyV2lkdGggfHwgNjQwXG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5zdGF0ZS5jb250YWluZXJIZWlnaHQgfHwgNDgwXG5cbiAgICBjb25zdCBmbGFzaHZhcnMgPSBgd2lkdGg9JHt3aWR0aH0maGVpZ2h0PSR7aGVpZ2h0fSZkZXN0X3dpZHRoPTEwMjQmZGVzdF9oZWlnaHQ9NzY4JmpwZWdfcXVhbGl0eT0xMDAmZnBzPTI0YFxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxvYmplY3QgY2xhc3NJRD0nY2xzaWQ6ZDI3Y2RiNmUtYWU2ZC0xMWNmLTk2YjgtNDQ0NTUzNTQwMDAwJyB0eXBlPSdhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCcgd2lkdGg9e3dpZHRofSBoZWlnaHQ9e2hlaWdodH0gcmVmPXtlID0+IHsgdGhpcy5fZmxhc2hXZWJjYW0gPSBlIH19IGFsaWduPSdtaWRkbGUnPlxuICAgICAgICA8cGFyYW0gbmFtZT0nd21vZGUnIHZhbHVlPSd0cmFuc3BhcmVudCcgLz5cbiAgICAgICAgPHBhcmFtIG5hbWU9J2FsbG93U2NyaXB0QWNjZXNzJyB2YWx1ZT0nYWx3YXlzJyAvPlxuICAgICAgICA8cGFyYW0gbmFtZT0nYWxsb3dGdWxsU2NyZWVuJyB2YWx1ZT0nZmFsc2UnIC8+XG4gICAgICAgIDxwYXJhbSBuYW1lPSdtb3ZpZScgdmFsdWU9e3RoaXMucHJvcHMuZmxhc2hVUkx9IC8+XG4gICAgICAgIDxwYXJhbSBuYW1lPSdsb29wJyB2YWx1ZT0nZmFsc2UnIC8+XG4gICAgICAgIDxwYXJhbSBuYW1lPSdtZW51JyB2YWx1ZT0nZmFsc2UnIC8+XG4gICAgICAgIDxwYXJhbSBuYW1lPSdxdWFsaXR5JyB2YWx1ZT0nYmVzdCcgLz5cbiAgICAgICAgPHBhcmFtIG5hbWU9J2JnY29sb3InIHZhbHVlPScjZmZmZmZmJyAvPlxuICAgICAgICA8cGFyYW0gbmFtZT0nZmxhc2h2YXJzJyB2YWx1ZT17Zmxhc2h2YXJzfSAvPlxuICAgICAgPC9vYmplY3Q+XG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSB3ZWJjYW0gc3RyZWFtIG1ldGFkYXRhIGlzIGxvYWRlZCBpbnRvIHRoZSB2aWRlbyBlbGVtZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWVtYmVyb2YgV2ViY2FtVmlkZW9Db21wb25lbnRcbiAgICovXG4gIF9vbkxvYWRlZE1ldGFkYXRhICgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHsgd2ViY2FtQXZhaWxhYmxlOiB0cnVlIH0sXG4gICAgICAoKSA9PiB7IHRoaXMucHJvcHMub25XZWJjYW1BdmFpbGFibGUgJiYgdGhpcy5wcm9wcy5vbldlYmNhbUF2YWlsYWJsZSgpIH0pXG4gIH1cblxuICByZW5kZXIgKCkge1xuICAgIGNvbnN0IHZpZGVvQ29tcG9uZW50ID0gdGhpcy5zdGF0ZS51c2VGbGFzaEZhbGxiYWNrXG4gICAgICA/IHRoaXMuX2dldEZsYXNoRmFsbGJhY2tDb21wb25lbnQoKVxuICAgICAgOiA8dmlkZW9cbiAgICAgICAgc3R5bGU9e3t3aWR0aDogJzEwMCUnfX1cbiAgICAgICAgYXV0b1BsYXlcbiAgICAgICAgcmVmPXtlID0+IHsgdGhpcy5fdmlkZW9FbGVtZW50ID0gZSB9fVxuICAgICAgICBvbkxvYWRlZE1ldGFkYXRhPXt0aGlzLl9vbkxvYWRlZE1ldGFkYXRhfSAvPlxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICB3aWR0aDogdGhpcy5zdGF0ZS51c2VGbGFzaEZhbGxiYWNrID8gdGhpcy5zdGF0ZS5jb250YWluZXJXaWR0aCA6ICcxMDAlJyxcbiAgICAgICAgICBoZWlnaHQ6IHRoaXMuc3RhdGUudXNlRmxhc2hGYWxsYmFjayA/IHRoaXMuc3RhdGUuY29udGFpbmVySGVpZ2h0IDogJzEwMCUnLFxuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgbWFyZ2luOiAnYXV0bycsXG4gICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gICAgICAgIH19XG4gICAgICAgIHJlZj17ZWwgPT4geyB0aGlzLl9jb250YWluZXIgPSBlbCB9fT5cbiAgICAgICAgeyB2aWRlb0NvbXBvbmVudCB9XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxuV2ViY2FtVmlkZW9Db21wb25lbnQucHJvcFR5cGVzID0ge1xuICBmbGFzaFVSTDogUHJvcFR5cGVzLnN0cmluZyxcbiAgb25XZWJjYW1BdmFpbGFibGU6IFByb3BUeXBlcy5mdW5jLFxuICBvbldlYmNhbUVycm9yOiBQcm9wVHlwZXMuZnVuY1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9zY3JlZW5zL3dlYmNhbS93ZWJjYW0tdmlkZW8tY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFByb3BUeXBlcywgU0RLVXRpbHMsIFJlYWN0QkVNLCBDb25zdGFudHMsIFNoYXJlZFN0YXRlLCBMb2cgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IE92ZXJ2aWV3Q29udHJvbHNDb21wb25lbnQgZnJvbSAnLi4vLi4vY29udHJvbHMvb3ZlcnZpZXcvb3ZlcnZpZXctY29udHJvbHMtY29tcG9uZW50J1xuaW1wb3J0IFNjcmVlbkNvbXBvbmVudCBmcm9tICcuLi9zY3JlZW4tY29tcG9uZW50J1xuaW1wb3J0IENhbnZhc0NvbXBvbmVudCBmcm9tICcuL2NhbnZhcy1jb21wb25lbnQnXG5pbXBvcnQgTW9kYWxNYW5hZ2VyIGZyb20gJy4uLy4uLy4uL2xpYi9tb2RhbC1tYW5hZ2VyJ1xuaW1wb3J0IE92ZXJ2aWV3Q29udHJvbHMgZnJvbSAnLi4vLi4vY29udHJvbHMvb3ZlcnZpZXcvJ1xuaW1wb3J0IEVkaXRvciBmcm9tICcuLi8uLi8uLi9saWIvZWRpdG9yJ1xuXG5jb25zdCBXSU5ET1dfUkVTSVpFX0RFTEFZID0gNTAwXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFZGl0b3JTY3JlZW5Db21wb25lbnQgZXh0ZW5kcyBTY3JlZW5Db21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9vdmVydmlld0NvbnRyb2xzID0gT3ZlcnZpZXdDb250cm9sc0NvbXBvbmVudFxuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdzd2l0Y2hUb0NvbnRyb2xzJyxcbiAgICAgICdfc3RhcnRFZGl0b3InLFxuICAgICAgJ19vbldpbmRvd1Jlc2l6ZScsXG4gICAgICAnX29uV2luZG93UmVzaXplRG9uZScsXG4gICAgICAnX29uSW1hZ2VSZXNpemUnLFxuICAgICAgJ19vbk5ld0ltYWdlJyxcbiAgICAgICdfb25SZW5kZXJFcnJvcidcbiAgICApXG5cbiAgICB0aGlzLl9wcmV2aW91c0NvbnRyb2xzU3RhY2sgPSBbXVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB6b29tOiBudWxsLFxuICAgICAgY29udHJvbHM6IE92ZXJ2aWV3Q29udHJvbHMsXG4gICAgICBkcmFnRW5hYmxlZDogdHJ1ZSxcbiAgICAgIHNoYXJlZFN0YXRlOiBuZXcgU2hhcmVkU3RhdGUoKVxuICAgIH1cblxuICAgIHRoaXMuX2VkaXRvciA9IG5ldyBFZGl0b3IoXG4gICAgICB0aGlzLmNvbnRleHQudWksXG4gICAgICB0aGlzLmNvbnRleHQub3B0aW9ucyxcbiAgICAgIHRoaXMuY29udGV4dC5tZWRpYXRvclxuICAgIClcbiAgICB0aGlzLl9lZGl0b3Iub24oJ25ldy1pbWFnZScsIHRoaXMuX29uTmV3SW1hZ2UpXG4gICAgdGhpcy5fZWRpdG9yLm9uKCdyZWFkeScsIHRoaXMuX3N0YXJ0RWRpdG9yKVxuICAgIHRoaXMuX2VkaXRvci5vbigncmVzaXplJywgdGhpcy5fb25JbWFnZVJlc2l6ZSlcbiAgICB0aGlzLl9lZGl0b3Iub24oJ3JlbmRlci1lcnJvcicsIHRoaXMuX29uUmVuZGVyRXJyb3IpXG5cbiAgICB0aGlzLl9oYXNVc2VkRm9yY2VDcm9wID0gZmFsc2VcblxuICAgIHRoaXMuX2ZvcmNlQ29udHJvbHMgPSB0aGlzLmNvbnRleHQub3B0aW9ucy5lZGl0b3IuZm9yY2VDb250cm9sc1xuICAgIHRoaXMuX2ZvcmNlQ29udHJvbEluZGV4ID0gMFxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIGFmdGVyIHRoaXMgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICBzdXBlci5jb21wb25lbnREaWRNb3VudCgpXG5cbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IHsgaW1hZ2UsIGZvcmNlQ3JvcCB9ID0gdGhpcy5jb250ZXh0Lm9wdGlvbnMuZWRpdG9yXG5cbiAgICB0aGlzLnNldEltYWdlKGltYWdlKVxuICAgIHRoaXMuX2VkaXRvci5yZW5kZXIoKVxuXG4gICAgdGhpcy5fZWRpdG9yLm9uKCdyZWFkeScsICgpID0+IHtcbiAgICAgIGlmIChmb3JjZUNyb3ApIHtcbiAgICAgICAgdGhpcy5fc3dpdGNoVG9Gcm9jZUNyb3BDb250cm9sKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3N3aXRjaFRvTmV4dEZvcmNlQ29udHJvbCgpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGlmIChvcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVubW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudFdpbGxVbm1vdW50KClcblxuICAgIHRoaXMuX2VkaXRvci5kaXNwb3NlKClcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dFxuICAgIGlmIChvcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgem9vbSBsZXZlbCBhbmQgc3RhcnRzIHRoZSBlZGl0b3IgcmVuZGVyaW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc3RhcnRFZGl0b3IgKCkge1xuICAgIHRoaXMuX2VkaXRvci5zdGFydCgpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBGT1JDRSBDT05UUk9MU1xuXG4gIF9zd2l0Y2hUb0Zyb2NlQ3JvcENvbnRyb2wgKCkge1xuICAgIGNvbnN0IGF2YWlsYWJsZUNvbnRyb2xzID0gdGhpcy5fZWRpdG9yLmNvbnRyb2xzLmdldEF2YWlsYWJsZSgpXG4gICAgY29uc3QgY29udHJvbE9iamVjdCA9IGF2YWlsYWJsZUNvbnRyb2xzWyd0cmFuc2Zvcm0nXVxuXG4gICAgaWYgKCFjb250cm9sT2JqZWN0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnN3aXRjaFRvQ29udHJvbHMoY29udHJvbE9iamVjdCwge30sIG51bGwsIHsgZm9yY2VDcm9wOiB0cnVlLCBmaXJzdENyb3A6IHRydWUgfSlcbiAgICB0aGlzLl9oYXNVc2VkRm9yY2VDcm9wID0gdHJ1ZVxuICB9XG4gIC8qKlxuICAgKiBTd2l0Y2hlcyB0byB0aGUgbmV4dCBmb3JjZWQgY29udHJvbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3N3aXRjaFRvTmV4dEZvcmNlQ29udHJvbCAoKSB7XG4gICAgaWYgKHRoaXMuX2ZvcmNlQ29udHJvbEluZGV4IDwgdGhpcy5fZm9yY2VDb250cm9scy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHsgY29udHJvbCwgb3B0aW9ucyB9ID0gdGhpcy5fZm9yY2VDb250cm9sc1t0aGlzLl9mb3JjZUNvbnRyb2xJbmRleF1cbiAgICAgIGNvbnN0IGF2YWlsYWJsZUNvbnRyb2xzID0gdGhpcy5fZWRpdG9yLmNvbnRyb2xzLmdldEF2YWlsYWJsZSgpXG4gICAgICBjb25zdCBjb250cm9sT2JqZWN0ID0gYXZhaWxhYmxlQ29udHJvbHNbY29udHJvbF1cblxuICAgICAgbGV0IGZpeGVkT3B0aW9ucyA9IFNES1V0aWxzLmRlZmF1bHRzKHtcbiAgICAgICAgZm9yY2VkQ29udHJvbDogdHJ1ZVxuICAgICAgfSwgb3B0aW9ucylcblxuICAgICAgaWYgKCFjb250cm9sT2JqZWN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRm9yY2UgY29udHJvbHM6IENvdWxkIG5vdCBmaW5kIGNvbnRyb2wgd2l0aCBpZGVudGlmaWVyIFxcYCR7Y29udHJvbH1cXGBgKVxuICAgICAgfVxuXG4gICAgICB0aGlzLnN3aXRjaFRvQ29udHJvbHMoY29udHJvbE9iamVjdCwge30sIG51bGwsIGZpeGVkT3B0aW9ucylcbiAgICAgIHRoaXMuX2ZvcmNlQ29udHJvbEluZGV4KytcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBlcnJvciBvY2N1cnJlZCB3aGlsZSByZW5kZXJpbmdcbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblJlbmRlckVycm9yIChlKSB7XG4gICAgTW9kYWxNYW5hZ2VyLmluc3RhbmNlLmRpc3BsYXlFcnJvcihcbiAgICAgIHRoaXMuX3QoJ3Blc2RrLmVkaXRvci50aXRsZS5yZW5kZXJpbmdFcnJvcicpLFxuICAgICAgdGhpcy5fdCgncGVzZGsuZWRpdG9yLnRleHQucmVuZGVyaW5nRXJyb3InKSxcbiAgICAgIHRydWVcbiAgICApXG4gICAgTG9nLmVycm9yKHRoaXMuY29uc3RydWN0b3IubmFtZSwgJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIHJlbmRlcmluZzogJyArIGUubWVzc2FnZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBpbWFnZSBoYXMgYmVlbiBjaGFuZ2VkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25OZXdJbWFnZSAoKSB7XG4gICAgdGhpcy5zd2l0Y2hUb0NvbnRyb2xzKE92ZXJ2aWV3Q29udHJvbHMpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgZWRpdG9yIHN0YXJ0cyByZXNpemluZyBhbiBpbWFnZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uSW1hZ2VSZXNpemUgKCkge1xuICAgIGNvbnN0IGxvYWRpbmdNb2RhbCA9IE1vZGFsTWFuYWdlci5pbnN0YW5jZS5kaXNwbGF5TG9hZGluZyh0aGlzLl90KCdwZXNkay5lZGl0b3IudGV4dC5yZXNpemluZycpKVxuICAgIHRoaXMuX2VkaXRvci5vbmNlKCdyZXNpemVkJywgKHsgZGltZW5zaW9ucywgcmVhc29uIH0pID0+IHtcbiAgICAgIGxvYWRpbmdNb2RhbC5jbG9zZSgpXG5cbiAgICAgIGlmICh0aGlzLmNvbnRleHQub3B0aW9ucy5lZGl0b3IuZGlzcGxheVJlc2l6ZU1lc3NhZ2UpIHtcbiAgICAgICAgTW9kYWxNYW5hZ2VyLmluc3RhbmNlLmRpc3BsYXlXYXJuaW5nKFxuICAgICAgICAgIHRoaXMuX3QoYHBlc2RrLmVkaXRvci50aXRsZS5pbWFnZVJlc2l6ZWRfJHtyZWFzb259YCksXG4gICAgICAgICAgdGhpcy5fdChgcGVzZGsuZWRpdG9yLnRleHQuaW1hZ2VSZXNpemVkXyR7cmVhc29ufWAsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1heE1lZ2FQaXhlbHM6IHRoaXMuX2VkaXRvci5nZXRNYXhNZWdhcGl4ZWxzKCksXG4gICAgICAgICAgICAgIHdpZHRoOiBkaW1lbnNpb25zLngsXG4gICAgICAgICAgICAgIGhlaWdodDogZGltZW5zaW9ucy55XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIG9uIHdpbmRvdyByZXNpemVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbldpbmRvd1Jlc2l6ZSAoKSB7XG4gICAgaWYgKHRoaXMuX3Jlc2l6ZVRpbWVvdXQpIHtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fcmVzaXplVGltZW91dClcbiAgICAgIHRoaXMuX3Jlc2l6ZVRpbWVvdXQgPSBudWxsXG4gICAgfVxuICAgIHRoaXMuX3Jlc2l6ZVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLl9vbldpbmRvd1Jlc2l6ZURvbmUsIFdJTkRPV19SRVNJWkVfREVMQVkpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgYFdJTkRPV19SRVNJWkVfREVMQVlgIG1zIGFmdGVyIHRoZSBsYXN0IHJlc2l6ZSBldmVudCBoYXMgYmVlbiBjYWxsZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbldpbmRvd1Jlc2l6ZURvbmUgKCkge1xuICAgIHRoaXMuX2VtaXRFdmVudChDb25zdGFudHMuRVZFTlRTLldJTkRPV19SRVNJWkUpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBNSVNDXG5cbiAgLyoqXG4gICAqIFN3aXRjaGVzIHRvIHRoZSBnaXZlbiBjb250cm9sc1xuICAgKiBAcGFyYW0gIHtDb21wb25lbnR9IGNvbnRyb2xzXG4gICAqIEBwYXJhbSAge09iamVjdH0gW2luaXRpYWxTdGF0ZV0gPSB7fVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtjb250cm9sT3B0aW9uc11cbiAgICovXG4gIHN3aXRjaFRvQ29udHJvbHMgKGNvbnRyb2xzLCBpbml0aWFsU3RhdGUgPSB7fSwgY2FsbGJhY2sgPSBudWxsLCBjb250cm9sT3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IG5ld0NvbnRyb2xzID0gbnVsbFxuICAgIGlmIChjb250cm9scyA9PT0gJ2JhY2snKSB7XG4gICAgICBuZXdDb250cm9scyA9IHRoaXMuX3ByZXZpb3VzQ29udHJvbHNTdGFjay5wb3AoKVxuICAgIH0gZWxzZSBpZiAoY29udHJvbHMgPT09ICdob21lJyB8fCBjb250cm9scyA9PT0gT3ZlcnZpZXdDb250cm9scykge1xuICAgICAgaWYgKHRoaXMuY29udGV4dC5vcHRpb25zLmVkaXRvci5mb3JjZUNyb3AgJiYgIXRoaXMuX2hhc1VzZWRGb3JjZUNyb3ApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N3aXRjaFRvRnJvY2VDcm9wQ29udHJvbCgpXG4gICAgICB9XG5cbiAgICAgIC8vIFdoZW4gYSBjb250cm9sIHN3aXRjaGVzIHRvIGBob21lYCwgb3ZlcnJpZGUgdGhpcyBhY3Rpb25cbiAgICAgIC8vIHdpdGggc3dpdGNoaW5nIHRvIHRoZSBuZXh0IGZvcmNlIGNvbnRyb2wgKGlmIHByZXNlbnQpXG4gICAgICBpZiAodGhpcy5fZm9yY2VDb250cm9sSW5kZXggPCB0aGlzLl9mb3JjZUNvbnRyb2xzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3dpdGNoVG9OZXh0Rm9yY2VDb250cm9sKClcbiAgICAgIH1cblxuICAgICAgbmV3Q29udHJvbHMgPSBPdmVydmlld0NvbnRyb2xzXG4gICAgICB0aGlzLl9wcmV2aW91c0NvbnRyb2xzU3RhY2sgPSBbXVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdDb250cm9scyA9IGNvbnRyb2xzXG4gICAgICB0aGlzLl9wcmV2aW91c0NvbnRyb2xzU3RhY2sucHVzaCh0aGlzLnN0YXRlLmNvbnRyb2xzKVxuICAgIH1cblxuICAgIGNvbnN0IGNvbnRyb2xzQ2hhbmdlZCA9IHRoaXMuc3RhdGUuY29udHJvbHMgIT09IG5ld0NvbnRyb2xzXG5cbiAgICAvLyBJZiB0aGUgcHJldmlvdXMgY29udHJvbHMgaGF2ZSBhbiBgb25FeGl0YCBtZXRob2QsIGNhbGwgaXRcbiAgICAvLyB3aXRoIHRoZSBjb250cm9scyBhcyBgdGhpc2BcbiAgICBpZiAodGhpcy5zdGF0ZS5jb250cm9scy5vbkV4aXQpIHtcbiAgICAgIHRoaXMuc3RhdGUuY29udHJvbHMub25FeGl0LmNhbGwoXG4gICAgICAgIHRoaXMucmVmcy5jb250cm9sc1xuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMuc3RhdGUuc2hhcmVkU3RhdGUuY2xlYXIoKVxuICAgIHRoaXMuc3RhdGUuc2hhcmVkU3RhdGUuc2V0KGluaXRpYWxTdGF0ZSwgZmFsc2UpXG5cbiAgICBsZXQgY29udHJvbHNPcHRpb25zID0gU0RLVXRpbHMuZGVmYXVsdHMoXG4gICAgICBTREtVdGlscy5kZWZhdWx0cyhcbiAgICAgICAgY29udHJvbE9wdGlvbnMsXG4gICAgICAgIHRoaXMuY29udGV4dC5vcHRpb25zLmVkaXRvci5jb250cm9sc09wdGlvbnNbbmV3Q29udHJvbHMuaWRlbnRpZmllcl1cbiAgICAgICksXG4gICAgICBuZXdDb250cm9scy5kZWZhdWx0T3B0aW9uc1xuICAgIClcblxuICAgIC8vIElmIHRoZSBuZXcgY29udHJvbHMgaGF2ZSBhbiBgb25FbnRlcmAgbWV0aG9kLCBjYWxsIGl0XG4gICAgaWYgKG5ld0NvbnRyb2xzLm9uRW50ZXIpIHtcbiAgICAgIG5ld0NvbnRyb2xzLm9uRW50ZXIuY2FsbCh0aGlzLnJlZnMuY29udHJvbHMsXG4gICAgICAgIHRoaXMuc3RhdGUuc2hhcmVkU3RhdGUsXG4gICAgICAgIGNvbnRyb2xzT3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAoY29udHJvbHNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgY29udHJvbHM6IG5ld0NvbnRyb2xzLFxuICAgICAgICBjb250cm9sc09wdGlvbnNcbiAgICAgIH0sIGNhbGxiYWNrKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB6b29tIGxldmVsXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldFpvb20gKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnpvb21cbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvcnRzIGFuIGltYWdlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZG93bmxvYWQgPSBmYWxzZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgZXhwb3J0ICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuc3dpdGNoVG9Db250cm9scygnaG9tZScsIHt9LCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2VkaXRvci5leHBvcnQoLi4uYXJncylcbiAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWRpdG9yXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuRWRpdG9yfVxuICAgKi9cbiAgZ2V0RWRpdG9yICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWRpdG9yXG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZWRpdG9yIHN0YXRlXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBzZXJpYWxpemUgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fZWRpdG9yLnNlcmlhbGl6ZSguLi5hcmdzKVxuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplcyB0aGUgZ2l2ZW4gZGF0YVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGFcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIGRlc2VyaWFsaXplIChkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VkaXRvci5kZXNlcmlhbGl6ZShkYXRhKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIERlY2lkZXMgd2hldGhlciB0aGUgdW5kbyBidXR0b24gc2hvdWxkIGJlIGRpc3BsYXllZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Nob3dVbmRvQnV0dG9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWRpdG9yLmhpc3RvcnkuaXNBdmFpbGFibGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbnRleHQgcGFzc2VkIHRvIGFsbCBjaGlsZHJlblxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRDaGlsZENvbnRleHQgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlZGl0b3I6IHRoaXMuX2VkaXRvcixcbiAgICAgIHVpOiB0aGlzLmNvbnRleHQudWksXG4gICAgICBvcHRpb25zOiB0aGlzLmNvbnRleHQub3B0aW9ucyxcbiAgICAgIGVkaXRvclNjcmVlbjogdGhpcyxcbiAgICAgIG1lZGlhdG9yOiB0aGlzLmNvbnRleHQubWVkaWF0b3IsXG4gICAgICBnbG9iYWxTdGF0ZTogdGhpcy5jb250ZXh0Lmdsb2JhbFN0YXRlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGltYWdlIHRvIHRoZSBnaXZlbiBvbmVcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VcbiAgICogQHBhcmFtIHtCb29sZWFufSByZXNldEVkaXRvclxuICAgKi9cbiAgc2V0SW1hZ2UgKGltYWdlLCByZXNldEVkaXRvcikge1xuICAgIHRoaXMuX2ZvcmNlQ29udHJvbEluZGV4ID0gMFxuICAgIHRoaXMuX2VkaXRvci5zZXRJbWFnZShpbWFnZSwgcmVzZXRFZGl0b3IpXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIHNjcmVlblxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclNjcmVlbiAoKSB7XG4gICAgY29uc3QgQ29udHJvbHNDb21wb25lbnQgPSB0aGlzLnN0YXRlLmNvbnRyb2xzLmNvbnRyb2xzQ29tcG9uZW50XG4gICAgbGV0IENhbnZhc0NvbnRyb2xzQ29tcG9uZW50ID0gdGhpcy5zdGF0ZS5jb250cm9scy5jYW52YXNDb250cm9sc0NvbXBvbmVudFxuICAgIGlmICghQ2FudmFzQ29udHJvbHNDb21wb25lbnQpIHtcbiAgICAgIENhbnZhc0NvbnRyb2xzQ29tcG9uZW50ID0gT3ZlcnZpZXdDb250cm9scy5jYW52YXNDb250cm9sc0NvbXBvbmVudFxuICAgIH1cbiAgICBsZXQgVG9wQmFyQ29udHJvbHNDb21wb25lbnQgPSB0aGlzLnN0YXRlLmNvbnRyb2xzLnRvcEJhckNvbnRyb2xzQ29tcG9uZW50XG4gICAgaWYgKCFUb3BCYXJDb250cm9sc0NvbXBvbmVudCkge1xuICAgICAgVG9wQmFyQ29udHJvbHNDb21wb25lbnQgPSBPdmVydmlld0NvbnRyb2xzLnRvcEJhckNvbnRyb2xzQ29tcG9uZW50XG4gICAgfVxuXG4gICAgbGV0IGNvbnRyb2xzLCBjYW52YXNDb250cm9scywgdG9wQmFyQ29udHJvbHNcblxuICAgIGlmIChUb3BCYXJDb250cm9sc0NvbXBvbmVudCAmJiB0aGlzLmNvbnRleHQub3B0aW9ucy5zaG93VG9wQmFyKSB7XG4gICAgICB0b3BCYXJDb250cm9scyA9ICg8VG9wQmFyQ29udHJvbHNDb21wb25lbnRcbiAgICAgICAgc2hhcmVkU3RhdGU9e3RoaXMuc3RhdGUuc2hhcmVkU3RhdGV9XG4gICAgICAgIG9wdGlvbnM9e3RoaXMuc3RhdGUuY29udHJvbHNPcHRpb25zfVxuICAgICAgICBhcHA9e3RoaXMucHJvcHMuYXBwfVxuICAgICAgICByZWY9J3RvcEJhckNvbnRyb2xzJyAvPilcbiAgICB9XG5cbiAgICBpZiAoQ29udHJvbHNDb21wb25lbnQpIHtcbiAgICAgIGNvbnRyb2xzID0gKDxDb250cm9sc0NvbXBvbmVudFxuICAgICAgICBvblN3aXRjaENvbnRyb2xzPXt0aGlzLnN3aXRjaFRvQ29udHJvbHN9XG4gICAgICAgIHNoYXJlZFN0YXRlPXt0aGlzLnN0YXRlLnNoYXJlZFN0YXRlfVxuICAgICAgICBvcHRpb25zPXt0aGlzLnN0YXRlLmNvbnRyb2xzT3B0aW9uc31cbiAgICAgICAgYXBwPXt0aGlzLnByb3BzLmFwcH1cbiAgICAgICAga2V5PXt0aGlzLnN0YXRlLmNvbnRyb2xzLmlkZW50aWZpZXIgKyAnLWNvbnRyb2xzJ31cbiAgICAgICAgcmVmPSdjb250cm9scycgLz4pXG4gICAgfVxuXG4gICAgaWYgKENhbnZhc0NvbnRyb2xzQ29tcG9uZW50KSB7XG4gICAgICBjYW52YXNDb250cm9scyA9ICg8Q2FudmFzQ29udHJvbHNDb21wb25lbnRcbiAgICAgICAgb25Td2l0Y2hDb250cm9scz17dGhpcy5zd2l0Y2hUb0NvbnRyb2xzfVxuICAgICAgICBzaGFyZWRTdGF0ZT17dGhpcy5zdGF0ZS5zaGFyZWRTdGF0ZX1cbiAgICAgICAgb3B0aW9ucz17dGhpcy5zdGF0ZS5jb250cm9sc09wdGlvbnN9XG4gICAgICAgIGFwcD17dGhpcy5wcm9wcy5hcHB9XG4gICAgICAgIGtleT17dGhpcy5zdGF0ZS5jb250cm9scy5pZGVudGlmaWVyICsgJy1jYW52YXNDb250cm9scyd9XG4gICAgICAgIHJlZj0nY2FudmFzQ29udHJvbHMnIC8+KVxuICAgIH1cblxuICAgIGxldCBiZW1TcGVjaWZpZXIgPSAnJGI6ZWRpdG9yU2NyZWVuJ1xuICAgIGlmICghdGhpcy5jb250ZXh0Lm9wdGlvbnMuc2hvd0hlYWRlcikge1xuICAgICAgYmVtU3BlY2lmaWVyICs9ICcgbTpub0hlYWRlcidcbiAgICB9XG5cbiAgICByZXR1cm4gKDxkaXYgYmVtPXtiZW1TcGVjaWZpZXJ9PlxuICAgICAge3RvcEJhckNvbnRyb2xzfVxuXG4gICAgICA8Q2FudmFzQ29tcG9uZW50XG4gICAgICAgIHJlZj0nY2FudmFzJ1xuICAgICAgICBsYXJnZUNvbnRyb2xzPXt0aGlzLnN0YXRlLmNvbnRyb2xzLmxhcmdlQ2FudmFzQ29udHJvbHN9PlxuICAgICAgICB7Y2FudmFzQ29udHJvbHN9XG4gICAgICA8L0NhbnZhc0NvbXBvbmVudD5cblxuICAgICAgPGRpdiBiZW09JyRiOmNvbnRyb2xzICRlOmNvbnRhaW5lciBlOnJvdyc+XG4gICAgICAgIDxkaXYgYmVtPSdlOmNlbGwnPlxuICAgICAgICAgIHtjb250cm9sc31cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuRWRpdG9yU2NyZWVuQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICB1aTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBlZGl0b3I6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgbWVkaWF0b3I6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgb3B0aW9uczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBlZGl0b3JTY3JlZW46IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgZ2xvYmFsU3RhdGU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufVxuXG5FZGl0b3JTY3JlZW5Db21wb25lbnQuY29udGV4dFR5cGVzID0gU2NyZWVuQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9zY3JlZW5zL2VkaXRvci9lZGl0b3Itc2NyZWVuLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhY2tCdXR0b25Db21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIHJldHVybiAoPGJlbSBzcGVjaWZpZXI9JyRiOmNvbnRyb2xzJz5cbiAgICAgIDxkaXYgYmVtPSdlOmNlbGwgbTpsYXJnZUJ1dHRvbic+XG4gICAgICAgIDxkaXYgYmVtPSckZTpsYXJnZUJ1dHRvbicgb25DbGljaz17dGhpcy5wcm9wcy5vbkNsaWNrfT5cbiAgICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aCgnY29udHJvbHMvYmFjay5wbmcnLCB0cnVlKX0gLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2JlbT4pXG4gIH1cbn1cblxuQmFja0J1dHRvbkNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9iYWNrLWJ1dHRvbi1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi9nbG9iYWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb25lQnV0dG9uQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICByZXR1cm4gKDxiZW0gc3BlY2lmaWVyPSckYjpjb250cm9scyc+XG4gICAgICA8ZGl2IGJlbT0nZTpjZWxsIG06bGFyZ2VCdXR0b24nPlxuICAgICAgICA8ZGl2IGJlbT0nJGU6bGFyZ2VCdXR0b24nIG9uQ2xpY2s9e3RoaXMucHJvcHMub25DbGlja30+XG4gICAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXt0aGlzLl9nZXRBc3NldFBhdGgoJ2NvbnRyb2xzL3RpY2sucG5nJywgdHJ1ZSl9IC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9iZW0+KVxuICB9XG59XG5cbkRvbmVCdXR0b25Db21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvZG9uZS1idXR0b24tY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7XG4gIFV0aWxzLCBSZWFjdEJFTSwgVmVjdG9yMiwgQmFzZUNvbXBvbmVudCwgQ29uc3RhbnRzXG59IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbnZhc0NvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbkRyYWdTdGFydCcsXG4gICAgICAnX29uRHJhZ01vdmUnLFxuICAgICAgJ19vbkRyYWdFbmQnLFxuICAgICAgJ19vbldpbmRvd1Jlc2l6ZScsXG4gICAgICAnX29uRmVhdHVyZXNVcGRhdGVkJyxcbiAgICAgICdfb25ab29tQ2hhbmdlJ1xuICAgIClcblxuICAgIHRoaXMuX2V2ZW50cyA9IHtcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLldJTkRPV19SRVNJWkVdOiB0aGlzLl9vbldpbmRvd1Jlc2l6ZSxcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLkZFQVRVUkVTX1VQREFURURdOiB0aGlzLl9vbkZlYXR1cmVzVXBkYXRlZFxuICAgIH1cblxuICAgIHRoaXMuX2luaXRpYWxSZW5kZXJEb25lID0gZmFsc2VcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBjYW52YXNQb3NpdGlvbjogbmV3IFZlY3RvcjIoKSxcbiAgICAgIGNhbnZhc09mZnNldDogbmV3IFZlY3RvcjIoKVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBhZnRlciB0aGUgd2luZG93IGhhcyBiZWVuIHJlc2l6ZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbldpbmRvd1Jlc2l6ZSAoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IHNkayA9IGVkaXRvci5nZXRTREsoKVxuICAgIHNkay5yZXNpemVUbyh0aGlzLl9nZXRDb250YWluZXJEaW1lbnNpb25zKCkpXG4gICAgZWRpdG9yLnpvb20uc2V0KCdhdXRvJylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGZlYXR1cmVzIChlLmcuIGRyYWcpIGFyZSB1cGRhdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IGlkZW50aWZpZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25GZWF0dXJlc1VwZGF0ZWQgKGlkZW50aWZpZXJzKSB7XG4gICAgaWYgKGlkZW50aWZpZXJzLmluZGV4T2YoJ2RyYWcnKSAhPT0gLTEpIHtcbiAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIExJRkVDWUNMRVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBhZnRlciB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgc3VwZXIuY29tcG9uZW50RGlkTW91bnQoKVxuXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IHJlbmRlcmVyID0gZWRpdG9yLmdldFJlbmRlcmVyKClcblxuICAgIGNvbnN0IHsgY2FudmFzQ2VsbCwgY2FudmFzIH0gPSB0aGlzLnJlZnNcbiAgICBjb25zdCB3aWR0aCA9IGNhbnZhc0NlbGwub2Zmc2V0V2lkdGhcbiAgICBjb25zdCBoZWlnaHQgPSBjYW52YXNDZWxsLm9mZnNldEhlaWdodFxuICAgIHJlbmRlcmVyLnNldENhbnZhcyhjYW52YXMpXG4gICAgcmVuZGVyZXIucmVzaXplVG8obmV3IFZlY3RvcjIod2lkdGgsIGhlaWdodCksIHRydWUpXG5cbiAgICBlZGl0b3Iuem9vbS5vbignc2V0JywgdGhpcy5fb25ab29tQ2hhbmdlKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgYWJvdXQgdG8gYmUgdW5tb3VudGVkXG4gICAqL1xuICBjb21wb25lbnRXaWxsVW5tb3VudCAoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGVkaXRvci56b29tLm9mZignc2V0JywgdGhpcy5fb25ab29tQ2hhbmdlKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHpvb20gaGFzIGNoYW5nZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblpvb21DaGFuZ2UgKCkge1xuICAgIHRoaXMuZm9yY2VVcGRhdGUoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRFJBR0dJTkdcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIGNhbnZhc1xuICAgKiBAcGFyYW0ge1JlYWN0LlN5bnRoZXRpY0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25EcmFnU3RhcnQgKGUpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgaWYgKCFlZGl0b3IuZmVhdHVyZXMuaXNFbmFibGVkKCdkcmFnJykpIHJldHVyblxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICB0aGlzLl9kcmFnU3RhcnRQb3NpdGlvbiA9IFV0aWxzLmdldEV2ZW50UG9zaXRpb24oZS5uYXRpdmVFdmVudClcbiAgICB0aGlzLl9kcmFnSW5pdGlhbE9mZnNldCA9IGVkaXRvci5nZXRPZmZzZXQoKS5jbG9uZSgpXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25EcmFnTW92ZSlcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbkRyYWdNb3ZlKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbkRyYWdFbmQpXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vbkRyYWdFbmQpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIGNhbnZhc1xuICAgKiBAcGFyYW0ge0RPTUV2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25EcmFnTW92ZSAoZSkge1xuICAgIGNvbnN0IGV2ZW50UG9zaXRpb24gPSBVdGlscy5nZXRFdmVudFBvc2l0aW9uKGUpXG4gICAgY29uc3QgZGlmZkZyb21TdGFydCA9IGV2ZW50UG9zaXRpb25cbiAgICAgIC5jbG9uZSgpXG4gICAgICAuc3VidHJhY3QodGhpcy5fZHJhZ1N0YXJ0UG9zaXRpb24pXG5cbiAgICBjb25zdCBuZXdPZmZzZXQgPSB0aGlzLl9kcmFnSW5pdGlhbE9mZnNldFxuICAgICAgLmNsb25lKClcbiAgICAgIC5hZGQoZGlmZkZyb21TdGFydClcblxuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBsYXN0T2Zmc2V0ID0gZWRpdG9yLmdldE9mZnNldCgpLmNsb25lKClcbiAgICBlZGl0b3Iuc2V0T2Zmc2V0KG5ld09mZnNldClcbiAgICBpZiAoIWVkaXRvci5nZXRPZmZzZXQoKS5lcXVhbHMobGFzdE9mZnNldCkpIHtcbiAgICAgIGVkaXRvci5yZW5kZXIoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIHRoZSBjYW52YXNcbiAgICogQHBhcmFtIHtET01FdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uRHJhZ0VuZCAoZSkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uRHJhZ01vdmUpXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25EcmFnTW92ZSlcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25EcmFnRW5kKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25EcmFnRW5kKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTUlTQ1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb250YWluZXIncyBkaW1lbnNpb25zXG4gICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0Q29udGFpbmVyRGltZW5zaW9ucyAoKSB7XG4gICAgY29uc3QgeyBjYW52YXNDZWxsIH0gPSB0aGlzLnJlZnNcbiAgICByZXR1cm4gbmV3IFZlY3RvcjIoY2FudmFzQ2VsbC5vZmZzZXRXaWR0aCwgY2FudmFzQ2VsbC5vZmZzZXRIZWlnaHQpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3R5bGUgcHJvcGVydGllcyBmb3IgdGhlIGRyYWdnYWJsZSBjYW52YXMgYXJlYVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldERyYWdnYWJsZVN0eWxlICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiB0aGlzLnN0YXRlLmNhbnZhc1Bvc2l0aW9uLnkgKyB0aGlzLnN0YXRlLmNhbnZhc09mZnNldC55LFxuICAgICAgbGVmdDogdGhpcy5zdGF0ZS5jYW52YXNQb3NpdGlvbi54ICsgdGhpcy5zdGF0ZS5jYW52YXNPZmZzZXQueFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBsZXQgY2FudmFzQ29udGVudCA9IG51bGxcbiAgICBsZXQgY29udGFpbmVyQ29udGVudCA9IG51bGxcbiAgICBpZiAodGhpcy5wcm9wcy5sYXJnZUNvbnRyb2xzKSB7XG4gICAgICBjb250YWluZXJDb250ZW50ID0gdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgIH0gZWxzZSB7XG4gICAgICBjYW52YXNDb250ZW50ID0gdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgIH1cblxuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCB6b29tQWxsb3dzRHJhZyA9IGVkaXRvci5pc1JlYWR5KCkgJiYgZWRpdG9yLnpvb20uZ2V0KCkgPiBlZGl0b3Iuem9vbS5nZXREZWZhdWx0KClcbiAgICBjb25zdCBkcmFnRW5hYmxlZCA9IGVkaXRvci5mZWF0dXJlcy5pc0VuYWJsZWQoJ2RyYWcnKSAmJiB6b29tQWxsb3dzRHJhZ1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgYmVtPSckYjpjYW52YXMgZTpjb250YWluZXIgZTpyb3cnPlxuICAgICAgICA8ZGl2IGJlbT0nZTpjb250YWluZXIgZTpjZWxsJyByZWY9J2NhbnZhc0NlbGwnPlxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGJlbT0nZTppbm5lckNvbnRhaW5lcidcbiAgICAgICAgICAgIGNsYXNzTmFtZT17ZHJhZ0VuYWJsZWQgPyAnaXMtZHJhZ2dhYmxlJyA6IG51bGx9XG4gICAgICAgICAgICBvblRvdWNoU3RhcnQ9e3RoaXMuX29uRHJhZ1N0YXJ0fVxuICAgICAgICAgICAgb25Nb3VzZURvd249e3RoaXMuX29uRHJhZ1N0YXJ0fVxuICAgICAgICAgICAgc3R5bGU9e3RoaXMuX2dldERyYWdnYWJsZVN0eWxlKCl9PlxuICAgICAgICAgICAgPGNhbnZhc1xuICAgICAgICAgICAgICBiZW09J2U6Y2FudmFzJ1xuICAgICAgICAgICAgICByZWY9J2NhbnZhcycgLz5cbiAgICAgICAgICAgIHtjYW52YXNDb250ZW50fVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIHtjb250YWluZXJDb250ZW50fVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5DYW52YXNDb21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvc2NyZWVucy9lZGl0b3IvY2FudmFzLWNvbXBvbmVudC5qc3giLCIvKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBDb250cm9scyBmcm9tICcuLi9jb250cm9scydcbmltcG9ydCBUb3BCYXJDb21wb25lbnQgZnJvbSAnLi90b3AtYmFyL3RvcC1iYXItY29tcG9uZW50J1xuaW1wb3J0IE92ZXJ2aWV3Q29udHJvbHNDb21wb25lbnQgZnJvbSAnLi9vdmVydmlldy1jb250cm9scy1jb21wb25lbnQnXG5pbXBvcnQgT3ZlcnZpZXdDYW52YXNDb250cm9sc0NvbXBvbmVudCBmcm9tICcuL292ZXJ2aWV3LWNhbnZhcy1jb250cm9scy1jb21wb25lbnQnXG5cbmNsYXNzIE92ZXJ2aWV3Q29udHJvbHMgZXh0ZW5kcyBDb250cm9scyB7XG5cbn1cblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyB0b3AgYmFyIGNvbnRyb2xzIGNvbXBvbmVudC4gVXNlZCBmb3IgdGhlIHN1Yi1oZWFkZXIgcGFydCBvZiB0aGUgZWRpdG9yLlxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNDb21wb25lbnR9XG4gKiBAaWdub3JlXG4gKi9cbk92ZXJ2aWV3Q29udHJvbHMudG9wQmFyQ29udHJvbHNDb21wb25lbnQgPSBUb3BCYXJDb21wb25lbnRcblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBjb250cm9scyBjb21wb25lbnQuIFVzZWQgZm9yIHRoZSBsb3dlciBjb250cm9scyBwYXJ0IG9mIHRoZSBlZGl0b3IuXG4gKiBAdHlwZSB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5Db250cm9sc0NvbXBvbmVudH1cbiAqIEBpZ25vcmVcbiAqL1xuT3ZlcnZpZXdDb250cm9scy5jb250cm9sc0NvbXBvbmVudCA9IE92ZXJ2aWV3Q29udHJvbHNDb21wb25lbnRcblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBjYW52YXMgY29tcG9uZW50LiBVc2VkIGZvciB0aGUgdXBwZXIgY29udHJvbHMgcGFydCBvZiB0aGUgZWRpdG9yIChvblxuICogdG9wIG9mIHRoZSBjYW52YXMpXG4gKiBAdHlwZSB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5Db250cm9sc0NvbXBvbmVudH1cbiAqIEBpZ25vcmVcbiAqL1xuT3ZlcnZpZXdDb250cm9scy5jYW52YXNDb250cm9sc0NvbXBvbmVudCA9IE92ZXJ2aWV3Q2FudmFzQ29udHJvbHNDb21wb25lbnRcblxuZXhwb3J0IGRlZmF1bHQgT3ZlcnZpZXdDb250cm9sc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9vdmVydmlldy9pbmRleC5qcyIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNIH0gZnJvbSAnLi4vLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBUb3BCYXJDb21wb25lbnQgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3RvcC1iYXIvdG9wLWJhci1jb21wb25lbnQnXG5pbXBvcnQgTmV3RmlsZUJ1dHRvbkNvbXBvbmVudCBmcm9tICcuL25ldy1maWxlLWJ1dHRvbi1jb21wb25lbnQnXG5pbXBvcnQgRXhwb3J0QnV0dG9uQ29tcG9uZW50IGZyb20gJy4vZXhwb3J0LWJ1dHRvbi1jb21wb25lbnQnXG5pbXBvcnQgVW5kb0J1dHRvbkNvbXBvbmVudCBmcm9tICcuL3VuZG8tYnV0dG9uLWNvbXBvbmVudCdcbmltcG9ydCBab29tQ29tcG9uZW50IGZyb20gJy4vem9vbS1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE92ZXJ2aWV3VG9wQmFyQ29tcG9uZW50IGV4dGVuZHMgVG9wQmFyQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGNvbnRlbnQgb2YgdGhpcyBPdmVydmlld1RvcEJhckNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyQ29udGVudCAoKSB7XG4gICAgbGV0IG5ld0ZpbGVCdXR0b24gPSBudWxsXG4gICAgaWYgKHRoaXMuY29udGV4dC5vcHRpb25zLmVuYWJsZVVwbG9hZCkge1xuICAgICAgbmV3RmlsZUJ1dHRvbiA9IDxOZXdGaWxlQnV0dG9uQ29tcG9uZW50IGFwcD17dGhpcy5wcm9wcy5hcHB9IC8+XG4gICAgfVxuXG4gICAgbGV0IHpvb21Db21wb25lbnQgPSBudWxsXG4gICAgaWYgKHRoaXMuY29udGV4dC5vcHRpb25zLmVkaXRvci5lbmFibGVab29tKSB7XG4gICAgICB6b29tQ29tcG9uZW50ID0gPFpvb21Db21wb25lbnQgLz5cbiAgICB9XG5cbiAgICByZXR1cm4gKDxiZW0gc3BlY2lmaWVyPSckYjp0b3BCYXInPlxuICAgICAgPGRpdiBiZW09J2U6bGVmdCc+XG4gICAgICAgIHtuZXdGaWxlQnV0dG9ufVxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgYmVtPSdlOnJpZ2h0Jz5cbiAgICAgICAgPFVuZG9CdXR0b25Db21wb25lbnQgLz5cbiAgICAgICAgPEV4cG9ydEJ1dHRvbkNvbXBvbmVudCAvPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIHt6b29tQ29tcG9uZW50fVxuICAgIDwvYmVtPilcbiAgfVxufVxuXG5PdmVydmlld1RvcEJhckNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBUb3BCYXJDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL292ZXJ2aWV3L3RvcC1iYXIvdG9wLWJhci1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIFV0aWxzLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBUb3BCYXJCdXR0b25Db21wb25lbnQgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3RvcC1iYXIvYnV0dG9uLWNvbXBvbmVudCdcbmltcG9ydCBJbnZpc2libGVVcGxvYWRDb21wb25lbnQgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2ludmlzaWJsZS11cGxvYWQtY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOZXdGaWxlQnV0dG9uQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uTmV3RmlsZScsXG4gICAgICAnX29uQnV0dG9uQ2xpY2snXG4gICAgKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgaGFzIHNlbGVjdGVkIGEgbmV3IGZpbGVcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VcbiAgICovXG4gIF9vbk5ld0ZpbGUgKGltYWdlKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGVkaXRvci5yZXNldCgpXG4gICAgZWRpdG9yLnNldEltYWdlKGltYWdlKVxuICAgIGVkaXRvci56b29tLnNldCgnYXV0bycpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgYnV0dG9uIGhhcyBiZWVuIGNsaWNrZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJ1dHRvbkNsaWNrICgpIHtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IHdlYmNhbUVuYWJsZWQgPSAob3B0aW9ucy5lbmFibGVXZWJjYW0gPT09IGZhbHNlIHx8IFV0aWxzLmlzTW9iaWxlKCkpXG4gICAgY29uc3QgcGhvdG9Sb2xsRW5hYmxlZCA9ICEhb3B0aW9ucy5waG90b1JvbGwucHJvdmlkZXJcbiAgICBpZiAod2ViY2FtRW5hYmxlZCAmJiAhcGhvdG9Sb2xsRW5hYmxlZCkge1xuICAgICAgdGhpcy5yZWZzLnVwbG9hZC5vcGVuKClcbiAgICB9IGVsc2UgaWYgKHBob3RvUm9sbEVuYWJsZWQpIHtcbiAgICAgIHRoaXMucHJvcHMuYXBwLnN3aXRjaFRvU2NyZWVuKCdwaG90b1JvbGwnKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByb3BzLmFwcC5zd2l0Y2hUb1NjcmVlbignc3BsYXNoJylcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzLmNvbnRleHRcblxuICAgIGxldCBidXR0b25MYWJlbCA9IG51bGxcbiAgICBpZiAob3B0aW9ucy5waG90b1JvbGwucHJvdmlkZXIpIHtcbiAgICAgIGJ1dHRvbkxhYmVsID0gdGhpcy5fdCgncGVzZGsuZWRpdG9yLmJ1dHRvbi5iYWNrZ3JvdW5kSW1hZ2UnKVxuICAgIH0gZWxzZSB7XG4gICAgICBidXR0b25MYWJlbCA9IHRoaXMuX3QoJ3Blc2RrLmVkaXRvci5idXR0b24ubmV3JylcbiAgICB9XG5cbiAgICByZXR1cm4gKDxkaXY+XG4gICAgICA8SW52aXNpYmxlVXBsb2FkQ29tcG9uZW50IG9uTmV3RmlsZT17dGhpcy5fb25OZXdGaWxlfSByZWY9J3VwbG9hZCcgLz5cbiAgICAgIDxUb3BCYXJCdXR0b25Db21wb25lbnRcbiAgICAgICAgbGFiZWw9e2J1dHRvbkxhYmVsfVxuICAgICAgICBpY29uPSdlZGl0b3IvbmV3LnBuZydcbiAgICAgICAgb25DbGljaz17dGhpcy5fb25CdXR0b25DbGlja30gLz5cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuTmV3RmlsZUJ1dHRvbkNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9vdmVydmlldy90b3AtYmFyL25ldy1maWxlLWJ1dHRvbi1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IE1vZGFsTWFuYWdlciBmcm9tICcuLi8uLi8uLi8uLi9saWIvbW9kYWwtbWFuYWdlcidcbmltcG9ydCBUb3BCYXJCdXR0b25Db21wb25lbnQgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3RvcC1iYXIvYnV0dG9uLWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXhwb3J0QnV0dG9uQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uQnV0dG9uQ2xpY2snXG4gICAgKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGJ1dHRvbiBoYXMgYmVlbiBjbGlja2VkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25CdXR0b25DbGljayAoKSB7XG4gICAgY29uc3QgeyBvcHRpb25zLCBlZGl0b3IsIGVkaXRvclNjcmVlbiB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3QgZXhwb3J0T3B0aW9ucyA9IG9wdGlvbnMuZWRpdG9yLmV4cG9ydFxuXG4gICAgZWRpdG9yU2NyZWVuLnN3aXRjaFRvQ29udHJvbHMoJ2hvbWUnLCBudWxsLCAoKSA9PiB7XG4gICAgICBjb25zdCBsb2FkaW5nTW9kYWwgPSBNb2RhbE1hbmFnZXIuaW5zdGFuY2UuZGlzcGxheUxvYWRpbmcodGhpcy5fdCgncGVzZGsuZWRpdG9yLnRleHQuZXhwb3J0aW5nJykpXG5cbiAgICAgIC8vIEdpdmUgaXQgc29tZSB0aW1lIHRvIGRpc3BsYXkgdGhlIGxvYWRpbmcgbW9kYWxcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBlZGl0b3IuZXhwb3J0KGV4cG9ydE9wdGlvbnMuZG93bmxvYWQpXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgbG9hZGluZ01vZGFsLmNsb3NlKClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgTW9kYWxNYW5hZ2VyLmluc3RhbmNlLmRpc3BsYXlFcnJvcih0aGlzLl90KCdwZXNkay5jb21tb24udGl0bGUuZXJyb3InKSwgZS5tZXNzYWdlKVxuICAgICAgICAgICAgbG9hZGluZ01vZGFsLmNsb3NlKClcbiAgICAgICAgICB9KVxuICAgICAgfSwgMTAwKVxuICAgIH0pXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzLmNvbnRleHRcbiAgICBpZiAoIW9wdGlvbnMuZWRpdG9yLmV4cG9ydC5zaG93QnV0dG9uKSByZXR1cm4gbnVsbFxuXG4gICAgcmV0dXJuICg8VG9wQmFyQnV0dG9uQ29tcG9uZW50XG4gICAgICBzdHlsZT0nYmx1ZSdcbiAgICAgIGxhYmVsPXt0aGlzLl90KCdwZXNkay5lZGl0b3IuYnV0dG9uLmV4cG9ydCcpfVxuICAgICAgaWNvbj0nZWRpdG9yL2V4cG9ydC5wbmcnXG4gICAgICBvbkNsaWNrPXt0aGlzLl9vbkJ1dHRvbkNsaWNrfSAvPilcbiAgfVxufVxuXG5FeHBvcnRCdXR0b25Db21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvb3ZlcnZpZXcvdG9wLWJhci9leHBvcnQtYnV0dG9uLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQ29uc3RhbnRzLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBUb3BCYXJCdXR0b25Db21wb25lbnQgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3RvcC1iYXIvYnV0dG9uLWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVW5kb0J1dHRvbkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbkJ1dHRvbkNsaWNrJyxcbiAgICAgICdfb25IaXN0b3J5VXBkYXRlZCcsXG4gICAgICAnX29uRmVhdHVyZXNVcGRhdGVkJ1xuICAgIClcblxuICAgIHRoaXMuX2V2ZW50cyA9IHtcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLkhJU1RPUllfVVBEQVRFRF06IHRoaXMuX29uSGlzdG9yeVVwZGF0ZWQsXG4gICAgICBbQ29uc3RhbnRzLkVWRU5UUy5GRUFUVVJFU19VUERBVEVEXTogdGhpcy5fb25GZWF0dXJlc1VwZGF0ZWRcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgZmVhdHVyZXMgaGF2ZSBiZWVuIGVuYWJsZWQgb3IgZGlzYWJsZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkZlYXR1cmVzVXBkYXRlZCAoKSB7XG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgaGlzdG9yeSBoYXMgYmVlbiB1cGRhdGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25IaXN0b3J5VXBkYXRlZCAoKSB7XG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgYnV0dG9uIGhhcyBiZWVuIGNsaWNrZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJ1dHRvbkNsaWNrICgpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgZWRpdG9yLmhpc3RvcnkudW5kbygpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGlmICghZWRpdG9yLmhpc3RvcnkuaXNBdmFpbGFibGUoKSkgcmV0dXJuIG51bGxcblxuICAgIHJldHVybiAoPFRvcEJhckJ1dHRvbkNvbXBvbmVudFxuICAgICAgbGFiZWw9e3RoaXMuX3QoJ3Blc2RrLmVkaXRvci5idXR0b24udW5kbycpfVxuICAgICAgaWNvbj0nZWRpdG9yL3VuZG8ucG5nJ1xuICAgICAgb25DbGljaz17dGhpcy5fb25CdXR0b25DbGlja30gLz4pXG4gIH1cbn1cblxuVW5kb0J1dHRvbkNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9vdmVydmlldy90b3AtYmFyL3VuZG8tYnV0dG9uLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBDb25zdGFudHMsIFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vZ2xvYmFscydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWm9vbUNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vblpvb21PdXRDbGljaycsXG4gICAgICAnX29uWm9vbUluQ2xpY2snLFxuICAgICAgJ19vblpvb21Eb25lJyxcbiAgICAgICdfb25GZWF0dXJlc1VwZGF0ZWQnXG4gICAgKVxuXG4gICAgdGhpcy5fZXZlbnRzID0ge1xuICAgICAgW0NvbnN0YW50cy5FVkVOVFMuWk9PTV9ET05FXTogdGhpcy5fb25ab29tRG9uZSxcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLkZFQVRVUkVTX1VQREFURURdOiB0aGlzLl9vbkZlYXR1cmVzVXBkYXRlZFxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBmZWF0dXJlcyBoYXZlIGJlZW4gdXBkYXRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uRmVhdHVyZXNVcGRhdGVkICgpIHtcbiAgICB0aGlzLmZvcmNlVXBkYXRlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBuZXcgem9vbSBsZXZlbCBoYXMgYmVlbiBhcHBsaWVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25ab29tRG9uZSAoKSB7XG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIFwiem9vbSBvdXRcIiBidXR0b25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uWm9vbU91dENsaWNrIChlKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGlmICghZWRpdG9yLmZlYXR1cmVzLmlzRW5hYmxlZCgnem9vbScpKSByZXR1cm5cblxuICAgIGVkaXRvci56b29tLm91dCgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIFwiem9vbSBpblwiIGJ1dHRvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25ab29tSW5DbGljayAoZSkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBpZiAoIWVkaXRvci5mZWF0dXJlcy5pc0VuYWJsZWQoJ3pvb20nKSkgcmV0dXJuXG5cbiAgICBlZGl0b3Iuem9vbS5pbigpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IHpvb20gPSBlZGl0b3Iuem9vbS5nZXQoKVxuICAgIGNvbnN0IGVuYWJsZWQgPSBlZGl0b3IuZmVhdHVyZXMuaXNFbmFibGVkKCd6b29tJylcblxuICAgIHJldHVybiAoXG4gICAgICA8YmVtIHNwZWNpZmllcj0nYjplZGl0b3JTY3JlZW4nPlxuICAgICAgICA8ZGl2IGJlbT0nJGU6em9vbSc+XG5cbiAgICAgICAgICA8ZGl2IGJlbT0nJGU6YnV0dG9uIG06em9vbU91dCdcbiAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uWm9vbU91dENsaWNrfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtlbmFibGVkID8gbnVsbCA6ICdpcy1kaXNhYmxlZCd9PlxuICAgICAgICAgICAgPGltZyBiZW09J2U6aW1hZ2UnIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKCdjb250cm9scy9taW51cy5wbmcnLCB0cnVlKX0gLz5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIDxkaXYgYmVtPSdlOmxhYmVsJz5cbiAgICAgICAgICAgIHt0aGlzLl90KCdwZXNkay5lZGl0b3IudGl0bGUuem9vbScpfTxiciAvPlxuICAgICAgICAgICAge01hdGgucm91bmQoem9vbSAqIDEwMCl9JVxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgYmVtPSckZTpidXR0b24gbTp6b29tSW4nXG4gICAgICAgICAgICBvbkNsaWNrPXt0aGlzLl9vblpvb21JbkNsaWNrfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtlbmFibGVkID8gbnVsbCA6ICdpcy1kaXNhYmxlZCd9PlxuICAgICAgICAgICAgPGltZyBiZW09J2U6aW1hZ2UnIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKCdjb250cm9scy9wbHVzLnBuZycsIHRydWUpfSAvPlxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9iZW0+XG4gICAgKVxuICB9XG59XG5cblpvb21Db21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvb3ZlcnZpZXcvdG9wLWJhci96b29tLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgVXRpbHMgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IENhbnZhc0NvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4uL2NhbnZhcy1jb250cm9scy1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE92ZXJ2aWV3Q2FudmFzQ29udHJvbHNDb21wb25lbnQgZXh0ZW5kcyBDYW52YXNDb250cm9sc0NvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcbiAgICB0aGlzLl9iaW5kQWxsKCdfb25DbGljaycpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgc29tZXdoZXJlIG9uIHRoZSBjYW52YXNcbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNsaWNrIChlKSB7XG4gICAgdGhpcy5fcGVyZm9ybUhpdFRlc3QoVXRpbHMuZ2V0RXZlbnRQb3NpdGlvbihlKSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFNUWUxJTkdcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29udGFpbmVyIHN0eWxlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRDb250YWluZXJTdHlsZSAoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRleHQuZWRpdG9yLmlzUmVhZHkoKSkge1xuICAgICAgcmV0dXJuIHsgbGVmdDogMCwgdG9wOiAwLCB3aWR0aDogMSwgaGVpZ2h0OiAxIH1cbiAgICB9XG5cbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0U0RLKCkuZ2V0U3ByaXRlKCkuZ2V0Qm91bmRzKClcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogeCxcbiAgICAgIHRvcDogeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIHJldHVybiAoPGRpdlxuICAgICAgYmVtPSckYjpjYW52YXNDb250cm9scyBlOmNvbnRhaW5lciBtOmZ1bGwnXG4gICAgICByZWY9J2NvbnRhaW5lcic+XG4gICAgICA8ZGl2XG4gICAgICAgIGJlbT0nJGI6Y2FudmFzQ29udHJvbHMgZTppbm5lckNvbnRhaW5lcidcbiAgICAgICAgcmVmPSdpbm5lckNvbnRhaW5lcidcbiAgICAgICAgc3R5bGU9e3RoaXMuX2dldENvbnRhaW5lclN0eWxlKCl9XG4gICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uQ2xpY2t9XG4gICAgICAgIG9uVG91Y2hTdGFydD17dGhpcy5fb25DbGlja30gLz5cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuT3ZlcnZpZXdDYW52YXNDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBDYW52YXNDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvb3ZlcnZpZXcvb3ZlcnZpZXctY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCIvKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlbmRlclR5cGUsIFV0aWxzIH0gZnJvbSAnZ2xvYmFscydcbmltcG9ydCBGaWxlRG93bmxvYWRlciBmcm9tICdzaGFyZWQvZG93bmxvYWRlci9maWxlLWRvd25sb2FkZXInXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV4cG9ydGVyIHtcbiAgY29uc3RydWN0b3IgKHNkaywgb3B0aW9ucywgZG93bmxvYWQpIHtcbiAgICB0aGlzLl9zZGsgPSBzZGtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMuX2Rvd25sb2FkID0gZG93bmxvYWRcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvcnRzIHRoZSBpbWFnZSAvIGRhdGEgdXJsXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBleHBvcnQgKCkge1xuICAgIGNvbnN0IHJlbmRlclR5cGUgPSB0aGlzLl9nZXRSZW5kZXJUeXBlKClcblxuICAgIHJldHVybiB0aGlzLl9zZGsuZXhwb3J0KHJlbmRlclR5cGUsIHRoaXMuX29wdGlvbnMuZm9ybWF0LCB0aGlzLl9vcHRpb25zLnF1YWxpdHkpXG4gICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fZG93bmxvYWQpIHtcbiAgICAgICAgICB0aGlzLl9kb3dubG9hZERhdGEocmVuZGVyVHlwZSwgZGF0YSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEb3dubG9hZHMgdGhlIGRhdGEgdXNpbmcgdGhlIGdpdmVuIHJlbmRlciB0eXBlXG4gICAqIEBwYXJhbSAge1JlbmRlclR5cGV9IHJlbmRlclR5cGVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZG93bmxvYWREYXRhIChyZW5kZXJUeXBlLCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZW5kZXJUeXBlKSB7XG4gICAgICBjYXNlIFJlbmRlclR5cGUuREFUQVVSTDpcbiAgICAgICAgRmlsZURvd25sb2FkZXIuZG93bmxvYWREYXRhVVJMKGRhdGEsIHRoaXMuX29wdGlvbnMuZmlsZUJhc2VuYW1lKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBSZW5kZXJUeXBlLk1TQkxPQjpcbiAgICAgICAgRmlsZURvd25sb2FkZXIuZG93bmxvYWRNU0Jsb2IoZGF0YSwgdGhpcy5fb3B0aW9ucy5maWxlQmFzZW5hbWUpXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlbmRlciB0eXBlIGZvciB0aGlzIGV4cG9ydFxuICAgKiBAcmV0dXJuIHtSZW5kZXJUeXBlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFJlbmRlclR5cGUgKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zXG4gICAgaWYgKG9wdGlvbnMudHlwZSAhPT0gUmVuZGVyVHlwZS5JTUFHRSB8fCAhdGhpcy5fZG93bmxvYWQpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLnR5cGVcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKFV0aWxzLnN1cHBvcnRzTVNCbG9iKCkpIHtcbiAgICAgICAgcmV0dXJuIFJlbmRlclR5cGUuTVNCTE9CXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUmVuZGVyVHlwZS5EQVRBVVJMXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9leHBvcnRlci5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgQmFzZTY0IH0gZnJvbSAnZ2xvYmFscydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsZURvd25sb2FkZXIge1xuICAvKipcbiAgICogRXhwb3J0cyB0aGUgZ2l2ZW4gZGF0YSB1cmxcbiAgICogQHBhcmFtICB7U3RyaW5nfSBkYXRhXG4gICAqIEBwYXJhbSAge1N0cmluZ30gYmFzZU5hbWUgPSAncGhvdG9lZGl0b3JzZGstZXhwb3J0J1xuICAgKi9cbiAgc3RhdGljIGRvd25sb2FkRGF0YVVSTCAoZGF0YSwgYmFzZU5hbWUgPSAncGhvdG9lZGl0b3JzZGstZXhwb3J0Jykge1xuICAgIGNvbnN0IHVybCA9IHRoaXMuY3JlYXRlQmxvYlVSTEZyb21EYXRhVVJMKGRhdGEpXG4gICAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy5nZXRFeHRlbnNpb25Gcm9tRGF0YVVSTChkYXRhKVxuXG4gICAgbGV0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcbiAgICBsaW5rLmRvd25sb2FkID0gYCR7YmFzZU5hbWV9LiR7ZXh0ZW5zaW9ufWBcbiAgICBsaW5rLmhyZWYgPSB1cmxcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspXG4gICAgbGluay5jbGljaygpXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKVxuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9ydHMgdGhlIGdpdmVuIGRhdGEgdXJsIHVzaW5nIG1zQmxvYlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGFcbiAgICogQHBhcmFtICB7U3RyaW5nfSBiYXNlTmFtZSA9ICdwaG90b2VkaXRvcnNkay1leHBvcnQnXG4gICAqL1xuICBzdGF0aWMgZG93bmxvYWRNU0Jsb2IgKGRhdGEsIGJhc2VOYW1lID0gJ3Bob3RvZWRpdG9yc2RrLWV4cG9ydCcpIHtcbiAgICBuYXZpZ2F0b3IubXNTYXZlQmxvYihkYXRhLCBgJHtiYXNlTmFtZX0ucG5nYClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaWxlIGV4dGVuc2lvbiBieSByZWFkaW5nIHRoZSBnaXZlbiBkYXRhIHVybFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGFcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldEV4dGVuc2lvbkZyb21EYXRhVVJMIChkYXRhKSB7XG4gICAgY29uc3QgbWltZVN0cmluZyA9IGRhdGEuc3BsaXQoJywnKVswXS5zcGxpdCgnOicpWzFdLnNwbGl0KCc7JylbMF1cbiAgICByZXR1cm4gbWltZVN0cmluZy5zcGxpdCgnLycpLnBvcCgpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIEJsb2IgVVJJIGZyb20gdGhlIGdpdmVuIERhdGEgVVJJXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQmxvYlVSTEZyb21EYXRhVVJMIChkYXRhKSB7XG4gICAgaWYgKCF3aW5kb3cuQmxvYiB8fCAhd2luZG93LlVSTCB8fCAhQXJyYXlCdWZmZXIgfHwgIVVpbnQ4QXJyYXkpIHtcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfVxuXG4gICAgY29uc3QgcmF3RGF0YSA9IEJhc2U2NC5kZWNvZGUoZGF0YS5zcGxpdCgnLCcpWzFdKVxuICAgIGNvbnN0IG1pbWVTdHJpbmcgPSBkYXRhLnNwbGl0KCcsJylbMF0uc3BsaXQoJzonKVsxXS5zcGxpdCgnOycpWzBdXG5cbiAgICAvLyB3cml0ZSB0aGUgYnl0ZXMgb2YgdGhlIHN0cmluZyB0byBhbiBBcnJheUJ1ZmZlclxuICAgIGNvbnN0IGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHJhd0RhdGEubGVuZ3RoKVxuICAgIGNvbnN0IGludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXdEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnRBcnJheVtpXSA9IHJhd0RhdGFbaV1cbiAgICB9XG5cbiAgICAvLyB3cml0ZSB0aGUgQXJyYXlCdWZmZXIgdG8gYSBibG9iLCBhbmQgeW91J3JlIGRvbmVcbiAgICBjb25zdCBibG9iID0gbmV3IHdpbmRvdy5CbG9iKFthcnJheUJ1ZmZlcl0sIHtcbiAgICAgIHR5cGU6IG1pbWVTdHJpbmdcbiAgICB9KVxuICAgIHJldHVybiB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9kb3dubG9hZGVyL2ZpbGUtZG93bmxvYWRlci5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUHJvbWlzZSwgVmVjdG9yMiB9IGZyb20gJy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEltYWdlUmVzaXplciB7XG4gIGNvbnN0cnVjdG9yIChpbWFnZSwgbWF4UGl4ZWxzLCBtYXhEaW1lbnNpb25zKSB7XG4gICAgdGhpcy5faW1hZ2UgPSBpbWFnZVxuICAgIHRoaXMuX21heFBpeGVscyA9IG1heFBpeGVsc1xuICAgIHRoaXMuX21heERpbWVuc2lvbnMgPSBtYXhEaW1lbnNpb25zXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBpbWFnZSBuZWVkcyB0byBiZSByZXNpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBuZWVkc1Jlc2l6ZSAoKSB7XG4gICAgY29uc3QgZGltZW5zaW9ucyA9IG5ldyBWZWN0b3IyKHRoaXMuX2ltYWdlLndpZHRoLCB0aGlzLl9pbWFnZS5oZWlnaHQpXG4gICAgY29uc3QgcGl4ZWxzID0gZGltZW5zaW9ucy54ICogZGltZW5zaW9ucy55XG4gICAgY29uc3QgZXhjZWVkc01heFBpeGVscyA9IHBpeGVscyA+IHRoaXMuX21heFBpeGVsc1xuICAgIGNvbnN0IGV4Y2VlZHNNYXhEaW1lbnNpb25zID0gKHRoaXMuX21heERpbWVuc2lvbnMgIT09IG51bGwgJiZcbiAgICAgIChkaW1lbnNpb25zLnggPiB0aGlzLl9tYXhEaW1lbnNpb25zIHx8IGRpbWVuc2lvbnMueSA+IHRoaXMuX21heERpbWVuc2lvbnMpKVxuXG4gICAgcmV0dXJuIGV4Y2VlZHNNYXhQaXhlbHMgfHwgZXhjZWVkc01heERpbWVuc2lvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemVzIHRoZSBpbWFnZSB0byBtYXRjaCB0aGUgbWF4aW11bSBhbW91bnQgb2YgcGl4ZWxzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICByZXNpemUgKCkge1xuICAgIGxldCByZWFzb24gPSBudWxsXG4gICAgbGV0IGNhbnZhcyA9IG51bGxcbiAgICBjb25zdCBtYXhEaW1lbnNpb25zID0gdGhpcy5fbWF4RGltZW5zaW9uc1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgaW5pdGlhbERpbWVuc2lvbnMgPSBuZXcgVmVjdG9yMih0aGlzLl9pbWFnZS53aWR0aCwgdGhpcy5faW1hZ2UuaGVpZ2h0KVxuICAgICAgICBjb25zdCBkaW1lbnNpb25zID0gaW5pdGlhbERpbWVuc2lvbnMuY2xvbmUoKVxuXG4gICAgICAgIC8vIElmIG1heCBwaXhlbHMgaXMgZXhjZWVkZWQsIHJlc2l6ZSB0byBmaXQgdGhlIG1heCBwaXhlbHNcbiAgICAgICAgaWYgKGRpbWVuc2lvbnMueCAqIGRpbWVuc2lvbnMueSA+IHRoaXMuX21heFBpeGVscykge1xuICAgICAgICAgIGRpbWVuc2lvbnMuY29weSh0aGlzLl9nZXREaW1lbnNpb25zQnlNYXhQaXhlbHMoKSlcbiAgICAgICAgICByZWFzb24gPSAnbWF4TWVnYVBpeGVscydcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG1heCBkaW1lbnNpb25zIChtYXhpbXVtIHRleHR1cmUgc2l6ZSkgaXMgZXhjZWVkZWQsXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgc2hvcnRlciBzaWRlIGVxdWFscyB0aGUgbWF4aW11bSB0ZXh0dXJlXG4gICAgICAgIC8vIHNpemVcbiAgICAgICAgaWYgKG1heERpbWVuc2lvbnMgIT09IG51bGwgJiZcbiAgICAgICAgICAgIChkaW1lbnNpb25zLnggPiBtYXhEaW1lbnNpb25zIHx8XG4gICAgICAgICAgICBkaW1lbnNpb25zLnkgPiBtYXhEaW1lbnNpb25zKSkge1xuICAgICAgICAgIGxldCBzY2FsZSA9IE1hdGgubWluKFxuICAgICAgICAgICAgbWF4RGltZW5zaW9ucyAvIGRpbWVuc2lvbnMueCxcbiAgICAgICAgICAgIG1heERpbWVuc2lvbnMgLyBkaW1lbnNpb25zLnlcbiAgICAgICAgICApXG4gICAgICAgICAgZGltZW5zaW9ucy5tdWx0aXBseShzY2FsZSlcbiAgICAgICAgICByZWFzb24gPSAnbWF4RGltZW5zaW9ucydcbiAgICAgICAgfVxuXG4gICAgICAgIGRpbWVuc2lvbnMuZmxvb3IoKVxuICAgICAgICBjYW52YXMgPSB0aGlzLl9jcmVhdGVSZXNpemVkSW1hZ2VDYW52YXMoZGltZW5zaW9ucylcblxuICAgICAgICByZXNvbHZlKHsgY2FudmFzLCBkaW1lbnNpb25zLCByZWFzb24gfSlcbiAgICAgIH0sIDEwMDApXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVzaXplZCBjYW52YXMgd2l0aCB0aGUgZ2l2ZW4gZGltZW5zaW9uc1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IGRpbWVuc2lvbnNcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBbaW1hZ2VEaW1lbnNpb25zXSA9IGRpbWVuc2lvbnNcbiAgICogQHJldHVybiB7Q2FudmFzfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZVJlc2l6ZWRJbWFnZUNhbnZhcyAoZGltZW5zaW9ucywgaW1hZ2VEaW1lbnNpb25zID0gZGltZW5zaW9ucykge1xuICAgIGNvbnN0IGltYWdlID0gdGhpcy5faW1hZ2VcblxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgY2FudmFzLndpZHRoID0gZGltZW5zaW9ucy54XG4gICAgY2FudmFzLmhlaWdodCA9IGRpbWVuc2lvbnMueVxuXG4gICAgY29uc3Qgb2Zmc2V0ID0gZGltZW5zaW9ucy5jbG9uZSgpXG4gICAgICAuc3VidHJhY3QoaW1hZ2VEaW1lbnNpb25zKVxuICAgICAgLmRpdmlkZSgyKVxuXG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsXG4gICAgICAwLCAwLFxuICAgICAgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCxcbiAgICAgIG9mZnNldC54LCBvZmZzZXQueSxcbiAgICAgIGltYWdlRGltZW5zaW9ucy54LCBpbWFnZURpbWVuc2lvbnMueSlcbiAgICByZXR1cm4gY2FudmFzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGltZW5zaW9ucyB0aGF0IG1hdGNoIHRoZSBtYXggcGl4ZWwgY291bnRcbiAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXREaW1lbnNpb25zQnlNYXhQaXhlbHMgKCkge1xuICAgIGNvbnN0IGltYWdlID0gdGhpcy5faW1hZ2VcbiAgICBjb25zdCBtYXhQaXhlbHMgPSB0aGlzLl9tYXhQaXhlbHNcblxuICAgIGNvbnN0IHJhdGlvSFYgPSBpbWFnZS53aWR0aCAvIGltYWdlLmhlaWdodFxuICAgIGNvbnN0IHJhdGlvVkggPSBpbWFnZS5oZWlnaHQgLyBpbWFnZS53aWR0aFxuXG4gICAgcmV0dXJuIG5ldyBWZWN0b3IyKFxuICAgICAgTWF0aC5zcXJ0KG1heFBpeGVscyAqIHJhdGlvSFYpLFxuICAgICAgTWF0aC5zcXJ0KG1heFBpeGVscyAqIHJhdGlvVkgpXG4gICAgKS5mbG9vcigpXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9pbWFnZS1yZXNpemVyLmpzIiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgUGhvdG9FZGl0b3JTREsgZnJvbSAncGhvdG9lZGl0b3JzZGsnXG5pbXBvcnQgeyBDb25zdGFudHMgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFZGl0b3JPcGVyYXRpb25zIHtcbiAgY29uc3RydWN0b3IgKGVkaXRvciwgc2RrLCBtZWRpYXRvcikge1xuICAgIHRoaXMuX2VkaXRvciA9IGVkaXRvclxuICAgIHRoaXMuX3NkayA9IHNka1xuICAgIHRoaXMuX21lZGlhdG9yID0gbWVkaWF0b3JcblxuICAgIHRoaXMuX21hcCA9IHt9XG5cbiAgICAvLyBgZWRpdG9yYCBtaWdodCBiZSBzaGFsbG93IChlLmcuIGZvciBwcmVsb2FkaW5nKSwgc28gX3NkayBtaWdodCBub3QgZXhpc3QuXG4gICAgdGhpcy5fc3RhY2sgPSB0aGlzLl9zZGsgJiYgdGhpcy5fc2RrLmdldE9wZXJhdGlvbnNTdGFjaygpXG4gICAgdGhpcy5fcHJlZmVycmVkT3JkZXIgPSB0aGlzLl9lZGl0b3IuZ2V0T3B0aW9ucygpLmVkaXRvci5vcGVyYXRpb25zT3JkZXJcblxuICAgIHRoaXMuX2F2YWlsYWJsZSA9IHt9XG5cbiAgICBjb25zdCB7IE9wZXJhdGlvbnMgfSA9IFBob3RvRWRpdG9yU0RLXG4gICAgZm9yIChsZXQgb3BlcmF0aW9uTmFtZSBpbiBPcGVyYXRpb25zKSB7XG4gICAgICBjb25zdCBPcGVyYXRpb24gPSBPcGVyYXRpb25zW29wZXJhdGlvbk5hbWVdXG4gICAgICB0aGlzLl9hdmFpbGFibGVbT3BlcmF0aW9uLmlkZW50aWZpZXJdID0gT3BlcmF0aW9uXG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IGVkaXRvci5nZXRPcHRpb25zKClcbiAgICBjb25zdCB7IG9wZXJhdGlvbnMgfSA9IG9wdGlvbnMuZXh0ZW5zaW9uc1xuICAgIGZvciAobGV0IGtleSBpbiBvcGVyYXRpb25zKSB7XG4gICAgICBjb25zdCBvcGVyYXRpb24gPSBvcGVyYXRpb25zW2tleV1cbiAgICAgIHRoaXMuX2F2YWlsYWJsZVtvcGVyYXRpb24uaWRlbnRpZmllcl0gPSBvcGVyYXRpb25cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhY2spIHtcbiAgICAgIHRoaXMuX2ZpeFN0YWNrKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYW4gb3BlcmF0aW9uIHdpdGggdGhlIGdpdmVuIGlkZW50aWZpZXIgZXhpc3RzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpZGVudGlmaWVyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBleGlzdHMgKGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gISF0aGlzLl9tYXBbaWRlbnRpZmllcl1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBvcGVyYXRpb24gdG8gdGhlIHN0YWNrXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICovXG4gIGFkZCAob3BlcmF0aW9uKSB7XG4gICAgY29uc3QgaWRlbnRpZmllciA9IG9wZXJhdGlvbi5jb25zdHJ1Y3Rvci5pZGVudGlmaWVyXG4gICAgb3BlcmF0aW9uLm9uKCd1cGRhdGUnLCAoKSA9PiB7XG4gICAgICB0aGlzLl9tZWRpYXRvci5lbWl0KENvbnN0YW50cy5FVkVOVFMuT1BFUkFUSU9OX1VQREFURUQsIG9wZXJhdGlvbilcbiAgICB9KVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fcHJlZmVycmVkT3JkZXIuaW5kZXhPZihpZGVudGlmaWVyKVxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRWRpdG9yT3BlcmF0aW9ucyNhZGQ6IFxcYCR7aWRlbnRpZmllcn1cXGAgZG9lcyBub3QgYXBwZWFyIGluIFxcYG9wZXJhdGlvbnNPcmRlclxcYGApXG4gICAgfVxuICAgIHRoaXMuX3N0YWNrLnNldChpbmRleCwgb3BlcmF0aW9uKVxuICAgIHRoaXMuX21hcFtpZGVudGlmaWVyXSA9IG9wZXJhdGlvblxuXG4gICAgdGhpcy5fbWVkaWF0b3IuZW1pdChDb25zdGFudHMuRVZFTlRTLk9QRVJBVElPTl9DUkVBVEVELCBvcGVyYXRpb24pXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gb3BlcmF0aW9uIGZyb20gdGhlIHN0YWNrXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqL1xuICByZW1vdmUgKG9wZXJhdGlvbikge1xuICAgIGNvbnN0IGlkZW50aWZpZXIgPSBvcGVyYXRpb24uY29uc3RydWN0b3IuaWRlbnRpZmllclxuICAgIGNvbnN0IHN0YWNrID0gdGhpcy5fc3RhY2suZ2V0U3RhY2soKVxuXG4gICAgLy8gUmVtb3ZlIG9wZXJhdGlvbiBmcm9tIG1hcFxuICAgIGRlbGV0ZSB0aGlzLl9tYXBbaWRlbnRpZmllcl1cblxuICAgIC8vIFJlbW92ZSBvcGVyYXRpb24gZnJvbSBzdGFja1xuICAgIGNvbnN0IGluZGV4ID0gc3RhY2tcbiAgICAgIC5tYXAoKG9wKSA9PiBvcC5jb25zdHJ1Y3Rvci5pZGVudGlmaWVyKVxuICAgICAgLmluZGV4T2Yob3BlcmF0aW9uLmNvbnN0cnVjdG9yLmlkZW50aWZpZXIpXG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9zdGFjay5yZW1vdmVBdChpbmRleClcblxuICAgICAgLy8gU2V0IGFsbCBmb2xsb3dpbmcgb3BlcmF0aW9ucyB0byBkaXJ0eSwgc2luY2UgdGhleSBtaWdodFxuICAgICAgLy8gaGF2ZSBjYWNoZWQgc3R1ZmYgZHJhd24gYnkgdGhlIHJlbW92ZWQgb3BlcmF0aW9uXG4gICAgICBmb3IgKGxldCBpID0gaW5kZXggKyAxOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gc3RhY2tbaV1cbiAgICAgICAgaWYgKCFvcGVyYXRpb24pIGNvbnRpbnVlXG4gICAgICAgIG9wZXJhdGlvbi5zZXREaXJ0eSh0cnVlKVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9tZWRpYXRvci5lbWl0KENvbnN0YW50cy5FVkVOVFMuT1BFUkFUSU9OX1JFTU9WRUQsIG9wZXJhdGlvbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3BlcmF0aW9uIHdpdGggdGhlIGdpdmVuIGlkZW50aWZpZXJcbiAgICogQHBhcmFtICB7U3RyaW5nfSBpZGVudGlmaWVyXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbn1cbiAgICovXG4gIGdldCAoaWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLl9tYXBbaWRlbnRpZmllcl1cbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgb3BlcmF0aW9uIHdpdGggdGhlIGdpdmVuIGlkZW50aWZpZXIgYWxyZWFkeSBleGlzdHMsIGl0IHJldHVybnNcbiAgICogdGhlIGV4aXN0aW5nIG9wZXJhdGlvbi4gT3RoZXJ3aXNlLCBpdCBjcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IG9uZS5cbiAgICogQHBhcmFtICB7U3RyaW5nfSBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb259XG4gICAqL1xuICBnZXRPckNyZWF0ZSAoaWRlbnRpZmllciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuX21hcFtpZGVudGlmaWVyXSkge1xuICAgICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5fbWFwW2lkZW50aWZpZXJdXG4gICAgICBvcGVyYXRpb24uc2V0KG9wdGlvbnMsIGZhbHNlKVxuICAgICAgcmV0dXJuIG9wZXJhdGlvblxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBPcGVyYXRpb24gPSB0aGlzLl9hdmFpbGFibGVbaWRlbnRpZmllcl1cbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IG5ldyBPcGVyYXRpb24odGhpcy5fc2RrLCBvcHRpb25zKVxuICAgICAgdGhpcy5hZGQob3BlcmF0aW9uKVxuICAgICAgcmV0dXJuIG9wZXJhdGlvblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcGVyYXRpb25zIHN0YWNrXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnNTdGFja31cbiAgICovXG4gIGdldFN0YWNrICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhY2tcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIG9wZXJhdGlvbiBpcyBhdmFpbGFibGVcbiAgICogQHBhcmFtIHtTdHJpbmd9XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0F2YWlsYWJsZSAoaWRlbnRpZmllcikge1xuICAgIHJldHVybiAhIXRoaXMuX2F2YWlsYWJsZVtpZGVudGlmaWVyXVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGF2YWlsYWJsZSBvcGVyYXRpb25zXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldEF2YWlsYWJsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F2YWlsYWJsZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgb3BlcmF0aW9uc1xuICAgKi9cbiAgcmVzZXQgKCkge1xuICAgIHRoaXMuX21hcCA9IHt9XG4gIH1cblxuICAvKipcbiAgICogU2luY2UgdGhlIFNESyBtaWdodCBjcmVhdGUgc29tZSBvcGVyYXRpb25zIHVwZnJvbnQgKGUuZy4gdG8gZml4IHRoZSBFWElGIG9yaWVudGF0aW9uKSxcbiAgICogd2UgbWlnaHQgaGF2ZSBvcGVyYXRpb25zIGF0IGFycmF5IHBvc2l0aW9ucyB3aGVyZSB0aGV5IHNob3VsZCBub3QgYmUuIFRoaXMgbWV0aG9kXG4gICAqIG1vdmVzIHRoZW0gdG8gdGhlaXIgYXBwcm9wcmlhdGUgcG9zaXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9maXhTdGFjayAoKSB7XG4gICAgY29uc3Qgc3RhY2sgPSB0aGlzLl9zdGFjay5nZXRTdGFjaygpLnNsaWNlKClcbiAgICB0aGlzLl9zdGFjay5jbGVhcigpXG5cbiAgICBzdGFjay5mb3JFYWNoKChzKSA9PiB7XG4gICAgICB0aGlzLmFkZChzKVxuICAgIH0pXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9lZGl0b3Ivb3BlcmF0aW9ucy5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0ICogYXMgQ29udHJvbHMgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9jb250cm9scy8nXG5pbXBvcnQgeyBTREtVdGlscywgTG9nIH0gZnJvbSAnLi4vLi4vZ2xvYmFscydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWRpdG9yQ29udHJvbHMge1xuICBjb25zdHJ1Y3RvciAoZWRpdG9yLCBzZGssIG1lZGlhdG9yKSB7XG4gICAgdGhpcy5fZWRpdG9yID0gZWRpdG9yXG4gICAgdGhpcy5fc2RrID0gc2RrXG4gICAgdGhpcy5fbWVkaWF0b3IgPSBtZWRpYXRvclxuXG4gICAgdGhpcy5faW52YWxpZE9wZXJhdGlvbnNTZWVuID0gW11cbiAgICB0aGlzLl9vcHRpb25zID0gdGhpcy5fZWRpdG9yLmdldE9wdGlvbnMoKVxuICAgIHRoaXMuX2F2YWlsYWJsZSA9IFNES1V0aWxzLmV4dGVuZCh7fSwgQ29udHJvbHMsIHRoaXMuX29wdGlvbnMuZXh0ZW5zaW9ucy5jb250cm9scylcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gaWRlbnRpZmllciBpcyBzZWxlY3RhYmxlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gIGlkZW50aWZpZXJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzRW5hYmxlZCAoaWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyb2wgPSB0aGlzLmdldChpZGVudGlmaWVyKVxuXG4gICAgaWYgKCFjb250cm9sKSB7XG4gICAgICBMb2cuaW5mbygnRWRpdG9yQ29udHJvbHMjaXNFbmFibGVkOiBVbmtub3duIGNvbnRyb2w6ICcgKyBpZGVudGlmaWVyKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWlyZWRPcGVyYXRpb25zID0gY29udHJvbC5yZXF1aXJlZE9wZXJhdGlvbnMgfHwgW11cbiAgICBjb25zdCBtaXNzaW5nT3BlcmF0aW9ucyA9IFtdXG4gICAgcmVxdWlyZWRPcGVyYXRpb25zLmZvckVhY2gob3BlcmF0aW9uSWRlbnRpZmllciA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2VkaXRvci5vcGVyYXRpb25zLmlzQXZhaWxhYmxlKG9wZXJhdGlvbklkZW50aWZpZXIpKSB7XG4gICAgICAgIG1pc3NpbmdPcGVyYXRpb25zLnB1c2gob3BlcmF0aW9uSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYgKG1pc3NpbmdPcGVyYXRpb25zLmxlbmd0aCkge1xuICAgICAgLy8gTWFraW5nIHN1cmUgd2Ugb25seSBzaG93IG9uZSBlcnJvciBwZXIgY29udHJvbFxuICAgICAgaWYgKHRoaXMuX2ludmFsaWRPcGVyYXRpb25zU2Vlbi5pbmRleE9mKGlkZW50aWZpZXIpID09PSAtMSkge1xuICAgICAgICB0aGlzLl9pbnZhbGlkT3BlcmF0aW9uc1NlZW4ucHVzaChpZGVudGlmaWVyKVxuICAgICAgICBMb2cuZXJyb3IoYENvbnRyb2wgXFxgJHtpZGVudGlmaWVyfVxcYCBjYW4gbm90IGJlIHVzZWQgYmVjYXVzZSAke21pc3NpbmdPcGVyYXRpb25zLmxlbmd0aCA9PT0gMSA/ICdvcGVyYXRpb24gaXMnIDogJ29wZXJhdGlvbnMgYXJlJ30gbWlzc2luZzogJHttaXNzaW5nT3BlcmF0aW9ucy5tYXAobyA9PiBgXFxgJHtvfVxcYGApLmpvaW4oJywgJyl9YClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiBjb250cm9sLmlzQXZhaWxhYmxlICYmIGNvbnRyb2wuaXNBdmFpbGFibGUodGhpcy5fZWRpdG9yKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gaWRlbnRpZmllclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGlkZW50aWZpZXJcbiAgICogQHJldHVybiB7Q29udHJvbH1cbiAgICovXG4gIGdldCAoaWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLl9hdmFpbGFibGVbaWRlbnRpZmllcl1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhdmFpbGFibGUgY29udHJvbHNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0QXZhaWxhYmxlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXZhaWxhYmxlXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9lZGl0b3IvY29udHJvbHMuanMiLCIvKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBDb250cm9scyBmcm9tICcuLi9jb250cm9scydcbmltcG9ydCBBZGp1c3RtZW50c0NvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4vYWRqdXN0bWVudHMtY29udHJvbHMtY29tcG9uZW50J1xuXG5jb25zdCBUT09MUyA9IFtcbiAgJ2JyaWdodG5lc3MnLCAnY2xhcml0eScsICdjb250cmFzdCcsICdleHBvc3VyZScsICdoaWdobGlnaHRzJywgJ3NhdHVyYXRpb24nLCAnc2hhZG93cycsICdnYW1tYScsICd3aGl0ZXMnLCAnYmxhY2tzJywgJ3RlbXBlcmF0dXJlJ1xuXVxuXG4vKipcbiAqIFRoZSBhZGp1c3RtZW50cyBjb250cm9sc1xuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xzXG4gKi9cbmNsYXNzIEFkanVzdG1lbnRzQ29udHJvbHMgZXh0ZW5kcyBDb250cm9scyB7XG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGVudGVycyB0aGVzZSBjb250cm9sc1xuICAgKiBAdGhpcyB7QWRqdXN0bWVudHNDb250cm9sc0NvbXBvbmVudH1cbiAgICogQHBhcmFtIHtTaGFyZWRTdGF0ZX0gc2hhcmVkU3RhdGVcbiAgICogQG92ZXJyaWRlXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBvbkVudGVyIChzaGFyZWRTdGF0ZSkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBvcGVyYXRpb25FeGlzdGVkQmVmb3JlID0gZWRpdG9yLm9wZXJhdGlvbnMuZXhpc3RzKCdhZGp1c3RtZW50cycpXG4gICAgY29uc3Qgb3BlcmF0aW9uID0gZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ2FkanVzdG1lbnRzJylcbiAgICBjb25zdCBpbml0aWFsT3B0aW9ucyA9IG9wZXJhdGlvbi5zZXJpYWxpemVPcHRpb25zKClcblxuICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUoeyBvcGVyYXRpb24sIG9wZXJhdGlvbkV4aXN0ZWRCZWZvcmUsIGluaXRpYWxPcHRpb25zIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgY29udHJvbCBpcyBhdmFpbGFibGUgdG8gdGhlIHVzZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5FZGl0b3J9IGVkaXRvclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIGlzQXZhaWxhYmxlIChlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzVG9vbEFsbG93ZWQoJ2FkanVzdG1lbnQnKSAmJlxuICAgICAgVE9PTFMuZmlsdGVyKCh0b29sKSA9PiBlZGl0b3IuaXNUb29sRW5hYmxlZCh0b29sKSkubGVuZ3RoID4gMFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFzc2V0cyB0aGF0IHNob3VsZCBiZSBwcmVsb2FkZWQgZm9yIHRoaXMgY29udHJvbFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkVkaXRvcn0gZWRpdG9yXG4gICAqIEByZXR1cm4ge1N0cmluZ1tdfVxuICAgKi9cbiAgc3RhdGljIGdldFByZWxvYWRBc3NldHMgKGVkaXRvcikge1xuICAgIHJldHVybiBUT09MU1xuICAgICAgLmZpbHRlcigodG9vbCkgPT4gZWRpdG9yLmlzVG9vbEVuYWJsZWQodG9vbCkpXG4gICAgICAubWFwKCh0b29sKSA9PiBgY29udHJvbHMvYWRqdXN0bWVudHMvJHt0b29sfS5wbmdgKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgY29udHJvbHMgY29tcG9uZW50LiBVc2VkIGZvciB0aGUgbG93ZXIgY29udHJvbHMgcGFydCBvZiB0aGUgZWRpdG9yLlxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNDb21wb25lbnR9XG4gKiBAaWdub3JlXG4gKi9cbkFkanVzdG1lbnRzQ29udHJvbHMuY29udHJvbHNDb21wb25lbnQgPSBBZGp1c3RtZW50c0NvbnRyb2xzQ29tcG9uZW50XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkFkanVzdG1lbnRzQ29udHJvbHMuaWRlbnRpZmllciA9ICdhZGp1c3RtZW50cydcblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBpY29uIHBhdGhcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAaWdub3JlXG4gKi9cbkFkanVzdG1lbnRzQ29udHJvbHMuaWNvblBhdGggPSAnY29udHJvbHMvb3ZlcnZpZXcvYWRqdXN0bWVudHMucG5nJ1xuXG4vKipcbiAqIFRoZSBsYW5ndWFnZSBrZXkgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhpcyBmaWx0ZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAaWdub3JlXG4gKi9cbkFkanVzdG1lbnRzQ29udHJvbHMubGFuZ3VhZ2VLZXkgPSAncGVzZGsuYWRqdXN0bWVudHMudGl0bGUubmFtZSdcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGlzIGNvbnRyb2xcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkFkanVzdG1lbnRzQ29udHJvbHMuZGVmYXVsdE9wdGlvbnMgPSB7XG5cbn1cblxuLyoqXG4gKiBUaGUgb3BlcmF0aW9ucyByZXF1aXJlZCBmb3IgdGhpcyBjb250cm9sIHRvIHdvcmsgcHJvcGVybHlcbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuQWRqdXN0bWVudHNDb250cm9scy5yZXF1aXJlZE9wZXJhdGlvbnMgPSBbJ2FkanVzdG1lbnRzJ11cblxuZXhwb3J0IGRlZmF1bHQgQWRqdXN0bWVudHNDb250cm9sc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9hZGp1c3RtZW50cy9pbmRleC5qcyIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBTREsgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IENvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4uL2NvbnRyb2xzLWNvbXBvbmVudCdcbmltcG9ydCBTY3JvbGxiYXJDb21wb25lbnQgZnJvbSAnLi4vLi4vc2Nyb2xsYmFyLWNvbXBvbmVudCdcbmltcG9ydCBTbGlkZXJPdmVybGF5Q29tcG9uZW50IGZyb20gJy4uL3NsaWRlci1vdmVybGF5LWNvbXBvbmVudCdcbmltcG9ydCBNaW5pU2xpZGVyQ29tcG9uZW50IGZyb20gJy4uL21pbmktc2xpZGVyLWNvbXBvbmVudCdcbmNvbnN0IHsgQWRqdXN0bWVudHNPcGVyYXRpb24gfSA9IFNESy5PcGVyYXRpb25zXG5cbmNvbnN0IElURU1TID0gWydicmlnaHRuZXNzJywgJ3NhdHVyYXRpb24nLCAnY29udHJhc3QnLCAnZ2FtbWEnLCAnY2xhcml0eScsICdleHBvc3VyZScsICdzaGFkb3dzJywgJ2hpZ2hsaWdodHMnLCAnd2hpdGVzJywgJ2JsYWNrcycsICd0ZW1wZXJhdHVyZSddXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFkanVzdG1lbnRzQ29udHJvbHNDb21wb25lbnQgZXh0ZW5kcyBDb250cm9sc0NvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uU2xpZGVyVmFsdWVDaGFuZ2UnXG4gICAgKVxuXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIHRoaXMuX29wZXJhdGlvbiA9IGVkaXRvci5vcGVyYXRpb25zLmdldE9yQ3JlYXRlKCdhZGp1c3RtZW50cycpXG5cbiAgICB0aGlzLnN0YXRlID0geyBzZWxlY3RlZENvbnRyb2xzOiBudWxsIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYmFjayBidXR0b25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQmFja0NsaWNrIChlKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG9wZXJhdGlvbkV4aXN0ZWRCZWZvcmUgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb25FeGlzdGVkQmVmb3JlJylcbiAgICBjb25zdCBpbml0aWFsT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2luaXRpYWxPcHRpb25zJylcblxuICAgIGlmICghdGhpcy5fb3BlcmF0aW9uLm9wdGlvbnNFcXVhbChpbml0aWFsT3B0aW9ucykpIHtcbiAgICAgIGVkaXRvci5oaXN0b3J5LmFkZCh0aGlzLl9vcGVyYXRpb24sXG4gICAgICAgIGluaXRpYWxPcHRpb25zLFxuICAgICAgICBvcGVyYXRpb25FeGlzdGVkQmVmb3JlKVxuICAgIH1cblxuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0gdGhpcy5fb3BlcmF0aW9uLmdldERlZmF1bHRPcHRpb25zKClcbiAgICBpZiAodGhpcy5fb3BlcmF0aW9uLm9wdGlvbnNFcXVhbChkZWZhdWx0T3B0aW9ucykpIHtcbiAgICAgIGVkaXRvci5vcGVyYXRpb25zLnJlbW92ZSh0aGlzLl9vcGVyYXRpb24pXG4gICAgfVxuXG4gICAgc3VwZXIuX29uQmFja0NsaWNrKGUpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjaGFuZ2VzIHRoZSBzbGlkZXIgdmFsdWVcbiAgICogQHBhcmFtICB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uU2xpZGVyVmFsdWVDaGFuZ2UgKHZhbHVlKSB7XG4gICAgY29uc3QgeyBzZWxlY3RlZENvbnRyb2xzIH0gPSB0aGlzLnN0YXRlXG4gICAgY29uc3Qgb3B0aW9uID0gQWRqdXN0bWVudHNPcGVyYXRpb24ucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnNbc2VsZWN0ZWRDb250cm9sc11cbiAgICBjb25zdCB7IG1pblZhbHVlLCBtaWRWYWx1ZSwgbWF4VmFsdWUgfSA9IG9wdGlvblxuXG4gICAgdmFsdWUgPSB2YWx1ZSA8IDBcbiAgICAgID8gKG1pZFZhbHVlICsgKG1pZFZhbHVlIC0gbWluVmFsdWUpICogdmFsdWUgLyAxMDApXG4gICAgICA6IChtaWRWYWx1ZSArIChtYXhWYWx1ZSAtIG1pZFZhbHVlKSAqIHZhbHVlIC8gMTAwKVxuXG4gICAgdGhpcy5fb3BlcmF0aW9uLnNldE9wdGlvbihzZWxlY3RlZENvbnRyb2xzLCB2YWx1ZSlcblxuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBlZGl0b3IucmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbmUgb2YgdGhlIHRocmVlIGJ1dHRvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRyb2xzSXRlbVxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25CdXR0b25DbGljayAoY29udHJvbHNJdGVtLCBlKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHNlbGVjdGVkQ29udHJvbHM6IGNvbnRyb2xzSXRlbSB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTUlTQ1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIHByb3BzIGhhc2ggcGFzc2VkIHRvIHRoZSBzbGlkZXJzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpZGVudGlmaWVyXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIF9idWlsZFNsaWRlclByb3BzIChpZGVudGlmaWVyKSB7XG4gICAgY29uc3Qgb3B0aW9uID0gQWRqdXN0bWVudHNPcGVyYXRpb24ucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnNbaWRlbnRpZmllcl1cbiAgICBjb25zdCB7IG1pblZhbHVlLCBtaWRWYWx1ZSwgbWF4VmFsdWUgfSA9IG9wdGlvblxuXG4gICAgbGV0IHZhbHVlID0gdGhpcy5fb3BlcmF0aW9uXG4gICAgICA/IHRoaXMuX29wZXJhdGlvbi5nZXRPcHRpb24oaWRlbnRpZmllcilcbiAgICAgIDogbWlkVmFsdWVcblxuICAgIGxldCBzbGlkZXJWYWx1ZSA9ICh2YWx1ZSA8PSBtaWRWYWx1ZVxuICAgICAgPyAodmFsdWUgLSBtaW5WYWx1ZSkgLyAobWlkVmFsdWUgLSBtaW5WYWx1ZSkgLSAxXG4gICAgICA6ICh2YWx1ZSAtIG1pZFZhbHVlKSAvIChtYXhWYWx1ZSAtIG1pZFZhbHVlKSkgKiAxMDBcblxuICAgIHJldHVybiB7XG4gICAgICBtaW5WYWx1ZTogLTEwMCxcbiAgICAgIG1heFZhbHVlOiAxMDAsXG4gICAgICB2YWx1ZTogc2xpZGVyVmFsdWUsXG4gICAgICB2YWx1ZVVuaXQ6ICclJyxcbiAgICAgIHBvc2l0aXZlVmFsdWVQcmVmaXg6ICcrJyxcbiAgICAgIGxhYmVsOiB0aGlzLl90KGBwZXNkay5hZGp1c3RtZW50cy50ZXh0LiR7aWRlbnRpZmllcn1gKSxcbiAgICAgIG1pZGRsZURvdDogdHJ1ZSxcbiAgICAgIG9uQ2hhbmdlOiB0aGlzLl9vblNsaWRlclZhbHVlQ2hhbmdlXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgcmVuZGVyT3ZlcmxheUNvbnRyb2xzICgpIHtcbiAgICBjb25zdCB7IHNlbGVjdGVkQ29udHJvbHMgfSA9IHRoaXMuc3RhdGVcbiAgICBpZiAoIXNlbGVjdGVkQ29udHJvbHMpIHJldHVyblxuXG4gICAgY29uc3Qgc2xpZGVyUHJvcHMgPSB0aGlzLl9idWlsZFNsaWRlclByb3BzKHNlbGVjdGVkQ29udHJvbHMpXG4gICAgcmV0dXJuICg8U2xpZGVyT3ZlcmxheUNvbXBvbmVudCB7Li4uc2xpZGVyUHJvcHN9IC8+KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGxpc3QgaXRlbXNcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudFtdfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckxpc3RJdGVtcyAoKSB7XG4gICAgcmV0dXJuIElURU1TXG4gICAgICAuZmlsdGVyKChpdGVtKSA9PiB0aGlzLmNvbnRleHQuZWRpdG9yLmlzVG9vbEVuYWJsZWQoaXRlbSkpXG4gICAgICAubWFwKChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSB0aGlzLnN0YXRlLnNlbGVjdGVkQ29udHJvbHMgPT09IGl0ZW1cbiAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gaXNTZWxlY3RlZCA/ICdpcy1hY3RpdmUnIDogbnVsbFxuXG4gICAgICAgIGxldCBtaW5pU2xpZGVyXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnN0YW50LWNvbmRpdGlvbiAqL1xuICAgICAgICBpZiAoIWlzU2VsZWN0ZWQgJiYgZmFsc2UpIHsgLy8gTWluaSBzbGlkZXJzIHRlbXBvcmFyaWx5IGRpc2FibGVkXG4gICAgICAgICAgY29uc3Qgc2xpZGVyUHJvcHMgPSB0aGlzLl9idWlsZFNsaWRlclByb3BzKGl0ZW0pXG4gICAgICAgICAgbWluaVNsaWRlciA9ICg8YmVtIHNwZWNpZmllcj0nYjphZGp1c3RtZW50c0NvbnRyb2xzJz5cbiAgICAgICAgICAgIDxkaXYgYmVtPSdlOm1pbmlTbGlkZXInPlxuICAgICAgICAgICAgICA8TWluaVNsaWRlckNvbXBvbmVudCB7Li4uc2xpZGVyUHJvcHN9IC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2JlbT4pXG4gICAgICAgIH1cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zdGFudC1jb25kaXRpb24gKi9cblxuICAgICAgICByZXR1cm4gKDxsaVxuICAgICAgICAgIGJlbT0nZTppdGVtJ1xuICAgICAgICAgIGtleT17aXRlbX1cbiAgICAgICAgICBkYXRhLWlkZW50aWZpZXI9e2l0ZW19PlxuICAgICAgICAgIDxiZW0gc3BlY2lmaWVyPSckYjpjb250cm9scyc+XG4gICAgICAgICAgICA8ZGl2IGJlbT0nJGU6YnV0dG9uIG06d2l0aExhYmVsJyBvbkNsaWNrPXt0aGlzLl9vbkJ1dHRvbkNsaWNrLmJpbmQodGhpcywgaXRlbSl9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cbiAgICAgICAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXt0aGlzLl9nZXRBc3NldFBhdGgoYGNvbnRyb2xzL2FkanVzdG1lbnRzLyR7aXRlbX0ucG5nYCwgdHJ1ZSl9IC8+XG4gICAgICAgICAgICAgIDxkaXYgYmVtPSdlOmxhYmVsJz57dGhpcy5fdChgcGVzZGsuYWRqdXN0bWVudHMudGV4dC4ke2l0ZW19YCl9PC9kaXY+XG4gICAgICAgICAgICAgIHttaW5pU2xpZGVyfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9iZW0+XG4gICAgICAgIDwvbGk+KVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb250cm9scyBvZiB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyQ29udHJvbHMgKCkge1xuICAgIGNvbnN0IGxpc3RJdGVtcyA9IHRoaXMuX3JlbmRlckxpc3RJdGVtcygpXG5cbiAgICByZXR1cm4gKDxkaXYgYmVtPSdlOmNlbGwgbTpsaXN0Jz5cbiAgICAgIDxTY3JvbGxiYXJDb21wb25lbnQ+XG4gICAgICAgIDx1bCBiZW09JyRlOmxpc3QnPlxuICAgICAgICAgIHtsaXN0SXRlbXN9XG4gICAgICAgIDwvdWw+XG4gICAgICA8L1Njcm9sbGJhckNvbXBvbmVudD5cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuQWRqdXN0bWVudHNDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvYWRqdXN0bWVudHMvYWRqdXN0bWVudHMtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5pbXBvcnQgeyBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1pbmlTbGlkZXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHZhbHVlOiB0aGlzLnByb3BzLnZhbHVlIHx8IDAsXG4gICAgICBzbGlkZXJQb3NpdGlvbjogMCxcbiAgICAgIGZvcmVncm91bmRMZWZ0OiAwLFxuICAgICAgZm9yZWdyb3VuZFdpZHRoOiAwXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIC8vIFRyaWdnZXIgYSByZS1yZW5kZXIgdG8gcG9zaXRpb24gdGhlIGtub2JcbiAgICB0aGlzLl9zZXRWYWx1ZSh0aGlzLnN0YXRlLnZhbHVlLCBmYWxzZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IHJlY2VpdmVzIG5ldyBwcm9wc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHByb3BzXG4gICAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChwcm9wcykge1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdGhpcy5zdGF0ZS52YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0VmFsdWUocHJvcHMudmFsdWUsIGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHlsZSBmb3IgdGhlIGtub2IgKHBvc2l0aW9uKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0S25vYlN0eWxlICgpIHtcbiAgICByZXR1cm4geyBsZWZ0OiB0aGlzLnN0YXRlLnNsaWRlclBvc2l0aW9uIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHlsZSBmb3IgdGhlIGZvcmVncm91bmQgYmFyXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRGb3JlZ3JvdW5kU3R5bGUgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB0aGlzLnN0YXRlLmZvcmVncm91bmRMZWZ0LFxuICAgICAgd2lkdGg6IHRoaXMuc3RhdGUuZm9yZWdyb3VuZFdpZHRoXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTUlTQ1xuXG4gIC8qKlxuICAgKiBEZWNpZGVzIHdoZXRoZXIgb3Igbm90IHRoaXMgc2xpZGVyIHNob3VsZCBoYXZlIGEgbWlkZGxlIGRvdCBvbiB0aGUgYmFyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGlzcGxheU1pZGRsZURvdCAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMubWlkZGxlRG90ICE9PSBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIHRvIHRoZSBnaXZlbiB2YWx1ZSwgdXBkYXRlcyB0aGUgc2xpZGVyIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVtaXRDaGFuZ2UgPSB0cnVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0VmFsdWUgKHZhbHVlLCBlbWl0Q2hhbmdlID0gdHJ1ZSkge1xuICAgIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSlcbiAgICBjb25zdCB7IG1pblZhbHVlLCBtYXhWYWx1ZSB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHByb2dyZXNzID0gKHZhbHVlIC0gbWluVmFsdWUpIC8gKG1heFZhbHVlIC0gbWluVmFsdWUpXG5cbiAgICAvLyBDYWxjdWxhdGUgc2xpZGVyIHBvc2l0aW9uXG4gICAgY29uc3QgeyBiYXIgfSA9IHRoaXMucmVmc1xuICAgIGNvbnN0IGJhcldpZHRoID0gYmFyLm9mZnNldFdpZHRoXG4gICAgY29uc3Qgc2xpZGVyUG9zaXRpb24gPSBiYXJXaWR0aCAqIHByb2dyZXNzXG5cbiAgICAvLyBDYWxjdWxhdGUgZm9yZWdyb3VuZCBwb3NpdGlvbiBhbmQgd2lkdGhcbiAgICBsZXQgZm9yZWdyb3VuZFdpZHRoID0gcHJvZ3Jlc3MgKiBiYXJXaWR0aFxuICAgIGxldCBmb3JlZ3JvdW5kTGVmdCA9IDBcbiAgICBpZiAodGhpcy5fZGlzcGxheU1pZGRsZURvdCgpKSB7XG4gICAgICBmb3JlZ3JvdW5kV2lkdGggPSBNYXRoLmFicyhwcm9ncmVzcyAtIDAuNSkgKiBiYXJXaWR0aFxuICAgICAgZm9yZWdyb3VuZExlZnQgPSBwcm9ncmVzcyA8IDAuNVxuICAgICAgICA/IChiYXJXaWR0aCAqIDAuNSAtIGZvcmVncm91bmRXaWR0aClcbiAgICAgICAgOiAnNTAlJ1xuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoeyB2YWx1ZSwgc2xpZGVyUG9zaXRpb24sIGZvcmVncm91bmRXaWR0aCwgZm9yZWdyb3VuZExlZnQgfSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBjb25zdCBmb3JlZ3JvdW5kUHJvcHMgPSB7XG4gICAgICBzdHlsZTogdGhpcy5fZ2V0Rm9yZWdyb3VuZFN0eWxlKClcbiAgICB9XG5cbiAgICByZXR1cm4gKDxkaXYgYmVtPSckYjptaW5pU2xpZGVyJz5cbiAgICAgIDxkaXYgYmVtPSckZTpiYXInIHJlZj0nYmFyJz5cbiAgICAgICAgPGRpdiBiZW09JyRlOmJhY2tncm91bmQnIC8+XG4gICAgICAgIDxkaXYgYmVtPSckZTpmb3JlZ3JvdW5kJyB7Li4uZm9yZWdyb3VuZFByb3BzfSAvPlxuICAgICAgICA8ZGl2IGJlbT0nZTprbm9iJyBzdHlsZT17dGhpcy5fZ2V0S25vYlN0eWxlKCl9IC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuTWluaVNsaWRlckNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9taW5pLXNsaWRlci1jb21wb25lbnQuanN4IiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBTREtVdGlscywgVmVjdG9yMiB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgQ29udHJvbHMgZnJvbSAnLi4vY29udHJvbHMnXG5pbXBvcnQgVHJhbnNmb3JtQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi90cmFuc2Zvcm0tY29udHJvbHMtY29tcG9uZW50J1xuaW1wb3J0IFRyYW5zZm9ybUNhbnZhc0NvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4vdHJhbnNmb3JtLWNhbnZhcy1jb250cm9scy1jb21wb25lbnQnXG5pbXBvcnQgVHJhbnNmb3JtVG9wQmFyQ29tcG9uZW50IGZyb20gJy4vdHJhbnNmb3JtLXRvcC1iYXItY29tcG9uZW50J1xuXG4vKipcbiAqIFRoZSB0cmFuc2Zvcm0gY29udHJvbHNcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5Db250cm9sXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5Db250cm9sc1xuICovXG5jbGFzcyBUcmFuc2Zvcm1Db250cm9scyBleHRlbmRzIENvbnRyb2xzIHtcbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgZW50ZXJzIHRoZXNlIGNvbnRyb2xzXG4gICAqIEB0aGlzIHtUcmFuc2Zvcm1Db250cm9sc0NvbXBvbmVudH1cbiAgICogQHBhcmFtIHtTaGFyZWRTdGF0ZX0gc2hhcmVkU3RhdGVcbiAgICogQG92ZXJyaWRlXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBvbkVudGVyIChzaGFyZWRTdGF0ZSkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcblxuICAgIGNvbnN0IHRyYW5zZm9ybU9wZXJhdGlvbkV4aXN0ZWRCZWZvcmUgPSBlZGl0b3Iub3BlcmF0aW9ucy5leGlzdHMoJ3RyYW5zZm9ybScpXG4gICAgY29uc3QgdHJhbnNmb3JtT3BlcmF0aW9uID0gZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ3RyYW5zZm9ybScpXG4gICAgdHJhbnNmb3JtT3BlcmF0aW9uLnNldEVuYWJsZWQoZmFsc2UsIGZhbHNlKVxuXG4gICAgY29uc3Qgb3JpZW50YXRpb25PcGVyYXRpb25FeGlzdGVkQmVmb3JlID0gZWRpdG9yLm9wZXJhdGlvbnMuZXhpc3RzKCdvcmllbnRhdGlvbicpXG4gICAgY29uc3Qgb3JpZW50YXRpb25PcGVyYXRpb24gPSBlZGl0b3Iub3BlcmF0aW9ucy5nZXRPckNyZWF0ZSgnb3JpZW50YXRpb24nKVxuXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBlbmQ6IG5ldyBWZWN0b3IyKDEsIDEpLFxuICAgICAgcm90YXRpb246IDAsXG4gICAgICBzdGFydDogbmV3IFZlY3RvcjIoMCwgMCksXG4gICAgICB0ZXh0dXJlU2NhbGU6IDFcbiAgICB9XG5cbiAgICBjb25zdCBpbnB1dERpbWVuc2lvbnMgPSB0cmFuc2Zvcm1PcGVyYXRpb24uZ2V0SW5wdXREaW1lbnNpb25zKGZhbHNlKVxuICAgIGNvbnN0IGluaXRpYWxEaW1lbnNpb25zID0gdHJhbnNmb3JtT3BlcmF0aW9uLmdldE5ld0RpbWVuc2lvbnMoaW5wdXREaW1lbnNpb25zKVxuXG4gICAgbGV0IGluaXRpYWxUcmFuc2Zvcm1PcHRpb25zID0gZGVmYXVsdE9wdGlvbnNcbiAgICBpZiAodHJhbnNmb3JtT3BlcmF0aW9uRXhpc3RlZEJlZm9yZSkge1xuICAgICAgaW5pdGlhbFRyYW5zZm9ybU9wdGlvbnMgPSB0cmFuc2Zvcm1PcGVyYXRpb24uc2VyaWFsaXplT3B0aW9ucygpXG4gICAgICBkZWxldGUgaW5pdGlhbFRyYW5zZm9ybU9wdGlvbnMuZW5hYmxlZFxuXG4gICAgICAvLyBDb252ZXJ0IG9wZXJhdGlvbiBvcHRpb25zIHRvIG91ciBVSSBvcHRpb25zXG4gICAgICBjb25zdCB7IHN0YXJ0LCBlbmQsIHJvdGF0aW9uIH0gPSBpbml0aWFsVHJhbnNmb3JtT3B0aW9uc1xuICAgICAgY29uc3QgZmluYWxTY2FsZSA9IHRyYW5zZm9ybU9wZXJhdGlvbi5jYWxjdWxhdGVTY2FsZShyb3RhdGlvbilcbiAgICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IHRyYW5zZm9ybU9wZXJhdGlvbi5nZXRJbnB1dERpbWVuc2lvbnMoZmFsc2UpXG4gICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhyb3RhdGlvbilcbiAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKHJvdGF0aW9uKVxuXG4gICAgICBjb25zdCBoYWxmUmVsYXRpdmVTaXplID0gZW5kLmNsb25lKCkuc3VidHJhY3Qoc3RhcnQpLmRpdmlkZSgyKVxuICAgICAgY29uc3QgbWlkZGxlSW5QaXhlbHMgPSBzdGFydC5jbG9uZSgpXG4gICAgICAgIC5hZGQoaGFsZlJlbGF0aXZlU2l6ZSlcbiAgICAgICAgLm11bHRpcGx5KGlucHV0RGltZW5zaW9ucylcblxuICAgICAgY29uc3QgbWlkZGxlRGlzdGFuY2VGcm9tQ2VudGVyID0gbWlkZGxlSW5QaXhlbHNcbiAgICAgICAgLnN1YnRyYWN0KGlucHV0RGltZW5zaW9ucy5jbG9uZSgpLm11bHRpcGx5KDAuNSkpXG5cbiAgICAgIC8vIFJvdGF0ZSBhbmQgc2NhbGUgdGhlIG1pZGRsZSBiYWNrXG4gICAgICBjb25zdCBuZXdNaWRkbGVEaXN0YW5jZUZyb21DZW50ZXIgPSBuZXcgVmVjdG9yMihcbiAgICAgICAgbWlkZGxlRGlzdGFuY2VGcm9tQ2VudGVyLnggKiBjb3MgLSBtaWRkbGVEaXN0YW5jZUZyb21DZW50ZXIueSAqIHNpbixcbiAgICAgICAgbWlkZGxlRGlzdGFuY2VGcm9tQ2VudGVyLnggKiBzaW4gKyBtaWRkbGVEaXN0YW5jZUZyb21DZW50ZXIueSAqIGNvc1xuICAgICAgKS5tdWx0aXBseShmaW5hbFNjYWxlKVxuXG4gICAgICBjb25zdCBuZXdNaWRkbGVJblBpeGVscyA9IGlucHV0RGltZW5zaW9ucy5jbG9uZSgpLm11bHRpcGx5KDAuNSlcbiAgICAgICAgLmFkZChuZXdNaWRkbGVEaXN0YW5jZUZyb21DZW50ZXIpXG5cbiAgICAgIGNvbnN0IG5ld1JlbGF0aXZlTWlkZGxlID0gbmV3TWlkZGxlSW5QaXhlbHMuY2xvbmUoKS5kaXZpZGUoaW5wdXREaW1lbnNpb25zKVxuXG4gICAgICBjb25zdCBuZXdTdGFydCA9IG5ld1JlbGF0aXZlTWlkZGxlLmNsb25lKCkuc3VidHJhY3QoaGFsZlJlbGF0aXZlU2l6ZS5jbG9uZSgpLm11bHRpcGx5KGZpbmFsU2NhbGUpKVxuICAgICAgY29uc3QgbmV3RW5kID0gbmV3UmVsYXRpdmVNaWRkbGUuY2xvbmUoKS5hZGQoaGFsZlJlbGF0aXZlU2l6ZS5jbG9uZSgpLm11bHRpcGx5KGZpbmFsU2NhbGUpKVxuXG4gICAgICBpbml0aWFsVHJhbnNmb3JtT3B0aW9ucy5zdGFydCA9IG5ld1N0YXJ0XG4gICAgICBpbml0aWFsVHJhbnNmb3JtT3B0aW9ucy5lbmQgPSBuZXdFbmRcbiAgICB9XG5cbiAgICBlZGl0b3IuYnJvYWRjYXN0VHJhbnNmb3JtKHRyYW5zZm9ybU9wZXJhdGlvbiwgZGVmYXVsdE9wdGlvbnMpXG5cbiAgICBjb25zdCBpbml0aWFsT3JpZW50YXRpb25PcHRpb25zID0gb3JpZW50YXRpb25PcGVyYXRpb24uc2VyaWFsaXplT3B0aW9ucygpXG4gICAgY29uc3QgYWN0aXZlUGFkZGluZyA9IFsxMCwgMCwgNTggKyAxMCwgMF1cbiAgICBlZGl0b3Iuc2V0U3ByaXRlU2NhbGUodHJhbnNmb3JtT3BlcmF0aW9uLmNhbGN1bGF0ZVNjYWxlKCkpXG4gICAgZWRpdG9yLnNldFJvdGF0aW9uKGluaXRpYWxUcmFuc2Zvcm1PcHRpb25zLnJvdGF0aW9uKVxuICAgIGVkaXRvci5zZXRQYWRkaW5nKGFjdGl2ZVBhZGRpbmcpXG5cbiAgICAvLyBSZXNldCBzdGFydCBhbmQgZW5kIHNvIHRoYXQgU3ByaXRlT3BlcmF0aW9uIGdldHMgYW4gdXBkYXRlIGFuZCByZXBvc2l0aW9uc1xuICAgIC8vIHRoZSBzdGlja2Vyc1xuICAgIHRyYW5zZm9ybU9wZXJhdGlvbi5zZXQoZGVmYXVsdE9wdGlvbnMsIHRyYW5zZm9ybU9wZXJhdGlvbkV4aXN0ZWRCZWZvcmUpXG5cbiAgICBlZGl0b3Iuem9vbS5zZXQoJ2F1dG8nLCAoKSA9PiB7XG4gICAgICAvLyBEaXNhYmxlIHpvb20gYW5kIGRyYWcgd2hpbGUgd2UncmUgdHJhbnNmb3JtcGluZ1xuICAgICAgZWRpdG9yLmZlYXR1cmVzLmRpc2FibGUoJ3pvb20nLCAnZHJhZycpXG4gICAgfSwgZmFsc2UpXG5cbiAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHtcbiAgICAgIGluaXRpYWxUcmFuc2Zvcm1PcHRpb25zLFxuICAgICAgaW5pdGlhbE9yaWVudGF0aW9uT3B0aW9ucyxcbiAgICAgIG9wZXJhdGlvbjogdHJhbnNmb3JtT3BlcmF0aW9uLFxuICAgICAgb3JpZW50YXRpb25PcGVyYXRpb24sXG4gICAgICBhY3RpdmVQYWRkaW5nLFxuICAgICAgb3JpZW50YXRpb25PcGVyYXRpb25FeGlzdGVkQmVmb3JlLFxuICAgICAgdHJhbnNmb3JtT3BlcmF0aW9uRXhpc3RlZEJlZm9yZSxcbiAgICAgIHN0YXJ0OiBWZWN0b3IyLmZyb21PYmplY3QoaW5pdGlhbFRyYW5zZm9ybU9wdGlvbnMuc3RhcnQpLFxuICAgICAgZW5kOiBWZWN0b3IyLmZyb21PYmplY3QoaW5pdGlhbFRyYW5zZm9ybU9wdGlvbnMuZW5kKSxcbiAgICAgIHJvdGF0aW9uOiBpbml0aWFsVHJhbnNmb3JtT3B0aW9ucy5yb3RhdGlvbixcbiAgICAgIG9yaWVudGF0aW9uUm90YXRpb246IG9yaWVudGF0aW9uT3BlcmF0aW9uLmdldFJvdGF0aW9uKCksXG4gICAgICBmbGlwVmVydGljYWxseTogb3JpZW50YXRpb25PcGVyYXRpb24uZ2V0RmxpcFZlcnRpY2FsbHkoKSxcbiAgICAgIGZsaXBIb3Jpem9udGFsbHk6IG9yaWVudGF0aW9uT3BlcmF0aW9uLmdldEZsaXBIb3Jpem9udGFsbHkoKSxcbiAgICAgIGluaXRpYWxEaW1lbnNpb25zLFxuICAgICAgaW5wdXREaW1lbnNpb25zXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBjb250cm9sIGlzIGF2YWlsYWJsZSB0byB0aGUgdXNlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkVkaXRvcn0gZWRpdG9yXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBpc0F2YWlsYWJsZSAoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1Rvb2xBbGxvd2VkKCd0cmFuc2Zvcm0nKSAmJlxuICAgICAgZWRpdG9yLmlzVG9vbEVuYWJsZWQoJ3RyYW5zZm9ybScpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXNzZXRzIHRoYXQgc2hvdWxkIGJlIHByZWxvYWRlZCBmb3IgdGhpcyBjb250cm9sXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuRWRpdG9yfSBlZGl0b3JcbiAgICogQHJldHVybiB7U3RyaW5nW119XG4gICAqL1xuICBzdGF0aWMgZ2V0UHJlbG9hZEFzc2V0cyAoZWRpdG9yKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGVkaXRvci5nZXRPcHRpb25zKClcbiAgICBjb25zdCB0cmFuc2Zvcm1PcHRpb25zID0gU0RLVXRpbHMuZGVmYXVsdHMoXG4gICAgICBvcHRpb25zLmVkaXRvci5jb250cm9sc09wdGlvbnMudHJhbnNmb3JtLFxuICAgICAgdGhpcy5kZWZhdWx0T3B0aW9uc1xuICAgIClcblxuICAgIGxldCBhc3NldHMgPSBbXG4gICAgICAnY29udHJvbHMvdHJhbnNmb3JtL3JvdGF0ZS1jY3cucG5nJyxcbiAgICAgICdjb250cm9scy90cmFuc2Zvcm0vcm90YXRlLWN3LnBuZycsXG4gICAgICAnY29udHJvbHMvdHJhbnNmb3JtL2ZsaXAtaC5wbmcnLFxuICAgICAgJ2NvbnRyb2xzL3RyYW5zZm9ybS9mbGlwLXYucG5nJ1xuICAgIF1cblxuICAgIC8vIEFkZCByYXRpb3NcbiAgICBjb25zdCByYXRpb3MgPSBUcmFuc2Zvcm1Db250cm9sc0NvbXBvbmVudC5nZXRSYXRpb3ModHJhbnNmb3JtT3B0aW9ucylcbiAgICByYXRpb3MuZm9yRWFjaCgoaXRlbU9yR3JvdXApID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1Pckdyb3VwKSkge1xuICAgICAgICBpdGVtT3JHcm91cC5mb3JFYWNoKCh7aWRlbnRpZmllcn0pID0+IHtcbiAgICAgICAgICBhc3NldHMucHVzaChgY29udHJvbHMvdHJhbnNmb3JtLyR7aWRlbnRpZmllcn0ucG5nYClcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2V0cy5wdXNoKGBjb250cm9scy90cmFuc2Zvcm0vJHtpdGVtT3JHcm91cC5pZGVudGlmaWVyfS5wbmdgKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gYXNzZXRzXG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyB0b3AgYmFyIGNvbXBvbmVudC4gVXNlZCBmb3IgdGhlIHVwcGVyIHBhcnQgb2YgdGhlIGVkaXRvci5cbiAqIEB0eXBlIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLlRvcEJhckNvbnRyb2xzQ29tcG9uZW50fVxuICovXG5UcmFuc2Zvcm1Db250cm9scy50b3BCYXJDb250cm9sc0NvbXBvbmVudCA9IFRyYW5zZm9ybVRvcEJhckNvbXBvbmVudFxuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIGNvbnRyb2xzIGNvbXBvbmVudC4gVXNlZCBmb3IgdGhlIGxvd2VyIGNvbnRyb2xzIHBhcnQgb2YgdGhlIGVkaXRvci5cbiAqIEB0eXBlIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xzQ29tcG9uZW50fVxuICogQGlnbm9yZVxuICovXG5UcmFuc2Zvcm1Db250cm9scy5jb250cm9sc0NvbXBvbmVudCA9IFRyYW5zZm9ybUNvbnRyb2xzQ29tcG9uZW50XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgY2FudmFzIGNvbXBvbmVudC4gVXNlZCBmb3IgdGhlIHVwcGVyIGNvbnRyb2xzIHBhcnQgb2YgdGhlIGVkaXRvciAob25cbiAqIHRvcCBvZiB0aGUgY2FudmFzKVxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNDb21wb25lbnR9XG4gKiBAaWdub3JlXG4gKi9cblRyYW5zZm9ybUNvbnRyb2xzLmNhbnZhc0NvbnRyb2xzQ29tcG9uZW50ID0gVHJhbnNmb3JtQ2FudmFzQ29udHJvbHNDb21wb25lbnRcblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuVHJhbnNmb3JtQ29udHJvbHMuaWRlbnRpZmllciA9ICd0cmFuc2Zvcm0nXG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgaWNvbiBwYXRoXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGlnbm9yZVxuICovXG5UcmFuc2Zvcm1Db250cm9scy5pY29uUGF0aCA9ICdjb250cm9scy9vdmVydmlldy90cmFuc2Zvcm0ucG5nJ1xuXG4vKipcbiAqIFRoZSBsYW5ndWFnZSBrZXkgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhpcyBmaWx0ZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAaWdub3JlXG4gKi9cblRyYW5zZm9ybUNvbnRyb2xzLmxhbmd1YWdlS2V5ID0gJ3Blc2RrLnRyYW5zZm9ybS50aXRsZS5uYW1lJ1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoaXMgY29udHJvbFxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0W119IFtyYXRpb3MgPSBbXV1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JlcGxhY2VSYXRpb3MgPSBmYWxzZV1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IFthdmFpbGFibGVSYXRpb3MgPSBudWxsXVxuICovXG5UcmFuc2Zvcm1Db250cm9scy5kZWZhdWx0T3B0aW9ucyA9IHtcblxufVxuXG4vKipcbiAqIFRoZSBvcGVyYXRpb25zIHJlcXVpcmVkIGZvciB0aGlzIGNvbnRyb2wgdG8gd29yayBwcm9wZXJseVxuICogQHR5cGUge0FycmF5fVxuICovXG5UcmFuc2Zvcm1Db250cm9scy5yZXF1aXJlZE9wZXJhdGlvbnMgPSBbJ3RyYW5zZm9ybSddXG5cbmV4cG9ydCBkZWZhdWx0IFRyYW5zZm9ybUNvbnRyb2xzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL3RyYW5zZm9ybS9pbmRleC5qcyIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IENvbnN0YW50cywgU0RLVXRpbHMsIFJlYWN0QkVNLCBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBDb250cm9sc0NvbXBvbmVudCBmcm9tICcuLi9jb250cm9scy1jb21wb25lbnQnXG5pbXBvcnQgU2Nyb2xsYmFyQ29tcG9uZW50IGZyb20gJy4uLy4uL3Njcm9sbGJhci1jb21wb25lbnQnXG5pbXBvcnQgU2xpZGVyT3ZlcmxheUNvbXBvbmVudCBmcm9tICcuLi9zbGlkZXItb3ZlcmxheS1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zZm9ybUNvbnRyb2xzQ29tcG9uZW50IGV4dGVuZHMgQ29udHJvbHNDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19zZWxlY3RSYXRpbycsXG4gICAgICAnX29uUm90YXRpb25DaGFuZ2UnLFxuICAgICAgJ19yZWFwcGx5UmF0aW8nXG4gICAgKVxuXG4gICAgdGhpcy5zdGF0ZSA9IHsgcmF0aW86IG51bGwgfVxuICAgIHRoaXMuX3JhdGlvcyA9IHRoaXMuY29uc3RydWN0b3IuZ2V0UmF0aW9zKHRoaXMucHJvcHMub3B0aW9ucylcblxuICAgIHRoaXMuX2V2ZW50cyA9IHtcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLlRSQU5TRk9STV9SRUFQUExZX1JBVElPXTogdGhpcy5fcmVhcHBseVJhdGlvXG4gICAgfVxuXG4gICAgdGhpcy5fc2VsZWN0SW5pdGlhbFJhdGlvKCF0aGlzLmdldFNoYXJlZFN0YXRlKCd0cmFuc2Zvcm1PcGVyYXRpb25FeGlzdGVkQmVmb3JlJykpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBJTklUSUFMSVpBVElPTlxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgYXZhaWxhYmxlIHJhdGlvc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAgICovXG4gIHN0YXRpYyBnZXRSYXRpb3MgKG9wdGlvbnMpIHtcbiAgICBsZXQgeyByYXRpb3MsIHJlcGxhY2VSYXRpb3MsIGF2YWlsYWJsZVJhdGlvcyB9ID0gb3B0aW9uc1xuICAgIHJhdGlvcyA9IHJhdGlvcyB8fCBbXVxuXG4gICAgbGV0IHNlbGVjdGFibGVSYXRpb3NcbiAgICBzZWxlY3RhYmxlUmF0aW9zID0gQ29uc3RhbnRzLkRFRkFVTFRTLlRSQU5TRk9STV9SQVRJT1NcbiAgICBpZiAocmVwbGFjZVJhdGlvcykge1xuICAgICAgc2VsZWN0YWJsZVJhdGlvcyA9IHJhdGlvc1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RhYmxlUmF0aW9zID0gc2VsZWN0YWJsZVJhdGlvcy5jb25jYXQocmF0aW9zKVxuICAgIH1cblxuICAgIGlmIChhdmFpbGFibGVSYXRpb3MgJiYgYXZhaWxhYmxlUmF0aW9zLmxlbmd0aCkge1xuICAgICAgbGV0IHBpY2tSYXRpb3MgPSAoaXRlbSkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgIHJldHVybiBpdGVtLm1hcChwaWNrUmF0aW9zKVxuICAgICAgICAgICAgLmZpbHRlcihyID0+IHIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGF2YWlsYWJsZVJhdGlvcy5pbmRleE9mKGl0ZW0uaWRlbnRpZmllcikgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2VsZWN0YWJsZVJhdGlvcyA9IHNlbGVjdGFibGVSYXRpb3MubWFwKHBpY2tSYXRpb3MpLmZpbHRlcihyID0+IHIpXG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGVjdGFibGVSYXRpb3NcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIExJRkVDWUNMRVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgY2hhbmdlIGZyb20gdGhlIGdpdmVuIHN0YXRlXG4gICAqIEBwYXJhbSAge09iamVjdH0gb2xkU3RhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBuZXdTdGF0ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc2hvdWxkU2hhcmVkQ29tcG9uZW50VXBkYXRlIChvbGRTdGF0ZSwgbmV3U3RhdGUpIHtcbiAgICByZXR1cm4gb2xkU3RhdGUucmF0aW8gIT09IG5ld1N0YXRlLnJhdGlvXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgcm90YXRpb24gaGFzIGJlZW4gY2hhZ25lZCAoYnkgdXNpbmcgdGhlIHNsaWRlcilcbiAgICogQHBhcmFtICB7TnVtYmVyfSByb3RhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uUm90YXRpb25DaGFuZ2UgKHJvdGF0aW9uKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtT3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgcm90YXRpb24gPSByb3RhdGlvbiAqIE1hdGguUEkgLyAxODBcbiAgICBlZGl0b3Iuc2V0Um90YXRpb24ocm90YXRpb24pXG4gICAgZWRpdG9yLnNldFNwcml0ZVNjYWxlKHRyYW5zZm9ybU9wZXJhdGlvbi5jYWxjdWxhdGVTY2FsZShyb3RhdGlvbikpXG5cbiAgICBlZGl0b3IucmVuZGVyKClcbiAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHsgcm90YXRpb24gfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBvdXRlciBib3VuZGluZyBkaW1lbnNpb25zIG9mIHRoZSByb3RhdGVkIHNwcml0ZVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0Um90YXRlZFNwcml0ZURpbWVuc2lvbnMgKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCByb3RhdGlvbiA9IGVkaXRvci5nZXRSb3RhdGlvbigpXG5cbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoZmFsc2UpXG5cbiAgICByZXR1cm4gbmV3IFZlY3RvcjIoXG4gICAgICBNYXRoLmFicyhvdXRwdXREaW1lbnNpb25zLnggKiBNYXRoLmNvcyhyb3RhdGlvbikpICsgTWF0aC5hYnMob3V0cHV0RGltZW5zaW9ucy55ICogTWF0aC5zaW4ocm90YXRpb24pKSxcbiAgICAgIE1hdGguYWJzKG91dHB1dERpbWVuc2lvbnMueCAqIE1hdGguc2luKHJvdGF0aW9uKSkgKyBNYXRoLmFicyhvdXRwdXREaW1lbnNpb25zLnkgKiBNYXRoLmNvcyhyb3RhdGlvbikpXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIHRleHR1cmUgc2NhbGUgdXNpbmcgdGhlIGN1cnJlbnQgc2V0dGluZ3NcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NhbGN1bGF0ZVRleHR1cmVTY2FsZSAoKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtT3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICBjb25zdCByYXRpbyA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3JhdGlvJylcbiAgICBpZiAoIXJhdGlvIHx8ICFyYXRpby5kaW1lbnNpb25zKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc3RhcnQnKVxuICAgIGNvbnN0IGVuZCA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2VuZCcpXG5cbiAgICBjb25zdCBzaXplID0gZW5kLmNsb25lKCkuc3VidHJhY3Qoc3RhcnQpXG4gICAgY29uc3QgdHJhbnNmb3JtRGltZW5zaW9ucyA9IHRyYW5zZm9ybU9wZXJhdGlvbi5nZXRJbnB1dERpbWVuc2lvbnMoZmFsc2UpXG4gICAgICAubXVsdGlwbHkoc2l6ZSlcbiAgICByZXR1cm4gcmF0aW8uZGltZW5zaW9ucy54IC8gdHJhbnNmb3JtRGltZW5zaW9ucy54XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgdGhlIGhpc3RvcnkgaXRlbXMgZm9yIGFsbCBvcGVyYXRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0SGlzdG9yeUl0ZW1zICgpIHtcbiAgICBjb25zdCBoaXN0b3J5SXRlbXMgPSBbXVxuXG4gICAgY29uc3QgdHJhbnNmb3JtSGlzdG9yeUl0ZW0gPSB0aGlzLl9nZXRUcmFuc2Zvcm1IaXN0b3J5SXRlbSgpXG4gICAgaWYgKHRyYW5zZm9ybUhpc3RvcnlJdGVtKSB7XG4gICAgICBoaXN0b3J5SXRlbXMucHVzaCh0cmFuc2Zvcm1IaXN0b3J5SXRlbSlcbiAgICB9XG5cbiAgICBjb25zdCBvcmllbnRhdGlvbkhpc3RvcnlJdGVtID0gdGhpcy5fZ2V0T3JpZW50YXRpb25IaXN0b3J5SXRlbSgpXG4gICAgaWYgKG9yaWVudGF0aW9uSGlzdG9yeUl0ZW0pIHtcbiAgICAgIGhpc3RvcnlJdGVtcy5wdXNoKG9yaWVudGF0aW9uSGlzdG9yeUl0ZW0pXG4gICAgfVxuXG4gICAgcmV0dXJuIGhpc3RvcnlJdGVtc1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhpc3RvcnkgaXRlbSBmb3IgdGhlIHRyYW5zZm9ybSBvcGVyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRUcmFuc2Zvcm1IaXN0b3J5SXRlbSAoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IHRyYW5zZm9ybU9wZXJhdGlvbiA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpXG4gICAgY29uc3QgaW5pdGlhbFRyYW5zZm9ybU9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdpbml0aWFsVHJhbnNmb3JtT3B0aW9ucycpXG4gICAgY29uc3QgdHJhbnNmb3JtT3BlcmF0aW9uRXhpc3RlZEJlZm9yZSA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3RyYW5zZm9ybU9wZXJhdGlvbkV4aXN0ZWRCZWZvcmUnKVxuICAgIGlmICghdHJhbnNmb3JtT3BlcmF0aW9uLm9wdGlvbnNFcXVhbChpbml0aWFsVHJhbnNmb3JtT3B0aW9ucykpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9wZXJhdGlvbjogdHJhbnNmb3JtT3BlcmF0aW9uLFxuICAgICAgICBvcHRpb25zOiBpbml0aWFsVHJhbnNmb3JtT3B0aW9ucyxcbiAgICAgICAgZXhpc3RlbnQ6IHRyYW5zZm9ybU9wZXJhdGlvbkV4aXN0ZWRCZWZvcmUsXG4gICAgICAgIHVuZG86IChvcGVyYXRpb24sIG5ld09wdGlvbnMpID0+IHtcbiAgICAgICAgICBlZGl0b3IuYnJvYWRjYXN0VHJhbnNmb3JtKG9wZXJhdGlvbiwgbmV3T3B0aW9ucylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoaXN0b3J5IGl0ZW0gZm9yIHRoZSBvcmllbnRhdGlvbiBvcGVyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRPcmllbnRhdGlvbkhpc3RvcnlJdGVtICgpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgb3JpZW50YXRpb25PcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcmllbnRhdGlvbk9wZXJhdGlvbicpXG4gICAgY29uc3QgaW5pdGlhbE9yaWVudGF0aW9uT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2luaXRpYWxPcmllbnRhdGlvbk9wdGlvbnMnKVxuICAgIGNvbnN0IG9yaWVudGF0aW9uT3BlcmF0aW9uRXhpc3RlZEJlZm9yZSA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29yaWVudGF0aW9uT3BlcmF0aW9uRXhpc3RlZEJlZm9yZScpXG4gICAgaWYgKCFvcmllbnRhdGlvbk9wZXJhdGlvbi5vcHRpb25zRXF1YWwoaW5pdGlhbE9yaWVudGF0aW9uT3B0aW9ucykpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9wZXJhdGlvbjogb3JpZW50YXRpb25PcGVyYXRpb24sXG4gICAgICAgIG9wdGlvbnM6IGluaXRpYWxPcmllbnRhdGlvbk9wdGlvbnMsXG4gICAgICAgIGV4aXN0ZW50OiBvcmllbnRhdGlvbk9wZXJhdGlvbkV4aXN0ZWRCZWZvcmUsXG4gICAgICAgIHVuZG86IChvcGVyYXRpb24sIG5ld09wdGlvbnMpID0+IHtcbiAgICAgICAgICBpZiAob3BlcmF0aW9uLmdldFJvdGF0aW9uKCkgIT09IG5ld09wdGlvbnMucm90YXRpb24pIHtcbiAgICAgICAgICAgIGVkaXRvci5icm9hZGNhc3RSb3RhdGUobmV3T3B0aW9ucy5yb3RhdGlvbiAtIG9wZXJhdGlvbi5nZXRSb3RhdGlvbigpKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJvdGF0aW9uID0gbmV3T3B0aW9ucy5yb3RhdGlvblxuICAgICAgICAgIGNvbnN0IGludmVyc2VGbGlwID0gcm90YXRpb24gPT09IDkwIHx8IHJvdGF0aW9uID09PSAyNzBcbiAgICAgICAgICBpZiAob3BlcmF0aW9uLmdldEZsaXBWZXJ0aWNhbGx5KCkgIT09IG5ld09wdGlvbnMuZmxpcFZlcnRpY2FsbHkpIHtcbiAgICAgICAgICAgIGVkaXRvci5icm9hZGNhc3RGbGlwKGludmVyc2VGbGlwID8gJ2hvcml6b250YWwnIDogJ3ZlcnRpY2FsJylcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5nZXRGbGlwSG9yaXpvbnRhbGx5KCkgIT09IG5ld09wdGlvbnMuZmxpcEhvcml6b250YWxseSkge1xuICAgICAgICAgICAgZWRpdG9yLmJyb2FkY2FzdEZsaXAoaW52ZXJzZUZsaXAgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZS1hcHBsaWVzIHRoZSBjdXJyZW50IHJhdGlvXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVhcHBseVJhdGlvICgpIHtcbiAgICBjb25zdCByYXRpbyA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3JhdGlvJylcbiAgICB0aGlzLl9zZWxlY3RSYXRpbyhyYXRpbylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYmFjayBidXR0b25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQmFja0NsaWNrIChlKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuXG4gICAgY29uc3QgcmF0aW8gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdyYXRpbycpXG4gICAgY29uc3QgdHJhbnNmb3JtT3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICBjb25zdCBvcmllbnRhdGlvbk9wZXJhdGlvbiA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29yaWVudGF0aW9uT3BlcmF0aW9uJylcblxuICAgIGNvbnN0IHJvdGF0aW9uID0gZWRpdG9yLmdldFJvdGF0aW9uKClcbiAgICBsZXQgc3RhcnQgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdzdGFydCcpLmNsb25lKClcbiAgICBsZXQgZW5kID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnZW5kJykuY2xvbmUoKVxuICAgIGlmICgocmF0aW8gPT09IG51bGwgfHwgKHN0YXJ0LmVxdWFscygwLCAwKSAmJiBlbmQuZXF1YWxzKDEsIDEpKSkgJiYgcm90YXRpb24gPT09IDApIHtcbiAgICAgIGVkaXRvci5vcGVyYXRpb25zLnJlbW92ZSh0cmFuc2Zvcm1PcGVyYXRpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhbGN1bGF0ZSB0ZXh0dXJlIHNjYWxlXG4gICAgICBsZXQgdGV4dHVyZVNjYWxlID0gdGhpcy5fY2FsY3VsYXRlVGV4dHVyZVNjYWxlKClcblxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmQsXG4gICAgICAgIHRleHR1cmVTY2FsZSxcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBmaW5hbFNjYWxlID0gdHJhbnNmb3JtT3BlcmF0aW9uLmNhbGN1bGF0ZVNjYWxlKHJvdGF0aW9uKVxuICAgICAgY29uc3QgaW5wdXREaW1lbnNpb25zID0gdHJhbnNmb3JtT3BlcmF0aW9uLmdldElucHV0RGltZW5zaW9ucyhmYWxzZSlcbiAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKC1yb3RhdGlvbilcbiAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKC1yb3RhdGlvbilcblxuICAgICAgY29uc3QgaGFsZlJlbGF0aXZlU2l6ZSA9IGVuZC5jbG9uZSgpLnN1YnRyYWN0KHN0YXJ0KS5kaXZpZGUoMilcbiAgICAgIGNvbnN0IG1pZGRsZUluUGl4ZWxzID0gc3RhcnQuY2xvbmUoKVxuICAgICAgICAuYWRkKGhhbGZSZWxhdGl2ZVNpemUpXG4gICAgICAgIC5tdWx0aXBseShpbnB1dERpbWVuc2lvbnMpXG5cbiAgICAgIGNvbnN0IG1pZGRsZURpc3RhbmNlRnJvbUNlbnRlciA9IG1pZGRsZUluUGl4ZWxzXG4gICAgICAgIC5zdWJ0cmFjdChpbnB1dERpbWVuc2lvbnMuY2xvbmUoKS5tdWx0aXBseSgwLjUpKVxuXG4gICAgICAvLyBSb3RhdGUgYW5kIHNjYWxlIHRoZSBtaWRkbGUgYmFja1xuICAgICAgY29uc3QgbmV3TWlkZGxlRGlzdGFuY2VGcm9tQ2VudGVyID0gbmV3IFZlY3RvcjIoXG4gICAgICAgIG1pZGRsZURpc3RhbmNlRnJvbUNlbnRlci54ICogY29zIC0gbWlkZGxlRGlzdGFuY2VGcm9tQ2VudGVyLnkgKiBzaW4sXG4gICAgICAgIG1pZGRsZURpc3RhbmNlRnJvbUNlbnRlci54ICogc2luICsgbWlkZGxlRGlzdGFuY2VGcm9tQ2VudGVyLnkgKiBjb3NcbiAgICAgICkuZGl2aWRlKGZpbmFsU2NhbGUpXG5cbiAgICAgIGNvbnN0IG5ld01pZGRsZUluUGl4ZWxzID0gaW5wdXREaW1lbnNpb25zLmNsb25lKCkubXVsdGlwbHkoMC41KVxuICAgICAgICAuYWRkKG5ld01pZGRsZURpc3RhbmNlRnJvbUNlbnRlcilcblxuICAgICAgY29uc3QgbmV3UmVsYXRpdmVNaWRkbGUgPSBuZXdNaWRkbGVJblBpeGVscy5jbG9uZSgpLmRpdmlkZShpbnB1dERpbWVuc2lvbnMpXG5cbiAgICAgIG9wdGlvbnMuc3RhcnQgPSBuZXdSZWxhdGl2ZU1pZGRsZS5jbG9uZSgpLnN1YnRyYWN0KGhhbGZSZWxhdGl2ZVNpemUuY2xvbmUoKS5kaXZpZGUoZmluYWxTY2FsZSkpXG4gICAgICBvcHRpb25zLmVuZCA9IG5ld1JlbGF0aXZlTWlkZGxlLmNsb25lKCkuYWRkKGhhbGZSZWxhdGl2ZVNpemUuY2xvbmUoKS5kaXZpZGUoZmluYWxTY2FsZSkpXG5cbiAgICAgIGVkaXRvci5icm9hZGNhc3RUcmFuc2Zvcm0odHJhbnNmb3JtT3BlcmF0aW9uLCBvcHRpb25zKVxuICAgICAgdHJhbnNmb3JtT3BlcmF0aW9uLnNldChvcHRpb25zKVxuICAgIH1cblxuICAgIGlmIChvcmllbnRhdGlvbk9wZXJhdGlvbi5nZXRSb3RhdGlvbigpID09PSAwICYmXG4gICAgICAgICFvcmllbnRhdGlvbk9wZXJhdGlvbi5nZXRGbGlwVmVydGljYWxseSgpICYmXG4gICAgICAgICFvcmllbnRhdGlvbk9wZXJhdGlvbi5nZXRGbGlwSG9yaXpvbnRhbGx5KCkpIHtcbiAgICAgIGVkaXRvci5vcGVyYXRpb25zLnJlbW92ZShvcmllbnRhdGlvbk9wZXJhdGlvbilcbiAgICB9XG5cbiAgICAvLyBSZXNldCBlZGl0b3IgdHJhbnNmb3Jtc1xuICAgIGVkaXRvci5zZXRQYWRkaW5nKGZhbHNlKVxuICAgIGVkaXRvci5zZXRSb3RhdGlvbigwKVxuICAgIGVkaXRvci5zZXRTcHJpdGVTY2FsZSgxKVxuXG4gICAgLy8gSGFuZGxlIGhpc3RvcnlcbiAgICBjb25zdCBoaXN0b3J5SXRlbXMgPSB0aGlzLl9nZXRIaXN0b3J5SXRlbXMoKVxuICAgIGlmIChoaXN0b3J5SXRlbXMubGVuZ3RoKSB7XG4gICAgICBsZXQgeyBmb3JjZUNyb3AsIGZpcnN0Q3JvcCB9ID0gdGhpcy5wcm9wcy5vcHRpb25zXG5cbiAgICAgIGlmICghZm9yY2VDcm9wICYmICFmaXJzdENyb3ApIHtcbiAgICAgICAgZWRpdG9yLmhpc3RvcnkuYWRkKGhpc3RvcnlJdGVtcylcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbmFibGUgem9vbSBhbmQgZHJhZyBhZ2FpbiwgcmVzZXQgem9vbVxuICAgIGVkaXRvci5mZWF0dXJlcy5lbmFibGUoJ3pvb20nLCAnZHJhZycpXG4gICAgZWRpdG9yLnpvb20uc2V0KCdhdXRvJylcblxuICAgIHN1cGVyLl9vbkJhY2tDbGljayhlKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkFUSU8gSEFORExJTkdcblxuICAvKipcbiAgICogU2VsZWN0cyB0aGUgaW5pdGlhbCByYXRpb1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNldERlZmF1bHRPcHRpb25zID0gdHJ1ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlbGVjdEluaXRpYWxSYXRpbyAoc2V0RGVmYXVsdE9wdGlvbnMgPSB0cnVlKSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICBsZXQgc2VsZWN0ZWRSYXRpbyA9IG51bGxcbiAgICBjb25zdCByYXRpb3MgPSBTREtVdGlscy5BcnJheS5mbGF0dGVuKHRoaXMuX3JhdGlvcylcblxuICAgIC8vIDEuIFNlbGVjdGVkIHJhdGlvIHN0b3JlZCBpbiBvcGVyYXRpb25cbiAgICBjb25zdCBvcGVyYXRpb25SYXRpbyA9IG9wZXJhdGlvbi5fcmF0aW9cbiAgICBpZiAob3BlcmF0aW9uUmF0aW8pIHtcbiAgICAgIGNvbnN0IG1hdGNoaW5nUmF0aW9zID0gcmF0aW9zLmZpbHRlcigocmF0aW8pID0+IHJhdGlvID09PSBvcGVyYXRpb25SYXRpbylcbiAgICAgIHNlbGVjdGVkUmF0aW8gPSBtYXRjaGluZ1JhdGlvc1swXVxuICAgIH1cblxuICAgIC8vIDIuIEZpcnN0IHJhdGlvIHdpdGggYHNlbGVjdGVkYCBmbGFnXG4gICAgaWYgKCFzZWxlY3RlZFJhdGlvKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZFJhdGlvcyA9IHJhdGlvcy5maWx0ZXIoKHJhdGlvKSA9PiByYXRpby5zZWxlY3RlZClcbiAgICAgIHNlbGVjdGVkUmF0aW8gPSBzZWxlY3RlZFJhdGlvcy5wb3AoKVxuICAgIH1cblxuICAgIC8vIDMuIEZpcnN0IHJhdGlvXG4gICAgaWYgKCFzZWxlY3RlZFJhdGlvKSB7XG4gICAgICBzZWxlY3RlZFJhdGlvID0gcmF0aW9zWzBdXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdFJhdGlvKHNlbGVjdGVkUmF0aW8sIHNldERlZmF1bHRPcHRpb25zLCBmYWxzZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3RzIHRoZSBnaXZlbiByYXRpb1xuICAgKiBAcGFyYW0ge1N0cmluZ30gcmF0aW9cbiAgICogQHBhcmFtIHtCb29sZWFufSBzZXREZWZhdWx0T3B0aW9ucyA9IHRydWVcbiAgICogQHBhcmFtIHtCb29sZWFufSB1cGRhdGUgPSB0cnVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VsZWN0UmF0aW8gKHJhdGlvLCBzZXREZWZhdWx0T3B0aW9ucyA9IHRydWUsIHVwZGF0ZSA9IHRydWUpIHtcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxuICAgIGlmIChzZXREZWZhdWx0T3B0aW9ucyAmJiByYXRpbykge1xuICAgICAgdGhpcy5fc2V0RGVmYXVsdE9wdGlvbnNGb3JSYXRpbyhyYXRpbywgdXBkYXRlKVxuICAgIH1cbiAgICBvcGVyYXRpb24uX3JhdGlvID0gcmF0aW9cblxuICAgIGNvbnN0IG5ld1NoYXJlZFN0YXRlID0ge1xuICAgICAgcmF0aW9cbiAgICB9XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGlmICghcmF0aW8pIHtcbiAgICAgIGVkaXRvci5zZXRQYWRkaW5nKGZhbHNlKVxuICAgICAgZWRpdG9yLnNldFJvdGF0aW9uKDApXG4gICAgICBlZGl0b3Iuc2V0U3ByaXRlU2NhbGUoMSlcblxuICAgICAgbmV3U2hhcmVkU3RhdGUucm90YXRpb24gPSAwXG4gICAgICBuZXdTaGFyZWRTdGF0ZS5zdGFydCA9IG5ldyBWZWN0b3IyKDAsIDApXG4gICAgICBuZXdTaGFyZWRTdGF0ZS5lbmQgPSBuZXcgVmVjdG9yMigxLCAxKVxuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0b3Iuc2V0UGFkZGluZyh0aGlzLmdldFNoYXJlZFN0YXRlKCdhY3RpdmVQYWRkaW5nJykpXG4gICAgfVxuICAgIGVkaXRvci5yZW5kZXIoKVxuICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUobmV3U2hhcmVkU3RhdGUsIHVwZGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZWZhdWx0IG9wdGlvbnMgKHN0YXJ0IC8gZW5kKSBmb3IgdGhlIGdpdmVuIHJhdGlvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByYXRpb1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVwZGF0ZSA9IGZhbHNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0RGVmYXVsdE9wdGlvbnNGb3JSYXRpbyAoeyByYXRpbywgbmFtZSwgZGltZW5zaW9ucyB9LCB1cGRhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBsZXQgc3RhcnQgPSBuZXcgVmVjdG9yMigpXG4gICAgbGV0IGVuZCA9IG5ldyBWZWN0b3IyKClcblxuICAgIGlmIChkaW1lbnNpb25zICYmICFyYXRpbykge1xuICAgICAgcmF0aW8gPSBkaW1lbnNpb25zLnggLyBkaW1lbnNpb25zLnlcbiAgICB9XG5cbiAgICBpZiAocmF0aW8gPT09ICcqJykge1xuICAgICAgc3RhcnQgPSBuZXcgVmVjdG9yMigwLCAwKVxuICAgICAgZW5kID0gbmV3IFZlY3RvcjIoMSwgMSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3V0cHV0RGltZW5zaW9ucyA9IGVkaXRvci5nZXRPdXRwdXREaW1lbnNpb25zKClcbiAgICAgIGNvbnN0IGNhbnZhc1JhdGlvID0gb3V0cHV0RGltZW5zaW9ucy54IC8gb3V0cHV0RGltZW5zaW9ucy55XG4gICAgICBpZiAoY2FudmFzUmF0aW8gPD0gcmF0aW8pIHtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gMSAvIG91dHB1dERpbWVuc2lvbnMueSAqIChvdXRwdXREaW1lbnNpb25zLnggLyByYXRpbylcbiAgICAgICAgc3RhcnQuc2V0KDAsICgxLjAgLSBoZWlnaHQpIC8gMilcbiAgICAgICAgZW5kLnNldCgxLjAsIDEgLSBzdGFydC55KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSAxIC8gb3V0cHV0RGltZW5zaW9ucy54ICogKHJhdGlvICogb3V0cHV0RGltZW5zaW9ucy55KVxuICAgICAgICBzdGFydC5zZXQoKDEgLSB3aWR0aCkgLyAyLCAwKVxuICAgICAgICBlbmQuc2V0KDEgLSBzdGFydC54LCAxLjApXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7IHN0YXJ0LCBlbmQgfSwgdXBkYXRlKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG92ZXJsYXkgY29udHJvbHMgb2YgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlck92ZXJsYXlDb250cm9scyAoKSB7XG4gICAgY29uc3Qgcm90YXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdyb3RhdGlvbicpICogMTgwIC8gTWF0aC5QSVxuICAgIGlmICghdGhpcy5nZXRTaGFyZWRTdGF0ZSgncmF0aW8nKSkgcmV0dXJuIG51bGxcbiAgICByZXR1cm4gKDxTbGlkZXJPdmVybGF5Q29tcG9uZW50XG4gICAgICB2YWx1ZT17cm90YXRpb259XG4gICAgICBtaW5WYWx1ZT17LTQ1fVxuICAgICAgbWlkZGxlRG90XG4gICAgICBtYXhWYWx1ZT17NDV9XG4gICAgICB2YWx1ZVVuaXQ9J8KwJ1xuICAgICAgbGFiZWw9e3RoaXMuX3QoJ3Blc2RrLnRyYW5zZm9ybS50ZXh0LnJvdGF0aW9uJyl9XG4gICAgICBvbkNoYW5nZT17dGhpcy5fb25Sb3RhdGlvbkNoYW5nZX0gLz4pXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgbGlzdCBpdGVtcyBmb3IgdGhpcyBjb250cm9sc1xuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50W119XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyTGlzdEl0ZW1zICgpIHtcbiAgICBsZXQgaXRlbXMgPSBbXVxuICAgIGNvbnN0IG1ha2VJdGVtID0gKHJhdGlvKSA9PiB7XG4gICAgICByZXR1cm4gKDxsaVxuICAgICAgICBiZW09J2U6aXRlbSdcbiAgICAgICAga2V5PXtyYXRpby5pZGVudGlmaWVyfVxuICAgICAgICBkYXRhLWlkZW50aWZpZXI9e3JhdGlvLmlkZW50aWZpZXJ9PlxuICAgICAgICA8YmVtIHNwZWNpZmllcj0nJGI6Y29udHJvbHMnPlxuICAgICAgICAgIDxkaXYgYmVtPSckZTpidXR0b24gbTp3aXRoTGFiZWwnXG4gICAgICAgICAgICBjbGFzc05hbWU9e3RoaXMuZ2V0U2hhcmVkU3RhdGUoJ3JhdGlvJykgPT09IHJhdGlvID8gJ2lzLWFjdGl2ZScgOiBudWxsfVxuICAgICAgICAgICAgb25DbGljaz17dGhpcy5fc2VsZWN0UmF0aW8uYmluZCh0aGlzLCByYXRpbyl9PlxuICAgICAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXt0aGlzLl9nZXRBc3NldFBhdGgoYGNvbnRyb2xzL3RyYW5zZm9ybS8ke3JhdGlvLmlkZW50aWZpZXJ9LnBuZ2AsIHRydWUpfSAvPlxuICAgICAgICAgICAgPGRpdiBiZW09J2U6bGFiZWwnPnt0aGlzLl90KGBwZXNkay50cmFuc2Zvcm0uYXNzZXQuJHtyYXRpby5pZGVudGlmaWVyfWApIHx8IHJhdGlvLmRlZmF1bHROYW1lfTwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2JlbT5cbiAgICAgIDwvbGk+KVxuICAgIH1cblxuICAgIHRoaXMuX3JhdGlvcy5mb3JFYWNoKChncm91cE9yUmF0aW8pID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGdyb3VwT3JSYXRpbykpIHtcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBncm91cE9yUmF0aW9cblxuICAgICAgICBsZXQgZ3JvdXBJdGVtcyA9IFtdXG4gICAgICAgIGdyb3VwLmZvckVhY2goKHJhdGlvKSA9PiB7XG4gICAgICAgICAgZ3JvdXBJdGVtcy5wdXNoKG1ha2VJdGVtKHJhdGlvKSlcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoZ3JvdXBJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGdyb3VwSXRlbXMpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJhdGlvID0gZ3JvdXBPclJhdGlvXG4gICAgICAgIGl0ZW1zLnB1c2gobWFrZUl0ZW0ocmF0aW8pKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBsZXQgZmluYWxJdGVtcyA9IFtdXG4gICAgaXRlbXMuZm9yRWFjaCgoaXRlbU9yR3JvdXApID0+IHtcbiAgICAgIGZpbmFsSXRlbXMgPSBmaW5hbEl0ZW1zLmNvbmNhdChpdGVtT3JHcm91cClcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1Pckdyb3VwKSAmJiBpdGVtT3JHcm91cCAhPT0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgZmluYWxJdGVtcy5wdXNoKDxsaSBiZW09J2U6c2VwYXJhdG9yJyAvPilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3Qgbm9UcmFuc2Zvcm1JdGVtID0gKDxsaVxuICAgICAgYmVtPSdlOml0ZW0nXG4gICAgICBkYXRhLWlkZW50aWZpZXI9J25vbmUnXG4gICAgICBrZXk9J25vVHJhbnNmb3JtJz5cbiAgICAgIDxiZW0gc3BlY2lmaWVyPSckYjpjb250cm9scyc+XG4gICAgICAgIDxkaXYgYmVtPSckZTpidXR0b24gbTp3aXRoTGFiZWwnXG4gICAgICAgICAgY2xhc3NOYW1lPXshdGhpcy5nZXRTaGFyZWRTdGF0ZSgncmF0aW8nKSA/ICdpcy1hY3RpdmUnIDogbnVsbH1cbiAgICAgICAgICBvbkNsaWNrPXt0aGlzLl9zZWxlY3RSYXRpby5iaW5kKHRoaXMsIG51bGwpfT5cbiAgICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aChgY29udHJvbHMvdHJhbnNmb3JtL25vLXRyYW5zZm9ybS5wbmdgLCB0cnVlKX0gLz5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTpsYWJlbCc+e3RoaXMuX3QoYHBlc2RrLnRyYW5zZm9ybS5idXR0b24ubm9uZWApfTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvYmVtPlxuICAgIDwvbGk+KVxuXG4gICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzLmNvbnRleHRcblxuICAgIHJldHVybiBvcHRpb25zLmVkaXRvci5mb3JjZUNyb3BcbiAgICAgID8gZmluYWxJdGVtc1xuICAgICAgOiBbbm9UcmFuc2Zvcm1JdGVtLCA8bGkgYmVtPSdlOnNlcGFyYXRvcicgLz5dLmNvbmNhdChmaW5hbEl0ZW1zKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGNvbnRyb2xzIG9mIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJDb250cm9scyAoKSB7XG4gICAgY29uc3QgbGlzdEl0ZW1zID0gdGhpcy5fcmVuZGVyTGlzdEl0ZW1zKClcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGJlbT0nZTpjZWxsIG06bGlzdCc+XG4gICAgICAgIDxTY3JvbGxiYXJDb21wb25lbnQ+XG4gICAgICAgICAgPHVsIGJlbT0nJGU6bGlzdCc+XG4gICAgICAgICAgICB7bGlzdEl0ZW1zfVxuICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvU2Nyb2xsYmFyQ29tcG9uZW50PlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG5cblRyYW5zZm9ybUNvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IENvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy90cmFuc2Zvcm0vdHJhbnNmb3JtLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgVmVjdG9yMiwgVXRpbHMgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IERyYWdnYWJsZUNvbXBvbmVudCBmcm9tICcuLi8uLi9kcmFnZ2FibGUtY29tcG9uZW50LmpzeCdcbmltcG9ydCBDYW52YXNDb250cm9sc0NvbXBvbmVudCBmcm9tICcuLi9jYW52YXMtY29udHJvbHMtY29tcG9uZW50J1xuXG5jb25zdCBNSU5fRElNRU5TSU9OUyA9IG5ldyBWZWN0b3IyKDUwLCA1MClcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhbnNmb3JtQ2FudmFzQ29udHJvbHNDb21wb25lbnQgZXh0ZW5kcyBDYW52YXNDb250cm9sc0NvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX25lZWRzU3R5bGVGaXhlcyA9IHRydWVcbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbkNlbnRlckRyYWdTdGFydCcsXG4gICAgICAnX29uQ2VudGVyRHJhZydcbiAgICApXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZGltZW5zaW9uczogdGhpcy5nZXRTaGFyZWRTdGF0ZSgnaW5pdGlhbERpbWVuc2lvbnMnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaXhlcyBzdHlsZXMgaW4gSUVcbiAgICovXG4gIGZpeFN0eWxlcyAoKSB7XG4gICAgaWYgKFV0aWxzLkJyb3dzZXIuaXNJRWx0ZSgxMSkpIHtcbiAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSB0aGlzLnJlZnNcblxuICAgICAgY29uc3QgY2FudmFzRGltZW5zaW9ucyA9IGVkaXRvci5nZXRDYW52YXNEaW1lbnNpb25zKGZhbHNlKVxuICAgICAgY29uc3QgY2VsbEhlaWdodCA9IGNhbnZhc0RpbWVuc2lvbnMueVxuICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAke2NlbGxIZWlnaHR9cHhgXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHNoYXJlZCBzdGF0ZSBkaWQgY2hhbmdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdTdGF0ZVxuICAgKi9cbiAgc2hhcmVkU3RhdGVEaWRDaGFuZ2UgKG5ld1N0YXRlKSB7XG4gICAgaWYgKG5ld1N0YXRlICE9PSB0aGlzLmdldFNoYXJlZFN0YXRlKCdyYXRpbycpKSB7XG4gICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZGltZW5zaW9ucyBkaXNwbGF5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlRGltZW5zaW9ucyAoKSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICBjb25zdCByYXRpbyA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3JhdGlvJykgfHwgeyByYXRpbzogJyonIH1cblxuICAgIGxldCBkaW1lbnNpb25zXG4gICAgaWYgKHJhdGlvLmRpbWVuc2lvbnMpIHtcbiAgICAgIGRpbWVuc2lvbnMgPSByYXRpby5kaW1lbnNpb25zLmNsb25lKClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW5wdXREaW1lbnNpb25zID0gb3BlcmF0aW9uLmdldElucHV0RGltZW5zaW9ucyhmYWxzZSlcbiAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc3RhcnQnKVxuICAgICAgY29uc3QgZW5kID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnZW5kJylcbiAgICAgIGNvbnN0IHRyYW5zZm9ybVNpemUgPSBlbmQuY2xvbmUoKS5zdWJ0cmFjdChzdGFydClcbiAgICAgIGRpbWVuc2lvbnMgPSB0cmFuc2Zvcm1TaXplLm11bHRpcGx5KGlucHV0RGltZW5zaW9ucykuZmxvb3IoKVxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoeyBkaW1lbnNpb25zIH0pXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBDRU5URVIgRFJBR0dJTkdcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdGFycyBkcmFnZ2luZyB0aGUgY2VudGVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25DZW50ZXJEcmFnU3RhcnQgKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc3RhcnQnKVxuICAgIGNvbnN0IGVuZCA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2VuZCcpXG5cbiAgICB0aGlzLl9pbml0aWFsVmFsdWVzID0ge1xuICAgICAgc3RhcnQ6IHN0YXJ0LmNsb25lKCksXG4gICAgICBlbmQ6IGVuZC5jbG9uZSgpLFxuICAgICAgc2l6ZTogZW5kLmNsb25lKCkuc3VidHJhY3Qoc3RhcnQpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBjZW50ZXJcbiAgICogQHBhcmFtIHtWZWN0b3IyfSBvZmZzZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNlbnRlckRyYWcgKG9mZnNldCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCB7IHN0YXJ0LCBzaXplIH0gPSB0aGlzLl9pbml0aWFsVmFsdWVzXG4gICAgY29uc3Qgb3V0cHV0RGltZW5zaW9ucyA9IGVkaXRvci5nZXRPdXRwdXREaW1lbnNpb25zKClcbiAgICBjb25zdCB0cmFuc2Zvcm1EaWZmZXJlbmNlID0gb2Zmc2V0LmNsb25lKCkuZGl2aWRlKG91dHB1dERpbWVuc2lvbnMpXG5cbiAgICBjb25zdCBtaW5TdGFydCA9IG5ldyBWZWN0b3IyKDAsIDApXG4gICAgY29uc3QgbWF4U3RhcnQgPSBuZXcgVmVjdG9yMigxLCAxKVxuICAgICAgLnN1YnRyYWN0KHNpemUpXG5cbiAgICBjb25zdCBuZXdTdGFydCA9IHN0YXJ0LmNsb25lKClcbiAgICAgIC5hZGQodHJhbnNmb3JtRGlmZmVyZW5jZSlcbiAgICAgIC5jbGFtcChtaW5TdGFydCwgbWF4U3RhcnQpXG4gICAgY29uc3QgbmV3RW5kID0gbmV3U3RhcnQuY2xvbmUoKVxuICAgICAgLmFkZChzaXplKVxuXG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7IHN0YXJ0OiBuZXdTdGFydCwgZW5kOiBuZXdFbmQgfSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEtOT0IgRFJBR0dJTkdcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgYSBrbm9iXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25OYW1lXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Lbm9iRHJhZ1N0YXJ0IChvcHRpb25OYW1lKSB7XG4gICAgdGhpcy5fY3VycmVudERyYWdPcHRpb24gPSBvcHRpb25OYW1lXG5cbiAgICB0aGlzLl9pbml0aWFsVmFsdWVzID0ge1xuICAgICAgc3RhcnQ6IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3N0YXJ0JykuY2xvbmUoKSxcbiAgICAgIGVuZDogdGhpcy5nZXRTaGFyZWRTdGF0ZSgnZW5kJykuY2xvbmUoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGlsZSB0aGUgdXNlciBkcmFncyBhIGtub2JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbk5hbWVcbiAgICogQHBhcmFtIHtWZWN0b3IyfSBvZmZzZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbktub2JEcmFnIChvcHRpb25OYW1lLCBvZmZzZXQpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgb3V0cHV0RGltZW5zaW9ucyA9IGVkaXRvci5nZXRPdXRwdXREaW1lbnNpb25zKClcbiAgICBsZXQgeyByYXRpbywgZGltZW5zaW9ucyB9ID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgncmF0aW8nKSB8fCB7IHJhdGlvOiAnKicgfVxuICAgIGlmIChkaW1lbnNpb25zICYmICFyYXRpbykge1xuICAgICAgcmF0aW8gPSBkaW1lbnNpb25zLnggLyBkaW1lbnNpb25zLnlcbiAgICB9XG5cbiAgICBjb25zdCBuZXdTaXplID0gdGhpcy5faW5pdGlhbFZhbHVlcy5lbmQuY2xvbmUoKVxuICAgICAgLnN1YnRyYWN0KHRoaXMuX2luaXRpYWxWYWx1ZXMuc3RhcnQpXG4gICAgICAubXVsdGlwbHkob3V0cHV0RGltZW5zaW9ucylcblxuICAgIC8vIENhbGN1bGF0ZSBtYXggc2l6ZSBhbmQgbmV3IHNpemVcbiAgICBsZXQgbWF4U2l6ZVxuICAgIGlmIChvcHRpb25OYW1lID09PSAnc3RhcnQnKSB7XG4gICAgICBuZXdTaXplLnN1YnRyYWN0KG9mZnNldClcbiAgICAgIG1heFNpemUgPSB0aGlzLl9pbml0aWFsVmFsdWVzLmVuZC5jbG9uZSgpXG4gICAgICAgIC5tdWx0aXBseShvdXRwdXREaW1lbnNpb25zKVxuICAgIH0gZWxzZSBpZiAob3B0aW9uTmFtZSA9PT0gJ2VuZCcpIHtcbiAgICAgIG5ld1NpemUuYWRkKG9mZnNldClcbiAgICAgIG1heFNpemUgPSBuZXcgVmVjdG9yMigxLCAxKVxuICAgICAgICAuc3VidHJhY3QodGhpcy5faW5pdGlhbFZhbHVlcy5zdGFydClcbiAgICAgICAgLm11bHRpcGx5KG91dHB1dERpbWVuc2lvbnMpXG4gICAgfVxuXG4gICAgbGV0IGJpZ2dlc3RQb3NzaWJsZUNyb3AgPSBvdXRwdXREaW1lbnNpb25zXG4gICAgaWYgKHR5cGVvZiByYXRpbyAhPT0gJ3VuZGVmaW5lZCcgJiYgcmF0aW8gIT09ICcqJykge1xuICAgICAgaWYgKHJhdGlvID4gb3V0cHV0RGltZW5zaW9ucy54IC8gb3V0cHV0RGltZW5zaW9ucy55KSB7XG4gICAgICAgIGJpZ2dlc3RQb3NzaWJsZUNyb3AgPSBuZXcgVmVjdG9yMihvdXRwdXREaW1lbnNpb25zLngsIG91dHB1dERpbWVuc2lvbnMueCAvIHJhdGlvKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmlnZ2VzdFBvc3NpYmxlQ3JvcCA9IG5ldyBWZWN0b3IyKG91dHB1dERpbWVuc2lvbnMueSAqIHJhdGlvLCBvdXRwdXREaW1lbnNpb25zLnkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgbmV3U2l6ZS54ID0gTWF0aC5taW4oTWF0aC5tYXgoTWF0aC5taW4oTUlOX0RJTUVOU0lPTlMueCwgYmlnZ2VzdFBvc3NpYmxlQ3JvcC54KSwgbmV3U2l6ZS54KSwgbWF4U2l6ZS54KVxuICAgIGlmIChyYXRpbyAhPT0gJyonKSB7XG4gICAgICBuZXdTaXplLnkgPSBuZXdTaXplLnggLyByYXRpb1xuICAgIH1cbiAgICBuZXdTaXplLnkgPSBNYXRoLm1pbihNYXRoLm1heChNYXRoLm1pbihNSU5fRElNRU5TSU9OUy55LCBiaWdnZXN0UG9zc2libGVDcm9wLnkpLCBuZXdTaXplLnkpLCBtYXhTaXplLnkpXG4gICAgaWYgKHJhdGlvICE9PSAnKicpIHtcbiAgICAgIG5ld1NpemUueCA9IG5ld1NpemUueSAqIHJhdGlvXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbk5hbWUgPT09ICdzdGFydCcpIHtcbiAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gdGhpcy5faW5pdGlhbFZhbHVlcy5lbmQuY2xvbmUoKVxuICAgICAgICAuc3VidHJhY3QoXG4gICAgICAgICAgbmV3U2l6ZVxuICAgICAgICAgICAgLmNsb25lKClcbiAgICAgICAgICAgIC5kaXZpZGUob3V0cHV0RGltZW5zaW9ucylcbiAgICAgICAgKVxuICAgICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7IHN0YXJ0OiBuZXdTdGFydCB9LCBmYWxzZSlcbiAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKVxuICAgIH0gZWxzZSBpZiAob3B0aW9uTmFtZSA9PT0gJ2VuZCcpIHtcbiAgICAgIGNvbnN0IG5ld0VuZCA9IHRoaXMuX2luaXRpYWxWYWx1ZXMuc3RhcnQuY2xvbmUoKVxuICAgICAgICAuYWRkKFxuICAgICAgICAgIG5ld1NpemVcbiAgICAgICAgICAgIC5jbG9uZSgpXG4gICAgICAgICAgICAuZGl2aWRlKG91dHB1dERpbWVuc2lvbnMpXG4gICAgICAgIClcbiAgICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUoeyBlbmQ6IG5ld0VuZCB9LCBmYWxzZSlcbiAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE1JU0NcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGltZW5zaW9ucyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgdHJhbnNmb3JtIGRpbWVuc2lvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jYWxjdWxhdGVEaW1lbnNpb25zICgpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdzdGFydCcpXG4gICAgY29uc3QgZW5kID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnZW5kJylcblxuICAgIHJldHVybiBlbmQuY2xvbmUoKVxuICAgICAgLnN1YnRyYWN0KHN0YXJ0KVxuICAgICAgLm11bHRpcGx5KGVkaXRvci5nZXRJbnB1dERpbWVuc2lvbnMoZmFsc2UpKVxuICAgICAgLnJvdW5kKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFU0laSU5HIC8gU1RZTElOR1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHlsZXMgKHdpZHRoIC8gaGVpZ2h0KSBmb3IgdGhlIHRyYW5zZm9ybSBhcmVhcyB0aGF0IGRlZmluZSB0aGVcbiAgICogdHJhbnNmb3JtIHNpemVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEFyZWFTdHlsZXMgKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuICAgIGNvbnN0IGNhbnZhc0RpbWVuc2lvbnMgPSBlZGl0b3IuZ2V0Q2FudmFzRGltZW5zaW9ucygpXG5cbiAgICBjb25zdCBzdGFydCA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3N0YXJ0JykuY2xvbmUoKS5tdWx0aXBseShvdXRwdXREaW1lbnNpb25zKS5mbG9vcigpXG4gICAgY29uc3QgZW5kID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnZW5kJykuY2xvbmUoKS5tdWx0aXBseShvdXRwdXREaW1lbnNpb25zKS5jZWlsKClcbiAgICBjb25zdCBzaXplID0gZW5kLmNsb25lKCkuc3VidHJhY3Qoc3RhcnQpXG5cbiAgICBjb25zdCBvZmZzZXQgPSBjYW52YXNEaW1lbnNpb25zLmNsb25lKClcbiAgICAgIC5zdWJ0cmFjdChvdXRwdXREaW1lbnNpb25zKVxuICAgICAgLmRpdmlkZSgyKVxuICAgICAgLmZsb29yKClcblxuICAgIGNvbnN0IHBhZGRpbmcgPSBlZGl0b3IuZ2V0UGFkZGluZygpXG4gICAgc3RhcnQuYWRkKG9mZnNldClcbiAgICAgIC5hZGQoMCwgcGFkZGluZ1swXSlcblxuICAgIHJldHVybiB7XG4gICAgICB0b3BMZWZ0OiB0aGlzLl9nZXREaW1lbnNpb25zU3R5bGVzKHN0YXJ0LngsIHN0YXJ0LnkpLFxuICAgICAgdG9wQ2VudGVyOiB0aGlzLl9nZXREaW1lbnNpb25zU3R5bGVzKHNpemUueCwgc3RhcnQueSksXG4gICAgICBjZW50ZXJMZWZ0OiB0aGlzLl9nZXREaW1lbnNpb25zU3R5bGVzKHN0YXJ0LngsIHNpemUueSksXG4gICAgICBjZW50ZXI6IHRoaXMuX2dldERpbWVuc2lvbnNTdHlsZXMoc2l6ZS54LCBzaXplLnkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpbWVuc2lvbnMgc3R5bGUgKHdpZHRoIC8gaGVpZ2h0KSBmb3IgdGhlIGdpdmVuIGRpbWVuc2lvbnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldERpbWVuc2lvbnNTdHlsZXMgKHgsIHkpIHtcbiAgICAvLyBUYWJsZSBjZWxscyBhbmQgcm93cyBjYW4ndCBoYXZlIGEgd2lkdGggLyBoZWlnaHQgb2YgMFxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogTWF0aC5tYXgoMSwgeCksXG4gICAgICBoZWlnaHQ6IE1hdGgubWF4KDEsIHkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIGNvbnN0IHJhdGlvID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgncmF0aW8nKVxuICAgIGNvbnN0IHsgZGltZW5zaW9ucyB9ID0gdGhpcy5zdGF0ZVxuXG4gICAgbGV0IGNhbnZhc0NvbnRlbnRcbiAgICBpZiAocmF0aW8pIHtcbiAgICAgIGNvbnN0IGFyZWFTdHlsZXMgPSB0aGlzLl9nZXRBcmVhU3R5bGVzKClcbiAgICAgIGNhbnZhc0NvbnRlbnQgPSAoPGRpdiBiZW09JyRiOnRyYW5zZm9ybUNhbnZhc0NvbnRyb2xzJz5cbiAgICAgICAgPGRpdiBiZW09J2U6cm93Jz5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTpjZWxsIG06ZGFyaycgc3R5bGU9e2FyZWFTdHlsZXMudG9wTGVmdH0+Jm5ic3A7PC9kaXY+XG4gICAgICAgICAgPGRpdiBiZW09J2U6Y2VsbCBtOmRhcmsnIHN0eWxlPXthcmVhU3R5bGVzLnRvcENlbnRlcn0+Jm5ic3A7PC9kaXY+XG4gICAgICAgICAgPGRpdiBiZW09J2U6Y2VsbCBtOmRhcmsnIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGJlbT0nZTpyb3cnPlxuICAgICAgICAgIDxkaXYgYmVtPSdlOmNlbGwgbTpkYXJrJyBzdHlsZT17YXJlYVN0eWxlcy5jZW50ZXJMZWZ0fT4mbmJzcDs8L2Rpdj5cbiAgICAgICAgICA8RHJhZ2dhYmxlQ29tcG9uZW50XG4gICAgICAgICAgICBvblN0YXJ0PXt0aGlzLl9vbkNlbnRlckRyYWdTdGFydH1cbiAgICAgICAgICAgIG9uRHJhZz17dGhpcy5fb25DZW50ZXJEcmFnfT5cbiAgICAgICAgICAgIDxkaXYgYmVtPSdlOmNlbGwgbTpib3JkZXJlZCcgc3R5bGU9e2FyZWFTdHlsZXMuY2VudGVyfT5cbiAgICAgICAgICAgICAgPERyYWdnYWJsZUNvbXBvbmVudFxuICAgICAgICAgICAgICAgIG9uU3RhcnQ9e3RoaXMuX29uS25vYkRyYWdTdGFydC5iaW5kKHRoaXMsICdzdGFydCcpfVxuICAgICAgICAgICAgICAgIG9uRHJhZz17dGhpcy5fb25Lbm9iRHJhZy5iaW5kKHRoaXMsICdzdGFydCcpfT5cbiAgICAgICAgICAgICAgICA8ZGl2IGJlbT0nZTprbm9iIG06dG9wTGVmdCAkYjprbm9iJz5cbiAgICAgICAgICAgICAgICAgIDxpbWcgYmVtPSdlOmljb24nIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKCdjb250cm9scy9rbm9icy9yZXNpemUtZGlhZ29uYWwtZG93bi5wbmcnLCB0cnVlKX0gLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9EcmFnZ2FibGVDb21wb25lbnQ+XG4gICAgICAgICAgICAgIDxkaXYgYmVtPSdlOmRpbWVuc2lvbnMnPntgJHtkaW1lbnNpb25zLnh9eCR7ZGltZW5zaW9ucy55fWB9PC9kaXY+XG4gICAgICAgICAgICAgIDxEcmFnZ2FibGVDb21wb25lbnRcbiAgICAgICAgICAgICAgICBvblN0YXJ0PXt0aGlzLl9vbktub2JEcmFnU3RhcnQuYmluZCh0aGlzLCAnZW5kJyl9XG4gICAgICAgICAgICAgICAgb25EcmFnPXt0aGlzLl9vbktub2JEcmFnLmJpbmQodGhpcywgJ2VuZCcpfT5cbiAgICAgICAgICAgICAgICA8ZGl2IGJlbT0nZTprbm9iIG06Ym90dG9tUmlnaHQgJGI6a25vYic+XG4gICAgICAgICAgICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aCgnY29udHJvbHMva25vYnMvcmVzaXplLWRpYWdvbmFsLWRvd24ucG5nJywgdHJ1ZSl9IC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvRHJhZ2dhYmxlQ29tcG9uZW50PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9EcmFnZ2FibGVDb21wb25lbnQ+XG4gICAgICAgICAgPGRpdiBiZW09J2U6Y2VsbCBtOmRhcmsnPiZuYnNwOzwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBiZW09J2U6cm93Jz5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTpjZWxsIG06ZGFyayc+Jm5ic3A7PC9kaXY+XG4gICAgICAgICAgPGRpdiBiZW09J2U6Y2VsbCBtOmRhcmsnPiZuYnNwOzwvZGl2PlxuICAgICAgICAgIDxkaXYgYmVtPSdlOmNlbGwgbTpkYXJrJz4mbmJzcDs8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj4pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbnZhc0NvbnRlbnQgPSAoPGRpdiBiZW09JyRiOnRyYW5zZm9ybUNhbnZhc0NvbnRyb2xzJz5cbiAgICAgICAgPGRpdiBiZW09J2U6ZGltZW5zaW9ucyc+e2Ake2RpbWVuc2lvbnMueH14JHtkaW1lbnNpb25zLnl9YH08L2Rpdj5cbiAgICAgIDwvZGl2PilcbiAgICB9XG5cbiAgICByZXR1cm4gKDxkaXYgYmVtPSdiOmNhbnZhc0NvbnRyb2xzIGU6Y29udGFpbmVyIG06ZnVsbCcgcmVmPSdjb250YWluZXInPlxuICAgICAge2NhbnZhc0NvbnRlbnR9XG4gICAgPC9kaXY+KVxuICB9XG59XG5cblRyYW5zZm9ybUNhbnZhc0NvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IENhbnZhc0NvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy90cmFuc2Zvcm0vdHJhbnNmb3JtLWNhbnZhcy1jb250cm9scy1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIENvbnN0YW50cyB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgVG9wQmFyQ29tcG9uZW50IGZyb20gJy4uLy4uL3NoYXJlZC90b3AtYmFyL3RvcC1iYXItY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFuc2Zvcm1Ub3BCYXJDb21wb25lbnQgZXh0ZW5kcyBUb3BCYXJDb21wb25lbnQge1xuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb25lIG9mIHRoZSByb3RhdGUgYnV0dG9uc1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpcmVjdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uUm90YXRlQ2xpY2sgKGRpcmVjdGlvbikge1xuICAgIGxldCBkZWdyZWVzXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2N3Jykge1xuICAgICAgZGVncmVlcyA9IDkwXG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdjY3cnKSB7XG4gICAgICBkZWdyZWVzID0gLTkwXG4gICAgfVxuXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29yaWVudGF0aW9uT3BlcmF0aW9uJylcbiAgICBjb25zdCBuZXdSb3RhdGlvbiA9IChvcGVyYXRpb24uZ2V0Um90YXRpb24oKSArIGRlZ3JlZXMpICUgMzYwXG5cbiAgICBvcGVyYXRpb24uc2V0KHsgcm90YXRpb246IG5ld1JvdGF0aW9uIH0pXG5cbiAgICBsZXQgbmV3U3RhdGUgPSB7XG4gICAgICBvcmllbnRhdGlvblJvdGF0aW9uOiBuZXdSb3RhdGlvblxuICAgIH1cblxuICAgIGNvbnN0IHJhdGlvID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgncmF0aW8nKVxuICAgIGlmIChyYXRpbyAmJiAhcmF0aW8uZGltZW5zaW9ucykge1xuICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdzdGFydCcpXG4gICAgICBjb25zdCBlbmQgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdlbmQnKVxuICAgICAgY29uc3QgdGVtcFN0YXJ0ID0gc3RhcnQuY2xvbmUoKVxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2N3Jykge1xuICAgICAgICBzdGFydC5zZXQoMS4wIC0gZW5kLnksIHRlbXBTdGFydC54KVxuICAgICAgICBlbmQuc2V0KDEuMCAtIHRlbXBTdGFydC55LCBlbmQueClcbiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnY2N3Jykge1xuICAgICAgICBzdGFydC5zZXQodGVtcFN0YXJ0LnksIDEuMCAtIGVuZC54KVxuICAgICAgICBlbmQuc2V0KGVuZC55LCAxLjAgLSB0ZW1wU3RhcnQueClcbiAgICAgIH1cbiAgICAgIG5ld1N0YXRlLnN0YXJ0ID0gc3RhcnRcbiAgICAgIG5ld1N0YXRlLmVuZCA9IGVuZFxuICAgIH1cblxuICAgIGlmIChyYXRpbyAmJiByYXRpby5kaW1lbnNpb25zKSB7XG4gICAgICB0aGlzLl9lbWl0RXZlbnQoQ29uc3RhbnRzLkVWRU5UUy5UUkFOU0ZPUk1fUkVBUFBMWV9SQVRJTylcbiAgICB9XG5cbiAgICB0aGlzLnNldFNoYXJlZFN0YXRlKG5ld1N0YXRlKVxuXG4gICAgZWRpdG9yLmJyb2FkY2FzdFJvdGF0ZShkZWdyZWVzKVxuICAgIGVkaXRvci56b29tLnNldCgnYXV0bycpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb25lIG9mIHRoZSBmbGlwIGJ1dHRvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkZsaXBDbGljayAoZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29yaWVudGF0aW9uT3BlcmF0aW9uJylcblxuICAgIGNvbnN0IG5ld0ZsaXAgPSAhdGhpcy5nZXRTaGFyZWRTdGF0ZShgZmxpcCR7ZGlyZWN0aW9ufWApXG4gICAgY29uc3QgbmV3Um90YXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdyb3RhdGlvbicpICogLTFcbiAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHtcbiAgICAgIFtgZmxpcCR7ZGlyZWN0aW9ufWBdOiBuZXdGbGlwLFxuICAgICAgcm90YXRpb246IG5ld1JvdGF0aW9uXG4gICAgfSlcbiAgICBlZGl0b3Iuc2V0Um90YXRpb24obmV3Um90YXRpb24pXG4gICAgb3BlcmF0aW9uLmZsaXAoZGlyZWN0aW9uKVxuXG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdzdGFydCcpXG4gICAgY29uc3QgZW5kID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnZW5kJylcbiAgICBjb25zdCB0bXBTdGFydCA9IHN0YXJ0LmNsb25lKClcbiAgICBpZiAoZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgIHN0YXJ0LnNldCgxLjAgLSBlbmQueCwgc3RhcnQueSlcbiAgICAgIGVuZC5zZXQoMS4wIC0gdG1wU3RhcnQueCwgZW5kLnkpXG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgIHN0YXJ0LnNldChzdGFydC54LCAxLjAgLSBlbmQueSlcbiAgICAgIGVuZC5zZXQoZW5kLngsIDEuMCAtIHRtcFN0YXJ0LnkpXG4gICAgfVxuXG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7IHN0YXJ0LCBlbmQgfSlcblxuICAgIGVkaXRvci5icm9hZGNhc3RGbGlwKGRpcmVjdGlvbilcbiAgICBlZGl0b3IucmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgY2hhbmdlIGZyb20gdGhlIGdpdmVuIHN0YXRlXG4gICAqIEBwYXJhbSAge09iamVjdH0gb2xkU3RhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBuZXdTdGF0ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc2hvdWxkU2hhcmVkQ29tcG9uZW50VXBkYXRlIChvbGRTdGF0ZSwgbmV3U3RhdGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb250ZW50IG9mIHRoaXMgT3ZlcnZpZXdUb3BCYXJDb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlckNvbnRlbnQgKCkge1xuICAgIHJldHVybiAoPGJlbSBzcGVjaWZpZXI9JyRiOnRvcEJhcic+XG4gICAgICA8ZGl2IGJlbT0nJGU6aWNvbkJ1dHRvbicgb25DbGljaz17dGhpcy5fb25GbGlwQ2xpY2suYmluZCh0aGlzLCAndmVydGljYWwnKX0+XG4gICAgICAgIDxpbWcgYmVtPSdlOmljb24nIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKCdjb250cm9scy90cmFuc2Zvcm0vZmxpcC12LnBuZycsIHRydWUpfSAvPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGJlbT0nJGU6aWNvbkJ1dHRvbicgb25DbGljaz17dGhpcy5fb25GbGlwQ2xpY2suYmluZCh0aGlzLCAnaG9yaXpvbnRhbCcpfT5cbiAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXt0aGlzLl9nZXRBc3NldFBhdGgoJ2NvbnRyb2xzL3RyYW5zZm9ybS9mbGlwLWgucG5nJywgdHJ1ZSl9IC8+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgYmVtPSdlOnNwYWNlJyAvPlxuICAgICAgPGRpdiBiZW09JyRlOmljb25CdXR0b24nIG9uQ2xpY2s9e3RoaXMuX29uUm90YXRlQ2xpY2suYmluZCh0aGlzLCAnY2N3Jyl9PlxuICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aCgnY29udHJvbHMvdHJhbnNmb3JtL3JvdGF0ZS1jY3cucG5nJywgdHJ1ZSl9IC8+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgYmVtPSckZTppY29uQnV0dG9uJyBvbkNsaWNrPXt0aGlzLl9vblJvdGF0ZUNsaWNrLmJpbmQodGhpcywgJ2N3Jyl9PlxuICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aCgnY29udHJvbHMvdHJhbnNmb3JtL3JvdGF0ZS1jdy5wbmcnLCB0cnVlKX0gLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvYmVtPilcbiAgfVxufVxuXG5UcmFuc2Zvcm1Ub3BCYXJDb21wb25lbnQuY29udGV4dFR5cGVzID0gVG9wQmFyQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy90cmFuc2Zvcm0vdHJhbnNmb3JtLXRvcC1iYXItY29tcG9uZW50LmpzeCIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgU0RLVXRpbHMgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IENvbnRyb2xzIGZyb20gJy4uL2NvbnRyb2xzJ1xuaW1wb3J0IEZpbHRlcnNDb250cm9sc0NvbXBvbmVudCBmcm9tICcuL2ZpbHRlci1jb250cm9scy1jb21wb25lbnQnXG5pbXBvcnQgRmlsdGVyTWFuYWdlciBmcm9tICdzaGFyZWQvbWFuYWdlcnMvZmlsdGVyLW1hbmFnZXInXG5cbi8qKlxuICogVGhlIGZpbHRlcnMgY29udHJvbHNcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5Db250cm9sXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5Db250cm9sc1xuICovXG5jbGFzcyBGaWx0ZXJzQ29udHJvbHMgZXh0ZW5kcyBDb250cm9scyB7XG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGVudGVycyB0aGVzZSBjb250cm9sc1xuICAgKiBAdGhpcyB7RmlsdGVyc0NvbnRyb2xzQ29tcG9uZW50fVxuICAgKiBAcGFyYW0ge1NoYXJlZFN0YXRlfSBzaGFyZWRTdGF0ZVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIG9uRW50ZXIgKHNoYXJlZFN0YXRlKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG9wZXJhdGlvbkV4aXN0ZWRCZWZvcmUgPSBlZGl0b3Iub3BlcmF0aW9ucy5leGlzdHMoJ2ZpbHRlcicpXG4gICAgY29uc3Qgb3BlcmF0aW9uID0gZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ2ZpbHRlcicpXG4gICAgY29uc3QgaW5pdGlhbE9wdGlvbnMgPSBvcGVyYXRpb24uc2VyaWFsaXplT3B0aW9ucyhbJ2lkZW50aWZpZXInLCAnZmlsdGVyJywgJ2ludGVuc2l0eSddKVxuXG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7IG9wZXJhdGlvbiwgb3BlcmF0aW9uRXhpc3RlZEJlZm9yZSwgaW5pdGlhbE9wdGlvbnMgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGxlYXZlcyB0aGVzZSBjb250cm9sc1xuICAgKiBAdGhpcyB7U3RpY2tlcnNDb250cm9sc0NvbXBvbmVudH1cbiAgICogQG92ZXJyaWRlXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBvbkV4aXQgKCkge1xuICAgIGNvbnN0IGluaXRpYWxPcHRpb25zID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnaW5pdGlhbE9wdGlvbnMnKVxuICAgIGNvbnN0IEZpbHRlckNvbnN0cnVjdG9yID0gdGhpcy5fb3BlcmF0aW9uLmdldEZpbHRlcigpLmNvbnN0cnVjdG9yXG4gICAgY29uc3QgSW5pdGlhbEZpbHRlckNvbnN0cnVjdG9yID0gaW5pdGlhbE9wdGlvbnMuZmlsdGVyLmNvbnN0cnVjdG9yXG5cbiAgICBsZXQgbHV0SW1hZ2VcbiAgICBpZiAoSW5pdGlhbEZpbHRlckNvbnN0cnVjdG9yLmlkZW50aWZpZXIgPT09ICczZC1sdXQnKSB7XG4gICAgICBsdXRJbWFnZSA9IGluaXRpYWxPcHRpb25zLmZpbHRlci5nZXRJbWFnZSgpXG4gICAgfVxuICAgIGNvbnN0IGludGVuc2l0eSA9IHRoaXMuX29wZXJhdGlvbi5nZXRJbnRlbnNpdHkoKVxuICAgIGlmICh0aGlzLl9vcGVyYXRpb24uZ2V0SWRlbnRpZmllcigpICE9PSBpbml0aWFsT3B0aW9ucy5pZGVudGlmaWVyIHx8XG4gICAgICBpbnRlbnNpdHkgIT09IGluaXRpYWxPcHRpb25zLmludGVuc2l0eSkge1xuICAgICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgICAgZWRpdG9yLmhpc3RvcnkuYWRkKHRoaXMuX29wZXJhdGlvbixcbiAgICAgICAge1xuICAgICAgICAgIGlkZW50aWZpZXI6IGluaXRpYWxPcHRpb25zLmlkZW50aWZpZXIsXG4gICAgICAgICAgaW50ZW5zaXR5XG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbkV4aXN0ZWRCZWZvcmUnKSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IGVkaXRvci5vcGVyYXRpb25zLmdldE9yQ3JlYXRlKCdmaWx0ZXInKVxuICAgICAgICAgIGlmIChJbml0aWFsRmlsdGVyQ29uc3RydWN0b3IuaWRlbnRpZmllciA9PT0gJzNkLWx1dCcpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbi5zZXRGaWx0ZXIobmV3IEluaXRpYWxGaWx0ZXJDb25zdHJ1Y3Rvcih7IGltYWdlOiBsdXRJbWFnZSB9KSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3BlcmF0aW9uLnNldEZpbHRlcihuZXcgSW5pdGlhbEZpbHRlckNvbnN0cnVjdG9yKCkpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGlmIChGaWx0ZXJDb25zdHJ1Y3Rvci5pc0lkZW50aXR5KSB7XG4gICAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgICBlZGl0b3Iub3BlcmF0aW9ucy5yZW1vdmUodGhpcy5fb3BlcmF0aW9uKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBjb250cm9sIGlzIGF2YWlsYWJsZSB0byB0aGUgdXNlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkVkaXRvcn0gZWRpdG9yXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3RhdGljIGlzQXZhaWxhYmxlIChlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzVG9vbEFsbG93ZWQoJ2ZpbHRlcicpICYmXG4gICAgICBlZGl0b3IuaXNUb29sRW5hYmxlZCh0aGlzLmlkZW50aWZpZXIpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXNzZXRzIHRoYXQgc2hvdWxkIGJlIHByZWxvYWRlZCBmb3IgdGhpcyBjb250cm9sXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuRWRpdG9yfSBlZGl0b3JcbiAgICogQHJldHVybiB7U3RyaW5nW119XG4gICAqL1xuICBzdGF0aWMgZ2V0UHJlbG9hZEFzc2V0cyAoZWRpdG9yKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGVkaXRvci5nZXRPcHRpb25zKClcbiAgICBjb25zdCBmaWx0ZXJPcHRpb25zID0gU0RLVXRpbHMuZGVmYXVsdHMoXG4gICAgICBvcHRpb25zLmVkaXRvci5jb250cm9sc09wdGlvbnMuZmlsdGVyLFxuICAgICAgdGhpcy5kZWZhdWx0T3B0aW9uc1xuICAgIClcbiAgICBjb25zdCBmaWx0ZXJNYW5hZ2VyID0gbmV3IEZpbHRlck1hbmFnZXIoZWRpdG9yLmdldFVJKCksIGZpbHRlck9wdGlvbnMpXG5cbiAgICBsZXQgYXNzZXRzID0gW11cbiAgICBjb25zdCBjYXRlZ29yaWVzID0gZmlsdGVyTWFuYWdlci5nZXRDYXRlZ29yaWVzKClcbiAgICBjYXRlZ29yaWVzLmZvckVhY2goKGNhdGVnb3J5KSA9PiB7XG4gICAgICBhc3NldHMucHVzaChgY29udHJvbHMvZmlsdGVycy9jYXRlZ29yaWVzLyR7Y2F0ZWdvcnkuaWRlbnRpZmllcn0ucG5nYClcbiAgICAgIGNvbnN0IGZpbHRlcnMgPSBmaWx0ZXJNYW5hZ2VyLmdldEZpbHRlcnNGb3JDYXRlZ29yeShjYXRlZ29yeS5pZGVudGlmaWVyKVxuICAgICAgZmlsdGVycy5mb3JFYWNoKChmaWx0ZXIpID0+IHtcbiAgICAgICAgYXNzZXRzLnB1c2goYGNvbnRyb2xzL2ZpbHRlcnMvJHtmaWx0ZXIuaWRlbnRpZmllcn0ucG5nYClcbiAgICAgICAgaWYgKGZpbHRlci5sdXRJbWFnZSkge1xuICAgICAgICAgIGFzc2V0cy5wdXNoKFtmaWx0ZXIubHV0SW1hZ2UsIGZhbHNlLCBmYWxzZV0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHJldHVybiBhc3NldHNcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIGNvbnRyb2xzIGNvbXBvbmVudC4gVXNlZCBmb3IgdGhlIGxvd2VyIGNvbnRyb2xzIHBhcnQgb2YgdGhlIGVkaXRvci5cbiAqIEB0eXBlIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xzQ29tcG9uZW50fVxuICogQGlnbm9yZVxuICovXG5GaWx0ZXJzQ29udHJvbHMuY29udHJvbHNDb21wb25lbnQgPSBGaWx0ZXJzQ29udHJvbHNDb21wb25lbnRcblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuRmlsdGVyc0NvbnRyb2xzLmlkZW50aWZpZXIgPSAnZmlsdGVyJ1xuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIGljb24gcGF0aFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBpZ25vcmVcbiAqL1xuRmlsdGVyc0NvbnRyb2xzLmljb25QYXRoID0gJ2NvbnRyb2xzL292ZXJ2aWV3L2ZpbHRlcnMucG5nJ1xuXG4vKipcbiAqIFRoZSBsYW5ndWFnZSBrZXkgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhpcyBmaWx0ZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAaWdub3JlXG4gKi9cbkZpbHRlcnNDb250cm9scy5sYW5ndWFnZUtleSA9ICdwZXNkay5maWx0ZXIudGl0bGUubmFtZSdcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGlzIGNvbnRyb2xcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge1Bob3RvRWRpdG9yU0RLLkZpbHRlcltdfSBbY2F0ZWdvcmllcyA9IFtdXVxuICogQHByb3BlcnR5IHtCb29sZWFufSBbcmVwbGFjZUNhdGVnb3JpZXMgPSBmYWxzZV1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IFthdmFpbGFibGVGaWx0ZXJzID0gbnVsbF1cbiAqL1xuRmlsdGVyc0NvbnRyb2xzLmRlZmF1bHRPcHRpb25zID0ge1xuICBjYXRlZ29yaWVzOiBbXSxcbiAgcmVwbGFjZUNhdGVnb3JpZXM6IGZhbHNlLFxuICBhdmFpbGFibGVGaWx0ZXJzOiBudWxsLFxuICBoaWRlQ2F0ZWdvcmllczogZmFsc2Vcbn1cblxuLyoqXG4gKiBUaGUgb3BlcmF0aW9ucyByZXF1aXJlZCBmb3IgdGhpcyBjb250cm9sIHRvIHdvcmsgcHJvcGVybHlcbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuRmlsdGVyc0NvbnRyb2xzLnJlcXVpcmVkT3BlcmF0aW9ucyA9IFsnZmlsdGVyJ11cblxuZXhwb3J0IGRlZmF1bHQgRmlsdGVyc0NvbnRyb2xzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL2ZpbHRlci9pbmRleC5qcyIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFNESywgUmVhY3RCRU0sIENvbnN0YW50cyB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi4vY29udHJvbHMtY29tcG9uZW50J1xuaW1wb3J0IFNjcm9sbGJhckNvbXBvbmVudCBmcm9tICcuLi8uLi9zY3JvbGxiYXItY29tcG9uZW50J1xuaW1wb3J0IENhdGVnb3J5RHJvcGRvd25Db21wb25lbnQgZnJvbSAnLi4vLi4vY2F0ZWdvcnktZHJvcGRvd24vY2F0ZWdvcnktZHJvcGRvd24tY29tcG9uZW50J1xuaW1wb3J0IFNsaWRlck92ZXJsYXlDb21wb25lbnQgZnJvbSAnLi4vc2xpZGVyLW92ZXJsYXktY29tcG9uZW50J1xuaW1wb3J0IEZpbHRlck1hbmFnZXIgZnJvbSAnc2hhcmVkL21hbmFnZXJzL2ZpbHRlci1tYW5hZ2VyJ1xuXG5jb25zdCB7IEZpbHRlcnMgfSA9IFNESy5PcGVyYXRpb25zLkZpbHRlck9wZXJhdGlvblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWx0ZXJDb250cm9sc0NvbXBvbmVudCBleHRlbmRzIENvbnRyb2xzQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25JdGVtQ2xpY2snLFxuICAgICAgJ19vbk9wZXJhdGlvblVwZGF0ZWQnLFxuICAgICAgJ19vblNsaWRlclZhbHVlQ2hhbmdlJyxcbiAgICAgICdfb25DYXRlZ29yeUNoYW5nZSdcbiAgICApXG4gICAgdGhpcy5fb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcblxuICAgIHRoaXMuX2V2ZW50cyA9IHtcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLk9QRVJBVElPTl9VUERBVEVEXTogdGhpcy5fb25PcGVyYXRpb25VcGRhdGVkXG4gICAgfVxuXG4gICAgdGhpcy5faW5pdEZpbHRlck1hbmFnZXIoKVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGNhdGVnb3J5OiB0aGlzLl9maWx0ZXJNYW5hZ2VyLmdldENhdGVnb3J5QnlJZGVudGlmaWVyKCdhbGwnKVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIElOSVRJQUxJWkFUSU9OXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBmaWx0ZXIgbWFuYWdlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRGaWx0ZXJNYW5hZ2VyICgpIHtcbiAgICB0aGlzLl9maWx0ZXJNYW5hZ2VyID0gbmV3IEZpbHRlck1hbmFnZXIodGhpcy5jb250ZXh0LnVpLCB0aGlzLnByb3BzLm9wdGlvbnMpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgc2xpZGVyIHZhbHVlIGhhcyBiZWVuIGNoYW5nZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25TbGlkZXJWYWx1ZUNoYW5nZSAodmFsdWUpIHtcbiAgICB0aGlzLl9vcGVyYXRpb24uc2V0SW50ZW5zaXR5KHZhbHVlIC8gMTAwKVxuXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGVkaXRvci5yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3dpdGNoZXMgdGhlIGNhdGVnb3J5XG4gICAqIEBwYXJhbSAge09iamVjdH0gY2F0ZWdvcnlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNhdGVnb3J5Q2hhbmdlIChjYXRlZ29yeSkge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBjYXRlZ29yeTogY2F0ZWdvcnkgfSwgKCkgPT4ge1xuICAgICAgdGhpcy5yZWZzLnNjcm9sbGJhci51cGRhdGUoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBvcGVyYXRpb24gaGFzIGJlZW4gdXBkYXRlZFxuICAgKiBAcGFyYW0gIHtPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uT3BlcmF0aW9uVXBkYXRlZCAob3BlcmF0aW9uKSB7XG4gICAgLy8gVGhlIHVuZG8gYnV0dG9uIG1pZ2h0IGNoYW5nZSB0aGlzIG9wZXJhdGlvbidzIHNlbGVjdGVkIGZpbHRlciBvciBpbnRlbnNpdHkuXG4gICAgLy8gVXBkYXRlIHRoZSBjb21wb25lbnQgdG8gcmVmbGVjdCB0aGUgY2hhbmdlXG4gICAgaWYgKG9wZXJhdGlvbiA9PT0gdGhpcy5fb3BlcmF0aW9uKSB7XG4gICAgICB0aGlzLmZvcmNlVXBkYXRlKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgYW4gaXRlbVxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWRlbnRpZmllclxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25JdGVtQ2xpY2sgKGlkZW50aWZpZXIsIGUpIHtcbiAgICB0aGlzLl9maWx0ZXJNYW5hZ2VyLmluc3RhbnRpYXRlRmlsdGVyV2l0aElkZW50aWZpZXIoaWRlbnRpZmllcilcbiAgICAgIC50aGVuKGZpbHRlciA9PiB7XG4gICAgICAgIHRoaXMuX29wZXJhdGlvbi5zZXQoe1xuICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICBpZGVudGlmaWVyLFxuICAgICAgICAgIGludGVuc2l0eTogMVxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICAgICAgZWRpdG9yLnJlbmRlcigpXG4gICAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKVxuICAgICAgfSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvdmVybGF5IGNvbnRyb2xzIG9mIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJPdmVybGF5Q29udHJvbHMgKCkge1xuICAgIGNvbnN0IGN1cnJlbnRGaWx0ZXIgPSB0aGlzLl9vcGVyYXRpb24uZ2V0RmlsdGVyKClcbiAgICBpZiAoY3VycmVudEZpbHRlci5pc0lkZW50aXR5KSByZXR1cm4gbnVsbFxuXG4gICAgY29uc3QgaW50ZW5zaXR5ID0gdGhpcy5fb3BlcmF0aW9uLmdldEludGVuc2l0eSgpXG4gICAgcmV0dXJuICg8U2xpZGVyT3ZlcmxheUNvbXBvbmVudFxuICAgICAgbWluVmFsdWU9ezB9XG4gICAgICBtYXhWYWx1ZT17MTAwfVxuICAgICAgdmFsdWU9e2ludGVuc2l0eSAqIDEwMH1cbiAgICAgIHZhbHVlVW5pdD0nJSdcbiAgICAgIHBvc2l0aXZlVmFsdWVQcmVmaXg9JysnXG4gICAgICBsYWJlbD17dGhpcy5fdCgncGVzZGsuZmlsdGVyLnRleHQuaW50ZW5zaXR5Jyl9XG4gICAgICBvbkNoYW5nZT17dGhpcy5fb25TbGlkZXJWYWx1ZUNoYW5nZX0gLz4pXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgbGlzdCBpdGVtcyBmb3IgdGhpcyBjb250cm9sXG4gICAqIEByZXR1cm4ge0FycmF5LjxSZWFjdEJFTS5FbGVtZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJMaXN0SXRlbXMgKCkge1xuICAgIGNvbnN0IGN1cnJlbnRGaWx0ZXJJZGVudGlmaWVyID0gdGhpcy5fb3BlcmF0aW9uLmdldElkZW50aWZpZXIoKVxuICAgIGNvbnN0IGZpbHRlcnMgPSB0aGlzLl9maWx0ZXJNYW5hZ2VyLmdldEZpbHRlcnNGb3JDYXRlZ29yeSh0aGlzLnN0YXRlLmNhdGVnb3J5LmlkZW50aWZpZXIpXG5cbiAgICByZXR1cm4gW0ZpbHRlcnMuSWRlbnRpdHlGaWx0ZXJdLmNvbmNhdChmaWx0ZXJzKS5tYXAoKGZpbHRlcikgPT4ge1xuICAgICAgY29uc3QgeyBpZGVudGlmaWVyIH0gPSBmaWx0ZXJcbiAgICAgIHJldHVybiAoPGxpXG4gICAgICAgIGJlbT0nZTppdGVtJ1xuICAgICAgICBrZXk9e2lkZW50aWZpZXJ9XG4gICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uSXRlbUNsaWNrLmJpbmQodGhpcywgaWRlbnRpZmllcil9PlxuICAgICAgICA8YmVtIHNwZWNpZmllcj0nJGI6Y29udHJvbHMnPlxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGJlbT0nJGU6YnV0dG9uIG06d2l0aElubGluZUxhYmVsJz5cbiAgICAgICAgICAgIDxpbWcgYmVtPSdlOmljb24nIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKGBjb250cm9scy9maWx0ZXJzLyR7aWRlbnRpZmllcn0ucG5nYCwgdHJ1ZSl9IC8+XG4gICAgICAgICAgICA8ZGl2IGJlbT0nJGU6aW5saW5lTGFiZWwnIGNsYXNzTmFtZT17KGlkZW50aWZpZXIgPT09IGN1cnJlbnRGaWx0ZXJJZGVudGlmaWVyKSA/ICdpcy1hY3RpdmUnIDogbnVsbH0+XG4gICAgICAgICAgICAgIDxkaXYgYmVtPSdlOmxhYmVsJz57XG4gICAgICAgICAgICAgICAgdGhpcy5fdChgcGVzZGsuZmlsdGVyLmFzc2V0LiR7ZmlsdGVyLmlkZW50aWZpZXJ9YCkgfHxcbiAgICAgICAgICAgICAgICBmaWx0ZXIuZGVmYXVsdE5hbWVcbiAgICAgICAgICAgICAgfTwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvYmVtPlxuICAgICAgPC9saT4pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjYXRlZ29yeSBkcm9wZG93biAoaWYgcHJlc2VudClcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJDYXRlZ29yeURyb3Bkb3duICgpIHtcbiAgICBjb25zdCBjYXRlZ29yaWVzID0gdGhpcy5fZmlsdGVyTWFuYWdlci5nZXRDYXRlZ29yaWVzKClcbiAgICBjb25zdCBjYXRlZ29yeURyb3Bkb3duVmlzaWJsZSA9XG4gICAgICAhdGhpcy5wcm9wcy5vcHRpb25zLmhpZGVDYXRlZ29yaWVzICYmXG4gICAgICBjYXRlZ29yaWVzLmxlbmd0aCA+IDFcbiAgICBpZiAoIWNhdGVnb3J5RHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0IGNhdGVnb3J5SXRlbXMgPSBjYXRlZ29yaWVzLm1hcCgoYykgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWRlbnRpZmllcjogYy5pZGVudGlmaWVyLFxuICAgICAgICBpdGVtOiBjLFxuICAgICAgICBsYWJlbDogdGhpcy5fdChgcGVzZGsuZmlsdGVyLmFzc2V0LiR7Yy5pZGVudGlmaWVyfWApIHx8IGMuZGVmYXVsdE5hbWUsXG4gICAgICAgIGljb246IHRoaXMuX2dldEFzc2V0UGF0aChgY29udHJvbHMvZmlsdGVycy9jYXRlZ29yaWVzLyR7Yy5pZGVudGlmaWVyfS5wbmdgLCB0cnVlKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBzZWxlY3RlZENhdGVnb3J5ID0ge1xuICAgICAgaWRlbnRpZmllcjogdGhpcy5zdGF0ZS5jYXRlZ29yeS5pZGVudGlmaWVyLFxuICAgICAgaXRlbTogdGhpcy5zdGF0ZS5jYXRlZ29yeSxcbiAgICAgIGxhYmVsOiB0aGlzLl90KGBwZXNkay5maWx0ZXIuYXNzZXQuJHt0aGlzLnN0YXRlLmNhdGVnb3J5LmlkZW50aWZpZXJ9YCkgfHwgdGhpcy5zdGF0ZS5jYXRlZ29yeS5kZWZhdWx0TmFtZSxcbiAgICAgIGljb246IHRoaXMuX2dldEFzc2V0UGF0aChgY29udHJvbHMvZmlsdGVycy9jYXRlZ29yaWVzLyR7dGhpcy5zdGF0ZS5jYXRlZ29yeS5pZGVudGlmaWVyfS5wbmdgLCB0cnVlKVxuICAgIH1cblxuICAgIHJldHVybiAoPGRpdiBiZW09J2U6Y2VsbCBtOmNhdGVnb3J5RHJvcGRvd24nPlxuICAgICAgPENhdGVnb3J5RHJvcGRvd25Db21wb25lbnRcbiAgICAgICAgaXRlbXM9e2NhdGVnb3J5SXRlbXN9XG4gICAgICAgIHNlbGVjdGVkSXRlbT17c2VsZWN0ZWRDYXRlZ29yeX1cbiAgICAgICAgb25DaGFuZ2U9e3RoaXMuX29uQ2F0ZWdvcnlDaGFuZ2V9IC8+XG4gICAgPC9kaXY+KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGNvbnRyb2xzIG9mIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJDb250cm9scyAoKSB7XG4gICAgY29uc3QgbGlzdEl0ZW1zID0gdGhpcy5fcmVuZGVyTGlzdEl0ZW1zKClcbiAgICBjb25zdCBjYXRlZ29yeURyb3Bkb3duID0gdGhpcy5fcmVuZGVyQ2F0ZWdvcnlEcm9wZG93bigpXG5cbiAgICByZXR1cm4gW1xuICAgICAgY2F0ZWdvcnlEcm9wZG93bixcbiAgICAgICg8ZGl2IGJlbT0nZTpjZWxsIG06bGlzdCc+XG4gICAgICAgIDxTY3JvbGxiYXJDb21wb25lbnQgcmVmPSdzY3JvbGxiYXInPlxuICAgICAgICAgIDx1bCBiZW09JyRlOmxpc3QnPlxuICAgICAgICAgICAge2xpc3RJdGVtc31cbiAgICAgICAgICA8L3VsPlxuICAgICAgICA8L1Njcm9sbGJhckNvbXBvbmVudD5cbiAgICAgIDwvZGl2PilcbiAgICBdXG4gIH1cbn1cblxuRmlsdGVyQ29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzID0gQ29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL2ZpbHRlci9maWx0ZXItY29udHJvbHMtY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vZ2xvYmFscydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2F0ZWdvcnlEcm9wZG93bk92ZXJsYXlDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIGFuIGl0ZW1cbiAgICogQHBhcmFtICB7T2JqZWN0fSBpdGVtXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25JdGVtQ2xpY2sgKGl0ZW0pIHtcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlICYmXG4gICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKGl0ZW0uaXRlbSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBsaXN0IGl0ZW1zXG4gICAqIEByZXR1cm4ge0FycmF5LjxSZWFjdC5FbGVtZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJMaXN0SXRlbXMgKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLml0ZW1zXG4gICAgICAubWFwKChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IGl0ZW0uaWRlbnRpZmllciA9PT0gdGhpcy5wcm9wcy5zZWxlY3RlZEl0ZW0uaWRlbnRpZmllclxuICAgICAgICByZXR1cm4gPGxpXG4gICAgICAgICAgYmVtPSckZTppdGVtJ1xuICAgICAgICAgIGNsYXNzTmFtZT17YWN0aXZlID8gJyBpcy1hY3RpdmUnIDogJyd9XG4gICAgICAgICAgb25DbGljaz17dGhpcy5fb25JdGVtQ2xpY2suYmluZCh0aGlzLCBpdGVtKX0+XG4gICAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXtpdGVtLmljb259IC8+XG4gICAgICAgICAgPGRpdiBiZW09J2U6bGFiZWwnPntpdGVtLmxhYmVsfTwvZGl2PlxuICAgICAgICA8L2xpPlxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICByZXR1cm4gKDxkaXYgYmVtPSckYjpjYXRlZ29yeURyb3Bkb3duICRlOm92ZXJsYXknPlxuICAgICAgPHVsIGJlbT0nJGU6bGlzdCc+XG4gICAgICAgIHt0aGlzLl9yZW5kZXJMaXN0SXRlbXMoKX1cbiAgICAgIDwvdWw+XG4gICAgPC9kaXY+KVxuICB9XG59XG5cbkNhdGVnb3J5RHJvcGRvd25PdmVybGF5Q29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NhdGVnb3J5LWRyb3Bkb3duL292ZXJsYXktY29tcG9uZW50LmpzeCIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IENvbnRyb2xzIGZyb20gJy4uL2NvbnRyb2xzJ1xuaW1wb3J0IEZvY3VzQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi9mb2N1cy1jb250cm9scy1jb21wb25lbnQnXG5pbXBvcnQgRm9jdXNDYW52YXNDb250cm9sc0NvbXBvbmVudCBmcm9tICcuL2ZvY3VzLWNhbnZhcy1jb250cm9scy1jb21wb25lbnQnXG5cbi8qKlxuICogVGhlIGZvY3VzIGNvbnRyb2xzXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbFxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNcbiAqL1xuY2xhc3MgRm9jdXNDb250cm9scyBleHRlbmRzIENvbnRyb2xzIHtcbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGNvbnRyb2wgaXMgYXZhaWxhYmxlIHRvIHRoZSB1c2VyXG4gICAqIEBwYXJhbSAge0VkaXRvcn0gZWRpdG9yXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBpc0F2YWlsYWJsZSAoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1Rvb2xBbGxvd2VkKCdmb2N1cycpICYmXG4gICAgICAoZWRpdG9yLmlzVG9vbEVuYWJsZWQoJ3JhZGlhbC1mb2N1cycpIHx8XG4gICAgICBlZGl0b3IuaXNUb29sRW5hYmxlZCgnbWlycm9yZWQtZm9jdXMnKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGxlYXZlcyB0aGVzZSBjb250cm9sc1xuICAgKiBAdGhpcyB7Rm9jdXNDb250cm9sc0NvbXBvbmVudH1cbiAgICogQG92ZXJyaWRlXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBvbkV4aXQgKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBlZGl0b3IuZmVhdHVyZXMuZW5hYmxlKCd6b29tJywgJ2RyYWcnKVxuXG4gICAgY29uc3QgaW5pdGlhbE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdpbml0aWFsT3B0aW9ucycpXG4gICAgY29uc3QgaW5pdGlhbE9wZXJhdGlvbiA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2luaXRpYWxPcGVyYXRpb24nKVxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpXG5cbiAgICBpZiAoKCFvcGVyYXRpb24gJiYgaW5pdGlhbE9wZXJhdGlvbikgfHxcbiAgICAgIChvcGVyYXRpb24gJiYgaW5pdGlhbE9wZXJhdGlvbiAmJiBvcGVyYXRpb24uY29uc3RydWN0b3IgPT09IGluaXRpYWxPcGVyYXRpb24uY29uc3RydWN0b3IpKSB7XG4gICAgICBlZGl0b3IuaGlzdG9yeS5hZGQoaW5pdGlhbE9wZXJhdGlvbixcbiAgICAgICAgaW5pdGlhbE9wdGlvbnMsXG4gICAgICAgIHRydWUpXG4gICAgfVxuXG4gICAgaWYgKG9wZXJhdGlvbiAmJiAhaW5pdGlhbE9wZXJhdGlvbikge1xuICAgICAgZWRpdG9yLmhpc3RvcnkuYWRkKG9wZXJhdGlvbixcbiAgICAgICAge30sXG4gICAgICAgIGZhbHNlKVxuICAgIH1cblxuICAgIGlmIChvcGVyYXRpb24gJiYgaW5pdGlhbE9wZXJhdGlvbiAmJiBvcGVyYXRpb24uY29uc3RydWN0b3IgIT09IGluaXRpYWxPcGVyYXRpb24uY29uc3RydWN0b3IpIHtcbiAgICAgIGVkaXRvci5oaXN0b3J5LmFkZChbe1xuICAgICAgICBvcGVyYXRpb246IGluaXRpYWxPcGVyYXRpb24sXG4gICAgICAgIG9wdGlvbnM6IGluaXRpYWxPcHRpb25zLFxuICAgICAgICBleGlzdGVudDogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBvcGVyYXRpb24sXG4gICAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgICBleGlzdGVudDogZmFsc2VcbiAgICAgIH1dKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGVudGVycyB0aGVzZSBjb250cm9sc1xuICAgKiBAdGhpcyB7Rm9jdXNDb250cm9sc0NvbXBvbmVudH1cbiAgICogQHBhcmFtIHtTaGFyZWRTdGF0ZX0gc2hhcmVkU3RhdGVcbiAgICogQG92ZXJyaWRlXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBvbkVudGVyIChzaGFyZWRTdGF0ZSkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBvcGVyYXRpb24gPSBlZGl0b3Iub3BlcmF0aW9ucy5nZXQoJ21pcnJvcmVkLWZvY3VzJykgfHwgZWRpdG9yLm9wZXJhdGlvbnMuZ2V0KCdyYWRpYWwtZm9jdXMnKVxuXG4gICAgbGV0IGluaXRpYWxPcHRpb25zID0ge31cbiAgICBpZiAob3BlcmF0aW9uKSB7XG4gICAgICBpbml0aWFsT3B0aW9ucyA9IG9wZXJhdGlvbi5zZXJpYWxpemVPcHRpb25zKClcbiAgICAgIGRlbGV0ZSBpbml0aWFsT3B0aW9ucy5lbmFibGVkXG4gICAgfVxuXG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7XG4gICAgICBvcGVyYXRpb24sXG4gICAgICBpbml0aWFsT3BlcmF0aW9uOiBvcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb25FeGlzdGVkQmVmb3JlOiAhIW9wZXJhdGlvbixcbiAgICAgIGluaXRpYWxPcHRpb25zLFxuICAgICAgaW5wdXREaW1lbnNpb25zOiBlZGl0b3IuZ2V0T3V0cHV0RGltZW5zaW9ucygpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhc3NldHMgdGhhdCBzaG91bGQgYmUgcHJlbG9hZGVkIGZvciB0aGlzIGNvbnRyb2xcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5FZGl0b3J9IGVkaXRvclxuICAgKiBAcmV0dXJuIHtTdHJpbmdbXX1cbiAgICovXG4gIHN0YXRpYyBnZXRQcmVsb2FkQXNzZXRzIChlZGl0b3IpIHtcbiAgICBsZXQgYXNzZXRzID0gW11cbiAgICBpZiAoZWRpdG9yLmlzVG9vbEVuYWJsZWQoJ3JhZGlhbC1mb2N1cycpKSB7XG4gICAgICBhc3NldHMucHVzaCgnY29udHJvbHMvZm9jdXMvcmFkaWFsLnBuZycpXG4gICAgfVxuICAgIGlmIChlZGl0b3IuaXNUb29sRW5hYmxlZCgnbWlycm9yZWQtZm9jdXMnKSkge1xuICAgICAgYXNzZXRzLnB1c2goJ2NvbnRyb2xzL2ZvY3VzL21pcnJvcmVkLnBuZycpXG4gICAgfVxuXG4gICAgcmV0dXJuIGFzc2V0c1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgY29udHJvbHMgY29tcG9uZW50LiBVc2VkIGZvciB0aGUgbG93ZXIgY29udHJvbHMgcGFydCBvZiB0aGUgZWRpdG9yLlxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNDb21wb25lbnR9XG4gKiBAaWdub3JlXG4gKi9cbkZvY3VzQ29udHJvbHMuY29udHJvbHNDb21wb25lbnQgPSBGb2N1c0NvbnRyb2xzQ29tcG9uZW50XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgY2FudmFzIGNvbXBvbmVudC4gVXNlZCBmb3IgdGhlIHVwcGVyIGNvbnRyb2xzIHBhcnQgb2YgdGhlIGVkaXRvciAob25cbiAqIHRvcCBvZiB0aGUgY2FudmFzKVxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNDb21wb25lbnR9XG4gKiBAaWdub3JlXG4gKi9cbkZvY3VzQ29udHJvbHMuY2FudmFzQ29udHJvbHNDb21wb25lbnQgPSBGb2N1c0NhbnZhc0NvbnRyb2xzQ29tcG9uZW50XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkZvY3VzQ29udHJvbHMuaWRlbnRpZmllciA9ICdmb2N1cydcblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBpY29uIHBhdGhcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAaWdub3JlXG4gKi9cbkZvY3VzQ29udHJvbHMuaWNvblBhdGggPSAnY29udHJvbHMvb3ZlcnZpZXcvZm9jdXMucG5nJ1xuXG4vKipcbiAqIFRoZSBsYW5ndWFnZSBrZXkgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhpcyBmaWx0ZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAaWdub3JlXG4gKi9cbkZvY3VzQ29udHJvbHMubGFuZ3VhZ2VLZXkgPSAncGVzZGsuZm9jdXMudGl0bGUubmFtZSdcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGlzIGNvbnRyb2xcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkZvY3VzQ29udHJvbHMuZGVmYXVsdE9wdGlvbnMgPSB7XG5cbn1cblxuLyoqXG4gKiBUaGUgb3BlcmF0aW9ucyByZXF1aXJlZCBmb3IgdGhpcyBjb250cm9sIHRvIHdvcmsgcHJvcGVybHlcbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuRm9jdXNDb250cm9scy5yZXF1aXJlZE9wZXJhdGlvbnMgPSBbJ3JhZGlhbC1mb2N1cycsICdtaXJyb3JlZC1mb2N1cycsICdsaW5lYXItZm9jdXMnLCAnYmx1ciddXG5cbmV4cG9ydCBkZWZhdWx0IEZvY3VzQ29udHJvbHNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvZm9jdXMvaW5kZXguanMiLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQ29uc3RhbnRzIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBDb250cm9sc0NvbXBvbmVudCBmcm9tICcuLi9jb250cm9scy1jb21wb25lbnQnXG5pbXBvcnQgU2Nyb2xsYmFyQ29tcG9uZW50IGZyb20gJy4uLy4uL3Njcm9sbGJhci1jb21wb25lbnQnXG5pbXBvcnQgU2xpZGVyT3ZlcmxheUNvbXBvbmVudCBmcm9tICcuLi9zbGlkZXItb3ZlcmxheS1jb21wb25lbnQnXG5cbmNvbnN0IElURU1TID0gW1xuICB7IHRvb2xOYW1lOiAncmFkaWFsLWZvY3VzJywgaWNvbk5hbWU6ICdyYWRpYWwnLCBsYW5ndWFnZUtleTogJ3Blc2RrLmZvY3VzLmJ1dHRvbi5yYWRpYWwnIH0sXG4gIHsgdG9vbE5hbWU6ICdtaXJyb3JlZC1mb2N1cycsIGljb25OYW1lOiAnbWlycm9yZWQnLCBsYW5ndWFnZUtleTogJ3Blc2RrLmZvY3VzLmJ1dHRvbi5taXJyb3JlZCcgfVxuXVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb2N1c0NvbnRyb2xzQ29tcG9uZW50IGV4dGVuZHMgQ29udHJvbHNDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25CbHVyUmFkaXVzQ2hhbmdlJyxcbiAgICAgICdfb25PcGVyYXRpb25SZW1vdmVkJ1xuICAgIClcbiAgICB0aGlzLl9yZW1vdmVkT3BlcmF0aW9uID0gbnVsbFxuXG4gICAgdGhpcy5fZXZlbnRzID0ge1xuICAgICAgW0NvbnN0YW50cy5FVkVOVFMuT1BFUkFUSU9OX1JFTU9WRURdOiB0aGlzLl9vbk9wZXJhdGlvblJlbW92ZWRcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgc2xpZGVyIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQmx1clJhZGl1c0NoYW5nZSAodmFsdWUpIHtcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxuICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2lucHV0RGltZW5zaW9ucycpXG4gICAgb3BlcmF0aW9uLnNldEJsdXJSYWRpdXModmFsdWUgLyBpbnB1dERpbWVuc2lvbnMubWluKCkpXG5cbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgZWRpdG9yLnJlbmRlcigpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb25lIG9mIHRoZSBidXR0b25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0b29sTmFtZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25CdXR0b25DbGljayAodG9vbE5hbWUsIGUpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3QgcHJldmlvdXNPcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxuICAgIGlmIChwcmV2aW91c09wZXJhdGlvbikge1xuICAgICAgdGhpcy5fcmVtb3ZlZE9wZXJhdGlvbiA9IHByZXZpb3VzT3BlcmF0aW9uXG4gICAgICBlZGl0b3Iub3BlcmF0aW9ucy5yZW1vdmUocHJldmlvdXNPcGVyYXRpb24pXG4gICAgfVxuXG4gICAgbGV0IG5ld09wZXJhdGlvbiA9IG51bGxcbiAgICBpZiAodG9vbE5hbWUpIHtcbiAgICAgIG5ld09wZXJhdGlvbiA9IGVkaXRvci5vcGVyYXRpb25zLmdldE9yQ3JlYXRlKHRvb2xOYW1lKVxuICAgIH1cblxuICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUoeyBvcGVyYXRpb246IG5ld09wZXJhdGlvbiB9KVxuICAgIGVkaXRvci5yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYW4gb3BlcmF0aW9uIGhhcyBiZWVuIHJlbW92ZWRcbiAgICogQHBhcmFtICB7T3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk9wZXJhdGlvblJlbW92ZWQgKG9wZXJhdGlvbikge1xuICAgIGNvbnN0IGN1cnJlbnRPcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxuICAgIGlmICghY3VycmVudE9wZXJhdGlvbiB8fCBvcGVyYXRpb24gIT09IGN1cnJlbnRPcGVyYXRpb24gfHwgb3BlcmF0aW9uID09PSB0aGlzLl9yZW1vdmVkT3BlcmF0aW9uKSByZXR1cm5cbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkNsaWNrZWQpIHJldHVyblxuXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IGlkZW50aWZpZXIgPSBjdXJyZW50T3BlcmF0aW9uLmNvbnN0cnVjdG9yLmlkZW50aWZpZXJcbiAgICBjb25zdCBuZXdPcGVyYXRpb24gPSBlZGl0b3Iub3BlcmF0aW9ucy5nZXRPckNyZWF0ZShpZGVudGlmaWVyKVxuXG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7XG4gICAgICBvcGVyYXRpb246IG5ld09wZXJhdGlvbixcbiAgICAgIG9wZXJhdGlvbkV4aXN0ZWRCZWZvcmU6IGZhbHNlLFxuICAgICAgaW5pdGlhbE9wdGlvbnM6IHt9XG4gICAgfSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvdmVybGF5IGNvbnRyb2xzIG9mIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJPdmVybGF5Q29udHJvbHMgKCkge1xuICAgIGNvbnN0IGZvY3VzT3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICBpZiAoIWZvY3VzT3BlcmF0aW9uKSByZXR1cm4gbnVsbFxuXG4gICAgY29uc3QgaW5wdXREaW1lbnNpb25zID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnaW5wdXREaW1lbnNpb25zJylcbiAgICBjb25zdCBzaG9ydGVzdFNpZGUgPSBpbnB1dERpbWVuc2lvbnMubWluKClcbiAgICBjb25zdCB2YWx1ZSA9IGZvY3VzT3BlcmF0aW9uLmdldEJsdXJSYWRpdXMoKSAqIHNob3J0ZXN0U2lkZVxuICAgIHJldHVybiAoPFNsaWRlck92ZXJsYXlDb21wb25lbnRcbiAgICAgIG1pblZhbHVlPXswfVxuICAgICAgbWF4VmFsdWU9e01hdGgubWluKDE4MCwgTWF0aC5yb3VuZChzaG9ydGVzdFNpZGUgKiAwLjEpKX1cbiAgICAgIHZhbHVlVW5pdD0ncHgnXG4gICAgICBtaWRkbGVEb3Q9e2ZhbHNlfVxuICAgICAgbGFiZWw9e3RoaXMuX3QoJ3Blc2RrLmZvY3VzLnRleHQuYmx1clJhZGl1cycpfVxuICAgICAgb25DaGFuZ2U9e3RoaXMuX29uQmx1clJhZGl1c0NoYW5nZX1cbiAgICAgIHZhbHVlPXt2YWx1ZX0gLz4pXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgbGlzdCBpdGVtcyBmb3IgdGhpcyBjb250cm9sXG4gICAqIEByZXR1cm4ge0FycmF5LjxSZWFjdEJFTS5FbGVtZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJMaXN0SXRlbXMgKCkge1xuICAgIGNvbnN0IGZvY3VzT3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcblxuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBub0ZvY3VzSXRlbSA9ICg8bGlcbiAgICAgIGJlbT0nZTppdGVtJ1xuICAgICAga2V5PSdub25lJz5cbiAgICAgIDxiZW0gc3BlY2lmaWVyPSckYjpjb250cm9scyc+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBiZW09JyRlOmJ1dHRvbiBtOndpdGhMYWJlbCdcbiAgICAgICAgICBjbGFzc05hbWU9eyFmb2N1c09wZXJhdGlvbiA/ICdpcy1hY3RpdmUnIDogbnVsbH1cbiAgICAgICAgICBvbkNsaWNrPXt0aGlzLl9vbkJ1dHRvbkNsaWNrLmJpbmQodGhpcywgbnVsbCl9PlxuICAgICAgICAgIDxpbWcgYmVtPSdlOmljb24nIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKCdjb250cm9scy9mb2N1cy9ub25lLnBuZycsIHRydWUpfSAvPlxuICAgICAgICAgIDxkaXYgYmVtPSdlOmxhYmVsJz57dGhpcy5fdCgncGVzZGsuZm9jdXMuYnV0dG9uLm5vbmUnKX08L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2JlbT5cbiAgICA8L2xpPilcblxuICAgIHJldHVybiBbbm9Gb2N1c0l0ZW1dLmNvbmNhdChJVEVNU1xuICAgICAgLmZpbHRlcigoeyB0b29sTmFtZSB9KSA9PiBlZGl0b3IuaXNUb29sRW5hYmxlZCh0b29sTmFtZSkpXG4gICAgICAubWFwKCh7IHRvb2xOYW1lLCBpY29uTmFtZSwgbGFuZ3VhZ2VLZXkgfSkgPT4ge1xuICAgICAgICBjb25zdCBpc0FjdGl2ZSA9IGZvY3VzT3BlcmF0aW9uICYmIGZvY3VzT3BlcmF0aW9uLmNvbnN0cnVjdG9yLmlkZW50aWZpZXIgPT09IHRvb2xOYW1lXG4gICAgICAgIHJldHVybiAoPGxpXG4gICAgICAgICAgYmVtPSdlOml0ZW0nXG4gICAgICAgICAgZGF0YS1pZGVudGlmaWVyPXt0b29sTmFtZX1cbiAgICAgICAgICBrZXk9e3Rvb2xOYW1lfT5cbiAgICAgICAgICA8YmVtIHNwZWNpZmllcj0nJGI6Y29udHJvbHMnPlxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICBiZW09JyRlOmJ1dHRvbiBtOndpdGhMYWJlbCdcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtpc0FjdGl2ZSA/ICdpcy1hY3RpdmUnIDogbnVsbH1cbiAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5fb25CdXR0b25DbGljay5iaW5kKHRoaXMsIHRvb2xOYW1lKX0+XG4gICAgICAgICAgICAgIDxpbWcgYmVtPSdlOmljb24nIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKGBjb250cm9scy9mb2N1cy8ke2ljb25OYW1lfS5wbmdgLCB0cnVlKX0gLz5cbiAgICAgICAgICAgICAgPGRpdiBiZW09J2U6bGFiZWwnPnt0aGlzLl90KGxhbmd1YWdlS2V5KX08L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvYmVtPlxuICAgICAgICA8L2xpPilcbiAgICAgIH0pKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGNvbnRyb2xzIG9mIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJDb250cm9scyAoKSB7XG4gICAgY29uc3QgbGlzdEl0ZW1zID0gdGhpcy5fcmVuZGVyTGlzdEl0ZW1zKClcblxuICAgIHJldHVybiAoPGRpdiBiZW09J2U6Y2VsbCBtOmxpc3QnPlxuICAgICAgPFNjcm9sbGJhckNvbXBvbmVudD5cbiAgICAgICAgPHVsIGJlbT0nJGU6bGlzdCc+XG4gICAgICAgICAge2xpc3RJdGVtc31cbiAgICAgICAgPC91bD5cbiAgICAgIDwvU2Nyb2xsYmFyQ29tcG9uZW50PlxuICAgIDwvZGl2PilcbiAgfVxufVxuXG5Gb2N1c0NvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IENvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9mb2N1cy9mb2N1cy1jb250cm9scy1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cclxuLyogQG1vZHVsZSAqL1xyXG4vKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cclxuICpcclxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxyXG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XHJcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxyXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxyXG4gKlxyXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcclxuICovXHJcblxyXG5pbXBvcnQgeyBSZWFjdEJFTSB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXHJcbmltcG9ydCBDYW52YXNDb250cm9sc0NvbXBvbmVudCBmcm9tICcuLi9jYW52YXMtY29udHJvbHMtY29tcG9uZW50J1xyXG5pbXBvcnQgTGluZWFyRm9jdXNDYW52YXNDb250cm9sc0NvbXBvbmVudCBmcm9tICcuL2xpbmVhci1mb2N1cy1jYW52YXMtY29udHJvbHMtY29tcG9uZW50J1xyXG5pbXBvcnQgUmFkaWFsRm9jdXNDYW52YXNDb250cm9sc0NvbXBvbmVudCBmcm9tICcuL3JhZGlhbC1mb2N1cy1jYW52YXMtY29udHJvbHMtY29tcG9uZW50J1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9jdXNDYW52YXNDb250cm9sc0NvbXBvbmVudCBleHRlbmRzIENhbnZhc0NvbnRyb2xzQ29tcG9uZW50IHtcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgY2FudmFzIGNvbnRyb2xzIGZvciB0aGUgZ2l2ZW4gb3BlcmF0aW9uXHJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufSBvcGVyYXRpb25cclxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2dldENvbnRyb2xzRm9yT3BlcmF0aW9uIChvcGVyYXRpb24pIHtcclxuICAgIGlmICghb3BlcmF0aW9uKSByZXR1cm4gbnVsbFxyXG5cclxuICAgIHN3aXRjaCAob3BlcmF0aW9uLmNvbnN0cnVjdG9yLmlkZW50aWZpZXIpIHtcclxuICAgICAgY2FzZSAnbWlycm9yZWQtZm9jdXMnOlxyXG4gICAgICAgIHJldHVybiBMaW5lYXJGb2N1c0NhbnZhc0NvbnRyb2xzQ29tcG9uZW50XHJcbiAgICAgIGNhc2UgJ3JhZGlhbC1mb2N1cyc6XHJcbiAgICAgICAgcmV0dXJuIFJhZGlhbEZvY3VzQ2FudmFzQ29udHJvbHNDb21wb25lbnRcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcclxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxyXG4gICAqL1xyXG4gIHJlbmRlcldpdGhCRU0gKCkge1xyXG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcclxuICAgIGNvbnN0IENvbnRyb2xzID0gdGhpcy5fZ2V0Q29udHJvbHNGb3JPcGVyYXRpb24ob3BlcmF0aW9uKVxyXG4gICAgaWYgKCFDb250cm9scykgcmV0dXJuIDxkaXYgLz5cclxuICAgIHJldHVybiA8Q29udHJvbHMgey4uLnRoaXMucHJvcHN9IC8+XHJcbiAgfVxyXG59XHJcblxyXG5Gb2N1c0NhbnZhc0NvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IENhbnZhc0NvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlc1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL2ZvY3VzL2ZvY3VzLWNhbnZhcy1jb250cm9scy1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIFZlY3RvcjIsIENvbnN0YW50cyB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgRHJhZ2dhYmxlQ29tcG9uZW50IGZyb20gJy4uLy4uL2RyYWdnYWJsZS1jb21wb25lbnQuanN4J1xuaW1wb3J0IENhbnZhc0NvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4uL2NhbnZhcy1jb250cm9scy1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVhckZvY3VzQ2FudmFzQ29udHJvbHNDb21wb25lbnQgZXh0ZW5kcyBDYW52YXNDb250cm9sc0NvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uQ2VudGVyRHJhZ1N0YXJ0JyxcbiAgICAgICdfb25DZW50ZXJEcmFnJyxcbiAgICAgICdfb25Lbm9iRHJhZ1N0YXJ0JyxcbiAgICAgICdfb25Lbm9iRHJhZycsXG4gICAgICAnX29uT3BlcmF0aW9uVXBkYXRlZCdcbiAgICApXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgYXJlYVBvc2l0aW9uOiBuZXcgVmVjdG9yMigpLFxuICAgICAgYXJlYURpbWVuc2lvbnM6IG5ldyBWZWN0b3IyKCksXG4gICAgICBrbm9iUG9zaXRpb246IG5ldyBWZWN0b3IyKClcbiAgICB9XG4gICAgdGhpcy5fb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcblxuICAgIHRoaXMuX2V2ZW50cyA9IHtcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLk9QRVJBVElPTl9VUERBVEVEXTogdGhpcy5fb25PcGVyYXRpb25VcGRhdGVkXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIGFmdGVyIHRoZSBjYW52YXMgaGFzIGJlZW4gem9vbWVkIGluIG9yIG91dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ2FudmFzWm9vbURvbmUgKCkge1xuICAgIHRoaXMuX3NldFN0eWxlc0Zyb21PcHRpb25zKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGFuIG9wZXJhdGlvbiBoYXMgYmVlbiB1cGRhdGVkXG4gICAqIEBwYXJhbSAge09wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25PcGVyYXRpb25VcGRhdGVkIChvcGVyYXRpb24pIHtcbiAgICBpZiAob3BlcmF0aW9uICE9PSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKSkgcmV0dXJuXG4gICAgdGhpcy5fc2V0U3R5bGVzRnJvbU9wdGlvbnMoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHNoYXJlZCBzdGF0ZSBkaWQgY2hhbmdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdTdGF0ZVxuICAgKi9cbiAgc2hhcmVkU3RhdGVEaWRDaGFuZ2UgKG5ld1N0YXRlKSB7XG4gICAgaWYgKG5ld1N0YXRlLm9wZXJhdGlvbikge1xuICAgICAgdGhpcy5fb3BlcmF0aW9uID0gbmV3U3RhdGUub3BlcmF0aW9uXG4gICAgICBpZiAodGhpcy5fb3BlcmF0aW9uLmNvbnN0cnVjdG9yLmlkZW50aWZpZXIgPT09ICdtaXJyb3JlZC1mb2N1cycpIHRoaXMuX3NldFN0eWxlc0Zyb21PcHRpb25zKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgc3VwZXIuY29tcG9uZW50RGlkTW91bnQoKVxuXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGVkaXRvci56b29tLnNldCgnYXV0bycsICgpID0+IHtcbiAgICAgIGVkaXRvci5mZWF0dXJlcy5kaXNhYmxlKCd6b29tJywgJ2RyYWcnKVxuICAgICAgdGhpcy5fc2V0U3R5bGVzRnJvbU9wdGlvbnMoKVxuICAgIH0pXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBDRU5URVIgRFJBR0dJTkdcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdGFycyBkcmFnZ2luZyB0aGUgY2VudGVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25DZW50ZXJEcmFnU3RhcnQgKCkge1xuICAgIHRoaXMuX2luaXRpYWxTdGFydCA9IHRoaXMuX29wZXJhdGlvbi5nZXRTdGFydCgpXG4gICAgdGhpcy5faW5pdGlhbEVuZCA9IHRoaXMuX29wZXJhdGlvbi5nZXRFbmQoKVxuICAgIHRoaXMuX2luaXRpYWxEaXN0ID0gdGhpcy5faW5pdGlhbEVuZC5jbG9uZSgpXG4gICAgICAuc3VidHJhY3QodGhpcy5faW5pdGlhbFN0YXJ0KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBjZW50ZXJcbiAgICogQHBhcmFtIHtWZWN0b3IyfSBvZmZzZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNlbnRlckRyYWcgKG9mZnNldCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcblxuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSBlZGl0b3IuZ2V0T3V0cHV0RGltZW5zaW9ucygpXG4gICAgY29uc3QgcmVsYXRpdmVPZmZzZXQgPSBvZmZzZXQuY2xvbmUoKVxuICAgICAgLmRpdmlkZShvdXRwdXREaW1lbnNpb25zKVxuXG4gICAgY29uc3QgbmV3U3RhcnQgPSB0aGlzLl9pbml0aWFsU3RhcnQuY2xvbmUoKS5hZGQocmVsYXRpdmVPZmZzZXQpXG4gICAgICAuY2xhbXAoXG4gICAgICAgIG5ldyBWZWN0b3IyKDAsIDApLFxuICAgICAgICBuZXcgVmVjdG9yMigxLCAxKS5zdWJ0cmFjdCh0aGlzLl9pbml0aWFsRGlzdClcbiAgICAgIClcbiAgICBjb25zdCBuZXdFbmQgPSBuZXdTdGFydC5jbG9uZSgpLmFkZCh0aGlzLl9pbml0aWFsRGlzdClcblxuICAgIHRoaXMuX29wZXJhdGlvbi5zZXQoe1xuICAgICAgc3RhcnQ6IG5ld1N0YXJ0LFxuICAgICAgZW5kOiBuZXdFbmRcbiAgICB9KVxuXG4gICAgZWRpdG9yLnJlbmRlcigpXG4gICAgdGhpcy5fc2V0U3R5bGVzRnJvbU9wdGlvbnMoKVxuICAgIHRoaXMuZm9yY2VVcGRhdGUoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gR1JBRElFTlQgS05PQiBEUkFHXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RhcnMgZHJhZ2dpbmcgdGhlIGdyYWRpZW50IGtub2JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbktub2JEcmFnU3RhcnQgKGUpIHtcbiAgICB0aGlzLl9pbml0aWFsS25vYlBvc2l0aW9uID0gdGhpcy5zdGF0ZS5rbm9iUG9zaXRpb24uY2xvbmUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBncmFkaWVudCBrbm9iXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gb2Zmc2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Lbm9iRHJhZyAob2Zmc2V0KSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSBlZGl0b3IuZ2V0T3V0cHV0RGltZW5zaW9ucygpXG5cbiAgICBjb25zdCBuZXdLbm9iUG9zaXRpb24gPSB0aGlzLl9pbml0aWFsS25vYlBvc2l0aW9uLmNsb25lKClcbiAgICAgIC5hZGQob2Zmc2V0KVxuICAgICAgLmNsYW1wKG5ldyBWZWN0b3IyKDAsIDApLCBvdXRwdXREaW1lbnNpb25zKVxuXG4gICAgY29uc3QgZGlzdGFuY2VGcm9tQ2VudGVyID0gbmV3S25vYlBvc2l0aW9uLmNsb25lKClcbiAgICAgIC5zdWJ0cmFjdCh0aGlzLnN0YXRlLmFyZWFQb3NpdGlvbilcblxuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGF0ZS5hcmVhUG9zaXRpb24uY2xvbmUoKVxuICAgICAgLmFkZCgtZGlzdGFuY2VGcm9tQ2VudGVyLnksIGRpc3RhbmNlRnJvbUNlbnRlci54KVxuICAgICAgLmRpdmlkZShvdXRwdXREaW1lbnNpb25zKVxuICAgIGNvbnN0IGVuZCA9IHRoaXMuc3RhdGUuYXJlYVBvc2l0aW9uLmNsb25lKClcbiAgICAgIC5hZGQoZGlzdGFuY2VGcm9tQ2VudGVyLnksIC1kaXN0YW5jZUZyb21DZW50ZXIueClcbiAgICAgIC5kaXZpZGUob3V0cHV0RGltZW5zaW9ucylcbiAgICBjb25zdCBzaXplID0gZGlzdGFuY2VGcm9tQ2VudGVyLmxlbigpICogMlxuXG4gICAgdGhpcy5fb3BlcmF0aW9uLnNldCh7XG4gICAgICBzdGFydCxcbiAgICAgIGVuZCxcbiAgICAgIHNpemU6IHNpemUgLyBvdXRwdXREaW1lbnNpb25zLm1pbigpLFxuICAgICAgZ3JhZGllbnRTaXplOiBzaXplIC8gb3V0cHV0RGltZW5zaW9ucy5taW4oKVxuICAgIH0pXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBrbm9iUG9zaXRpb246IG5ld0tub2JQb3NpdGlvbixcbiAgICAgIGFyZWFEaW1lbnNpb25zOiBuZXcgVmVjdG9yMih0aGlzLnN0YXRlLmFyZWFEaW1lbnNpb25zLngsIHNpemUpXG4gICAgfSlcbiAgICBlZGl0b3IucmVuZGVyKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFNUWUxJTkdcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgQ1NTIHN0eWxlcyBmb3IgdGhlIGFyZWEgZGl2XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRBcmVhU3R5bGUgKCkge1xuICAgIGNvbnN0IGRpc3QgPSB0aGlzLnN0YXRlLmtub2JQb3NpdGlvbi5jbG9uZSgpXG4gICAgICAuc3VidHJhY3QodGhpcy5zdGF0ZS5hcmVhUG9zaXRpb24pXG4gICAgbGV0IGRlZ3JlZXMgPSBNYXRoLmF0YW4yKGRpc3QueCwgZGlzdC55KSAqICgxODAgLyBNYXRoLlBJKVxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IGByb3RhdGUoJHsoLWRlZ3JlZXMpLnRvRml4ZWQoMil9ZGVnKWBcblxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogdGhpcy5zdGF0ZS5hcmVhRGltZW5zaW9ucy54LFxuICAgICAgaGVpZ2h0OiB0aGlzLnN0YXRlLmFyZWFEaW1lbnNpb25zLnksXG4gICAgICBsZWZ0OiB0aGlzLnN0YXRlLmFyZWFQb3NpdGlvbi54LFxuICAgICAgdG9wOiB0aGlzLnN0YXRlLmFyZWFQb3NpdGlvbi55LFxuICAgICAgbWFyZ2luTGVmdDogdGhpcy5zdGF0ZS5hcmVhRGltZW5zaW9ucy54ICogLTAuNSxcbiAgICAgIG1hcmdpblRvcDogdGhpcy5zdGF0ZS5hcmVhRGltZW5zaW9ucy55ICogLTAuNSxcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgTW96VHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICBtc1RyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgV2Via2l0VHJhbnNmb3JtOiB0cmFuc2Zvcm1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgQ1NTIHN0eWxlcyBmb3IgdGhlIGtub2JcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEtub2JTdHlsZSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IHRoaXMuc3RhdGUua25vYlBvc2l0aW9uLngsXG4gICAgICB0b3A6IHRoaXMuc3RhdGUua25vYlBvc2l0aW9uLnlcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogU2V0cyB0aGUgZGltZW5zaW9ucyBhbmQgcG9zaXRpb24gdmFsdWVzIGZyb20gdGhlIGN1cnJlbnQgb3BlcmF0aW9uIG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRTdHlsZXNGcm9tT3B0aW9ucyAoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSBlZGl0b3IuZ2V0T3V0cHV0RGltZW5zaW9ucygpXG5cbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX29wZXJhdGlvbi5nZXRTdGFydCgpLmNsb25lKCkubXVsdGlwbHkob3V0cHV0RGltZW5zaW9ucylcbiAgICBjb25zdCBlbmQgPSB0aGlzLl9vcGVyYXRpb24uZ2V0RW5kKCkuY2xvbmUoKS5tdWx0aXBseShvdXRwdXREaW1lbnNpb25zKVxuICAgIGNvbnN0IHNpemUgPSB0aGlzLl9vcGVyYXRpb24uZ2V0U2l6ZSgpICogb3V0cHV0RGltZW5zaW9ucy5taW4oKVxuXG4gICAgY29uc3QgZGlzdCA9IGVuZC5jbG9uZSgpLnN1YnRyYWN0KHN0YXJ0KVxuICAgIGNvbnN0IG1pZGRsZSA9IHN0YXJ0LmNsb25lKClcbiAgICAgIC5hZGQoZGlzdC5jbG9uZSgpLmRpdmlkZSgyKSlcblxuICAgIGNvbnN0IGFyZWFTaXplID0gbmV3IFZlY3RvcjIoXG4gICAgICBvdXRwdXREaW1lbnNpb25zLmxlbigpICogMixcbiAgICAgIHNpemVcbiAgICApXG5cbiAgICBjb25zdCB0b3RhbERpc3QgPSBkaXN0LmxlbigpXG4gICAgY29uc3QgZmFjdG9yID0gZGlzdC5jbG9uZSgpLmRpdmlkZSh0b3RhbERpc3QpLmRpdmlkZSgyKVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBhcmVhRGltZW5zaW9uczogYXJlYVNpemUsXG4gICAgICBhcmVhUG9zaXRpb246IG1pZGRsZS5jbG9uZSgpLFxuICAgICAga25vYlBvc2l0aW9uOiBtaWRkbGUuY2xvbmUoKVxuICAgICAgICAuYWRkKC1zaXplICogZmFjdG9yLnksIHNpemUgKiBmYWN0b3IueClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbnRhaW5lciBzdHlsZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0Q29udGFpbmVyU3R5bGUgKCkge1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXRTREsoKS5nZXRTcHJpdGUoKS5nZXRCb3VuZHMoKVxuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB4LFxuICAgICAgdG9wOiB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgcmV0dXJuICg8ZGl2IGJlbT0nYjpjYW52YXNDb250cm9scyBlOmNvbnRhaW5lciBtOmZ1bGwnIHJlZj0nY29udGFpbmVyJyBzdHlsZT17dGhpcy5fZ2V0Q29udGFpbmVyU3R5bGUoKX0+XG4gICAgICA8ZGl2IGJlbT0nJGI6bGluZWFyRm9jdXNDYW52YXNDb250cm9scyc+XG4gICAgICAgIDxEcmFnZ2FibGVDb21wb25lbnRcbiAgICAgICAgICBvblN0YXJ0PXt0aGlzLl9vbkNlbnRlckRyYWdTdGFydH1cbiAgICAgICAgICBvbkRyYWc9e3RoaXMuX29uQ2VudGVyRHJhZ30+XG4gICAgICAgICAgPGRpdiBiZW09J2U6YXJlYScgc3R5bGU9e3RoaXMuX2dldEFyZWFTdHlsZSgpfSAvPlxuICAgICAgICA8L0RyYWdnYWJsZUNvbXBvbmVudD5cbiAgICAgICAgPERyYWdnYWJsZUNvbXBvbmVudFxuICAgICAgICAgIG9uU3RhcnQ9e3RoaXMuX29uS25vYkRyYWdTdGFydH1cbiAgICAgICAgICBvbkRyYWc9e3RoaXMuX29uS25vYkRyYWd9PlxuICAgICAgICAgIDxkaXYgYmVtPSdlOmtub2IgJGI6a25vYicgc3R5bGU9e3RoaXMuX2dldEtub2JTdHlsZSgpfSAvPlxuICAgICAgICA8L0RyYWdnYWJsZUNvbXBvbmVudD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PilcbiAgfVxufVxuXG5MaW5lYXJGb2N1c0NhbnZhc0NvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IENhbnZhc0NvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9mb2N1cy9saW5lYXItZm9jdXMtY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgVmVjdG9yMiwgQ29uc3RhbnRzIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBEcmFnZ2FibGVDb21wb25lbnQgZnJvbSAnLi4vLi4vZHJhZ2dhYmxlLWNvbXBvbmVudC5qc3gnXG5pbXBvcnQgQ2FudmFzQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi4vY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkaWFsRm9jdXNDYW52YXNDb250cm9sc0NvbXBvbmVudCBleHRlbmRzIENhbnZhc0NvbnRyb2xzQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25DZW50ZXJEcmFnU3RhcnQnLFxuICAgICAgJ19vbkNlbnRlckRyYWcnLFxuICAgICAgJ19vbktub2JEcmFnU3RhcnQnLFxuICAgICAgJ19vbktub2JEcmFnJyxcbiAgICAgICdfb25PcGVyYXRpb25VcGRhdGVkJ1xuICAgIClcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBhcmVhUG9zaXRpb246IG5ldyBWZWN0b3IyKCksXG4gICAgICBhcmVhRGltZW5zaW9uczogbmV3IFZlY3RvcjIoKSxcbiAgICAgIGtub2JQb3NpdGlvbjogbmV3IFZlY3RvcjIoKVxuICAgIH1cbiAgICB0aGlzLl9rbm9iQ2hhbmdlZE1hbnVhbGx5ID0gZmFsc2VcbiAgICB0aGlzLl9vcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxuXG4gICAgdGhpcy5fZXZlbnRzID0ge1xuICAgICAgW0NvbnN0YW50cy5FVkVOVFMuT1BFUkFUSU9OX1VQREFURURdOiB0aGlzLl9vbk9wZXJhdGlvblVwZGF0ZWRcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgYWZ0ZXIgdGhlIGNhbnZhcyBoYXMgYmVlbiB6b29tZWQgaW4gb3Igb3V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25DYW52YXNab29tRG9uZSAoKSB7XG4gICAgdGhpcy5fc2V0U3R5bGVzRnJvbU9wdGlvbnMoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYW4gb3BlcmF0aW9uIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICogQHBhcmFtICB7T3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk9wZXJhdGlvblVwZGF0ZWQgKG9wZXJhdGlvbikge1xuICAgIGlmIChvcGVyYXRpb24gIT09IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpKSByZXR1cm5cbiAgICB0aGlzLl9rbm9iQ2hhbmdlZE1hbnVhbGx5ID0gZmFsc2VcbiAgICB0aGlzLl9zZXRTdHlsZXNGcm9tT3B0aW9ucygpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBMSUZFQ1lDTEVcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgc2hhcmVkIHN0YXRlIGRpZCBjaGFuZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG5ld1N0YXRlXG4gICAqL1xuICBzaGFyZWRTdGF0ZURpZENoYW5nZSAobmV3U3RhdGUpIHtcbiAgICBpZiAobmV3U3RhdGUub3BlcmF0aW9uKSB7XG4gICAgICB0aGlzLl9vcGVyYXRpb24gPSBuZXdTdGF0ZS5vcGVyYXRpb25cbiAgICAgIGlmICh0aGlzLl9vcGVyYXRpb24uY29uc3RydWN0b3IuaWRlbnRpZmllciA9PT0gJ3JhZGlhbC1mb2N1cycpIHRoaXMuX3NldFN0eWxlc0Zyb21PcHRpb25zKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgc3VwZXIuY29tcG9uZW50RGlkTW91bnQoKVxuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBlZGl0b3Iuem9vbS5zZXQoJ2F1dG8nLCAoKSA9PiB7XG4gICAgICBlZGl0b3IuZmVhdHVyZXMuZGlzYWJsZSgnem9vbScsICdkcmFnJylcbiAgICAgIHRoaXMuX3NldFN0eWxlc0Zyb21PcHRpb25zKClcbiAgICB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gQ0VOVEVSIERSQUdHSU5HXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RhcnMgZHJhZ2dpbmcgdGhlIGNlbnRlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ2VudGVyRHJhZ1N0YXJ0ICgpIHtcbiAgICB0aGlzLl9pbml0aWFsUG9zaXRpb24gPSB0aGlzLl9vcGVyYXRpb24uZ2V0UG9zaXRpb24oKVxuICAgIHRoaXMuX2luaXRpYWxLbm9iUG9zaXRpb24gPSB0aGlzLnN0YXRlLmtub2JQb3NpdGlvbi5jbG9uZSgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIGNlbnRlclxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG9mZnNldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ2VudGVyRHJhZyAob2Zmc2V0KSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuXG4gICAgY29uc3Qgb3V0cHV0RGltZW5zaW9ucyA9IGVkaXRvci5nZXRPdXRwdXREaW1lbnNpb25zKClcbiAgICBjb25zdCByZWxhdGl2ZU9mZnNldCA9IG9mZnNldC5jbG9uZSgpLmRpdmlkZShvdXRwdXREaW1lbnNpb25zKVxuICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gdGhpcy5faW5pdGlhbFBvc2l0aW9uXG4gICAgICAuY2xvbmUoKVxuICAgICAgLmFkZChyZWxhdGl2ZU9mZnNldClcblxuICAgIGNvbnN0IG5ld0tub2JQb3NpdGlvbiA9IHRoaXMuX2luaXRpYWxLbm9iUG9zaXRpb24uY2xvbmUoKVxuICAgICAgLmFkZChvZmZzZXQpXG5cbiAgICB0aGlzLl9vcGVyYXRpb24uc2V0KHtcbiAgICAgIHBvc2l0aW9uOiBuZXdQb3NpdGlvblxuICAgIH0pXG5cbiAgICB0aGlzLnN0YXRlLmtub2JQb3NpdGlvbiA9IG5ld0tub2JQb3NpdGlvblxuXG4gICAgZWRpdG9yLnJlbmRlcigpXG4gICAgdGhpcy5fc2V0U3R5bGVzRnJvbU9wdGlvbnMoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gR1JBRElFTlQgS05PQiBEUkFHXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RhcnMgZHJhZ2dpbmcgdGhlIGdyYWRpZW50IGtub2JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbktub2JEcmFnU3RhcnQgKGUpIHtcbiAgICB0aGlzLl9rbm9iQ2hhbmdlZE1hbnVhbGx5ID0gdHJ1ZVxuICAgIHRoaXMuX2luaXRpYWxLbm9iUG9zaXRpb24gPSB0aGlzLnN0YXRlLmtub2JQb3NpdGlvbi5jbG9uZSgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIGdyYWRpZW50IGtub2JcbiAgICogQHBhcmFtIHtWZWN0b3IyfSBvZmZzZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbktub2JEcmFnIChvZmZzZXQpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgb3V0cHV0RGltZW5zaW9ucyA9IGVkaXRvci5nZXRPdXRwdXREaW1lbnNpb25zKClcblxuICAgIGNvbnN0IG5ld0tub2JQb3NpdGlvbiA9IHRoaXMuX2luaXRpYWxLbm9iUG9zaXRpb24uY2xvbmUoKVxuICAgICAgLmFkZChvZmZzZXQpXG4gICAgICAuY2xhbXAobmV3IFZlY3RvcjIoMCwgMCksIG91dHB1dERpbWVuc2lvbnMpXG5cbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX29wZXJhdGlvbi5nZXRQb3NpdGlvbigpLmNsb25lKClcbiAgICAgIC5tdWx0aXBseShvdXRwdXREaW1lbnNpb25zKVxuXG4gICAgY29uc3QgcmFkaXVzID0gbmV3S25vYlBvc2l0aW9uXG4gICAgICAuY2xvbmUoKVxuICAgICAgLnN1YnRyYWN0KHBvc2l0aW9uKVxuICAgICAgLmFicygpXG4gICAgICAubGVuKClcbiAgICBjb25zdCBncmFkaWVudFJhZGl1cyA9IHJhZGl1cyAvIDJcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAga25vYlBvc2l0aW9uOiBuZXdLbm9iUG9zaXRpb24sXG4gICAgICBhcmVhRGltZW5zaW9uczogbmV3IFZlY3RvcjIoXG4gICAgICAgIHJhZGl1cyAqIDIsXG4gICAgICAgIHJhZGl1cyAqIDJcbiAgICAgIClcbiAgICB9KVxuICAgIHRoaXMuX29wZXJhdGlvbi5zZXQoe1xuICAgICAgcmFkaXVzOiByYWRpdXMgLyBvdXRwdXREaW1lbnNpb25zLm1pbigpLFxuICAgICAgZ3JhZGllbnRSYWRpdXM6IGdyYWRpZW50UmFkaXVzIC8gb3V0cHV0RGltZW5zaW9ucy5taW4oKVxuICAgIH0pXG5cbiAgICBlZGl0b3IucmVuZGVyKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFNUWUxJTkdcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgQ1NTIHN0eWxlcyBmb3IgdGhlIGFyZWEgZGl2XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRBcmVhU3R5bGUgKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogdGhpcy5zdGF0ZS5hcmVhRGltZW5zaW9ucy54LFxuICAgICAgaGVpZ2h0OiB0aGlzLnN0YXRlLmFyZWFEaW1lbnNpb25zLnksXG4gICAgICBsZWZ0OiB0aGlzLnN0YXRlLmFyZWFQb3NpdGlvbi54LFxuICAgICAgdG9wOiB0aGlzLnN0YXRlLmFyZWFQb3NpdGlvbi55LFxuICAgICAgbWFyZ2luTGVmdDogdGhpcy5zdGF0ZS5hcmVhRGltZW5zaW9ucy54ICogLTAuNSxcbiAgICAgIG1hcmdpblRvcDogdGhpcy5zdGF0ZS5hcmVhRGltZW5zaW9ucy55ICogLTAuNVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBDU1Mgc3R5bGVzIGZvciB0aGUga25vYlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0S25vYlN0eWxlICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogdGhpcy5zdGF0ZS5rbm9iUG9zaXRpb24ueCxcbiAgICAgIHRvcDogdGhpcy5zdGF0ZS5rbm9iUG9zaXRpb24ueVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkaW1lbnNpb25zIGFuZCBwb3NpdGlvbiB2YWx1ZXMgZnJvbSB0aGUgY3VycmVudCBvcGVyYXRpb24gb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldFN0eWxlc0Zyb21PcHRpb25zICgpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG5cbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5fb3BlcmF0aW9uLmdldFBvc2l0aW9uKCkuY2xvbmUoKVxuICAgICAgLm11bHRpcGx5KG91dHB1dERpbWVuc2lvbnMpXG5cbiAgICBjb25zdCByYWRpdXMgPSB0aGlzLl9vcGVyYXRpb24uZ2V0UmFkaXVzKCkgKiBvdXRwdXREaW1lbnNpb25zLm1pbigpXG4gICAgY29uc3QgZGlhbWV0ZXIgPSByYWRpdXMgKiAyXG4gICAgY29uc3QgYXJlYVNpemUgPSBuZXcgVmVjdG9yMihkaWFtZXRlciwgZGlhbWV0ZXIpXG5cbiAgICBsZXQgbmV3U3RhdGUgPSB7XG4gICAgICBhcmVhRGltZW5zaW9uczogYXJlYVNpemUsXG4gICAgICBhcmVhUG9zaXRpb246IHBvc2l0aW9uXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9rbm9iQ2hhbmdlZE1hbnVhbGx5KSB7XG4gICAgICBuZXdTdGF0ZS5rbm9iUG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZSgpXG4gICAgICAgIC5hZGQocmFkaXVzLCAwKVxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUobmV3U3RhdGUpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29udGFpbmVyIHN0eWxlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRDb250YWluZXJTdHlsZSAoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gZWRpdG9yLmdldFNESygpLmdldFNwcml0ZSgpLmdldEJvdW5kcygpXG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IHgsXG4gICAgICB0b3A6IHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICByZXR1cm4gKDxkaXYgYmVtPSdiOmNhbnZhc0NvbnRyb2xzIGU6Y29udGFpbmVyIG06ZnVsbCcgcmVmPSdjb250YWluZXInIHN0eWxlPXt0aGlzLl9nZXRDb250YWluZXJTdHlsZSgpfT5cbiAgICAgIDxkaXYgYmVtPSckYjpyYWRpYWxGb2N1c0NhbnZhc0NvbnRyb2xzJz5cbiAgICAgICAgPERyYWdnYWJsZUNvbXBvbmVudFxuICAgICAgICAgIG9uU3RhcnQ9e3RoaXMuX29uQ2VudGVyRHJhZ1N0YXJ0fVxuICAgICAgICAgIG9uRHJhZz17dGhpcy5fb25DZW50ZXJEcmFnfT5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTphcmVhJyBzdHlsZT17dGhpcy5fZ2V0QXJlYVN0eWxlKCl9IC8+XG4gICAgICAgIDwvRHJhZ2dhYmxlQ29tcG9uZW50PlxuICAgICAgICA8RHJhZ2dhYmxlQ29tcG9uZW50XG4gICAgICAgICAgb25TdGFydD17dGhpcy5fb25Lbm9iRHJhZ1N0YXJ0fVxuICAgICAgICAgIG9uRHJhZz17dGhpcy5fb25Lbm9iRHJhZ30+XG4gICAgICAgICAgPGRpdiBiZW09J2U6a25vYiAkYjprbm9iJyBzdHlsZT17dGhpcy5fZ2V0S25vYlN0eWxlKCl9IC8+XG4gICAgICAgIDwvRHJhZ2dhYmxlQ29tcG9uZW50PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+KVxuICB9XG59XG5cblJhZGlhbEZvY3VzQ2FudmFzQ29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzID0gQ2FudmFzQ29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL2ZvY3VzL3JhZGlhbC1mb2N1cy1jYW52YXMtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgU0RLIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBDb250cm9scyBmcm9tICcuLi9jb250cm9scydcbmltcG9ydCBTdGlja2VyQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi9zdGlja2VyLWNvbnRyb2xzLWNvbXBvbmVudCdcbmltcG9ydCBTdGlja2VyQ2FudmFzQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi9zdGlja2VyLWNhbnZhcy1jb250cm9scy1jb21wb25lbnQnXG5jb25zdCB7IFN0aWNrZXJTcHJpdGUsIEJydXNoU3ByaXRlIH0gPSBTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb25cblxuLyoqXG4gKiBUaGUgc3RpY2tlciBjb250cm9sc1xuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xzXG4gKi9cbmNsYXNzIFN0aWNrZXJDb250cm9scyBleHRlbmRzIENvbnRyb2xzIHtcbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgbGVhdmVzIHRoZXNlIGNvbnRyb2xzXG4gICAqIEB0aGlzIHtTdGlja2VyQ29udHJvbHNDb21wb25lbnR9XG4gICAqIEBvdmVycmlkZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgb25FeGl0ICgpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcblxuICAgIGlmICghdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2tpcEhpc3RvcnknKSkge1xuICAgICAgZWRpdG9yLmhpc3RvcnkuYWRkKFxuICAgICAgICBvcGVyYXRpb24sXG4gICAgICAgIHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2luaXRpYWxPcHRpb25zJyksXG4gICAgICAgIHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbkV4aXN0ZWRCZWZvcmUnKVxuICAgICAgKVxuICAgIH1cblxuICAgIGVkaXRvci56b29tLnJlc3RvcmUoKVxuICAgIGVkaXRvci5mZWF0dXJlcy5lbmFibGUoJ3pvb20nLCAnZHJhZycpXG4gICAgZWRpdG9yLnJlbmRlcigpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBlbnRlcnMgdGhlc2UgY29udHJvbHNcbiAgICogQHRoaXMge1N0aWNrZXJDb250cm9sc0NvbXBvbmVudH1cbiAgICogQHBhcmFtIHtTaGFyZWRTdGF0ZX0gc2hhcmVkU3RhdGVcbiAgICogQG92ZXJyaWRlXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBvbkVudGVyIChzaGFyZWRTdGF0ZSkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBvcGVyYXRpb25FeGlzdGVkQmVmb3JlID0gZWRpdG9yLm9wZXJhdGlvbnMuZXhpc3RzKCdzcHJpdGUnKVxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IGVkaXRvci5vcGVyYXRpb25zLmdldE9yQ3JlYXRlKCdzcHJpdGUnKVxuICAgIGNvbnN0IHNwcml0ZXMgPSBvcGVyYXRpb24uZ2V0U3ByaXRlcygpXG4gICAgY29uc3Qgc3RpY2tlcnMgPSBvcGVyYXRpb24uZ2V0U3ByaXRlc09mVHlwZShTdGlja2VyU3ByaXRlKVxuICAgIGNvbnN0IGluaXRpYWxPcHRpb25zID0gb3BlcmF0aW9uLnNlcmlhbGl6ZU9wdGlvbnMoKVxuXG4gICAgZWRpdG9yLnpvb20uc2F2ZSgpXG4gICAgZWRpdG9yLnpvb20uc2V0KCdhdXRvJylcbiAgICBlZGl0b3IuZmVhdHVyZXMuZGlzYWJsZSgnem9vbScsICdkcmFnJylcblxuICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUoe1xuICAgICAgb3BlcmF0aW9uRXhpc3RlZEJlZm9yZSwgb3BlcmF0aW9uLCBzcHJpdGVzLCBzdGlja2VycywgaW5pdGlhbE9wdGlvbnNcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGVyZSBpcyBzb21ldGhpbmcgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIHRoYXRcbiAgICogd291bGQgY2F1c2UgdGhlIFVJIHRvIHN3aXRjaCB0byB0aGlzIGNvbnRyb2wgb24gY2xpY2tcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBwb3NpdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkVkaXRvcn0gZWRpdG9yXG4gICAqIEByZXR1cm4geyp9XG4gICAqIEBvdmVycmlkZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgY2xpY2tBdFBvc2l0aW9uIChwb3NpdGlvbiwgZWRpdG9yKSB7XG4gICAgaWYgKCFlZGl0b3Iub3BlcmF0aW9ucy5leGlzdHMoJ3Nwcml0ZScpKSByZXR1cm4gZmFsc2VcblxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IGVkaXRvci5vcGVyYXRpb25zLmdldE9yQ3JlYXRlKCdzcHJpdGUnKVxuICAgIGxldCBzcHJpdGVzID0gb3BlcmF0aW9uLmdldFNwcml0ZXNBdFBvc2l0aW9uKHBvc2l0aW9uLCBlZGl0b3IuZ2V0T3V0cHV0VGV4dHVyZURpbWVuc2lvbnMoKSlcbiAgICAgIC5maWx0ZXIoKHMpID0+ICEocyBpbnN0YW5jZW9mIEJydXNoU3ByaXRlKSlcblxuICAgIGlmIChzcHJpdGVzLmxlbmd0aCAmJiBzcHJpdGVzWzBdIGluc3RhbmNlb2YgU3RpY2tlclNwcml0ZSkge1xuICAgICAgcmV0dXJuIHsgc2VsZWN0ZWRTcHJpdGU6IHNwcml0ZXNbMF0gfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgY29udHJvbCBpcyBhdmFpbGFibGUgdG8gdGhlIHVzZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5FZGl0b3J9IGVkaXRvclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIGlzQXZhaWxhYmxlIChlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzVG9vbEFsbG93ZWQoJ3N0aWNrZXInKSAmJlxuICAgICAgZWRpdG9yLmlzVG9vbEVuYWJsZWQoJ3N0aWNrZXInKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgY29udHJvbHMgY29tcG9uZW50LiBVc2VkIGZvciB0aGUgbG93ZXIgY29udHJvbHMgcGFydCBvZiB0aGUgZWRpdG9yLlxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNDb21wb25lbnR9XG4gKiBAaWdub3JlXG4gKi9cblN0aWNrZXJDb250cm9scy5jb250cm9sc0NvbXBvbmVudCA9IFN0aWNrZXJDb250cm9sc0NvbXBvbmVudFxuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIGNhbnZhcyBjb21wb25lbnQuIFVzZWQgZm9yIHRoZSB1cHBlciBjb250cm9scyBwYXJ0IG9mIHRoZSBlZGl0b3IgKG9uXG4gKiB0b3Agb2YgdGhlIGNhbnZhcylcbiAqIEB0eXBlIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xzQ29tcG9uZW50fVxuICogQGlnbm9yZVxuICovXG5TdGlja2VyQ29udHJvbHMuY2FudmFzQ29udHJvbHNDb21wb25lbnQgPSBTdGlja2VyQ2FudmFzQ29udHJvbHNDb21wb25lbnRcblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuU3RpY2tlckNvbnRyb2xzLmlkZW50aWZpZXIgPSAnc3RpY2tlcidcblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBpY29uIHBhdGhcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAaWdub3JlXG4gKi9cblN0aWNrZXJDb250cm9scy5pY29uUGF0aCA9ICdjb250cm9scy9vdmVydmlldy9zdGlja2VyLnBuZydcblxuLyoqXG4gKiBUaGUgbGFuZ3VhZ2Uga2V5IHRoYXQgc2hvdWxkIGJlIHVzZWQgd2hlbiBkaXNwbGF5aW5nIHRoaXMgZmlsdGVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGlnbm9yZVxuICovXG5TdGlja2VyQ29udHJvbHMubGFuZ3VhZ2VLZXkgPSAncGVzZGsuc3RpY2tlci50aXRsZS5uYW1lJ1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoaXMgY29udHJvbFxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0W119IFtjYXRlZ29yaWVzID0gW11dXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyZXBsYWNlQ2F0ZWdvcmllcyA9IGZhbHNlXVxuICogQHByb3BlcnR5IHtTdHJpbmdbXX0gW2F2YWlsYWJsZVN0aWNrZXJzID0gbnVsbF1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3Rvb2x0aXBzID0gZmFsc2VdXG4gKi9cblN0aWNrZXJDb250cm9scy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgY2F0ZWdvcmllczogbnVsbCxcbiAgcmVwbGFjZUNhdGVnb3JpZXM6IGZhbHNlLFxuICBhdmFpbGFibGVTdGlja2VyczogbnVsbCxcbiAgdG9vbHRpcHM6IGZhbHNlLFxuICBoaWRlQ2F0ZWdvcmllczogZmFsc2UsXG4gIGZpeGVkUmF0aW86IHRydWUsXG4gIHNuYXBSb3RhdGlvbjogOTAsXG4gIHNuYXBSb3RhdGlvblRvbGVyYW5jZTogNSxcbiAgc21vb3RoRG93bnNjYWxpbmc6IGZhbHNlXG59XG5cbi8qKlxuICogVGhlIG9wZXJhdGlvbnMgcmVxdWlyZWQgZm9yIHRoaXMgY29udHJvbCB0byB3b3JrIHByb3Blcmx5XG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cblN0aWNrZXJDb250cm9scy5yZXF1aXJlZE9wZXJhdGlvbnMgPSBbJ3Nwcml0ZSddXG5cblN0aWNrZXJDb250cm9scy5nZXRQcmVsb2FkQXNzZXRzID0gQ29udHJvbHMuZ2V0UHJlbG9hZEFzc2V0c1xuXG5leHBvcnQgZGVmYXVsdCBTdGlja2VyQ29udHJvbHNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvc3RpY2tlci9pbmRleC5qcyIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFNES1V0aWxzLCBSZWFjdEJFTSwgVmVjdG9yMiwgQ29uc3RhbnRzIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBDb250cm9sc0NvbXBvbmVudCBmcm9tICcuLi9jb250cm9scy1jb21wb25lbnQnXG5pbXBvcnQgU2Nyb2xsYmFyQ29tcG9uZW50IGZyb20gJy4uLy4uL3Njcm9sbGJhci1jb21wb25lbnQnXG5pbXBvcnQgQ2F0ZWdvcnlEcm9wZG93bkNvbXBvbmVudCBmcm9tICcuLi8uLi9jYXRlZ29yeS1kcm9wZG93bi9jYXRlZ29yeS1kcm9wZG93bi1jb21wb25lbnQnXG5pbXBvcnQgTW9kYWxNYW5hZ2VyIGZyb20gJy4uLy4uLy4uL2xpYi9tb2RhbC1tYW5hZ2VyJ1xuaW1wb3J0IFN0aWNrZXJNYW5hZ2VyIGZyb20gJ3NoYXJlZC9tYW5hZ2Vycy9zdGlja2VyLW1hbmFnZXInXG5pbXBvcnQgU3RpY2tlckl0ZW1Db21wb25lbnQgZnJvbSAnLi9zdGlja2VyLWl0ZW0tY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGlja2VyT3ZlcnZpZXdDb250cm9sc0NvbXBvbmVudCBleHRlbmRzIENvbnRyb2xzQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25TdGlja2VyTW91c2VMZWF2ZScsXG4gICAgICAnX3JlbmRlclRvb2x0aXBDYW52YXMnLFxuICAgICAgJ19vbkNhdGVnb3J5Q2hhbmdlJyxcbiAgICAgICdfb25CZWZvcmVIaXN0b3J5VW5kbydcbiAgICApXG4gICAgdGhpcy5fZXZlbnRzID0ge1xuICAgICAgW0NvbnN0YW50cy5FVkVOVFMuSElTVE9SWV9CRUZPUkVfVU5ET106IHRoaXMuX29uQmVmb3JlSGlzdG9yeVVuZG9cbiAgICB9XG5cbiAgICB0aGlzLl9vcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxuICAgIHRoaXMuX3Nwcml0ZXMgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdzcHJpdGVzJylcbiAgICB0aGlzLl9zdGlja2VycyA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3N0aWNrZXJzJylcblxuICAgIHRoaXMuX2luaXRTdGlja2VyTWFuYWdlcigpXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgY2F0ZWdvcnk6IHRoaXMuX3N0aWNrZXJNYW5hZ2VyLmdldENhdGVnb3J5KCdhbGwnKVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBiZWZvcmUgYSBoaXN0b3J5IGl0ZW0gaXMgYmVpbmcgdW5kb25lXG4gICAqIEBwYXJhbSAge09iamVjdH0gaGlzdG9yeU9iamVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQmVmb3JlSGlzdG9yeVVuZG8gKGhpc3RvcnlPYmplY3QpIHtcbiAgICBjb25zdCB7IG9wZXJhdGlvbiwgb3B0aW9ucyB9ID0gaGlzdG9yeU9iamVjdFxuICAgIGlmIChvcGVyYXRpb24gIT09IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpKSByZXR1cm5cblxuICAgIGNvbnN0IHsgc3ByaXRlcyB9ID0gb3B0aW9uc1xuICAgIGlmIChzcHJpdGVzLmluZGV4T2YodGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKSkgPT09IC0xKSB7XG4gICAgICAvLyBDdXJyZW50bHkgc2VsZWN0ZWQgc3ByaXRlIGlzIGJlaW5nIHJlbW92ZWQuIExlYXZlIGNvbnRyb2wgd2l0aG91dCBhZGRpbmcgaGlzdG9yeSBpdGVtLlxuICAgICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7IHNraXBIaXN0b3J5OiB0cnVlIH0sIGZhbHNlKVxuICAgICAgdGhpcy5wcm9wcy5vblN3aXRjaENvbnRyb2xzKCdob21lJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzd2l0Y2hlcyB0aGUgY2F0ZWdvcnlcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjYXRlZ29yeVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ2F0ZWdvcnlDaGFuZ2UgKGNhdGVnb3J5KSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGNhdGVnb3J5OiBjYXRlZ29yeSB9LCAoKSA9PiB7XG4gICAgICB0aGlzLnJlZnMuc2Nyb2xsYmFyLnVwZGF0ZSgpXG4gICAgfSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIExJRkVDWUNMRVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGlzIG1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICBzdXBlci5jb21wb25lbnREaWRNb3VudCgpXG5cbiAgICBpZiAodGhpcy5wcm9wcy5vcHRpb25zLnN0aWNrZXJzSlNPTlBhdGgpIHtcbiAgICAgIHRoaXMuX2xvYWRFeHRlcm5hbFN0aWNrZXJzKClcbiAgICB9XG5cbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgZWRpdG9yLnpvb20uc2V0KCdhdXRvJywgKCkgPT4ge1xuICAgICAgZWRpdG9yLmZlYXR1cmVzLmRpc2FibGUoJ3pvb20nLCAnZHJhZycpXG4gICAgfSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVYVEVSTkFMIFNUSUNLRVIgTE9BRElOR1xuXG4gIC8qKlxuICAgKiBMb2FkcyB0aGUgc3RpY2tlcnMgZnJvbSBhbiBleHRlcm5hbCBKU09OIHNvdXJjZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2xvYWRFeHRlcm5hbFN0aWNrZXJzICgpIHtcbiAgICAvLyBEaXNwbGF5IGxvYWRpbmcgbW9kYWwgYWZ0ZXIgMTAwbXNcbiAgICBsZXQgbG9hZGluZ01vZGFsID0gbnVsbFxuICAgIGxldCBsb2FkVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbG9hZGluZ01vZGFsID0gTW9kYWxNYW5hZ2VyLmluc3RhbmNlLmRpc3BsYXlMb2FkaW5nKHRoaXMuX3QoJ3Blc2RrLmNvbW1vbi50ZXh0LmxvYWRpbmcnKSlcbiAgICB9LCAxMDApXG5cbiAgICAvLyBDYWxsZWQgd2hlbiBsb2FkaW5nIGlzIGRvbmUuIENhbmNlbHMgdGhlIGxvYWRpbmcgdGltZW91dFxuICAgIC8vIG9yIGNsb3NlcyB0aGUgbG9hZGluZ01vZGFsIGluIGNhc2UgaXQgaGFzIGJlZW4gb3BlbmVkXG4gICAgY29uc3QgZG9uZUxvYWRpbmcgPSAoKSA9PiB7XG4gICAgICBpZiAobG9hZFRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGxvYWRUaW1lb3V0KVxuICAgICAgICBsb2FkVGltZW91dCA9IG51bGxcbiAgICAgIH1cbiAgICAgIGlmIChsb2FkaW5nTW9kYWwpIGxvYWRpbmdNb2RhbC5jbG9zZSgpXG4gICAgICB0aGlzLl9qc29uTG9hZGVkID0gdHJ1ZVxuICAgIH1cblxuICAgIHRoaXMuX3N0aWNrZXJNYW5hZ2VyXG4gICAgICAubG9hZEV4dGVybmFsKHRoaXMucHJvcHMub3B0aW9ucy5zdGlja2Vyc0pTT05QYXRoKVxuICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lTG9hZGluZygpXG4gICAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVmcy5zY3JvbGxiYXIudXBkYXRlKClcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgZG9uZUxvYWRpbmcoKVxuICAgICAgICBjb25zdCBlcnJvck1vZGFsID0gTW9kYWxNYW5hZ2VyLmluc3RhbmNlLmRpc3BsYXlFcnJvcihcbiAgICAgICAgICB0aGlzLl90KCdwZXNkay5zdGlja2VyLnRpdGxlLmxvYWRpbmdTdGlja2Vyc0ZhaWxlZCcpLFxuICAgICAgICAgIGUubWVzc2FnZVxuICAgICAgICApXG4gICAgICAgIGVycm9yTW9kYWwub24oJ2Nsb3NlJywgKCkgPT4geyB0aGlzLnByb3BzLm9uQmFjaygpIH0pXG4gICAgICB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gU1RJQ0tFUiBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgc3RpY2tlciBvbiB0aGUgdG9vbHRpcCBjYW52YXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJUb29sdGlwQ2FudmFzICgpIHtcbiAgICBjb25zdCB7IGhvdmVyZWRTdGlja2VyIH0gPSB0aGlzLnN0YXRlXG4gICAgY29uc3QgaW1hZ2UgPSBuZXcgd2luZG93LkltYWdlKClcbiAgICBjb25zdCB7IG1lZGlhQmFzZSB9ID0gaG92ZXJlZFN0aWNrZXIuaW1hZ2VzXG4gICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5zdGF0ZS50b29sdGlwVmlzaWJsZSB8fFxuICAgICAgICAgIHRoaXMuc3RhdGUuaG92ZXJlZFN0aWNrZXIgIT09IGhvdmVyZWRTdGlja2VyKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG1lZGlhQmFzZS53aWR0aCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICB0eXBlb2YgbWVkaWFCYXNlLmhlaWdodCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaW1hZ2Uud2lkdGggPSBtZWRpYUJhc2Uud2lkdGhcbiAgICAgICAgaW1hZ2UuaGVpZ2h0ID0gbWVkaWFCYXNlLmhlaWdodFxuICAgICAgfVxuXG4gICAgICBjb25zdCBjYW52YXMgPSB0aGlzLnJlZnMudG9vbHRpcENhbnZhc1xuICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzLm9mZnNldFdpZHRoXG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLm9mZnNldEhlaWdodFxuXG4gICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5taW4oY2FudmFzLndpZHRoIC8gaW1hZ2Uud2lkdGgsIGNhbnZhcy5oZWlnaHQgLyBpbWFnZS5oZWlnaHQpXG4gICAgICBjb25zdCBkcmF3U2l6ZSA9IG5ldyBWZWN0b3IyKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpXG4gICAgICAgIC5tdWx0aXBseShzY2FsZSlcbiAgICAgIGNvbnN0IGRyYXdQb3NpdGlvbiA9IG5ldyBWZWN0b3IyKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcbiAgICAgICAgLmRpdmlkZSgyKVxuICAgICAgICAuc3VidHJhY3QoZHJhd1NpemUuY2xvbmUoKS5kaXZpZGUoMikpXG5cbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLFxuICAgICAgICAwLCAwLFxuICAgICAgICBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LFxuICAgICAgICBkcmF3UG9zaXRpb24ueCwgZHJhd1Bvc2l0aW9uLnksXG4gICAgICAgIGRyYXdTaXplLngsIGRyYXdTaXplLnkpXG4gICAgfSlcblxuICAgIGNvbnN0IHJlc29sdmVkU3RpY2tlclBhdGggPSB0aGlzLl9nZXRBc3NldFBhdGgoU3RpY2tlck1hbmFnZXIuZ2V0VVJMRm9yU3RpY2tlcihob3ZlcmVkU3RpY2tlciwgJ2Jhc2UnKSlcbiAgICBpbWFnZS5jcm9zc09yaWdpbiA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0Q3Jvc3NPcmlnaW4oKVxuICAgIGltYWdlLnNyYyA9IHJlc29sdmVkU3RpY2tlclBhdGhcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFNUSUNLRVJTXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBzdGlja2VyIG1hbmFnZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0U3RpY2tlck1hbmFnZXIgKCkge1xuICAgIHRoaXMuX3N0aWNrZXJNYW5hZ2VyID0gbmV3IFN0aWNrZXJNYW5hZ2VyKHRoaXMuY29udGV4dC51aSwgdGhpcy5wcm9wcy5vcHRpb25zKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBiYWNrIGJ1dHRvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25CYWNrQ2xpY2sgKGUpIHtcbiAgICB0aGlzLl9iYWNrQnV0dG9uQ2xpY2tlZCA9IHRydWVcbiAgICB0aGlzLnByb3BzLm9uU3dpdGNoQ29udHJvbHMoJ2hvbWUnKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYSBzdGlja2VyIGhhcyBiZWVuIGNsaWNrZWRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBzdGlja2VyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25TdGlja2VyQ2xpY2sgKHN0aWNrZXIpIHtcbiAgICBjb25zdCB7IG1lZGlhQmFzZSB9ID0gc3RpY2tlci5pbWFnZXNcbiAgICBjb25zdCB1cmwgPSBTdGlja2VyTWFuYWdlci5nZXRVUkxGb3JTdGlja2VyKHN0aWNrZXIsICdiYXNlJylcbiAgICBjb25zdCByZXNvbHZlZFN0aWNrZXJQYXRoID0gdGhpcy5fZ2V0QXNzZXRQYXRoKHVybClcbiAgICBjb25zdCBpbWFnZSA9IG5ldyB3aW5kb3cuSW1hZ2UoKVxuXG4gICAgbGV0IGxvYWRpbmdNb2RhbFxuICAgIGxldCBsb2FkVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbG9hZGluZ01vZGFsID0gTW9kYWxNYW5hZ2VyLmluc3RhbmNlLmRpc3BsYXlMb2FkaW5nKHRoaXMuX3QoJ3Blc2RrLmNvbW1vbi50ZXh0LmxvYWRpbmcnKSlcbiAgICB9LCAxMDApXG5cbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgaWYgKGxvYWRpbmdNb2RhbCkgbG9hZGluZ01vZGFsLmNsb3NlKClcbiAgICAgIGlmIChsb2FkVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQobG9hZFRpbWVvdXQpXG4gICAgICAgIGxvYWRUaW1lb3V0ID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG1lZGlhQmFzZS53aWR0aCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICB0eXBlb2YgbWVkaWFCYXNlLmhlaWdodCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaW1hZ2Uud2lkdGggPSBtZWRpYUJhc2Uud2lkdGhcbiAgICAgICAgaW1hZ2UuaGVpZ2h0ID0gbWVkaWFCYXNlLmhlaWdodFxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG5cbiAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fY2FsY3VsYXRlSW5pdGlhbFN0aWNrZXJTY2FsZShzdGlja2VyLCBpbWFnZSlcbiAgICAgIGNvbnN0IHNwcml0ZSA9IHRoaXMuX29wZXJhdGlvbi5jcmVhdGVTdGlja2VyKHtcbiAgICAgICAgaWRlbnRpZmllcjogc3RpY2tlci5pZGVudGlmaWVyLFxuICAgICAgICBpbWFnZSxcbiAgICAgICAgcG9zaXRpb246IG5ldyBWZWN0b3IyKDAuNSwgMC41KSxcbiAgICAgICAgZGltZW5zaW9uczogbmV3IFZlY3RvcjIoaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCkubXVsdGlwbHkoc2NhbGUpLFxuICAgICAgICByb3RhdGlvbjogMCxcbiAgICAgICAgc21vb3RoRG93bnNjYWxpbmc6IHRoaXMucHJvcHMub3B0aW9ucy5zbW9vdGhEb3duc2NhbGluZ1xuICAgICAgfSlcbiAgICAgIHRoaXMuX29wZXJhdGlvbi5hZGRTcHJpdGUoc3ByaXRlKVxuICAgICAgdGhpcy5fc3RpY2tlcnMucHVzaChzcHJpdGUpXG5cbiAgICAgIGVkaXRvci5yZW5kZXIoKCkgPT4ge1xuICAgICAgICAvLyBCcm9hZGNhc3QgbmV3IHN0YXRlXG4gICAgICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUoe1xuICAgICAgICAgIHNlbGVjdGVkU3ByaXRlOiBzcHJpdGUsXG4gICAgICAgICAgc3ByaXRlczogdGhpcy5fc3ByaXRlcyxcbiAgICAgICAgICBzdGlja2VyczogdGhpcy5fc3RpY2tlcnNcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgaWYgKGxvYWRpbmdNb2RhbCkgbG9hZGluZ01vZGFsLmNsb3NlKClcbiAgICAgIGlmIChsb2FkVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQobG9hZFRpbWVvdXQpXG4gICAgICAgIGxvYWRUaW1lb3V0ID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBNb2RhbE1hbmFnZXIuaW5zdGFuY2UuZGlzcGxheUVycm9yKFxuICAgICAgICB0aGlzLl90KCdwZXNkay5jb21tb24udGl0bGUuaW1hZ2VMb2FkRmFpbCcpLFxuICAgICAgICB0aGlzLl90KCdwZXNkay5jb21tb24udGV4dC5pbWFnZUxvYWRGYWlsJywgeyBwYXRoOiBpbWFnZS5zcmMgfSlcbiAgICAgIClcbiAgICB9KVxuXG4gICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldENyb3NzT3JpZ2luKClcbiAgICBpbWFnZS5zcmMgPSByZXNvbHZlZFN0aWNrZXJQYXRoXG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgaW5pdGlhbCBzdGlja2VyIHNjYWxlXG4gICAqIEBwYXJhbSAge09iamVjdH0gc3RpY2tlclxuICAgKiBAcGFyYW0gIHtJbWFnZX0gaW1hZ2VcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NhbGN1bGF0ZUluaXRpYWxTdGlja2VyU2NhbGUgKHN0aWNrZXIsIGltYWdlKSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICBjb25zdCBpbnB1dERpbWVuc2lvbnMgPSBvcGVyYXRpb24uZ2V0SW5wdXREaW1lbnNpb25zKGZhbHNlKVxuICAgIGNvbnN0IGltYWdlRGltZW5zaW9ucyA9IG5ldyBWZWN0b3IyKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpXG5cbiAgICBjb25zdCBzdGlja2VyRGltZW5zaW9ucyA9IFNES1V0aWxzLnJlc2l6ZVZlY3RvclRvRml0KGltYWdlRGltZW5zaW9ucywgaW5wdXREaW1lbnNpb25zLmNsb25lKCkubXVsdGlwbHkoMC41KSlcbiAgICByZXR1cm4gc3RpY2tlckRpbWVuc2lvbnMueCAvIGltYWdlRGltZW5zaW9ucy54XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgaG92ZXJpbmcgYSBzdGlja2VyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gc3RpY2tlclBhdGhcbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblN0aWNrZXJNb3VzZUVudGVyIChzdGlja2VyUGF0aCwgZSkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdG9vbHRpcFZpc2libGU6IHRydWUsXG4gICAgICBob3ZlcmVkU3RpY2tlcjogc3RpY2tlclBhdGgsXG4gICAgICBob3ZlcmVkU3RpY2tlckVsZW1lbnQ6IGUuY3VycmVudFRhcmdldFxuICAgIH0sICgpID0+IHtcbiAgICAgIHRoaXMuX3JlbmRlclRvb2x0aXBDYW52YXMoKVxuICAgICAgdGhpcy5fdXBkYXRlVG9vbHRpcFBvc2l0aW9uKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHRvb2x0aXAgcG9zaXRpb24gdG8gbWF0Y2ggdGhlIGN1cnJlbnRseSBob3ZlcmVkXG4gICAqIHN0aWNrZXIncyBwb3NpdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZVRvb2x0aXBQb3NpdGlvbiAoKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzLnN0YXRlLmhvdmVyZWRTdGlja2VyRWxlbWVudFxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucmVmcy5yb290XG4gICAgY29uc3QgYm91bmRpbmdSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBjb25zdCBwYXJlbnRCb3VuZGluZ1JlY3QgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdG9vbHRpcFBvc2l0aW9uOiBib3VuZGluZ1JlY3QubGVmdCAtIHBhcmVudEJvdW5kaW5nUmVjdC5sZWZ0XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGRvZXMgbm8gbG9uZ2VyIGhvdmVyIGEgc3RpY2tlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uU3RpY2tlck1vdXNlTGVhdmUgKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdG9vbHRpcFZpc2libGU6IGZhbHNlLFxuICAgICAgaG92ZXJlZFN0aWNrZXI6IG51bGxcbiAgICB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGxpc3QgaXRlbXMgZm9yIHRoaXMgY29udHJvbFxuICAgKiBAcmV0dXJuIHtBcnJheS48UmVhY3RCRU0uRWxlbWVudD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyTGlzdEl0ZW1zICgpIHtcbiAgICBjb25zdCB7IHN0aWNrZXJzSlNPTlBhdGgsIHJlcGxhY2VDYXRlZ29yaWVzIH0gPSB0aGlzLnByb3BzLm9wdGlvbnNcbiAgICBpZiAoc3RpY2tlcnNKU09OUGF0aCAmJiByZXBsYWNlQ2F0ZWdvcmllcyAmJiAhdGhpcy5fanNvbkxvYWRlZCkge1xuICAgICAgLy8gSWYgYWxsIGNhdGVnb3JpZXMgYXJlIHJlcGxhY2VkIGJ5IHRoZSBKU09OIGFueXdheXMsIHdlIGRvbid0IG5lZWQgdG8gcmVuZGVyXG4gICAgICAvLyBhbnl0aGluZyBiZWZvcmUgcmVjZWl2aW5nIHRoZSBKU09OIGRhdGFcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHN0aWNrZXJzID0gdGhpcy5fc3RpY2tlck1hbmFnZXIuZ2V0U3RpY2tlcnNGb3JDYXRlZ29yeSh0aGlzLnN0YXRlLmNhdGVnb3J5LmlkZW50aWZpZXIpXG4gICAgcmV0dXJuIHN0aWNrZXJzLm1hcCgoc3RpY2tlciwgaSkgPT4ge1xuICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzLnByb3BzXG5cbiAgICAgIGNvbnN0IGl0ZW1FdmVudHMgPSBvcHRpb25zLnRvb2x0aXBzXG4gICAgICAgID8ge1xuICAgICAgICAgIG9uTW91c2VFbnRlcjogdGhpcy5fb25TdGlja2VyTW91c2VFbnRlci5iaW5kKHRoaXMsIHN0aWNrZXIpLFxuICAgICAgICAgIG9uTW91c2VMZWF2ZTogdGhpcy5fb25TdGlja2VyTW91c2VMZWF2ZVxuICAgICAgICB9XG4gICAgICAgIDogbnVsbFxuXG4gICAgICByZXR1cm4gKDxTdGlja2VySXRlbUNvbXBvbmVudFxuICAgICAgICBzdGlja2VyPXtzdGlja2VyfVxuICAgICAgICBvbkNsaWNrPXt0aGlzLl9vblN0aWNrZXJDbGljay5iaW5kKHRoaXMsIHN0aWNrZXIpfVxuICAgICAgICB7Li4uaXRlbUV2ZW50c30gLz4pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSB0b29sdGlwIChpZiBwcmVzZW50KVxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclRvb2x0aXAgKCkge1xuICAgIGNvbnN0IHRvb2x0aXBWaXNpYmxlID0gdGhpcy5wcm9wcy5vcHRpb25zLnRvb2x0aXBzICYmXG4gICAgICB0aGlzLnN0YXRlLnRvb2x0aXBWaXNpYmxlXG5cbiAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgIGxlZnQ6IHRoaXMuc3RhdGUudG9vbHRpcFBvc2l0aW9uXG4gICAgfVxuXG4gICAgcmV0dXJuIHRvb2x0aXBWaXNpYmxlXG4gICAgICA/ICg8ZGl2IGJlbT0nZTpjZWxsIG06ZW1wdHknPlxuICAgICAgICA8ZGl2IGJlbT0nJGI6c3RpY2tlcnNDb250cm9scyAkZTp0b29sdGlwJ1xuICAgICAgICAgIHN0eWxlPXtzdHlsZX0+XG4gICAgICAgICAgPGNhbnZhcyBiZW09J2U6Y2FudmFzJyByZWY9J3Rvb2x0aXBDYW52YXMnIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+KVxuICAgICAgOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY2F0ZWdvcnkgZHJvcGRvd24gKGlmIHByZXNlbnQpXG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyQ2F0ZWdvcnlEcm9wZG93biAoKSB7XG4gICAgY29uc3QgeyBzdGlja2Vyc0pTT05QYXRoLCByZXBsYWNlQ2F0ZWdvcmllcyB9ID0gdGhpcy5wcm9wcy5vcHRpb25zXG4gICAgaWYgKHN0aWNrZXJzSlNPTlBhdGggJiYgcmVwbGFjZUNhdGVnb3JpZXMgJiYgIXRoaXMuX2pzb25Mb2FkZWQpIHtcbiAgICAgIC8vIElmIGFsbCBjYXRlZ29yaWVzIGFyZSByZXBsYWNlZCBieSB0aGUgSlNPTiBhbnl3YXlzLCB3ZSBkb24ndCBuZWVkIHRvIHJlbmRlclxuICAgICAgLy8gYW55dGhpbmcgYmVmb3JlIHJlY2VpdmluZyB0aGUgSlNPTiBkYXRhXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBjYXRlZ29yaWVzID0gdGhpcy5fc3RpY2tlck1hbmFnZXIuZ2V0Q2F0ZWdvcmllcyh0cnVlKVxuICAgIGNvbnN0IGNhdGVnb3J5RHJvcGRvd25WaXNpYmxlID1cbiAgICAgICF0aGlzLnByb3BzLm9wdGlvbnMuaGlkZUNhdGVnb3JpZXMgJiZcbiAgICAgIGNhdGVnb3JpZXMubGVuZ3RoID4gMVxuICAgIGlmICghY2F0ZWdvcnlEcm9wZG93blZpc2libGUpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgY29uc3QgY2F0ZWdvcnlJdGVtcyA9IGNhdGVnb3JpZXMubWFwKChjKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZGVudGlmaWVyOiBjLmlkZW50aWZpZXIsXG4gICAgICAgIGl0ZW06IGMsXG4gICAgICAgIGxhYmVsOiB0aGlzLl90KGBwZXNkay5zdGlja2VyLmFzc2V0LiR7Yy5pZGVudGlmaWVyfWApIHx8IGMuZGVmYXVsdE5hbWUsXG4gICAgICAgIGljb246IHRoaXMuX2dldEFzc2V0UGF0aChgY29udHJvbHMvc3RpY2tlcnMvY2F0ZWdvcmllcy8ke2MuaWRlbnRpZmllcn0ucG5nYCwgdHJ1ZSlcbiAgICAgIH1cbiAgICB9KVxuICAgIGNvbnN0IHsgY2F0ZWdvcnk6IGN1cnJlbnRDYXRlZ29yeSB9ID0gdGhpcy5zdGF0ZVxuICAgIGNvbnN0IHNlbGVjdGVkQ2F0ZWdvcnlJdGVtID0ge1xuICAgICAgaWRlbnRpZmllcjogY3VycmVudENhdGVnb3J5LmlkZW50aWZpZXIsXG4gICAgICBpdGVtOiBjdXJyZW50Q2F0ZWdvcnksXG4gICAgICBsYWJlbDogdGhpcy5fdChgcGVzZGsuc3RpY2tlci5hc3NldC4ke2N1cnJlbnRDYXRlZ29yeS5pZGVudGlmaWVyfWApIHx8IGN1cnJlbnRDYXRlZ29yeS5kZWZhdWx0TmFtZSxcbiAgICAgIGljb246IHRoaXMuX2dldEFzc2V0UGF0aChgY29udHJvbHMvc3RpY2tlcnMvY2F0ZWdvcmllcy8ke2N1cnJlbnRDYXRlZ29yeS5pZGVudGlmaWVyfS5wbmdgLCB0cnVlKVxuICAgIH1cblxuICAgIHJldHVybiAoPGRpdiBiZW09J2U6Y2VsbCBtOmNhdGVnb3J5RHJvcGRvd24nPlxuICAgICAgPENhdGVnb3J5RHJvcGRvd25Db21wb25lbnRcbiAgICAgICAgaXRlbXM9e2NhdGVnb3J5SXRlbXN9XG4gICAgICAgIHNlbGVjdGVkSXRlbT17c2VsZWN0ZWRDYXRlZ29yeUl0ZW19XG4gICAgICAgIG9uQ2hhbmdlPXt0aGlzLl9vbkNhdGVnb3J5Q2hhbmdlfSAvPlxuICAgIDwvZGl2PilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb250cm9scyBvZiB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyQ29udHJvbHMgKCkge1xuICAgIGNvbnN0IGxpc3RJdGVtcyA9IHRoaXMuX3JlbmRlckxpc3RJdGVtcygpXG4gICAgY29uc3QgdG9vbHRpcCA9IHRoaXMuX3JlbmRlclRvb2x0aXAoKVxuICAgIGNvbnN0IGNhdGVnb3J5RHJvcGRvd24gPSB0aGlzLl9yZW5kZXJDYXRlZ29yeURyb3Bkb3duKClcblxuICAgIHJldHVybiBbdG9vbHRpcCxcbiAgICAgIGNhdGVnb3J5RHJvcGRvd24sXG4gICAgICAoPGRpdiBiZW09J2U6Y2VsbCBtOmxpc3QnPlxuICAgICAgICA8U2Nyb2xsYmFyQ29tcG9uZW50IHJlZj0nc2Nyb2xsYmFyJz5cbiAgICAgICAgICA8dWwgYmVtPSckZTpsaXN0Jz5cbiAgICAgICAgICAgIHtsaXN0SXRlbXN9XG4gICAgICAgICAgPC91bD5cbiAgICAgICAgPC9TY3JvbGxiYXJDb21wb25lbnQ+XG4gICAgICA8L2Rpdj4pXVxuICB9XG59XG5cblN0aWNrZXJPdmVydmlld0NvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IENvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9zdGlja2VyL3N0aWNrZXItY29udHJvbHMtY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50LCBWZWN0b3IyLCBVdGlscyB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgU3RpY2tlck1hbmFnZXIgZnJvbSAnc2hhcmVkL21hbmFnZXJzL3N0aWNrZXItbWFuYWdlcidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RpY2tlck92ZXJ2aWV3Q29udHJvbHNDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHN0aWNrZXI6IHRoaXMucHJvcHMuc3RpY2tlclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICB0aGlzLl9yZW5kZXJTdGlja2VyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGlzIGFib3V0IHRvIHJlY2VpdmUgbmV3IHByb3BlcnRpZXNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBuZXh0UHJvcHNcbiAgICovXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKG5leHRQcm9wcykge1xuICAgIGlmICh0aGlzLnByb3BzLnN0aWNrZXIgIT09IG5leHRQcm9wcy5zdGlja2VyKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgc3RpY2tlcjogbmV4dFByb3BzLnN0aWNrZXIgfSwgKCkgPT4ge1xuICAgICAgICB0aGlzLl9yZW5kZXJTdGlja2VyKClcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHN0aWNrZXIgb250byB0aGUgY2FudmFzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyU3RpY2tlciAoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IHNkayA9IGVkaXRvci5nZXRTREsoKVxuXG4gICAgY29uc3QgeyBzdGlja2VyIH0gPSB0aGlzLnByb3BzXG5cbiAgICBjb25zdCB7IG1lZGlhVGh1bWIgfSA9IHN0aWNrZXIuaW1hZ2VzXG4gICAgY29uc3QgdXJsID0gU3RpY2tlck1hbmFnZXIuZ2V0VVJMRm9yU3RpY2tlcihzdGlja2VyLCAndGh1bWInKVxuICAgIGNvbnN0IHJlc29sdmVkU3RpY2tlclBhdGggPSB0aGlzLl9nZXRBc3NldFBhdGgodXJsKVxuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMucmVmc1tgY2FudmFzLSR7c3RpY2tlci5uYW1lfWBdXG5cbiAgICBjb25zdCBwaXhlbFJhdGlvID0gc2RrLmdldFBpeGVsUmF0aW8oKVxuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5vZmZzZXRXaWR0aCAqIHBpeGVsUmF0aW9cbiAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLm9mZnNldEhlaWdodCAqIHBpeGVsUmF0aW9cblxuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGAke2NhbnZhcy5vZmZzZXRXaWR0aH1weGBcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gYCR7Y2FudmFzLm9mZnNldEhlaWdodH1weGBcblxuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgIGNvbnN0IGltYWdlID0gbmV3IHdpbmRvdy5JbWFnZSgpXG4gICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgbWVkaWFUaHVtYi53aWR0aCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICB0eXBlb2YgbWVkaWFUaHVtYi5oZWlnaHQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgIVV0aWxzLkJyb3dzZXIuZ2V0SUVWZXJzaW9uKCkpIHtcbiAgICAgICAgaW1hZ2Uud2lkdGggPSBtZWRpYVRodW1iLndpZHRoXG4gICAgICAgIGltYWdlLmhlaWdodCA9IG1lZGlhVGh1bWIuaGVpZ2h0XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5taW4oY2FudmFzLndpZHRoIC8gaW1hZ2Uud2lkdGgsIGNhbnZhcy5oZWlnaHQgLyBpbWFnZS5oZWlnaHQpXG4gICAgICBjb25zdCBkcmF3U2l6ZSA9IG5ldyBWZWN0b3IyKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpXG4gICAgICAgIC5tdWx0aXBseShzY2FsZSlcbiAgICAgIGNvbnN0IGRyYXdQb3NpdGlvbiA9IG5ldyBWZWN0b3IyKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcbiAgICAgICAgLmRpdmlkZSgyKVxuICAgICAgICAuc3VidHJhY3QoZHJhd1NpemUuY2xvbmUoKS5kaXZpZGUoMikpXG5cbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLFxuICAgICAgICAwLCAwLFxuICAgICAgICBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LFxuICAgICAgICBkcmF3UG9zaXRpb24ueCwgZHJhd1Bvc2l0aW9uLnksXG4gICAgICAgIGRyYXdTaXplLngsIGRyYXdTaXplLnkpXG4gICAgfSlcbiAgICBpbWFnZS5jcm9zc09yaWdpbiA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0Q3Jvc3NPcmlnaW4oKVxuICAgIGltYWdlLnNyYyA9IHJlc29sdmVkU3RpY2tlclBhdGhcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgZWxlbWVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5lbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgcmV0dXJuICg8bGlcbiAgICAgIGJlbT0nJGI6c3RpY2tlcnNDb250cm9scyAkZTppdGVtJ1xuICAgICAga2V5PXt0aGlzLnByb3BzLnN0aWNrZXIubmFtZX1cbiAgICAgIG9uQ2xpY2s9e3RoaXMucHJvcHMub25DbGlja31cbiAgICAgIG9uTW91c2VFbnRlcj17dGhpcy5wcm9wcy5vbk1vdXNlRW50ZXJ9XG4gICAgICBvbk1vdXNlTGVhdmU9e3RoaXMucHJvcHMub25Nb3VzZUxlYXZlfT5cbiAgICAgIDxjYW52YXMgYmVtPSdlOmNhbnZhcycgcmVmPXtgY2FudmFzLSR7dGhpcy5wcm9wcy5zdGlja2VyLm5hbWV9YH0gLz5cbiAgICA8L2xpPilcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9zdGlja2VyL3N0aWNrZXItaXRlbS1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cbmltcG9ydCB7IFJlYWN0QkVNIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBTcHJpdGVzQ2FudmFzQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi4vc3ByaXRlcy9zcHJpdGVzLWNhbnZhcy1jb250cm9scy1jb21wb25lbnQnXG5pbXBvcnQgU3RpY2tlckNvbnRyb2xzT3ZlcmxheUNvbXBvbmVudCBmcm9tICcuLi9zdGlja2VyL3N0aWNrZXItY29udHJvbHMtb3ZlcmxheS1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0aWNrZXJDYW52YXNDb250cm9sc0NvbXBvbmVudCBleHRlbmRzIFNwcml0ZXNDYW52YXNDb250cm9sc0NvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBUaGlzIHJlbmRlcnMgY29udHJvbHMgb24gdG9wIG9mIHRoZSBzcHJpdGVzXG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyT3ZlcmxheUNvbnRyb2xzICgpIHtcbiAgICBpZiAoIXRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3NlbGVjdGVkU3ByaXRlJykpIHJldHVyblxuXG4gICAgcmV0dXJuICg8U3RpY2tlckNvbnRyb2xzT3ZlcmxheUNvbXBvbmVudFxuICAgICAgb25GbGlwPXt0aGlzLl9vblNwcml0ZUZsaXB9XG4gICAgICBvblRha2VUb0Zyb250PXt0aGlzLl9vblNwcml0ZVRha2VUb0Zyb250fVxuICAgICAgb25SZW1vdmU9e3RoaXMuX29uU3ByaXRlUmVtb3ZlfSAvPilcbiAgfVxufVxuXG5TdGlja2VyQ2FudmFzQ29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzID0gU3ByaXRlc0NhbnZhc0NvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9zdGlja2VyL3N0aWNrZXItY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBVdGlscywgUmVhY3RCRU0sIG5vdyB9IGZyb20gJy4uLy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgRHJhZ2dhYmxlQ29tcG9uZW50IGZyb20gJy4uLy4uLy4uL2RyYWdnYWJsZS1jb21wb25lbnQnXG5pbXBvcnQgSXRlbUNvbXBvbmVudCBmcm9tICcuL2l0ZW0tY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0SXRlbUNvbXBvbmVudCBleHRlbmRzIEl0ZW1Db21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vblRleHRDaGFuZ2UnLFxuICAgICAgJ19vbkl0ZW1Eb3VibGVDbGljaycsXG4gICAgICAnX29uSXRlbVRvdWNoU3RhcnQnLFxuICAgICAgJ19vbkl0ZW1Ub3VjaEVuZCcsXG4gICAgICAnX29uUmVzaXplS25vYkRyYWdTdGFydCcsXG4gICAgICAnX29uUmVzaXplS25vYkRyYWcnLFxuICAgICAgJ19vblJlc2l6ZUtub2JEcmFnU3RvcCcsXG4gICAgICAnX29uUm90YXRpb25Lbm9iRHJhZ1N0YXJ0JyxcbiAgICAgICdfb25Sb3RhdGlvbktub2JEcmFnJyxcbiAgICAgICdfb25Sb3RhdGlvbktub2JEcmFnU3RvcCcsXG4gICAgICAnX29uQmx1cidcbiAgICApXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZWRpdE1vZGU6IGZhbHNlLFxuICAgICAgdGV4dDogdGhpcy5wcm9wcy5zcHJpdGUuZ2V0VGV4dCgpXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgd2lsbCByZWNlaXZlIG5ldyBwcm9wc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IG5leHRQcm9wc1xuICAgKi9cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAobmV4dFByb3BzKSB7XG4gICAgc3VwZXIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpXG4gICAgaWYgKG5leHRQcm9wcy5zcHJpdGUgIT09IHRoaXMucHJvcHMuc3ByaXRlKSB7XG4gICAgICB0aGlzLnJlZnMudGV4dGFyZWEuYmx1cigpXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdGV4dDogbmV4dFByb3BzLnNwcml0ZS5nZXRUZXh0KCksXG4gICAgICAgIGVkaXRNb2RlOiBmYWxzZVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBoYXMgY2hhbmdlZCB0aGUgdGV4dFxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uVGV4dENoYW5nZSAoZSkge1xuICAgIGNvbnN0IHsgc3ByaXRlIH0gPSB0aGlzLnByb3BzXG4gICAgc3ByaXRlLnNldFRleHQoZS50YXJnZXQudmFsdWUpXG4gICAgdGhpcy5zZXRTdGF0ZSh7IHRleHQ6IGUudGFyZ2V0LnZhbHVlIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBkb3VibGUgY2xpY2tzIHRoZSB0ZXh0LiBUdXJucyB0aGUgc3ByaXRlIGludG9cbiAgICogZWRpdGluZyBtb2RlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uSXRlbURvdWJsZUNsaWNrICgpIHtcbiAgICB0aGlzLmVudGVyRWRpdE1vZGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEVudGVycyB0aGUgZWRpdCBtb2RlXG4gICAqL1xuICBlbnRlckVkaXRNb2RlICgpIHtcbiAgICBjb25zdCB7IHNwcml0ZSB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcblxuICAgIHNwcml0ZS5zZXRWaXNpYmxlKGZhbHNlKVxuXG4gICAgaWYgKCFzcHJpdGUuX2VkaXRlZCkge1xuICAgICAgc3ByaXRlLnNldFRleHQoJycpXG4gICAgICB0aGlzLnJlZnMudGV4dGFyZWEudmFsdWUgPSAnJ1xuICAgICAgc3ByaXRlLl9lZGl0ZWQgPSB0cnVlXG4gICAgICB0aGlzLnNldFN0YXRlKHsgdGV4dDogJycgfSlcbiAgICB9XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGVkaXRNb2RlOiB0cnVlIH0sICgpID0+IHtcbiAgICAgIHRoaXMucmVmcy50ZXh0YXJlYS5mb2N1cygpXG4gICAgICB0aGlzLnJlZnMudGV4dGFyZWEuc2VsZWN0KClcbiAgICB9KVxuXG4gICAgZWRpdG9yLnJlbmRlcigpXG4gIH1cblxuICAvKipcbiAgICogIExlYXZlcyBlZGl0IG1vZGVcbiAgICovXG4gIGxlYXZlRWRpdE1vZGUgKCkge1xuICAgIGNvbnN0IHsgc3ByaXRlIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuXG4gICAgc3ByaXRlLnNldFZpc2libGUodHJ1ZSlcbiAgICBlZGl0b3IucmVuZGVyKClcbiAgICB0aGlzLnNldFN0YXRlKHsgZWRpdE1vZGU6IGZhbHNlIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgdG91Y2hpbmcgdGhlIGl0ZW1cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uSXRlbVRvdWNoU3RhcnQgKGUpIHtcbiAgICB0aGlzLl9pbml0aWFsVG91Y2hQb3NpdGlvbiA9IFV0aWxzLmdldEV2ZW50UG9zaXRpb24oZSlcbiAgICB0aGlzLl90YXBTdGFydEF0ID0gbm93KClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIHRvdWNoaW5nIHRoZSBpdGVtXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25JdGVtVG91Y2hFbmQgKCkge1xuICAgIC8vIFJlY29nbml6ZSBkb3VibGUgdGFwXG4gICAgaWYgKG5vdygpIC0gdGhpcy5fdGFwU3RhcnRBdCA8PSAxMDApIHtcbiAgICAgIC8vIFRvdWNoIGRpZG4ndCBsYXN0IGxvbmdlciB0aGFuIDEwMG1zID0+IHJlY29nbml6ZWQgYXMgdGFwXG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2xhc3RUYXBBdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICBub3coKSAtIHRoaXMuX2xhc3RUYXBBdCA8PSAzMDApIHtcbiAgICAgICAgLy8gTGFzdCB0YXAgd2FzIG5vIGxvbmdlciB0aGFuIDMwMG1zIGFnbyA9PiByZWNvZ25pemVkIGFzIGRvdWJsZSB0YXBcbiAgICAgICAgdGhpcy5fb25JdGVtRG91YmxlQ2xpY2soKVxuICAgICAgfVxuICAgICAgdGhpcy5fbGFzdFRhcEF0ID0gbm93KClcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBST1RBVElPTiBEUkFHR0lOR1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgcmVzaXplIGtub2JcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gcG9zaXRpb25cbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblJvdGF0aW9uS25vYkRyYWdTdGFydCAocG9zaXRpb24sIGUpIHtcbiAgICB0aGlzLl9kcmFnZ2luZyA9IHRydWVcbiAgICB0aGlzLl9pbml0aWFsUG9zaXRpb24gPSB0aGlzLl9nZXRSb3RhdGlvbktub2JQb3NpdGlvbigpXG5cbiAgICB0aGlzLnByb3BzLm9uRHJhZ1N0YXJ0ICYmIHRoaXMucHJvcHMub25EcmFnU3RhcnQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIHJvdGF0ZXMgdGhlIHRleHRcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gb2Zmc2V0XG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Sb3RhdGlvbktub2JEcmFnIChvZmZzZXQsIGUpIHtcbiAgICBjb25zdCB7IHNwcml0ZSB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcblxuICAgIGNvbnN0IHNwcml0ZVBvc2l0aW9uID0gdGhpcy5fZ2V0QWJzb2x1dGVTcHJpdGVQb3NpdGlvbigpXG4gICAgY29uc3QgbmV3S25vYlBvc2l0aW9uID0gdGhpcy5faW5pdGlhbFBvc2l0aW9uXG4gICAgICAuY2xvbmUoKVxuICAgICAgLmFkZChvZmZzZXQpXG5cbiAgICAvLyBDYWxjdWxhdGUgbmV3IHJvdGF0aW9uIGFuZCBzY2FsZSBmcm9tIG5ldyBrbm9iIHBvc2l0aW9uXG4gICAgY29uc3Qga25vYkRpc3RhbmNlRnJvbUNlbnRlciA9IG5ld0tub2JQb3NpdGlvblxuICAgICAgLmNsb25lKClcbiAgICAgIC5zdWJ0cmFjdChzcHJpdGVQb3NpdGlvbilcblxuICAgIGNvbnN0IGJvdW5kaW5nQm94ID0gc3ByaXRlLmdldERpbWVuc2lvbnMoZWRpdG9yLmdldFNESygpLCBlZGl0b3IuZ2V0T3V0cHV0RGltZW5zaW9ucygpKVxuICAgIGNvbnN0IHJhZGlhbnMgPSBNYXRoLmF0YW4yKFxuICAgICAga25vYkRpc3RhbmNlRnJvbUNlbnRlci55IC8gMixcbiAgICAgIGtub2JEaXN0YW5jZUZyb21DZW50ZXIueCAvIDJcbiAgICApIC0gTWF0aC5hdGFuMihib3VuZGluZ0JveC55IC8gMiwgYm91bmRpbmdCb3gueCAvIDIpXG5cbiAgICBzcHJpdGUuc2V0Um90YXRpb24ocmFkaWFucylcbiAgICBlZGl0b3IucmVuZGVyKClcbiAgICB0aGlzLmZvcmNlVXBkYXRlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIHJvdGF0aW5nIHRoZSB0ZXh0XG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Sb3RhdGlvbktub2JEcmFnU3RvcCAoZSkge1xuICAgIHRoaXMucHJvcHMub25EcmFnU3RvcCAmJiB0aGlzLnByb3BzLm9uRHJhZ1N0b3AoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVTSVpFIERSQUdHSU5HXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIHJlc2l6aW5nIHRoZSB0ZXh0XG4gICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHBvc2l0aW9uXG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25SZXNpemVLbm9iRHJhZ1N0YXJ0IChwb3NpdGlvbiwgZSkge1xuICAgIHRoaXMuX2luaXRpYWxQb3NpdGlvbiA9IHRoaXMuX2dldFJlc2l6ZUtub2JQb3NpdGlvbigpXG5cbiAgICB0aGlzLnByb3BzLm9uRHJhZ1N0YXJ0ICYmIHRoaXMucHJvcHMub25EcmFnU3RhcnQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIHJlc2l6ZXMgdGhlIHRleHRcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gb2Zmc2V0XG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25SZXNpemVLbm9iRHJhZyAob2Zmc2V0LCBlKSB7XG4gICAgY29uc3QgeyBzcHJpdGUgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCB0ZXh0Um90YXRpb24gPSBzcHJpdGUuZ2V0Um90YXRpb24oKVxuXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSBlZGl0b3IuZ2V0T3V0cHV0RGltZW5zaW9ucygpXG5cbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyh0ZXh0Um90YXRpb24pXG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4odGV4dFJvdGF0aW9uKVxuXG4gICAgY29uc3QgbmV3S25vYlBvc2l0aW9uID0gdGhpcy5faW5pdGlhbFBvc2l0aW9uLmNsb25lKClcbiAgICAgIC5hZGQob2Zmc2V0KVxuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5fZ2V0QWJzb2x1dGVTcHJpdGVQb3NpdGlvbigpXG4gICAgY29uc3QgZGlzdGFuY2VUb1Bvc2l0aW9uID0gbmV3S25vYlBvc2l0aW9uLmNsb25lKClcbiAgICAgIC5zdWJ0cmFjdChwb3NpdGlvbilcblxuICAgIGNvbnN0IG5ld01heFdpZHRoID0gTWF0aC5tYXgoXG4gICAgICAoZGlzdGFuY2VUb1Bvc2l0aW9uLnggKiBjb3MgKyBkaXN0YW5jZVRvUG9zaXRpb24ueSAqIHNpbikgLyBvdXRwdXREaW1lbnNpb25zLnggKiAyLFxuICAgICAgMC4xXG4gICAgKVxuICAgIHNwcml0ZS5zZXRNYXhXaWR0aChuZXdNYXhXaWR0aClcbiAgICBlZGl0b3IucmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIHJlc2l6aW5nIHRoZSB0ZXh0XG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25SZXNpemVLbm9iRHJhZ1N0b3AgKGUpIHtcbiAgICB0aGlzLnByb3BzLm9uRHJhZ1N0b3AgJiYgdGhpcy5wcm9wcy5vbkRyYWdTdG9wKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY2FsbGVkIHdoZW4gdGhlIHRleHRhcmVhIGxvc2VzIGZvY3VzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25CbHVyICgpIHtcbiAgICB0aGlzLmxlYXZlRWRpdE1vZGUoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gU1RZTElOR1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHlsZSBvYmplY3QgZm9yIHRoZSByb3RhdGlvbiBrbm9iXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRSb3RhdGlvbktub2JTdHlsZSAoKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLl9nZXRSb3RhdGlvbktub2JQb3NpdGlvbigpXG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IHBvc2l0aW9uLngsXG4gICAgICB0b3A6IHBvc2l0aW9uLnlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3R5bGUgb2JqZWN0IGZvciB0aGUgcmVzaXplIGtub2JcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFJlc2l6ZUtub2JTdHlsZSAoKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLl9nZXRSZXNpemVLbm9iUG9zaXRpb24oKVxuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBwb3NpdGlvbi54LFxuICAgICAgdG9wOiBwb3NpdGlvbi55XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0eWxlIG9iamVjdCBmb3IgdGhlIGdpdmVuIHRleHQgb2JqZWN0XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRUZXh0U3R5bGUgKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCB7IHNwcml0ZSB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHNkayA9IGVkaXRvci5nZXRTREsoKVxuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSBlZGl0b3IuZ2V0T3V0cHV0RGltZW5zaW9ucygpXG4gICAgY29uc3Qgc3R5bGUgPSBzcHJpdGUuZ2V0RE9NU3R5bGUoc2RrLCBvdXRwdXREaW1lbnNpb25zKVxuXG4gICAgY29uc3Qgc3ByaXRlUG9zaXRpb24gPSB0aGlzLl9nZXRBYnNvbHV0ZVNwcml0ZVBvc2l0aW9uKClcbiAgICBjb25zdCBib3VuZGluZ0JveCA9IHNwcml0ZS5nZXREaW1lbnNpb25zKHNkaywgb3V0cHV0RGltZW5zaW9ucylcbiAgICBzdHlsZS5oZWlnaHQgPSBNYXRoLm1pbihib3VuZGluZ0JveC55LCBvdXRwdXREaW1lbnNpb25zLnkgLSBzcHJpdGVQb3NpdGlvbi55KVxuICAgIGlmICghdGhpcy5zdGF0ZS5lZGl0TW9kZSkge1xuICAgICAgc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHlsZSBvYmplY3QgZm9yIHRoZSBpdGVtIGNvbnRhaW5lclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0SXRlbUNvbnRhaW5lclN0eWxlICgpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3QgeyBzcHJpdGUgfSA9IHRoaXMucHJvcHNcblxuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSBlZGl0b3IuZ2V0T3V0cHV0RGltZW5zaW9ucygpXG4gICAgY29uc3QgYm91bmRpbmdCb3ggPSBzcHJpdGUuZ2V0RGltZW5zaW9ucyhlZGl0b3IuZ2V0U0RLKCksIG91dHB1dERpbWVuc2lvbnMpXG5cbiAgICBjb25zdCBwb3NpdGlvbiA9IHNwcml0ZS5nZXRQb3NpdGlvbigpXG4gICAgICAuY2xvbmUoKVxuICAgICAgLm11bHRpcGx5KG91dHB1dERpbWVuc2lvbnMpXG5cbiAgICBjb25zdCBkZWdyZWVzID0gc3ByaXRlLmdldFJvdGF0aW9uKCkgKiAxODAgLyBNYXRoLlBJXG4gICAgY29uc3QgdHJhbnNmb3JtID0gYHJvdGF0ZVooJHtkZWdyZWVzLnRvRml4ZWQoMil9ZGVnKWBcbiAgICBjb25zdCB0cmFuc2Zvcm1PcmlnaW4gPSAnNTAlIDUwJSdcblxuICAgIGNvbnN0IHdpZHRoID0gYm91bmRpbmdCb3gueFxuICAgIGNvbnN0IGhlaWdodCA9IGJvdW5kaW5nQm94LnlcblxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIGxlZnQ6IHBvc2l0aW9uLnggLSB3aWR0aCAqIDAuNSxcbiAgICAgIHRvcDogcG9zaXRpb24ueSAtIGhlaWdodCAqIDAuNSxcbiAgICAgIG1hcmdpbkxlZnQ6IDAsXG4gICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgIE1velRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgbXNUcmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgIFdlYmtpdFRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgdHJhbnNmb3JtT3JpZ2luOiB0cmFuc2Zvcm1PcmlnaW4sXG4gICAgICBNb3pUcmFuc2Zvcm1PcmlnaW46IHRyYW5zZm9ybU9yaWdpbixcbiAgICAgIG1zVHJhbnNmb3JtT3JpZ2luOiB0cmFuc2Zvcm1PcmlnaW4sXG4gICAgICBXZWJraXRUcmFuc2Zvcm1PcmlnaW46IHRyYW5zZm9ybU9yaWdpblxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIENBTENVTEFUSU9OU1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgcm90YXRpb24ga25vYlxuICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFJvdGF0aW9uS25vYlBvc2l0aW9uICgpIHtcbiAgICBjb25zdCB7IHNwcml0ZSB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcblxuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKHNwcml0ZS5nZXRSb3RhdGlvbigpKVxuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKHNwcml0ZS5nZXRSb3RhdGlvbigpKVxuXG4gICAgY29uc3Qgb3V0cHV0RGltZW5zaW9ucyA9IGVkaXRvci5nZXRPdXRwdXREaW1lbnNpb25zKClcbiAgICBjb25zdCBib3VuZGluZ0JveCA9IHNwcml0ZS5nZXREaW1lbnNpb25zKGVkaXRvci5nZXRTREsoKSwgb3V0cHV0RGltZW5zaW9ucylcbiAgICBjb25zdCBoYWxmRGltZW5zaW9ucyA9IGJvdW5kaW5nQm94LmNsb25lKCkuZGl2aWRlKDIpXG5cbiAgICBjb25zdCBwb3NpdGlvbiA9IHNwcml0ZS5nZXRQb3NpdGlvbigpXG4gICAgICAuY2xvbmUoKVxuICAgICAgLm11bHRpcGx5KG91dHB1dERpbWVuc2lvbnMpXG4gICAgICAuYWRkKFxuICAgICAgICBoYWxmRGltZW5zaW9ucy54ICogY29zIC0gaGFsZkRpbWVuc2lvbnMueSAqIHNpbixcbiAgICAgICAgaGFsZkRpbWVuc2lvbnMueCAqIHNpbiArIGhhbGZEaW1lbnNpb25zLnkgKiBjb3NcbiAgICAgIClcbiAgICByZXR1cm4gcG9zaXRpb25cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgcmVzaXplIGtub2JcbiAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRSZXNpemVLbm9iUG9zaXRpb24gKCkge1xuICAgIGNvbnN0IHsgc3ByaXRlIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuXG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4oc3ByaXRlLmdldFJvdGF0aW9uKCkpXG4gICAgY29uc3QgY29zID0gTWF0aC5jb3Moc3ByaXRlLmdldFJvdGF0aW9uKCkpXG5cbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuICAgIGNvbnN0IGJvdW5kaW5nQm94ID0gc3ByaXRlLmdldERpbWVuc2lvbnMoZWRpdG9yLmdldFNESygpLCBvdXRwdXREaW1lbnNpb25zKVxuICAgIGNvbnN0IGhhbGZEaW1lbnNpb25zID0gYm91bmRpbmdCb3guY2xvbmUoKS5kaXZpZGUoMilcbiAgICBjb25zdCBwb3NpdGlvbiA9IHNwcml0ZS5nZXRQb3NpdGlvbigpXG4gICAgICAuY2xvbmUoKVxuICAgICAgLm11bHRpcGx5KG91dHB1dERpbWVuc2lvbnMpXG4gICAgICAuYWRkKFxuICAgICAgICBoYWxmRGltZW5zaW9ucy54ICogY29zICsgaGFsZkRpbWVuc2lvbnMueSAqIHNpbixcbiAgICAgICAgaGFsZkRpbWVuc2lvbnMueCAqIHNpbiAtIGhhbGZEaW1lbnNpb25zLnkgKiBjb3NcbiAgICAgIClcbiAgICByZXR1cm4gcG9zaXRpb25cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBrbm9icyBmb3IgdGhpcyBpdGVtXG4gICAqIEByZXR1cm4ge0FycmF5LjxSZWFjdEJFTS5FbGVtZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJLbm9icyAoKSB7XG4gICAgbGV0IGtub2JzID0gW11cbiAgICBpZiAodGhpcy5wcm9wcy5zZWxlY3RlZCAmJiAhdGhpcy5zdGF0ZS5lZGl0TW9kZSkge1xuICAgICAga25vYnMgPSBbXG4gICAgICAgICg8RHJhZ2dhYmxlQ29tcG9uZW50XG4gICAgICAgICAgb25TdGFydD17dGhpcy5fb25Sb3RhdGlvbktub2JEcmFnU3RhcnR9XG4gICAgICAgICAgb25EcmFnPXt0aGlzLl9vblJvdGF0aW9uS25vYkRyYWd9XG4gICAgICAgICAgb25TdG9wPXt0aGlzLl9vblJvdGF0aW9uS25vYkRyYWdTdG9wfT5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTprbm9iIG06cm90YXRlICRiOmtub2InIHN0eWxlPXt0aGlzLl9nZXRSb3RhdGlvbktub2JTdHlsZSgpfT5cbiAgICAgICAgICAgIDxpbWcgYmVtPSdlOmljb24gbTpsYXJnZXInIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKCdjb250cm9scy9rbm9icy9yb3RhdGUucG5nJywgdHJ1ZSl9IC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvRHJhZ2dhYmxlQ29tcG9uZW50PiksXG4gICAgICAgICg8RHJhZ2dhYmxlQ29tcG9uZW50XG4gICAgICAgICAgb25TdGFydD17dGhpcy5fb25SZXNpemVLbm9iRHJhZ1N0YXJ0fVxuICAgICAgICAgIG9uRHJhZz17dGhpcy5fb25SZXNpemVLbm9iRHJhZ31cbiAgICAgICAgICBvblN0b3A9e3RoaXMuX29uUmVzaXplS25vYkRyYWdTdG9wfT5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTprbm9iIG06cmVzaXplICRiOmtub2InIHN0eWxlPXt0aGlzLl9nZXRSZXNpemVLbm9iU3R5bGUoKX0+XG4gICAgICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aCgnY29udHJvbHMva25vYnMvcmVzaXplLWRpYWdvbmFsLXVwLnBuZycsIHRydWUpfSAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L0RyYWdnYWJsZUNvbXBvbmVudD4pXG4gICAgICBdXG4gICAgfVxuICAgIHJldHVybiBrbm9ic1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGRyYWdnYWJsZSBpdGVtXG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVySXRlbSAoKSB7XG4gICAgY29uc3QgaXRlbUNvbnRhaW5lclN0eWxlID0gdGhpcy5fZ2V0SXRlbUNvbnRhaW5lclN0eWxlKClcbiAgICBjb25zdCB0ZXh0QXJlYSA9ICg8dGV4dGFyZWFcbiAgICAgIGJlbT0nZTpjb250ZW50J1xuICAgICAgcmVmPSd0ZXh0YXJlYSdcbiAgICAgIHN0eWxlPXt0aGlzLl9nZXRUZXh0U3R5bGUoKX1cbiAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLnRleHR9XG4gICAgICBkaXNhYmxlZD17IXRoaXMuc3RhdGUuZWRpdE1vZGV9XG4gICAgICBvbkJsdXI9e3RoaXMuX29uQmx1cn1cbiAgICAgIG9uQ2hhbmdlPXt0aGlzLl9vblRleHRDaGFuZ2V9IC8+KVxuXG4gICAgcmV0dXJuICg8YmVtIHNwZWNpZmllcj0nZTp0ZXh0Jz5cbiAgICAgIDxkaXYgYmVtPSdlOmNvbnRhaW5lcicgc3R5bGU9e2l0ZW1Db250YWluZXJTdHlsZX0+XG4gICAgICAgIHt0ZXh0QXJlYX1cbiAgICAgIDwvZGl2PlxuICAgIDwvYmVtPilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvdmVybGF5IHRoYXQgYXBwZWFycyB3aGVuIHRoZSBzcHJpdGUgaXMgc2VsZWN0ZWRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJTZWxlY3RlZE92ZXJsYXkgKCkge1xuICAgIGxldCBzZWxlY3RlZE92ZXJsYXlDbGFzc05hbWVzID0gW11cbiAgICBpZiAodGhpcy5wcm9wcy5zZWxlY3RlZCkge1xuICAgICAgc2VsZWN0ZWRPdmVybGF5Q2xhc3NOYW1lcy5wdXNoKCdpcy1zZWxlY3RlZCcpXG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlLmVkaXRNb2RlKSB7XG4gICAgICBzZWxlY3RlZE92ZXJsYXlDbGFzc05hbWVzLnB1c2goJ2lzLWRpc2FibGVkJylcbiAgICB9XG4gICAgc2VsZWN0ZWRPdmVybGF5Q2xhc3NOYW1lcyA9IHNlbGVjdGVkT3ZlcmxheUNsYXNzTmFtZXMuam9pbignICcpXG4gICAgY29uc3Qgb3ZlcmxheVN0eWxlID0gdGhpcy5fZ2V0SXRlbUNvbnRhaW5lclN0eWxlKClcblxuICAgIHJldHVybiAoPGJlbSBzcGVjaWZpZXI9J2U6dGV4dCc+XG4gICAgICA8RHJhZ2dhYmxlQ29tcG9uZW50XG4gICAgICAgIG9uU3RhcnQ9e3RoaXMuX29uSXRlbURyYWdTdGFydH1cbiAgICAgICAgb25TdG9wPXt0aGlzLl9vbkl0ZW1EcmFnU3RvcH1cbiAgICAgICAgb25EcmFnPXt0aGlzLl9vbkl0ZW1EcmFnfVxuICAgICAgICBkaXNhYmxlZD17IXRoaXMucHJvcHMuc2VsZWN0ZWQgfHwgKHRoaXMucHJvcHMuc2VsZWN0ZWQgJiYgdGhpcy5zdGF0ZS5lZGl0TW9kZSl9PlxuICAgICAgICA8ZGl2IGJlbT0nZTpzZWxlY3RlZE92ZXJsYXknXG4gICAgICAgICAgb25Eb3VibGVDbGljaz17dGhpcy5fb25JdGVtRG91YmxlQ2xpY2t9XG4gICAgICAgICAgb25Ub3VjaFN0YXJ0PXt0aGlzLl9vbkl0ZW1Ub3VjaFN0YXJ0fVxuICAgICAgICAgIG9uVG91Y2hFbmQ9e3RoaXMuX29uSXRlbVRvdWNoRW5kfVxuICAgICAgICAgIHN0eWxlPXtvdmVybGF5U3R5bGV9XG4gICAgICAgICAgY2xhc3NOYW1lPXtzZWxlY3RlZE92ZXJsYXlDbGFzc05hbWVzfSAvPlxuICAgICAgPC9EcmFnZ2FibGVDb21wb25lbnQ+XG4gICAgPC9iZW0+KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIHJldHVybiAoPGJlbSBzcGVjaWZpZXI9J2I6c3ByaXRlc0NhbnZhc0NvbnRyb2xzJz5cbiAgICAgIDxkaXYgYmVtPSckZTppdGVtIGU6Y29udGFpbmVyJz5cbiAgICAgICAge3RoaXMuX3JlbmRlckl0ZW0oKX1cbiAgICAgICAge3RoaXMuX3JlbmRlclNlbGVjdGVkT3ZlcmxheSgpfVxuICAgICAgICB7dGhpcy5fcmVuZGVyS25vYnMoKX1cbiAgICAgIDwvZGl2PlxuICAgIDwvYmVtPilcbiAgfVxufVxuXG5UZXh0SXRlbUNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBJdGVtQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9zcHJpdGVzL2l0ZW1zL3RleHQtaXRlbS1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgU0RLVXRpbHMsIFJlYWN0QkVNLCBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBEcmFnZ2FibGVDb21wb25lbnQgZnJvbSAnLi4vLi4vLi4vZHJhZ2dhYmxlLWNvbXBvbmVudCdcbmltcG9ydCBJdGVtQ29tcG9uZW50IGZyb20gJy4vaXRlbS1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0aWNrZXJJdGVtQ29tcG9uZW50IGV4dGVuZHMgSXRlbUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uUm90YXRlS25vYkRyYWdTdGFydCcsXG4gICAgICAnX29uUm90YXRlS25vYkRyYWcnLFxuICAgICAgJ19vblJvdGF0ZUtub2JEcmFnU3RvcCdcbiAgICApXG4gICAgdGhpcy5faWQgPSBTREtVdGlscy5nZXRVVUlEKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyBhIGtub2JcbiAgICogQHBhcmFtICB7U3RyaW5nfSBzaWRlXG4gICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHBvc2l0aW9uXG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Lbm9iRHJhZ1N0YXJ0IChzaWRlLCBwb3NpdGlvbiwgZSkge1xuICAgIGNvbnN0IHsgc3ByaXRlIH0gPSB0aGlzLnByb3BzXG4gICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICB0aGlzLl9pbml0aWFsUG9zaXRpb24gPSB0aGlzLl9nZXRCb3R0b21EcmFnS25vYlBvc2l0aW9uKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgIHRoaXMuX2luaXRpYWxQb3NpdGlvbiA9IHRoaXMuX2dldFRvcERyYWdLbm9iUG9zaXRpb24oKVxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIHRoaXMuX2luaXRpYWxEaW1lbnNpb25zID0gc3ByaXRlLmdldERpbWVuc2lvbnMoKS5jbG9uZSgpXG5cbiAgICB0aGlzLnByb3BzLm9uRHJhZ1N0YXJ0ICYmIHRoaXMucHJvcHMub25EcmFnU3RhcnQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIGEgc3RpY2tlclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpZGVcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gb2Zmc2V0XG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Lbm9iRHJhZyAoc2lkZSwgb2Zmc2V0LCBlKSB7XG4gICAgY29uc3QgeyBzcHJpdGUgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG5cbiAgICBjb25zdCBzdGlja2VyUG9zaXRpb24gPSB0aGlzLl9nZXRBYnNvbHV0ZVNwcml0ZVBvc2l0aW9uKClcbiAgICBjb25zdCBuZXdLbm9iUG9zaXRpb24gPSB0aGlzLl9pbml0aWFsUG9zaXRpb25cbiAgICAgIC5jbG9uZSgpXG4gICAgICAuYWRkKG9mZnNldClcblxuICAgIC8vIENhbGN1bGF0ZSBuZXcgcm90YXRpb24gYW5kIGRpbWVuc2lvbnMgZnJvbSBuZXcga25vYiBwb3NpdGlvblxuICAgIGNvbnN0IGtub2JEaXN0YW5jZUZyb21DZW50ZXIgPSBuZXdLbm9iUG9zaXRpb25cbiAgICAgIC5jbG9uZSgpXG4gICAgICAuc3VidHJhY3Qoc3RpY2tlclBvc2l0aW9uKVxuXG4gICAgY29uc3QgaW5pdGlhbEtub2JEaXN0YW5jZUZyb21DZW50ZXIgPSB0aGlzLl9pbml0aWFsUG9zaXRpb25cbiAgICAgIC5jbG9uZSgpXG4gICAgICAuc3VidHJhY3Qoc3RpY2tlclBvc2l0aW9uKVxuXG4gICAgaWYgKHRoaXMucHJvcHMub3B0aW9ucy5maXhlZFJhdGlvKSB7XG4gICAgICBjb25zdCBoYWxmRGltZW5zaW9ucyA9IHRoaXMuX2dldFN0aWNrZXJEaW1lbnNpb25zKClcbiAgICAgICAgLmRpdmlkZSgyKVxuICAgICAgICAuYWJzKClcblxuICAgICAgY29uc3QgaW5pdGlhbERpc3RhbmNlRnJvbUNlbnRlciA9IHRoaXMuX2luaXRpYWxQb3NpdGlvblxuICAgICAgICAuY2xvbmUoKVxuICAgICAgICAuc3VidHJhY3Qoc3RpY2tlclBvc2l0aW9uKVxuXG4gICAgICBsZXQgcmFkaWFuc1xuXG4gICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICByYWRpYW5zID0gTWF0aC5hdGFuMihcbiAgICAgICAgICAgIGtub2JEaXN0YW5jZUZyb21DZW50ZXIueSxcbiAgICAgICAgICAgIGtub2JEaXN0YW5jZUZyb21DZW50ZXIueFxuICAgICAgICAgICkgLSBNYXRoLmF0YW4yKGhhbGZEaW1lbnNpb25zLnksIGhhbGZEaW1lbnNpb25zLngpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICByYWRpYW5zID0gTWF0aC5hdGFuMihcbiAgICAgICAgICAgIGtub2JEaXN0YW5jZUZyb21DZW50ZXIueSxcbiAgICAgICAgICAgIGtub2JEaXN0YW5jZUZyb21DZW50ZXIueFxuICAgICAgICAgICkgLSBNYXRoLmF0YW4yKC1oYWxmRGltZW5zaW9ucy55LCAtaGFsZkRpbWVuc2lvbnMueClcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdEaW1lbnNpb25zID0gdGhpcy5faW5pdGlhbERpbWVuc2lvbnNcbiAgICAgICAgLmNsb25lKClcbiAgICAgICAgLm11bHRpcGx5KFxuICAgICAgICAgIGtub2JEaXN0YW5jZUZyb21DZW50ZXIubGVuKCkgLyBpbml0aWFsRGlzdGFuY2VGcm9tQ2VudGVyLmxlbigpXG4gICAgICAgIClcblxuICAgICAgY29uc3QgeyBzbmFwUm90YXRpb24sIHNuYXBSb3RhdGlvblRvbGVyYW5jZSB9ID0gdGhpcy5wcm9wcy5vcHRpb25zXG4gICAgICBjb25zdCBkZWdyZWVzID0gTWF0aC5yb3VuZChyYWRpYW5zICogMTgwIC8gTWF0aC5QSSlcbiAgICAgIGNvbnN0IG5leHRTbmFwID0gTWF0aC5yb3VuZChkZWdyZWVzIC8gc25hcFJvdGF0aW9uKSAqIHNuYXBSb3RhdGlvblxuICAgICAgY29uc3QgcmVtYWluZGVyID0gZGVncmVlcyAtIG5leHRTbmFwXG4gICAgICBpZiAoTWF0aC5hYnMocmVtYWluZGVyKSA8IHNuYXBSb3RhdGlvblRvbGVyYW5jZSkge1xuICAgICAgICByYWRpYW5zID0gbmV4dFNuYXAgKiBNYXRoLlBJIC8gMTgwXG4gICAgICB9XG5cbiAgICAgIHNwcml0ZS5zZXQoe1xuICAgICAgICBkaW1lbnNpb25zOiBuZXdEaW1lbnNpb25zLFxuICAgICAgICByb3RhdGlvbjogcmFkaWFuc1xuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgem9vbSA9IHRoaXMuY29udGV4dC5lZGl0b3Iuem9vbS5nZXQoKVxuICAgICAgY29uc3Qgcm90YXRpb24gPSBzcHJpdGUuZ2V0Um90YXRpb24oKVxuICAgICAgY29uc3QgY29zID0gTWF0aC5jb3Mocm90YXRpb24gKiAtMSlcbiAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKHJvdGF0aW9uICogLTEpXG5cbiAgICAgIGNvbnN0IGxvY2FsRGlzdGFuY2VUb0NlbnRlciA9IG5ldyBWZWN0b3IyKFxuICAgICAgICBrbm9iRGlzdGFuY2VGcm9tQ2VudGVyLnggKiBjb3MgLSBrbm9iRGlzdGFuY2VGcm9tQ2VudGVyLnkgKiBzaW4sXG4gICAgICAgIGtub2JEaXN0YW5jZUZyb21DZW50ZXIueCAqIHNpbiArIGtub2JEaXN0YW5jZUZyb21DZW50ZXIueSAqIGNvc1xuICAgICAgKVxuXG4gICAgICBjb25zdCBwcmV2aW91c0xvY2FsRGlzdGFuY2VUb0NlbnRlciA9IG5ldyBWZWN0b3IyKFxuICAgICAgICBpbml0aWFsS25vYkRpc3RhbmNlRnJvbUNlbnRlci54ICogY29zIC0gaW5pdGlhbEtub2JEaXN0YW5jZUZyb21DZW50ZXIueSAqIHNpbixcbiAgICAgICAgaW5pdGlhbEtub2JEaXN0YW5jZUZyb21DZW50ZXIueCAqIHNpbiArIGluaXRpYWxLbm9iRGlzdGFuY2VGcm9tQ2VudGVyLnkgKiBjb3NcbiAgICAgIClcblxuICAgICAgbGV0IGRpc3RhbmNlVG9DZW50ZXJEaWZmXG5cbiAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIGRpc3RhbmNlVG9DZW50ZXJEaWZmID0gbG9jYWxEaXN0YW5jZVRvQ2VudGVyLmNsb25lKClcbiAgICAgICAgICAgIC5zdWJ0cmFjdChwcmV2aW91c0xvY2FsRGlzdGFuY2VUb0NlbnRlcilcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIGRpc3RhbmNlVG9DZW50ZXJEaWZmID0gcHJldmlvdXNMb2NhbERpc3RhbmNlVG9DZW50ZXIuY2xvbmUoKVxuICAgICAgICAgICAgLnN1YnRyYWN0KGxvY2FsRGlzdGFuY2VUb0NlbnRlcilcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdEaW1lbnNpb25zID0gdGhpcy5faW5pdGlhbERpbWVuc2lvbnMuY2xvbmUoKVxuICAgICAgICAuYWRkKGRpc3RhbmNlVG9DZW50ZXJEaWZmLmNsb25lKCkuZGl2aWRlKHpvb20pLm11bHRpcGx5KDIpKVxuXG4gICAgICBzcHJpdGUuc2V0KHtcbiAgICAgICAgZGltZW5zaW9uczogbmV3RGltZW5zaW9uc1xuICAgICAgfSlcbiAgICB9XG4gICAgZWRpdG9yLnJlbmRlcigpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyBhIGtub2JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbktub2JEcmFnU3RvcCAoKSB7XG4gICAgdGhpcy5wcm9wcy5vbkRyYWdTdG9wICYmIHRoaXMucHJvcHMub25EcmFnU3RvcCgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIHJvdGF0ZSBrbm9iXG4gICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHBvc2l0aW9uXG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Sb3RhdGVLbm9iRHJhZ1N0YXJ0IChwb3NpdGlvbiwgZSkge1xuICAgIHRoaXMuX2luaXRpYWxQb3NpdGlvbiA9IHRoaXMuX2dldFJvdGF0ZUtub2JQb3NpdGlvbigpXG4gICAgdGhpcy5wcm9wcy5vbkRyYWdTdGFydCAmJiB0aGlzLnByb3BzLm9uRHJhZ1N0YXJ0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIHRoZSByb3RhdGUga25vYlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uUm90YXRlS25vYkRyYWdTdG9wICgpIHtcbiAgICB0aGlzLnByb3BzLm9uRHJhZ1N0b3AgJiYgdGhpcy5wcm9wcy5vbkRyYWdTdG9wKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGlsZSB0aGUgdXNlciBkcmFncyBhIHN0aWNrZXJcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gb2Zmc2V0XG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Sb3RhdGVLbm9iRHJhZyAob2Zmc2V0LCBlKSB7XG4gICAgY29uc3QgeyBzcHJpdGUgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgc3RpY2tlclBvc2l0aW9uID0gdGhpcy5fZ2V0QWJzb2x1dGVTcHJpdGVQb3NpdGlvbigpXG4gICAgY29uc3QgbmV3S25vYlBvc2l0aW9uID0gdGhpcy5faW5pdGlhbFBvc2l0aW9uXG4gICAgICAuY2xvbmUoKVxuICAgICAgLmFkZChvZmZzZXQpXG5cbiAgICBjb25zdCBoYWxmRGltZW5zaW9ucyA9IHRoaXMuX2dldFN0aWNrZXJEaW1lbnNpb25zKClcbiAgICAgIC5kaXZpZGUoMilcblxuICAgIC8vIENhbGN1bGF0ZSBuZXcgcm90YXRpb24gYW5kIGRpbWVuc2lvbnMgZnJvbSBuZXcga25vYiBwb3NpdGlvblxuICAgIGNvbnN0IGtub2JEaXN0YW5jZUZyb21DZW50ZXIgPSBuZXdLbm9iUG9zaXRpb25cbiAgICAgIC5jbG9uZSgpXG4gICAgICAuc3VidHJhY3Qoc3RpY2tlclBvc2l0aW9uKVxuXG4gICAgbGV0IHJhZGlhbnNcbiAgICByYWRpYW5zID0gTWF0aC5hdGFuMihcbiAgICAgIGtub2JEaXN0YW5jZUZyb21DZW50ZXIueSxcbiAgICAgIGtub2JEaXN0YW5jZUZyb21DZW50ZXIueFxuICAgICkgLSBNYXRoLmF0YW4yKC1oYWxmRGltZW5zaW9ucy55LCBoYWxmRGltZW5zaW9ucy54KVxuXG4gICAgc3ByaXRlLnNldCh7XG4gICAgICByb3RhdGlvbjogcmFkaWFuc1xuICAgIH0pXG5cbiAgICBlZGl0b3IucmVuZGVyKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFNUWUxJTkdcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3R5bGUgb2JqZWN0IGZvciB0aGUgYm90dG9tIHJpZ2h0IGRyYWcga25vYlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0Qm90dG9tRHJhZ0tub2JTdHlsZSAoKSB7XG4gICAgY29uc3Qga25vYlBvc2l0aW9uID0gdGhpcy5fZ2V0Qm90dG9tRHJhZ0tub2JQb3NpdGlvbigpXG5cbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDoga25vYlBvc2l0aW9uLngsXG4gICAgICB0b3A6IGtub2JQb3NpdGlvbi55XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0eWxlIG9iamVjdCBmb3IgdGhlIHRvcCByaWdodCBkcmFnIGtub2JcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFRvcERyYWdLbm9iU3R5bGUgKCkge1xuICAgIGNvbnN0IGtub2JQb3NpdGlvbiA9IHRoaXMuX2dldFRvcERyYWdLbm9iUG9zaXRpb24oKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGtub2JQb3NpdGlvbi54LFxuICAgICAgdG9wOiBrbm9iUG9zaXRpb24ueVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHlsZSBvYmplY3QgZm9yIHRoZSByb3RhdGUga25vYlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0Um90YXRlS25vYlN0eWxlICgpIHtcbiAgICBjb25zdCBrbm9iUG9zaXRpb24gPSB0aGlzLl9nZXRSb3RhdGVLbm9iUG9zaXRpb24oKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGtub2JQb3NpdGlvbi54LFxuICAgICAgdG9wOiBrbm9iUG9zaXRpb24ueVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIHN0eWxlIG9iamVjdCBmb3IgdGhpcyBzdGlja2VyXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRTdGlja2VyU3R5bGUgKCkge1xuICAgIGNvbnN0IHsgc3ByaXRlIH0gPSB0aGlzLnByb3BzXG5cbiAgICBjb25zdCBwcm9jZXNzZWREaW1lbnNpb25zID0gdGhpcy5fZ2V0U3RpY2tlckRpbWVuc2lvbnMoKVxuICAgICAgLmFicygpXG4gICAgY29uc3Qgc3ByaXRlUG9zaXRpb24gPSB0aGlzLl9nZXRBYnNvbHV0ZVNwcml0ZVBvc2l0aW9uKClcbiAgICAgIC5zdWJ0cmFjdChwcm9jZXNzZWREaW1lbnNpb25zLmNsb25lKCkuZGl2aWRlKDIpKVxuXG4gICAgY29uc3QgZGVncmVlcyA9IHNwcml0ZS5nZXRSb3RhdGlvbigpICogMTgwIC8gTWF0aC5QSVxuICAgIGxldCB0cmFuc2Zvcm0gPSBgcm90YXRlKCR7ZGVncmVlcy50b0ZpeGVkKDIpfWRlZylgXG5cbiAgICBjb25zdCBzcHJpdGVEaW1lbnNpb25zID0gc3ByaXRlLmdldERpbWVuc2lvbnMoKVxuXG4gICAgbGV0IGZsaXBWZXJ0aWNhbGx5ID0gc3ByaXRlLmdldEZsaXBWZXJ0aWNhbGx5KClcbiAgICBpZiAoc3ByaXRlRGltZW5zaW9ucy55IDwgMCkgZmxpcFZlcnRpY2FsbHkgPSAhZmxpcFZlcnRpY2FsbHlcbiAgICBpZiAoZmxpcFZlcnRpY2FsbHkpIHtcbiAgICAgIHRyYW5zZm9ybSArPSAnIHNjYWxlWSgtMSknXG4gICAgfVxuXG4gICAgbGV0IGZsaXBIb3Jpem9udGFsbHkgPSBzcHJpdGUuZ2V0RmxpcEhvcml6b250YWxseSgpXG4gICAgaWYgKHNwcml0ZURpbWVuc2lvbnMueCA8IDApIGZsaXBIb3Jpem9udGFsbHkgPSAhZmxpcEhvcml6b250YWxseVxuICAgIGlmIChmbGlwSG9yaXpvbnRhbGx5KSB7XG4gICAgICB0cmFuc2Zvcm0gKz0gJyBzY2FsZVgoLTEpJ1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHNwcml0ZVBvc2l0aW9uLnksXG4gICAgICBsZWZ0OiBzcHJpdGVQb3NpdGlvbi54LFxuICAgICAgd2lkdGg6IHByb2Nlc3NlZERpbWVuc2lvbnMueCxcbiAgICAgIGhlaWdodDogcHJvY2Vzc2VkRGltZW5zaW9ucy55LFxuICAgICAgV2Via2l0VHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICBtc1RyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgTW96VHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICBPVHJhbnNmb3JtOiB0cmFuc2Zvcm1cbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBDQUxDVUxBVElPTlNcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgc3RpY2tlciBkaW1lbnNpb25zXG4gICAqIEBwYXJhbSAge09iamVjdH0gc3RpY2tlclxuICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFN0aWNrZXJEaW1lbnNpb25zICgpIHtcbiAgICBjb25zdCB7IHNwcml0ZSB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcblxuICAgIHJldHVybiBzcHJpdGUuZ2V0RGltZW5zaW9ucygpXG4gICAgICAuY2xvbmUoKVxuICAgICAgLm11bHRpcGx5KGVkaXRvci56b29tLmdldCgpKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIHJvdGF0ZSBidXR0b24ga25vYidzIHBvc2l0aW9uXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRSb3RhdGVLbm9iUG9zaXRpb24gKCkge1xuICAgIGNvbnN0IHsgc3ByaXRlIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3Qgc3RpY2tlclBvc2l0aW9uID0gdGhpcy5fZ2V0QWJzb2x1dGVTcHJpdGVQb3NpdGlvbigpXG4gICAgY29uc3Qgc3RpY2tlclJvdGF0aW9uID0gc3ByaXRlLmdldFJvdGF0aW9uKClcblxuICAgIC8vIENhbGN1bGF0ZSBzaW4gYW5kIGNvcyBmb3Igcm90YXRpb25cbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihzdGlja2VyUm90YXRpb24gfHwgMClcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhzdGlja2VyUm90YXRpb24gfHwgMClcblxuICAgIC8vIENhbGN1bGF0ZSBzdGlja2VyIGRpbWVuc2lvbnNcbiAgICBjb25zdCBoYWxmRGltZW5zaW9ucyA9IHRoaXMuX2dldFN0aWNrZXJEaW1lbnNpb25zKClcbiAgICAgIC5kaXZpZGUoMilcblxuICAgIC8vIENhbGN1bGF0ZSBrbm9iIHBvc2l0aW9uXG4gICAgcmV0dXJuIHN0aWNrZXJQb3NpdGlvbi5jbG9uZSgpXG4gICAgICAuYWRkKFxuICAgICAgICBoYWxmRGltZW5zaW9ucy54ICogY29zICsgaGFsZkRpbWVuc2lvbnMueSAqIHNpbixcbiAgICAgICAgaGFsZkRpbWVuc2lvbnMueCAqIHNpbiAtIGhhbGZEaW1lbnNpb25zLnkgKiBjb3NcbiAgICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBkcmFnIGJvdHRvbSByaWdodCBrbm9iJ3MgcG9zaXRpb25cbiAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRCb3R0b21EcmFnS25vYlBvc2l0aW9uICgpIHtcbiAgICBjb25zdCB7IHNwcml0ZSB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHN0aWNrZXJQb3NpdGlvbiA9IHRoaXMuX2dldEFic29sdXRlU3ByaXRlUG9zaXRpb24oKVxuICAgIGNvbnN0IHN0aWNrZXJSb3RhdGlvbiA9IHNwcml0ZS5nZXRSb3RhdGlvbigpXG5cbiAgICAvLyBDYWxjdWxhdGUgc2luIGFuZCBjb3MgZm9yIHJvdGF0aW9uXG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4oc3RpY2tlclJvdGF0aW9uIHx8IDApXG4gICAgY29uc3QgY29zID0gTWF0aC5jb3Moc3RpY2tlclJvdGF0aW9uIHx8IDApXG5cbiAgICAvLyBDYWxjdWxhdGUgc3RpY2tlciBkaW1lbnNpb25zXG4gICAgY29uc3QgaGFsZkRpbWVuc2lvbnMgPSB0aGlzLl9nZXRTdGlja2VyRGltZW5zaW9ucygpXG4gICAgICAuZGl2aWRlKDIpXG5cbiAgICAvLyBDYWxjdWxhdGUga25vYiBwb3NpdGlvblxuICAgIHJldHVybiBzdGlja2VyUG9zaXRpb24uY2xvbmUoKVxuICAgICAgLmFkZChcbiAgICAgICAgaGFsZkRpbWVuc2lvbnMueCAqIGNvcyAtIGhhbGZEaW1lbnNpb25zLnkgKiBzaW4sXG4gICAgICAgIGhhbGZEaW1lbnNpb25zLnggKiBzaW4gKyBoYWxmRGltZW5zaW9ucy55ICogY29zXG4gICAgICApXG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgZHJhZyB0b3AgcmlnaHQga25vYidzIHBvc2l0aW9uXG4gICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0VG9wRHJhZ0tub2JQb3NpdGlvbiAoKSB7XG4gICAgY29uc3QgeyBzcHJpdGUgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCBzdGlja2VyUG9zaXRpb24gPSB0aGlzLl9nZXRBYnNvbHV0ZVNwcml0ZVBvc2l0aW9uKClcbiAgICBjb25zdCBzdGlja2VyUm90YXRpb24gPSBzcHJpdGUuZ2V0Um90YXRpb24oKVxuXG4gICAgLy8gQ2FsY3VsYXRlIHNpbiBhbmQgY29zIGZvciByb3RhdGlvblxuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKHN0aWNrZXJSb3RhdGlvbiB8fCAwKVxuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKHN0aWNrZXJSb3RhdGlvbiB8fCAwKVxuXG4gICAgLy8gQ2FsY3VsYXRlIHN0aWNrZXIgZGltZW5zaW9uc1xuICAgIGNvbnN0IGhhbGZEaW1lbnNpb25zID0gdGhpcy5fZ2V0U3RpY2tlckRpbWVuc2lvbnMoc3ByaXRlKVxuICAgICAgLmRpdmlkZSgyKVxuXG4gICAgLy8gQ2FsY3VsYXRlIGtub2IgcG9zaXRpb25cbiAgICByZXR1cm4gc3RpY2tlclBvc2l0aW9uLmNsb25lKClcbiAgICAgIC5zdWJ0cmFjdChcbiAgICAgICAgaGFsZkRpbWVuc2lvbnMueCAqIGNvcyAtIGhhbGZEaW1lbnNpb25zLnkgKiBzaW4sXG4gICAgICAgIGhhbGZEaW1lbnNpb25zLnggKiBzaW4gKyBoYWxmRGltZW5zaW9ucy55ICogY29zXG4gICAgICApXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUga25vYnMgZm9yIHRoaXMgaXRlbVxuICAgKiBAcmV0dXJuIHtBcnJheS48UmVhY3RCRU0uRWxlbWVudD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyS25vYnMgKCkge1xuICAgIGxldCBrbm9icyA9IFtdXG4gICAgaWYgKHRoaXMucHJvcHMuc2VsZWN0ZWQpIHtcbiAgICAgIGtub2JzID0gW1xuICAgICAgICAoPERyYWdnYWJsZUNvbXBvbmVudFxuICAgICAgICAgIG9uU3RhcnQ9e3RoaXMuX29uS25vYkRyYWdTdGFydC5iaW5kKHRoaXMsICdib3R0b20nKX1cbiAgICAgICAgICBvblN0b3A9e3RoaXMuX29uS25vYkRyYWdTdG9wLmJpbmQodGhpcywgJ2JvdHRvbScpfVxuICAgICAgICAgIG9uRHJhZz17dGhpcy5fb25Lbm9iRHJhZy5iaW5kKHRoaXMsICdib3R0b20nKX0+XG4gICAgICAgICAgPGRpdiBiZW09J2U6a25vYiAkYjprbm9iJyBzdHlsZT17dGhpcy5fZ2V0Qm90dG9tRHJhZ0tub2JTdHlsZSgpfT5cbiAgICAgICAgICAgIDxpbWcgYmVtPSdlOmljb24nIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKCdjb250cm9scy9rbm9icy9yZXNpemUtZGlhZ29uYWwtZG93bi5wbmcnLCB0cnVlKX0gLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9EcmFnZ2FibGVDb21wb25lbnQ+KSxcbiAgICAgICAgKDxEcmFnZ2FibGVDb21wb25lbnRcbiAgICAgICAgICBvblN0YXJ0PXt0aGlzLl9vbktub2JEcmFnU3RhcnQuYmluZCh0aGlzLCAndG9wJyl9XG4gICAgICAgICAgb25TdG9wPXt0aGlzLl9vbktub2JEcmFnU3RvcC5iaW5kKHRoaXMsICd0b3AnKX1cbiAgICAgICAgICBvbkRyYWc9e3RoaXMuX29uS25vYkRyYWcuYmluZCh0aGlzLCAndG9wJyl9PlxuICAgICAgICAgIDxkaXYgYmVtPSdlOmtub2IgJGI6a25vYicgc3R5bGU9e3RoaXMuX2dldFRvcERyYWdLbm9iU3R5bGUoKX0+XG4gICAgICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aCgnY29udHJvbHMva25vYnMvcmVzaXplLWRpYWdvbmFsLWRvd24ucG5nJywgdHJ1ZSl9IC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvRHJhZ2dhYmxlQ29tcG9uZW50PilcbiAgICAgIF1cblxuICAgICAgaWYgKCF0aGlzLnByb3BzLm9wdGlvbnMuZml4ZWRSYXRpbykge1xuICAgICAgICBrbm9icy5wdXNoKFxuICAgICAgICAgICg8RHJhZ2dhYmxlQ29tcG9uZW50XG4gICAgICAgICAgICBvblN0YXJ0PXt0aGlzLl9vblJvdGF0ZUtub2JEcmFnU3RhcnR9XG4gICAgICAgICAgICBvblN0b3A9e3RoaXMuX29uUm90YXRlS25vYkRyYWdTdG9wfVxuICAgICAgICAgICAgb25EcmFnPXt0aGlzLl9vblJvdGF0ZUtub2JEcmFnfT5cbiAgICAgICAgICAgIDxkaXYgYmVtPSdlOmtub2IgJGI6a25vYicgc3R5bGU9e3RoaXMuX2dldFJvdGF0ZUtub2JTdHlsZSgpfT5cbiAgICAgICAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXt0aGlzLl9nZXRBc3NldFBhdGgoJ2NvbnRyb2xzL2tub2JzL3JvdGF0ZS5wbmcnLCB0cnVlKX0gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvRHJhZ2dhYmxlQ29tcG9uZW50PilcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga25vYnNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBTVkcgZmlsdGVyc1xuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclNWR0ZpbHRlciAoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuaGlkZUNvbnRlbnQpIHJldHVybiBudWxsXG4gICAgY29uc3QgeyBzcHJpdGUgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCBhZGp1c3RtZW50cyA9IHNwcml0ZS5nZXRBZGp1c3RtZW50cygpXG4gICAgY29uc3QgYnJpZ2h0bmVzcyA9IGFkanVzdG1lbnRzLmdldEJyaWdodG5lc3MoKVxuICAgIGNvbnN0IHNhdHVyYXRpb24gPSBhZGp1c3RtZW50cy5nZXRTYXR1cmF0aW9uKClcbiAgICBjb25zdCBjb250cmFzdCA9IGFkanVzdG1lbnRzLmdldENvbnRyYXN0KClcblxuICAgIGNvbnN0IGZpbHRlcnNTVkcgPSAoXG4gICAgICBgPGZpbHRlciBpZD0ncGVzZGstc3RpY2tlci0ke3RoaXMuX2lkfS1maWx0ZXInPlxuICAgICAgICA8ZmVDb21wb25lbnRUcmFuc2Zlcj5cbiAgICAgICAgICA8ZmVGdW5jUiB0eXBlPSdsaW5lYXInIGludGVyY2VwdD0nJHticmlnaHRuZXNzfScgLz5cbiAgICAgICAgICA8ZmVGdW5jRyB0eXBlPSdsaW5lYXInIGludGVyY2VwdD0nJHticmlnaHRuZXNzfScgLz5cbiAgICAgICAgICA8ZmVGdW5jQiB0eXBlPSdsaW5lYXInIGludGVyY2VwdD0nJHticmlnaHRuZXNzfScgLz5cbiAgICAgICAgPC9mZUNvbXBvbmVudFRyYW5zZmVyPlxuICAgICAgICA8ZmVDb2xvck1hdHJpeCB0eXBlPSdzYXR1cmF0ZScgdmFsdWVzPScke3NhdHVyYXRpb259JyAvPlxuICAgICAgICA8ZmVDb21wb25lbnRUcmFuc2Zlcj5cbiAgICAgICAgICA8ZmVGdW5jUiB0eXBlPSdsaW5lYXInIHNsb3BlPScke2NvbnRyYXN0fScgaW50ZXJjZXB0PSckey0oMC41ICogY29udHJhc3QpICsgMC41fScgLz5cbiAgICAgICAgICA8ZmVGdW5jRyB0eXBlPSdsaW5lYXInIHNsb3BlPScke2NvbnRyYXN0fScgaW50ZXJjZXB0PSckey0oMC41ICogY29udHJhc3QpICsgMC41fScgLz5cbiAgICAgICAgICA8ZmVGdW5jQiB0eXBlPSdsaW5lYXInIHNsb3BlPScke2NvbnRyYXN0fScgaW50ZXJjZXB0PSckey0oMC41ICogY29udHJhc3QpICsgMC41fScgLz5cbiAgICAgICAgPC9mZUNvbXBvbmVudFRyYW5zZmVyPlxuICAgICAgPC9maWx0ZXI+YFxuICAgIClcblxuICAgIC8vIFdlIGFkZGVkIGBrZXk6IE1hdGgucmFuZG9tKClgIGJlY2F1c2UgaW4gU2FmYXJpLCBkYW5nZXJvdXNseVNldElubmVySFRNTFxuICAgIC8vIHdvdWxkIG5vdCB1cGRhdGUgd2l0aG91dCB0aGF0Li4uXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yODYzXG4gICAgcmV0dXJuICg8c3ZnIHdpZHRoPScwJyBoZWlnaHQ9JzAnIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0nc1JHQicgaXM9J3N2Zyc+XG4gICAgICB7UmVhY3RCRU0uY3JlYXRlRWxlbWVudCgnZGVmcycsIHtcbiAgICAgICAga2V5OiBNYXRoLnJhbmRvbSgpLFxuICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICAgIF9faHRtbDogZmlsdGVyc1NWR1xuICAgICAgICB9XG4gICAgICB9KX1cbiAgICA8L3N2Zz4pXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb3ZlcmxheSB0aGF0IGFwcGVhcnMgd2hlbiB0aGUgc3ByaXRlIGlzIHNlbGVjdGVkXG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyU2VsZWN0ZWRPdmVybGF5ICgpIHtcbiAgICBsZXQgc2VsZWN0ZWRPdmVybGF5Q2xhc3NOYW1lcyA9IFtdXG4gICAgaWYgKHRoaXMucHJvcHMuc2VsZWN0ZWQpIHtcbiAgICAgIHNlbGVjdGVkT3ZlcmxheUNsYXNzTmFtZXMucHVzaCgnaXMtc2VsZWN0ZWQnKVxuICAgIH1cbiAgICBzZWxlY3RlZE92ZXJsYXlDbGFzc05hbWVzID0gc2VsZWN0ZWRPdmVybGF5Q2xhc3NOYW1lcy5qb2luKCcgJylcblxuICAgIGNvbnN0IG92ZXJsYXlTdHlsZSA9IHRoaXMuX2dldFN0aWNrZXJTdHlsZSgpXG4gICAgcmV0dXJuICg8YmVtIHNwZWNpZmllcj0nZTp0ZXh0Jz5cbiAgICAgIDxEcmFnZ2FibGVDb21wb25lbnRcbiAgICAgICAgb25TdGFydD17dGhpcy5fb25JdGVtRHJhZ1N0YXJ0fVxuICAgICAgICBvblN0b3A9e3RoaXMuX29uSXRlbURyYWdTdG9wfVxuICAgICAgICBvbkRyYWc9e3RoaXMuX29uSXRlbURyYWd9XG4gICAgICAgIGRpc2FibGVkPXshdGhpcy5wcm9wcy5zZWxlY3RlZH0+XG4gICAgICAgIDxkaXYgYmVtPSdlOnNlbGVjdGVkT3ZlcmxheSdcbiAgICAgICAgICBvbkRvdWJsZUNsaWNrPXt0aGlzLl9vbkl0ZW1Eb3VibGVDbGlja31cbiAgICAgICAgICBvblRvdWNoU3RhcnQ9e3RoaXMuX29uSXRlbVRvdWNoU3RhcnR9XG4gICAgICAgICAgb25Ub3VjaEVuZD17dGhpcy5fb25JdGVtVG91Y2hFbmR9XG4gICAgICAgICAgc3R5bGU9e292ZXJsYXlTdHlsZX1cbiAgICAgICAgICBjbGFzc05hbWU9e3NlbGVjdGVkT3ZlcmxheUNsYXNzTmFtZXN9IC8+XG4gICAgICA8L0RyYWdnYWJsZUNvbXBvbmVudD5cbiAgICA8L2JlbT4pXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZHJhZ2dhYmxlIGl0ZW1cbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJJdGVtICgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5oaWRlQ29udGVudCkgcmV0dXJuIG51bGxcblxuICAgIGNvbnN0IHsgc3ByaXRlIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3Qgc3RpY2tlclN0eWxlID0gdGhpcy5fZ2V0U3RpY2tlclN0eWxlKClcblxuICAgIGNvbnN0IGJhc2VVUkwgPSB3aW5kb3cubG9jYXRpb24uaHJlZi5yZXBsYWNlKHdpbmRvdy5sb2NhdGlvbi5oYXNoLCAnJylcbiAgICBjb25zdCBzdGlja2VySW1hZ2VTdHlsZSA9IHsgZmlsdGVyOiBgdXJsKFwiJHtiYXNlVVJMfSNwZXNkay1zdGlja2VyLSR7dGhpcy5faWR9LWZpbHRlclwiKWAgfVxuXG4gICAgY29uc3Qgc3ZnU3R5bGUgPSB7IHdpZHRoOiBzdGlja2VyU3R5bGUud2lkdGgsIGhlaWdodDogc3RpY2tlclN0eWxlLmhlaWdodCB9XG4gICAgcmV0dXJuICg8YmVtIHNwZWNpZmllcj0nZTpzdGlja2VyJz5cbiAgICAgIDxkaXYgYmVtPSdlOmNvbnRhaW5lcicgc3R5bGU9e3N0aWNrZXJTdHlsZX0+XG4gICAgICAgIDxzdmcgd2lkdGg9e3BhcnNlSW50KHN0aWNrZXJTdHlsZS53aWR0aCl9IGhlaWdodD17cGFyc2VJbnQoc3RpY2tlclN0eWxlLmhlaWdodCl9IGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0nc1JHQicgaXM9J3N2Zycgc3R5bGU9e3N2Z1N0eWxlfSBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSdub25lJz5cbiAgICAgICAgICB7UmVhY3RCRU0uY3JlYXRlRWxlbWVudCgnaW1hZ2UnLCB7XG4gICAgICAgICAgICB4bGlua0hyZWY6IHNwcml0ZS5nZXRJbWFnZSgpLnNyYyxcbiAgICAgICAgICAgIHdpZHRoOiBzdGlja2VyU3R5bGUud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHN0aWNrZXJTdHlsZS5oZWlnaHQsXG4gICAgICAgICAgICBzdHlsZTogc3RpY2tlckltYWdlU3R5bGUsXG4gICAgICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAnbm9uZSdcbiAgICAgICAgICB9KX1cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2Rpdj5cbiAgICA8L2JlbT4pXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgcmV0dXJuICg8YmVtIHNwZWNpZmllcj0nYjpzcHJpdGVzQ2FudmFzQ29udHJvbHMnPlxuICAgICAgPGRpdiBiZW09JyRlOml0ZW0gZTpjb250YWluZXInPlxuICAgICAgICB7dGhpcy5fcmVuZGVyU1ZHRmlsdGVyKCl9XG4gICAgICAgIHt0aGlzLl9yZW5kZXJJdGVtKCl9XG4gICAgICAgIHt0aGlzLl9yZW5kZXJTZWxlY3RlZE92ZXJsYXkoKX1cbiAgICAgICAge3RoaXMuX3JlbmRlcktub2JzKCl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2JlbT4pXG4gIH1cbn1cblxuU3RpY2tlckl0ZW1Db21wb25lbnQuY29udGV4dFR5cGVzID0gSXRlbUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvc3ByaXRlcy9pdGVtcy9zdGlja2VyLWl0ZW0tY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNIH0gZnJvbSAnLi4vLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBJdGVtQ29tcG9uZW50IGZyb20gJy4vaXRlbS1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJydXNoSXRlbUNvbXBvbmVudCBleHRlbmRzIEl0ZW1Db21wb25lbnQge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBMSUZFQ1lDTEVcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgc3VwZXIuY29tcG9uZW50RGlkTW91bnQoKVxuICAgIGlmICh0aGlzLnByb3BzLmhpZGVDb250ZW50KSByZXR1cm5cbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLnByb3BzLnNwcml0ZS5nZXRDYW52YXMoKVxuICAgIHRoaXMuX2FwcGVuZENhbnZhcyhjYW52YXMpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyBhYm91dCB0byByZWNlaXZlIG5ldyBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSAge09iamVjdH0gbmV4dFByb3BzXG4gICAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChuZXh0UHJvcHMpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5oaWRlQ29udGVudCkgcmV0dXJuXG4gICAgaWYgKG5leHRQcm9wcy5zcHJpdGUgIT09IHRoaXMucHJvcHMuc3ByaXRlKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSB0aGlzLnByb3BzLnNwcml0ZS5nZXRDYW52YXMoKVxuICAgICAgY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2FudmFzKVxuICAgICAgY29uc3QgbmV3Q2FudmFzID0gbmV4dFByb3BzLnNwcml0ZS5nZXRDYW52YXMoKVxuICAgICAgdGhpcy5fYXBwZW5kQ2FudmFzKG5ld0NhbnZhcylcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBNSVNDXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGl0ZW0gaXMgY3VycmVudGx5IHNlbGVjdGVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBfaXNTZWxlY3RlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2JydXNoJykgPT09IHRoaXMucHJvcHMuc3ByaXRlXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogQXBwZW5kcyBhbmQgc3R5bGVzIHRoZSBnaXZlbiBjYW52YXNcbiAgICogQHBhcmFtICB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGVuZENhbnZhcyAoY2FudmFzKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSBlZGl0b3IuZ2V0T3V0cHV0RGltZW5zaW9ucygpXG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gb3V0cHV0RGltZW5zaW9ucy54ICsgJ3B4J1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBvdXRwdXREaW1lbnNpb25zLnkgKyAncHgnXG4gICAgdGhpcy5yZWZzLmJydXNoLmFwcGVuZENoaWxkKGNhbnZhcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5oaWRlQ29udGVudCkgcmV0dXJuIG51bGxcblxuICAgIGNvbnN0IGJydXNoQ2xhc3NOYW1lID0gdGhpcy5faXNTZWxlY3RlZCgpID8gJ2lzLXNlbGVjdGVkJyA6IG51bGxcbiAgICByZXR1cm4gKDxiZW0gc3BlY2lmaWVyPSdiOnNwcml0ZXNDYW52YXNDb250cm9scyc+XG4gICAgICA8ZGl2IGJlbT0nJGU6aXRlbSBlOmNvbnRhaW5lciBtOmZ1bGwnIHJlZj0nY29udGFpbmVyJz5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGJlbT0nJGU6YnJ1c2gnXG4gICAgICAgICAgY2xhc3NOYW1lPXticnVzaENsYXNzTmFtZX1cbiAgICAgICAgICByZWY9J2JydXNoJyAvPlxuICAgICAgPC9kaXY+XG4gICAgPC9iZW0+KVxuICB9XG59XG5cbkJydXNoSXRlbUNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBJdGVtQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9zcHJpdGVzL2l0ZW1zL2JydXNoLWl0ZW0tY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IEJhc2VDb21wb25lbnQsIFJlYWN0QkVNIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RpY2tlckNvbnRyb2xzT3ZlcmxheUNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb25lIG9mIHRoZSBmbGlwIGl0ZW1zXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZGlyZWN0aW9uXG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25GbGlwQ2xpY2sgKGRpcmVjdGlvbiwgZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIHRoaXMucHJvcHMub25GbGlwICYmIHRoaXMucHJvcHMub25GbGlwKGRpcmVjdGlvbilcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYHRha2UgdG8gZnJvbnRgIGl0ZW1cbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblRha2VUb0Zyb250Q2xpY2sgKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICB0aGlzLnByb3BzLm9uVGFrZVRvRnJvbnQgJiYgdGhpcy5wcm9wcy5vblRha2VUb0Zyb250KClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYHJlbW92ZWAgaXRlbVxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uUmVtb3ZlQ2xpY2sgKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICB0aGlzLnByb3BzLm9uUmVtb3ZlICYmIHRoaXMucHJvcHMub25SZW1vdmUoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGl0ZW1zIG9mIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge0FycmF5LjxSZWFjdEJFTS5FbGVtZW50Pn1cbiAgICovXG4gIF9yZW5kZXJJdGVtcyAoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICg8ZGl2IGJlbT0nJGU6aXRlbScgb25DbGljaz17dGhpcy5fb25GbGlwQ2xpY2suYmluZCh0aGlzLCAnaCcpfT5cbiAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXt0aGlzLl9nZXRBc3NldFBhdGgoJ2NvbnRyb2xzL3Nwcml0ZXMvZmxpcC1oLnBuZycsIHRydWUpfSAvPlxuICAgICAgPC9kaXY+KSxcbiAgICAgICg8ZGl2IGJlbT0nJGU6aXRlbScgb25DbGljaz17dGhpcy5fb25GbGlwQ2xpY2suYmluZCh0aGlzLCAndicpfT5cbiAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXt0aGlzLl9nZXRBc3NldFBhdGgoJ2NvbnRyb2xzL3Nwcml0ZXMvZmxpcC12LnBuZycsIHRydWUpfSAvPlxuICAgICAgPC9kaXY+KSxcbiAgICAgICg8ZGl2IGJlbT0nJGU6aXRlbScgb25DbGljaz17dGhpcy5fb25UYWtlVG9Gcm9udENsaWNrLmJpbmQodGhpcyl9PlxuICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aCgnY29udHJvbHMvc3ByaXRlcy90YWtlLXRvLWZyb250LnBuZycsIHRydWUpfSAvPlxuICAgICAgPC9kaXY+KSxcbiAgICAgICg8ZGl2IGJlbT0nJGU6c2VwYXJhdG9yJyAvPiksXG4gICAgICAoPGRpdiBiZW09JyRlOml0ZW0nIG9uQ2xpY2s9e3RoaXMuX29uUmVtb3ZlQ2xpY2suYmluZCh0aGlzKX0+XG4gICAgICAgIDxpbWcgYmVtPSdlOmljb24nIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKCdjb250cm9scy9zcHJpdGVzL3JlbW92ZS5wbmcnLCB0cnVlKX0gLz5cbiAgICAgIDwvZGl2PilcbiAgICBdXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgcmV0dXJuICg8ZGl2XG4gICAgICBiZW09JyRiOnNwcml0ZXNDb250cm9sc092ZXJsYXknPlxuICAgICAge3RoaXMuX3JlbmRlckl0ZW1zKCl9XG4gICAgPC9kaXY+KVxuICB9XG59XG5cblN0aWNrZXJDb250cm9sc092ZXJsYXlDb21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvc3RpY2tlci9zdGlja2VyLWNvbnRyb2xzLW92ZXJsYXktY29tcG9uZW50LmpzeCIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgU0RLIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBDb250cm9scyBmcm9tICcuLi9jb250cm9scydcbmltcG9ydCBUZXh0Q2FudmFzQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi4vdGV4dC90ZXh0LWNhbnZhcy1jb250cm9scy1jb21wb25lbnQnXG5pbXBvcnQgVGV4dENvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4vdGV4dC1jb250cm9scy1jb21wb25lbnQnXG5pbXBvcnQgRm9udE1hbmFnZXIgZnJvbSAnc2hhcmVkL21hbmFnZXJzL2ZvbnQtbWFuYWdlcidcbmNvbnN0IHsgVGV4dFNwcml0ZSwgQnJ1c2hTcHJpdGUgfSA9IFNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvblxuLyoqXG4gKiBUaGUgdGV4dCBjb250cm9sc1xuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xzXG4gKi9cbmNsYXNzIFRleHRDb250cm9scyBleHRlbmRzIENvbnRyb2xzIHtcbiAgLyoqXG4gICAqIFNhdmVzIHRoZSBjdXJyZW50IHRleHQgc2V0dGluZ3MgdG8gdGhlIGdsb2JhbCBzdGF0ZVxuICAgKi9cbiAgc2F2ZVRleHRTZXR0aW5ncyAoKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRTcHJpdGUgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdzZWxlY3RlZFNwcml0ZScpXG5cbiAgICBpZiAoIXNlbGVjdGVkU3ByaXRlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnNldEdsb2JhbFRvb2xTdGF0ZSgndGV4dCcsIHNlbGVjdGVkU3ByaXRlLnNlcmlhbGl6ZU9wdGlvbnMoW1xuICAgICAgJ2NvbG9yJyxcbiAgICAgICdiYWNrZ3JvdW5kQ29sb3InLFxuICAgICAgJ2NoYXJhY3RlclNwYWNpbmcnLFxuICAgICAgJ2xpbmVIZWlnaHQnLFxuICAgICAgJ2FsaWdubWVudCcsXG4gICAgICAnZm9udElkZW50aWZpZXInLFxuICAgICAgJ2ZvbnRGYW1pbHknLFxuICAgICAgJ2ZvbnRXZWlnaHQnLFxuICAgICAgJ2ZvbnRTdHlsZSdcbiAgICBdKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGxlYXZlcyB0aGVzZSBjb250cm9sc1xuICAgKiBAdGhpcyB7VGV4dENvbnRyb2xzQ29tcG9uZW50fVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgb25FeGl0ICgpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcblxuICAgIHRoaXMuc2F2ZVRleHRTZXR0aW5ncygpXG5cbiAgICBpZiAoIXRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3NraXBIaXN0b3J5JykpIHtcbiAgICAgIGVkaXRvci5oaXN0b3J5LmFkZChcbiAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICB0aGlzLmdldFNoYXJlZFN0YXRlKCdpbml0aWFsT3B0aW9ucycpLFxuICAgICAgICB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb25FeGlzdGVkQmVmb3JlJylcbiAgICAgIClcbiAgICB9XG4gICAgZWRpdG9yLnpvb20ucmVzdG9yZSgpXG4gICAgZWRpdG9yLmZlYXR1cmVzLmVuYWJsZSgnem9vbScsICdkcmFnJylcbiAgICBlZGl0b3IucmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGVudGVycyB0aGVzZSBjb250cm9sc1xuICAgKiBAdGhpcyB7U3RpY2tlckNvbnRyb2xzQ29tcG9uZW50fVxuICAgKiBAcGFyYW0ge1NoYXJlZFN0YXRlfSBzaGFyZWRTdGF0ZVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIG9uRW50ZXIgKHNoYXJlZFN0YXRlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBlZGl0b3IsIHVpIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBvcGVyYXRpb25FeGlzdGVkQmVmb3JlID0gZWRpdG9yLm9wZXJhdGlvbnMuZXhpc3RzKCdzcHJpdGUnKVxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IGVkaXRvci5vcGVyYXRpb25zLmdldE9yQ3JlYXRlKCdzcHJpdGUnKVxuICAgIGNvbnN0IHNwcml0ZXMgPSBvcGVyYXRpb24uZ2V0U3ByaXRlcygpXG4gICAgY29uc3QgaW5pdGlhbE9wdGlvbnMgPSBvcGVyYXRpb24uc2VyaWFsaXplT3B0aW9ucygpXG5cbiAgICBjb25zdCBmb250TWFuYWdlciA9IG5ldyBGb250TWFuYWdlcih1aSwgb3B0aW9ucylcbiAgICBjb25zdCBkZWZhdWx0Rm9udFZhcmlhdGlvbiA9IGZvbnRNYW5hZ2VyLmdldERlZmF1bHRWYXJpYXRpb24oKVxuXG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7XG4gICAgICBvcGVyYXRpb25FeGlzdGVkQmVmb3JlLFxuICAgICAgb3BlcmF0aW9uLFxuICAgICAgc3ByaXRlcyxcbiAgICAgIGluaXRpYWxPcHRpb25zLFxuICAgICAgZm9udE1hbmFnZXIsXG4gICAgICBkZWZhdWx0Rm9udFZhcmlhdGlvbixcbiAgICAgIGZvbnRzOiBmb250TWFuYWdlci5nZXRGb250cygpXG4gICAgfSlcblxuICAgIGVkaXRvci56b29tLnNhdmUoKVxuICAgIGVkaXRvci5yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGVyZSBpcyBzb21ldGhpbmcgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIHRoYXRcbiAgICogd291bGQgY2F1c2UgdGhlIFVJIHRvIHN3aXRjaCB0byB0aGlzIGNvbnRyb2wgb24gY2xpY2tcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBwb3NpdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkVkaXRvcn0gZWRpdG9yXG4gICAqIEByZXR1cm4geyp9XG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBjbGlja0F0UG9zaXRpb24gKHBvc2l0aW9uLCBlZGl0b3IpIHtcbiAgICBpZiAoIWVkaXRvci5vcGVyYXRpb25zLmV4aXN0cygnc3ByaXRlJykpIHJldHVybiBmYWxzZVxuXG4gICAgY29uc3Qgb3BlcmF0aW9uID0gZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ3Nwcml0ZScpXG4gICAgbGV0IHNwcml0ZXMgPSBvcGVyYXRpb24uZ2V0U3ByaXRlc0F0UG9zaXRpb24ocG9zaXRpb24sIGVkaXRvci5nZXRPdXRwdXRUZXh0dXJlRGltZW5zaW9ucygpKVxuICAgICAgLmZpbHRlcigocykgPT4gIShzIGluc3RhbmNlb2YgQnJ1c2hTcHJpdGUpKVxuXG4gICAgaWYgKHNwcml0ZXMubGVuZ3RoICYmIHNwcml0ZXNbMF0gaW5zdGFuY2VvZiBUZXh0U3ByaXRlKSB7XG4gICAgICByZXR1cm4geyBzZWxlY3RlZFNwcml0ZTogc3ByaXRlc1swXSB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBjb250cm9sIGlzIGF2YWlsYWJsZSB0byB0aGUgdXNlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkVkaXRvcn0gZWRpdG9yXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBpc0F2YWlsYWJsZSAoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1Rvb2xBbGxvd2VkKCd0ZXh0JykgJiZcbiAgICAgIGVkaXRvci5pc1Rvb2xFbmFibGVkKCd0ZXh0JylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhc3NldHMgdGhhdCBzaG91bGQgYmUgcHJlbG9hZGVkIGZvciB0aGlzIGNvbnRyb2xcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5FZGl0b3J9IGVkaXRvclxuICAgKiBAcmV0dXJuIHtTdHJpbmdbXX1cbiAgICovXG4gIHN0YXRpYyBnZXRQcmVsb2FkQXNzZXRzIChlZGl0b3IpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJ2NvbnRyb2xzL3RleHQvYWxpZ25fbGVmdC5wbmcnLFxuICAgICAgJ2NvbnRyb2xzL3RleHQvYWxpZ25fcmlnaHQucG5nJyxcbiAgICAgICdjb250cm9scy90ZXh0L2FsaWduX2NlbnRlci5wbmcnLFxuICAgICAgJ2NvbnRyb2xzL3RleHQvbWludXMucG5nJyxcbiAgICAgICdjb250cm9scy90ZXh0L3BsdXMucG5nJ1xuICAgIF1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIGNvbnRyb2xzIGNvbXBvbmVudC4gVXNlZCBmb3IgdGhlIGxvd2VyIGNvbnRyb2xzIHBhcnQgb2YgdGhlIGVkaXRvci5cbiAqIEB0eXBlIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xzQ29tcG9uZW50fVxuICogQGlnbm9yZVxuICovXG5UZXh0Q29udHJvbHMuY29udHJvbHNDb21wb25lbnQgPSBUZXh0Q29udHJvbHNDb21wb25lbnRcblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBjYW52YXMgY29tcG9uZW50LiBVc2VkIGZvciB0aGUgdXBwZXIgY29udHJvbHMgcGFydCBvZiB0aGUgZWRpdG9yIChvblxuICogdG9wIG9mIHRoZSBjYW52YXMpXG4gKiBAdHlwZSB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5Db250cm9sc0NvbXBvbmVudH1cbiAqIEBpZ25vcmVcbiAqL1xuVGV4dENvbnRyb2xzLmNhbnZhc0NvbnRyb2xzQ29tcG9uZW50ID0gVGV4dENhbnZhc0NvbnRyb2xzQ29tcG9uZW50XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cblRleHRDb250cm9scy5pZGVudGlmaWVyID0gJ3RleHQnXG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgaWNvbiBwYXRoXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGlnbm9yZVxuICovXG5UZXh0Q29udHJvbHMuaWNvblBhdGggPSAnY29udHJvbHMvb3ZlcnZpZXcvdGV4dC5wbmcnXG5cbi8qKlxuICogVGhlIGxhbmd1YWdlIGtleSB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gZGlzcGxheWluZyB0aGlzIGZpbHRlclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBpZ25vcmVcbiAqL1xuVGV4dENvbnRyb2xzLmxhbmd1YWdlS2V5ID0gJ3Blc2RrLnRleHQudGl0bGUubmFtZSdcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGlzIGNvbnRyb2xcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge09iamVjdFtdfSBbZm9udHMgPSBbXV1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JlcGxhY2VGb250cyA9IGZhbHNlXVxuICogQHByb3BlcnR5IHtTdHJpbmdbXX0gW2F2YWlsYWJsZVZhcmlhdGlvbnMgPSBudWxsXVxuICovXG5UZXh0Q29udHJvbHMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGZvbnRzOiBbXSxcbiAgcmVwbGFjZUZvbnRzOiBmYWxzZSxcbiAgYXZhaWxhYmxlVmFyaWF0aW9uczogbnVsbFxufVxuXG4vKipcbiAqIFRoZSBvcGVyYXRpb25zIHJlcXVpcmVkIGZvciB0aGlzIGNvbnRyb2wgdG8gd29yayBwcm9wZXJseVxuICogQHR5cGUge0FycmF5fVxuICovXG5UZXh0Q29udHJvbHMucmVxdWlyZWRPcGVyYXRpb25zID0gWydzcHJpdGUnXVxuXG5leHBvcnQgZGVmYXVsdCBUZXh0Q29udHJvbHNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvdGV4dC9pbmRleC5qcyIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5pbXBvcnQgeyBSZWFjdEJFTSB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgU3ByaXRlc0NhbnZhc0NvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4uL3Nwcml0ZXMvc3ByaXRlcy1jYW52YXMtY29udHJvbHMtY29tcG9uZW50J1xuaW1wb3J0IFRleHRDb250cm9sc092ZXJsYXlDb21wb25lbnQgZnJvbSAnLi90ZXh0LWNvbnRyb2xzLW92ZXJsYXktY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0Q2FudmFzQ29udHJvbHNDb21wb25lbnQgZXh0ZW5kcyBTcHJpdGVzQ2FudmFzQ29udHJvbHNDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKCdfb25UZXh0RWRpdCcpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgc2VsZWN0ZWQgaXRlbSBpcyBkZXNlbGVjdGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25JdGVtQmx1ciAoKSB7XG4gICAgY29uc3Qgc3ByaXRlID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKVxuICAgIGlmIChzcHJpdGUgJiYgc3ByaXRlLmdldFRleHQoKSA9PT0gJycpIHtcbiAgICAgIHNwcml0ZS5zZXRUZXh0KHRoaXMuX3QoJ3Blc2RrLnRleHQucGxhY2Vob2xkZXIuZGVmYXVsdFRleHQnKSlcbiAgICAgIHNwcml0ZS5fZWRpdGVkID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciByZW1vdmVzIHRoZSBzZWxlY3RlZCBzcHJpdGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblNwcml0ZVJlbW92ZSAoKSB7XG4gICAgc3VwZXIuX29uU3ByaXRlUmVtb3ZlKClcbiAgICB0aGlzLnByb3BzLm9uU3dpdGNoQ29udHJvbHMoJ2hvbWUnKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGNsaWNrcyB0aGUgZWRpdCBidXR0b25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblRleHRFZGl0ICgpIHtcbiAgICBjb25zdCBzcHJpdGUgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdzZWxlY3RlZFNwcml0ZScpXG4gICAgdGhpcy5yZWZzW2BzcHJpdGUtJHtzcHJpdGUuZ2V0SWQoKX1gXS5lbnRlckVkaXRNb2RlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIHJlbmRlcnMgY29udHJvbHMgb24gdG9wIG9mIHRoZSBzcHJpdGVzXG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyT3ZlcmxheUNvbnRyb2xzICgpIHtcbiAgICBpZiAoIXRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3NlbGVjdGVkU3ByaXRlJykpIHJldHVyblxuXG4gICAgcmV0dXJuICg8VGV4dENvbnRyb2xzT3ZlcmxheUNvbXBvbmVudFxuICAgICAgb25UYWtlVG9Gcm9udD17dGhpcy5fb25TcHJpdGVUYWtlVG9Gcm9udH1cbiAgICAgIG9uUmVtb3ZlPXt0aGlzLl9vblNwcml0ZVJlbW92ZX1cbiAgICAgIG9uRWRpdD17dGhpcy5fb25UZXh0RWRpdH0gLz4pXG4gIH1cbn1cblxuVGV4dENhbnZhc0NvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IFNwcml0ZXNDYW52YXNDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvdGV4dC90ZXh0LWNhbnZhcy1jb250cm9scy1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCwgUmVhY3RCRU0sIFV0aWxzIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dENvbnRyb2xzT3ZlcmxheUNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIGBlZGl0YCBpdGVtXG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25FZGl0Q2xpY2sgKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICB0aGlzLnByb3BzLm9uRWRpdCAmJiB0aGlzLnByb3BzLm9uRWRpdCgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIGB0YWtlIHRvIGZyb250YCBpdGVtXG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25UYWtlVG9Gcm9udENsaWNrIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgdGhpcy5wcm9wcy5vblRha2VUb0Zyb250ICYmIHRoaXMucHJvcHMub25UYWtlVG9Gcm9udCgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIGByZW1vdmVgIGl0ZW1cbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblJlbW92ZUNsaWNrIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgdGhpcy5wcm9wcy5vblJlbW92ZSAmJiB0aGlzLnByb3BzLm9uUmVtb3ZlKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBpdGVtcyBvZiB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtBcnJheS48UmVhY3RCRU0uRWxlbWVudD59XG4gICAqL1xuICBfcmVuZGVySXRlbXMgKCkge1xuICAgIGxldCBpdGVtcyA9IFtcbiAgICAgICg8ZGl2IGJlbT0nJGU6aXRlbScgb25DbGljaz17dGhpcy5fb25UYWtlVG9Gcm9udENsaWNrLmJpbmQodGhpcyl9PlxuICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aCgnY29udHJvbHMvc3ByaXRlcy90YWtlLXRvLWZyb250LnBuZycsIHRydWUpfSAvPlxuICAgICAgPC9kaXY+KVxuICAgIF1cblxuICAgIGlmIChVdGlscy5pc1RvdWNoRGV2aWNlKCkpIHtcbiAgICAgIGl0ZW1zID0gaXRlbXMuY29uY2F0KFtcbiAgICAgICAgKDxkaXYgYmVtPSckZTpzZXBhcmF0b3InIC8+KSxcbiAgICAgICAgKDxkaXYgYmVtPSckZTppdGVtJyBvbkNsaWNrPXt0aGlzLl9vbkVkaXRDbGljay5iaW5kKHRoaXMpfT5cbiAgICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aCgnY29udHJvbHMvc3ByaXRlcy9lZGl0LnBuZycsIHRydWUpfSAvPlxuICAgICAgICA8L2Rpdj4pXG4gICAgICBdKVxuICAgIH1cblxuICAgIGl0ZW1zID0gaXRlbXMuY29uY2F0KFtcbiAgICAgICg8ZGl2IGJlbT0nJGU6c2VwYXJhdG9yJyAvPiksXG4gICAgICAoPGRpdiBiZW09JyRlOml0ZW0nIG9uQ2xpY2s9e3RoaXMuX29uUmVtb3ZlQ2xpY2suYmluZCh0aGlzKX0+XG4gICAgICAgIDxpbWcgYmVtPSdlOmljb24nIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKCdjb250cm9scy9zcHJpdGVzL3JlbW92ZS5wbmcnLCB0cnVlKX0gLz5cbiAgICAgIDwvZGl2PilcbiAgICBdKVxuXG4gICAgcmV0dXJuIGl0ZW1zXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgcmV0dXJuICg8ZGl2XG4gICAgICBiZW09JyRiOnNwcml0ZXNDb250cm9sc092ZXJsYXknPlxuICAgICAge3RoaXMuX3JlbmRlckl0ZW1zKCl9XG4gICAgPC9kaXY+KVxuICB9XG59XG5cblRleHRDb250cm9sc092ZXJsYXlDb21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvdGV4dC90ZXh0LWNvbnRyb2xzLW92ZXJsYXktY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBDb25zdGFudHMsIFZlY3RvcjIgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IENvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4uL2NvbnRyb2xzLWNvbXBvbmVudCdcbmltcG9ydCBTY3JvbGxiYXJDb21wb25lbnQgZnJvbSAnLi4vLi4vc2Nyb2xsYmFyLWNvbXBvbmVudCdcbmltcG9ydCBDb2xvclBpY2tlckNvbXBvbmVudCBmcm9tICcuLi8uLi9jb2xvci1waWNrZXIvY29sb3ItcGlja2VyLWNvbXBvbmVudCdcbmltcG9ydCBTbGlkZXJPdmVybGF5Q29tcG9uZW50IGZyb20gJy4uL3NsaWRlci1vdmVybGF5LWNvbXBvbmVudCdcbmltcG9ydCBGb250UHJldmlld0NvbXBvbmVudCBmcm9tICcuL2ZvbnQtcHJldmlldy1jb21wb25lbnQnXG5pbXBvcnQgRm9udENvbXBvbmVudCBmcm9tICcuL2ZvbnQtY29tcG9uZW50J1xuaW1wb3J0IE1vZGFsTWFuYWdlciBmcm9tICcuLi8uLi8uLi9saWIvbW9kYWwtbWFuYWdlci5qcydcblxuY29uc3QgQUxJR05NRU5UUyA9IFtcbiAgJ2xlZnQnLFxuICAnY2VudGVyJyxcbiAgJ3JpZ2h0J1xuXVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dENvbnRyb2xzQ29tcG9uZW50IGV4dGVuZHMgQ29udHJvbHNDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbkZvbnRTaXplQ2hhbmdlJyxcbiAgICAgICdfb25Gb250Q2hhbmdlJyxcbiAgICAgICdfb25BbGlnbm1lbnRDbGljaycsXG4gICAgICAnX29uVGFrZVRvRnJvbnRDbGljaycsXG4gICAgICAnX29uRm9yZWdyb3VuZENvbG9yQ2hhbmdlJyxcbiAgICAgICdfb25CYWNrZ3JvdW5kQ29sb3JDaGFuZ2UnLFxuICAgICAgJ19vbkJlZm9yZUhpc3RvcnlVbmRvJ1xuICAgIClcbiAgICB0aGlzLl9ldmVudHMgPSB7XG4gICAgICBbQ29uc3RhbnRzLkVWRU5UUy5ISVNUT1JZX0JFRk9SRV9VTkRPXTogdGhpcy5fb25CZWZvcmVIaXN0b3J5VW5kb1xuICAgIH1cbiAgICB0aGlzLl9vcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxuICAgIHRoaXMuX2ZvbnRMb2FkZXIgPSB0aGlzLmNvbnRleHQudWkuZ2V0Rm9udExvYWRlcigpXG4gICAgdGhpcy5fZm9udExvYWRlci5zZXRGb250cyh0aGlzLmdldFNoYXJlZFN0YXRlKCdmb250cycpKVxuXG4gICAgdGhpcy5zdGF0ZSA9IHsgbW9kZTogbnVsbCwgbG9hZGluZzogdHJ1ZSB9XG5cbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgZWRpdG9yLnJlbmRlcigpXG5cbiAgICB0aGlzLl9mb250cyA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2ZvbnRzJylcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIExJRkVDWUNMRVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICBzdXBlci5jb21wb25lbnREaWRNb3VudCgpXG5cbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgZWRpdG9yLnpvb20uc2V0KCdhdXRvJywgKCkgPT4ge1xuICAgICAgZWRpdG9yLmZlYXR1cmVzLmRpc2FibGUoJ3pvb20nLCAnZHJhZycpXG4gICAgfSlcblxuICAgIGNvbnN0IGZvbnRzTG9hZGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5fY3JlYXRlVGV4dCgpXG4gICAgICB0aGlzLnNldFN0YXRlKHsgbG9hZGluZzogZmFsc2UgfSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZm9udExvYWRlci5uZWVkc1RvTG9hZCgpKSB7XG4gICAgICB0aGlzLl9sb2FkRm9udHMoKVxuICAgICAgICAudGhlbihmb250c0xvYWRlZC5iaW5kKHRoaXMpKVxuICAgIH0gZWxzZSB7XG4gICAgICBmb250c0xvYWRlZCgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBmb250c1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2xvYWRGb250cyAoKSB7XG4gICAgY29uc3QgbG9hZGluZ01vZGFsID0gTW9kYWxNYW5hZ2VyLmluc3RhbmNlLmRpc3BsYXlMb2FkaW5nKHRoaXMuX3QoJ3Blc2RrLmNvbW1vbi50ZXh0LmxvYWRpbmcnKSlcbiAgICByZXR1cm4gdGhpcy5fZm9udExvYWRlci5sb2FkKClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgbG9hZGluZ01vZGFsLmNsb3NlKClcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgbG9hZGluZ01vZGFsLmNsb3NlKClcbiAgICAgICAgTW9kYWxNYW5hZ2VyLmluc3RhbmNlLmRpc3BsYXlXYXJuaW5nKFxuICAgICAgICAgIHRoaXMuX3QoJ3Blc2RrLnRleHQudGl0bGUubG9hZGluZ0ZvbnRzRmFpbGVkJyksXG4gICAgICAgICAgdGhpcy5fdCgncGVzZGsudGV4dC50ZXh0LmxvYWRpbmdGb250c0ZhaWxlZCcpXG4gICAgICAgIClcbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB0ZXh0IG9iamVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZVRleHQgKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBzZWxlY3RlZFNwcml0ZSA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3NlbGVjdGVkU3ByaXRlJylcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxuICAgIGNvbnN0IGZvbnRNYW5hZ2VyID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnZm9udE1hbmFnZXInKVxuXG4gICAgLy8gQ2hlY2sgZm9yIHByZXZpb3VzbHkgc2F2ZWQgdGV4dCBzZXR0aW5ncyBpbiB0aGUgZ2xvYmFsIHN0YXRlXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB0aGlzLmdldEdsb2JhbFRvb2xTdGF0ZSgndGV4dCcpXG5cbiAgICBjb25zdCBkZWZhdWx0Rm9udFZhcmlhdGlvbiA9IGRlZmF1bHRPcHRpb25zXG4gICAgICA/IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2RlZmF1bHRGb250VmFyaWF0aW9uJylcbiAgICAgIDogZm9udE1hbmFnZXIuZ2V0RGVmYXVsdFZhcmlhdGlvbigpXG5cbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuICAgIGlmICghc2VsZWN0ZWRTcHJpdGUpIHtcbiAgICAgIGNvbnN0IHNkayA9IGVkaXRvci5nZXRTREsoKVxuICAgICAgY29uc3QgcmVuZGVyZXIgPSBzZGsuZ2V0UmVuZGVyZXIoKVxuXG4gICAgICBjb25zdCBtYXhUZXh0dXJlU2l6ZSA9IHJlbmRlcmVyLmdldE1heFRleHR1cmVTaXplKClcbiAgICAgIGNvbnN0IHRleHQgPSBvcGVyYXRpb24uY3JlYXRlVGV4dCh7XG4gICAgICAgIGZvbnRJZGVudGlmaWVyOiBkZWZhdWx0Rm9udFZhcmlhdGlvbi5nZXRJZGVudGlmaWVyKCksXG4gICAgICAgIHRleHQ6IHRoaXMuX3QoJ3Blc2RrLnRleHQucGxhY2Vob2xkZXIuZGVmYXVsdFRleHQnKSxcbiAgICAgICAgcG9zaXRpb246IG5ldyBWZWN0b3IyKDAuNSwgMC41KSxcbiAgICAgICAgcGl2b3Q6IG5ldyBWZWN0b3IyKDAuNSwgMC41KSxcbiAgICAgICAgbWF4V2lkdGg6IDAuNSxcbiAgICAgICAgbWF4SGVpZ2h0OiBtYXhUZXh0dXJlU2l6ZSA/IG1heFRleHR1cmVTaXplIC8gb3V0cHV0RGltZW5zaW9ucy55IDogMyxcbiAgICAgICAgZm9udFNpemU6IDAuMDgsXG4gICAgICAgIGZvbnRGYW1pbHk6IGRlZmF1bHRGb250VmFyaWF0aW9uLmdldEZvbnQoKS5nZXRGb250RmFtaWx5KCksXG4gICAgICAgIGZvbnRXZWlnaHQ6IGRlZmF1bHRGb250VmFyaWF0aW9uLmdldEZvbnRXZWlnaHQoKSxcbiAgICAgICAgZm9udFN0eWxlOiBkZWZhdWx0Rm9udFZhcmlhdGlvbi5nZXRGb250U3R5bGUoKSxcbiAgICAgICAgYWxpZ25tZW50OiAnY2VudGVyJyxcbiAgICAgICAgLi4uKGRlZmF1bHRPcHRpb25zIHx8IHt9KVxuICAgICAgfSlcbiAgICAgIG9wZXJhdGlvbi5hZGRTcHJpdGUodGV4dClcbiAgICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUoeyBzZWxlY3RlZFNwcml0ZTogdGV4dCB9KVxuICAgICAgZWRpdG9yLnJlbmRlcigpXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIGJlZm9yZSBhIGhpc3RvcnkgaXRlbSBpcyBiZWluZyB1bmRvbmVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBoaXN0b3J5T2JqZWN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25CZWZvcmVIaXN0b3J5VW5kbyAoaGlzdG9yeU9iamVjdCkge1xuICAgIGNvbnN0IHsgb3BlcmF0aW9uLCBvcHRpb25zIH0gPSBoaXN0b3J5T2JqZWN0XG4gICAgaWYgKG9wZXJhdGlvbiAhPT0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJykpIHJldHVyblxuXG4gICAgY29uc3QgeyBzcHJpdGVzIH0gPSBvcHRpb25zXG4gICAgaWYgKHNwcml0ZXMuaW5kZXhPZih0aGlzLmdldFNoYXJlZFN0YXRlKCdzZWxlY3RlZFNwcml0ZScpKSA9PT0gLTEpIHtcbiAgICAgIC8vIEN1cnJlbnRseSBzZWxlY3RlZCBzcHJpdGUgaXMgYmVpbmcgcmVtb3ZlZC4gTGVhdmUgY29udHJvbCB3aXRob3V0IGFkZGluZyBoaXN0b3J5IGl0ZW0uXG4gICAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHsgc2tpcEhpc3Rvcnk6IHRydWUgfSwgZmFsc2UpXG4gICAgICB0aGlzLnByb3BzLm9uU3dpdGNoQ29udHJvbHMoJ2hvbWUnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYmFjayBidXR0b25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQmFja0NsaWNrIChlKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIHRoaXMuc2F2ZVRleHRTZXR0aW5ncygpXG4gICAgZWRpdG9yLnJlbmRlcigpXG4gICAgdGhpcy5fYmFja0J1dHRvbkNsaWNrZWQgPSB0cnVlXG4gICAgdGhpcy5wcm9wcy5vblN3aXRjaENvbnRyb2xzKCdob21lJylcbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlcyB0aGUgY3VycmVudCB0ZXh0IHNldHRpbmdzIHRvIHRoZSBnbG9iYWwgc3RhdGVcbiAgICovXG4gIHNhdmVUZXh0U2V0dGluZ3MgKCkge1xuICAgIGNvbnN0IHNlbGVjdGVkU3ByaXRlID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKVxuXG4gICAgaWYgKCFzZWxlY3RlZFNwcml0ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5zZXRHbG9iYWxUb29sU3RhdGUoJ3RleHQnLCBzZWxlY3RlZFNwcml0ZS5zZXJpYWxpemVPcHRpb25zKFtcbiAgICAgICdjb2xvcicsXG4gICAgICAnYmFja2dyb3VuZENvbG9yJyxcbiAgICAgICdjaGFyYWN0ZXJTcGFjaW5nJyxcbiAgICAgICdsaW5lSGVpZ2h0JyxcbiAgICAgICdhbGlnbm1lbnQnLFxuICAgICAgJ2ZvbnRJZGVudGlmaWVyJyxcbiAgICAgICdmb250RmFtaWx5JyxcbiAgICAgICdmb250V2VpZ2h0JyxcbiAgICAgICdmb250U3R5bGUnXG4gICAgXSkpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgc2hhcmVkIHN0YXRlIGhhcyBjaGFuZ2VkXG4gICAqIEBwYXJhbSAge09iamVjdH0gbmV3U3RhdGVcbiAgICovXG4gIHNoYXJlZFN0YXRlRGlkQ2hhbmdlIChuZXdTdGF0ZSkge1xuICAgIGlmICgnc2VsZWN0ZWRTcHJpdGUnIGluIG5ld1N0YXRlKSB7XG4gICAgICB0aGlzLmZvcmNlVXBkYXRlKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgZm9udCBzaXplIGhhcyBiZWVuIGNoYW5nZWRcbiAgICogQHBhcmFtICB7TnVtYmVyfSBmb250U2l6ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uRm9udFNpemVDaGFuZ2UgKGZvbnRTaXplKSB7XG4gICAgY29uc3Qge2VkaXRvcn0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXRPdXRwdXREaW1lbnNpb25zKClcbiAgICBjb25zdCBzZWxlY3RlZFRleHQgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdzZWxlY3RlZFNwcml0ZScpXG4gICAgc2VsZWN0ZWRUZXh0LnNldEZvbnRTaXplKGZvbnRTaXplIC8gb3V0cHV0RGltZW5zaW9ucy55KVxuICAgIHRoaXMuZm9yY2VVcGRhdGUoKVxuICAgIGVkaXRvci5yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGZvbnQgZmFtaWx5IG9yIHdlaWdodCBoYXMgYmVlbiBjaGFuZ2VkXG4gICAqIEBwYXJhbSAge09iamVjdH0gdmFyaWF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Gb250Q2hhbmdlICh2YXJpYXRpb24pIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKVxuICAgIHNlbGVjdGVkVGV4dC5zZXRGb250RmFtaWx5KHZhcmlhdGlvbi5nZXRGb250KCkuZ2V0Rm9udEZhbWlseSgpKVxuICAgIHNlbGVjdGVkVGV4dC5zZXRGb250V2VpZ2h0KHZhcmlhdGlvbi5nZXRGb250V2VpZ2h0KCkpXG4gICAgc2VsZWN0ZWRUZXh0LnNldEZvbnRTdHlsZSh2YXJpYXRpb24uZ2V0Rm9udFN0eWxlKCkpXG4gICAgc2VsZWN0ZWRUZXh0LnNldEZvbnRJZGVudGlmaWVyKHZhcmlhdGlvbi5nZXRJZGVudGlmaWVyKCkpXG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gICAgZWRpdG9yLnJlbmRlcigpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIGFsaWdubWVudCBidXR0b25cbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkFsaWdubWVudENsaWNrIChlKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IHNlbGVjdGVkVGV4dCA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3NlbGVjdGVkU3ByaXRlJylcbiAgICBjb25zdCBhbGlnbm1lbnQgPSBzZWxlY3RlZFRleHQuZ2V0QWxpZ25tZW50KClcblxuICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IEFMSUdOTUVOVFMuaW5kZXhPZihhbGlnbm1lbnQpXG4gICAgY29uc3QgbmV4dEluZGV4ID0gKGN1cnJlbnRJbmRleCArIDEpICUgQUxJR05NRU5UUy5sZW5ndGhcbiAgICBjb25zdCBuZXdBbGlnbm1lbnQgPSBBTElHTk1FTlRTW25leHRJbmRleF1cblxuICAgIHNlbGVjdGVkVGV4dC5zZXRBbGlnbm1lbnQobmV3QWxpZ25tZW50KVxuICAgIHRoaXMuZm9yY2VTaGFyZWRVcGRhdGUoKVxuICAgIGVkaXRvci5yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBcInRha2UgdG8gZnJvbnRcIiBidXR0b25cbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblRha2VUb0Zyb250Q2xpY2sgKGUpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICBvcGVyYXRpb24udGFrZVNwcml0ZVRvRnJvbnQodGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKSlcbiAgICB0aGlzLmZvcmNlU2hhcmVkVXBkYXRlKClcbiAgICBlZGl0b3IucmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNoYW5nZXMgdGhlIGZvcmVncm91bmQgY29sb3JcbiAgICogQHBhcmFtICB7Q29sb3J9IGNvbG9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Gb3JlZ3JvdW5kQ29sb3JDaGFuZ2UgKGNvbG9yKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IHNlbGVjdGVkVGV4dCA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3NlbGVjdGVkU3ByaXRlJylcbiAgICBzZWxlY3RlZFRleHQuc2V0Q29sb3IoY29sb3IpXG4gICAgZWRpdG9yLnJlbmRlcigpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjaGFuZ2VzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yXG4gICAqIEBwYXJhbSAge0NvbG9yfSBjb2xvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQmFja2dyb3VuZENvbG9yQ2hhbmdlIChjb2xvcikge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBzZWxlY3RlZFRleHQgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdzZWxlY3RlZFNwcml0ZScpXG4gICAgc2VsZWN0ZWRUZXh0LnNldEJhY2tncm91bmRDb2xvcihjb2xvcilcbiAgICBlZGl0b3IucmVuZGVyKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE1PREVTXG5cbiAgLyoqXG4gICAqIFN3aXRjaGVzIHRvIHRoZSBnaXZlbiBtb2RlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbW9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3N3aXRjaFRvTW9kZSAobW9kZSkge1xuICAgIGlmIChtb2RlID09PSB0aGlzLnN0YXRlLm1vZGUpIG1vZGUgPSBudWxsXG5cbiAgICB0aGlzLnNldFN0YXRlKHsgbW9kZSB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG92ZXJsYXkgY29udHJvbHMgb2YgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlck92ZXJsYXlDb250cm9scyAoKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlLm1vZGUpIHtcbiAgICAgIGNhc2UgJ3NpemUnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyRm9udFNpemVPdmVybGF5Q29udHJvbCgpXG4gICAgICBjYXNlICdmb250JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlckZvbnRGYW1pbHlPdmVybGF5Q29udHJvbCgpXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEZPTlQgU0laRVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBmb250IHNpemUgb3ZlcmxheSBjb250cm9sIChzbGlkZXIpXG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyRm9udFNpemVPdmVybGF5Q29udHJvbCAoKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKVxuICAgIGlmICghc2VsZWN0ZWRUZXh0KSByZXR1cm5cblxuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuXG4gICAgY29uc3QgbWF4Rm9udFNpemUgPSBNYXRoLnJvdW5kKG91dHB1dERpbWVuc2lvbnMueSlcbiAgICBjb25zdCBmb250U2l6ZSA9IE1hdGgucm91bmQoc2VsZWN0ZWRUZXh0LmdldEZvbnRTaXplKCkgKiBvdXRwdXREaW1lbnNpb25zLnkpXG4gICAgcmV0dXJuICg8U2xpZGVyT3ZlcmxheUNvbXBvbmVudFxuICAgICAgdmFsdWU9e2ZvbnRTaXplfVxuICAgICAgbWluVmFsdWU9e291dHB1dERpbWVuc2lvbnMueSAqIDAuMDV9XG4gICAgICBtYXhWYWx1ZT17bWF4Rm9udFNpemV9XG4gICAgICBsYWJlbD17dGhpcy5fdCgncGVzZGsudGV4dC5idXR0b24uc2l6ZScpfVxuICAgICAgb25DaGFuZ2U9e3RoaXMuX29uRm9udFNpemVDaGFuZ2V9IC8+KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGZvbnQgc2l6ZSBsaXN0IGl0ZW1cbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclNpemVJdGVtICgpIHtcbiAgICBjb25zdCBzZWxlY3RlZFRleHQgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdzZWxlY3RlZFNwcml0ZScpXG4gICAgaWYgKCFzZWxlY3RlZFRleHQpIHJldHVyblxuXG4gICAgY29uc3Qgb3V0cHV0RGltZW5zaW9ucyA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0T3V0cHV0RGltZW5zaW9ucygpXG5cbiAgICBjb25zdCBmb250U2l6ZSA9IHNlbGVjdGVkVGV4dC5nZXRGb250U2l6ZSgpXG4gICAgY29uc3QgY2xhc3NOYW1lID0gdGhpcy5zdGF0ZS5tb2RlID09PSAnc2l6ZScgPyAnaXMtYWN0aXZlJyA6IG51bGxcblxuICAgIHJldHVybiAoPGxpXG4gICAgICBiZW09J2U6aXRlbSdcbiAgICAgIGtleT0nc2l6ZSc+XG4gICAgICA8YmVtIHNwZWNpZmllcj0nJGI6Y29udHJvbHMnPlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgYmVtPSckZTpidXR0b24gbTp3aXRoTGFiZWwnXG4gICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgICAgICAgZGF0YS1pZGVudGlmaWVyPSdmb250U2l6ZSdcbiAgICAgICAgICBvbkNsaWNrPXt0aGlzLl9zd2l0Y2hUb01vZGUuYmluZCh0aGlzLCAnc2l6ZScpfT5cbiAgICAgICAgICA8ZGl2IGJlbT0nYjpmb250U2l6ZSBlOnRleHQnPntNYXRoLnJvdW5kKGZvbnRTaXplICogb3V0cHV0RGltZW5zaW9ucy55KX08L2Rpdj5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTpsYWJlbCc+e3RoaXMuX3QoJ3Blc2RrLnRleHQuYnV0dG9uLnNpemUnKX08L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2JlbT5cbiAgICA8L2xpPilcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEZPTlQgRkFNSUxZXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGZvbnQgZmFtaWx5IG92ZXJsYXkgY29udHJvbFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckZvbnRGYW1pbHlPdmVybGF5Q29udHJvbCAoKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKVxuICAgIGlmICghc2VsZWN0ZWRUZXh0KSByZXR1cm5cblxuICAgIHJldHVybiAoPEZvbnRDb21wb25lbnRcbiAgICAgIGZvbnRGYW1pbHk9e3NlbGVjdGVkVGV4dC5nZXRGb250RmFtaWx5KCl9XG4gICAgICBmb250V2VpZ2h0PXtzZWxlY3RlZFRleHQuZ2V0Rm9udFdlaWdodCgpfVxuICAgICAgZm9udFN0eWxlPXtzZWxlY3RlZFRleHQuZ2V0Rm9udFN0eWxlKCl9XG4gICAgICBmb250cz17dGhpcy5fZm9udHN9XG4gICAgICBvbkNoYW5nZT17dGhpcy5fb25Gb250Q2hhbmdlfSAvPilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBmb250IGxpc3QgaXRlbVxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyRm9udEl0ZW0gKCkge1xuICAgIGNvbnN0IHNlbGVjdGVkVGV4dCA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3NlbGVjdGVkU3ByaXRlJylcbiAgICBpZiAoIXNlbGVjdGVkVGV4dCkgcmV0dXJuXG5cbiAgICBjb25zdCBjbGFzc05hbWUgPSB0aGlzLnN0YXRlLm1vZGUgPT09ICdmb250JyA/ICdpcy1hY3RpdmUnIDogbnVsbFxuICAgIHJldHVybiAoPGxpXG4gICAgICBiZW09J2U6aXRlbSdcbiAgICAgIGtleT0nZm9udCc+XG4gICAgICA8YmVtIHNwZWNpZmllcj0nJGI6Y29udHJvbHMnPlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgYmVtPSckZTpidXR0b24gbTp3aXRoTGFiZWwnXG4gICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgICAgICAgZGF0YS1pZGVudGlmaWVyPSdmb250J1xuICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuX3N3aXRjaFRvTW9kZS5iaW5kKHRoaXMsICdmb250Jyl9PlxuICAgICAgICAgIDxGb250UHJldmlld0NvbXBvbmVudFxuICAgICAgICAgICAgZm9udEZhbWlseT17c2VsZWN0ZWRUZXh0LmdldEZvbnRGYW1pbHkoKX1cbiAgICAgICAgICAgIGZvbnRXZWlnaHQ9e3NlbGVjdGVkVGV4dC5nZXRGb250V2VpZ2h0KCl9XG4gICAgICAgICAgICBmb250U3R5bGU9e3NlbGVjdGVkVGV4dC5nZXRGb250U3R5bGUoKX0gLz5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTpsYWJlbCc+e3RoaXMuX3QoJ3Blc2RrLnRleHQuYnV0dG9uLmZvbnQnKX08L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2JlbT5cbiAgICA8L2xpPilcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEFMSUdOTUVOVFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSB0ZXh0IGFsaWdubWVudCBsaXN0IGl0ZW1cbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckFsaWdubWVudEl0ZW0gKCkge1xuICAgIGNvbnN0IHNlbGVjdGVkVGV4dCA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3NlbGVjdGVkU3ByaXRlJylcbiAgICBpZiAoIXNlbGVjdGVkVGV4dCkgcmV0dXJuXG5cbiAgICBjb25zdCBhbGlnbm1lbnQgPSBzZWxlY3RlZFRleHQuZ2V0QWxpZ25tZW50KClcblxuICAgIHJldHVybiAoPGxpXG4gICAgICBiZW09J2U6aXRlbSdcbiAgICAgIGtleT0nYWxpZ25tZW50Jz5cbiAgICAgIDxiZW0gc3BlY2lmaWVyPSckYjpjb250cm9scyc+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBiZW09JyRlOmJ1dHRvbiBtOndpdGhMYWJlbCdcbiAgICAgICAgICBvbkNsaWNrPXt0aGlzLl9vbkFsaWdubWVudENsaWNrfVxuICAgICAgICAgIGRhdGEtaWRlbnRpZmllcj0nYWxpZ25tZW50Jz5cbiAgICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aChgY29udHJvbHMvdGV4dC9hbGlnbl8ke2FsaWdubWVudH0ucG5nYCwgdHJ1ZSl9IC8+XG4gICAgICAgICAgPGRpdiBiZW09J2U6bGFiZWwnPnt0aGlzLl90KCdwZXNkay50ZXh0LmJ1dHRvbi5hbGlnbm1lbnQnKX08L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2JlbT5cbiAgICA8L2xpPilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBcInRha2UgdG8gZnJvbnRcIiBsaXN0IGl0ZW1cbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclRha2VUb0Zyb250SXRlbSAoKSB7XG4gICAgcmV0dXJuICg8bGlcbiAgICAgIGJlbT0nZTppdGVtJ1xuICAgICAga2V5PSd0YWtlVG9Gcm9udCc+XG4gICAgICA8YmVtIHNwZWNpZmllcj0nJGI6Y29udHJvbHMnPlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgYmVtPSckZTpidXR0b24gbTp3aXRoTGFiZWwnXG4gICAgICAgICAgb25DbGljaz17dGhpcy5fb25UYWtlVG9Gcm9udENsaWNrfT5cbiAgICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aCgnY29udHJvbHMvc3ByaXRlcy90YWtlX3RvX2Zyb250LnBuZycsIHRydWUpfSAvPlxuICAgICAgICAgIDxkaXYgYmVtPSdlOmxhYmVsJz57dGhpcy5fdCgncGVzZGsudGV4dC5idXR0b24udGFrZVRvRnJvbnQnKX08L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2JlbT5cbiAgICA8L2xpPilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge0FycmF5LjxSZWFjdEJFTS5FbGVtZW50Pn1cbiAgICovXG4gIHJlbmRlckNvbnRyb2xzICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5sb2FkaW5nKSByZXR1cm4gPGRpdiAvPlxuXG4gICAgY29uc3QgbGlzdEl0ZW1zID0gW1xuICAgICAgdGhpcy5fcmVuZGVyU2l6ZUl0ZW0oKSxcbiAgICAgIHRoaXMuX3JlbmRlckZvbnRJdGVtKCksXG4gICAgICB0aGlzLl9yZW5kZXJBbGlnbm1lbnRJdGVtKClcbiAgICBdXG5cbiAgICBjb25zdCBzZWxlY3RlZFRleHQgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdzZWxlY3RlZFNwcml0ZScpXG5cbiAgICBjb25zdCBmb3JlZ3JvdW5kQ29sb3IgPSBzZWxlY3RlZFRleHQuZ2V0Q29sb3IoKS5jbG9uZSgpXG4gICAgY29uc3QgYmFja2dyb3VuZENvbG9yID0gc2VsZWN0ZWRUZXh0LmdldEJhY2tncm91bmRDb2xvcigpLmNsb25lKClcblxuICAgIHJldHVybiBbXG4gICAgICAoPGRpdiBiZW09J2U6Y2VsbCBtOmxpc3QnPlxuICAgICAgICA8U2Nyb2xsYmFyQ29tcG9uZW50IHJlZj0nc2Nyb2xsYmFyJz5cbiAgICAgICAgICA8dWwgYmVtPSckZTpsaXN0Jz5cbiAgICAgICAgICAgIHtsaXN0SXRlbXN9XG4gICAgICAgICAgPC91bD5cbiAgICAgICAgPC9TY3JvbGxiYXJDb21wb25lbnQ+XG4gICAgICA8L2Rpdj4pLFxuICAgICAgKDxkaXYgYmVtPSdlOmNlbGwgbTpjb2xvclBpY2tlcic+XG4gICAgICAgIDxDb2xvclBpY2tlckNvbXBvbmVudFxuICAgICAgICAgIGluaXRpYWxWYWx1ZT17Zm9yZWdyb3VuZENvbG9yfVxuICAgICAgICAgIGxhYmVsPXt0aGlzLl90KCdwZXNkay50ZXh0LmJ1dHRvbi5mb3JlZ3JvdW5kJyl9XG4gICAgICAgICAgb25DaGFuZ2U9e3RoaXMuX29uRm9yZWdyb3VuZENvbG9yQ2hhbmdlfSAvPlxuICAgICAgPC9kaXY+KSxcbiAgICAgICg8ZGl2IGJlbT0nZTpjZWxsIG06Y29sb3JQaWNrZXInPlxuICAgICAgICA8Q29sb3JQaWNrZXJDb21wb25lbnRcbiAgICAgICAgICBpbml0aWFsVmFsdWU9e2JhY2tncm91bmRDb2xvcn1cbiAgICAgICAgICBsYWJlbD17dGhpcy5fdCgncGVzZGsudGV4dC5idXR0b24uYmFja2dyb3VuZCcpfVxuICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLl9vbkJhY2tncm91bmRDb2xvckNoYW5nZX0gLz5cbiAgICAgIDwvZGl2PilcbiAgICBdXG4gIH1cbn1cblxuVGV4dENvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IENvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy90ZXh0L3RleHQtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vZ2xvYmFscydcbmltcG9ydCBBbHBoYUNvbXBvbmVudCBmcm9tICcuL2FscGhhLWNvbXBvbmVudCdcbmltcG9ydCBTYXR1cmF0aW9uQ29tcG9uZW50IGZyb20gJy4vc2F0dXJhdGlvbi1jb21wb25lbnQnXG5pbXBvcnQgSHVlQ29tcG9uZW50IGZyb20gJy4vaHVlLWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sb3JQaWNrZXJPdmVybGF5Q29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5wcm9wcy5pbml0aWFsVmFsdWUuY2xvbmUoKVxuICAgIGNvbnN0IGhzdkFyciA9IHRoaXMuX3ZhbHVlLnRvSFNWKClcbiAgICBjb25zdCBoID0gaHN2QXJyWzBdXG4gICAgY29uc3QgcyA9IGhzdkFyclsxXVxuICAgIGNvbnN0IHYgPSBoc3ZBcnJbMl1cbiAgICB0aGlzLl9oc3YgPSB7IGgsIHMsIHYgfVxuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25FbGVtZW50Q2xpY2snLFxuICAgICAgJ19vbkNvbG9yQ2hhbmdlJyxcbiAgICAgICdfb25Eb2N1bWVudENsaWNrJ1xuICAgIClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIExJRkVDWUNMRVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICBzdXBlci5jb21wb25lbnREaWRNb3VudCgpXG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uRG9jdW1lbnRDbGljaylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGlzIGFib3V0IHRvIGJlIHVubW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVubW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudFdpbGxVbm1vdW50KClcblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25Eb2N1bWVudENsaWNrKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIGFueXdoZXJlIG9uIHRoZSBzY3JlZW4uIElmIHRoZSBjbGljayBpcyBvdXRzaWRlXG4gICAqIG9mIHRoZSBjb2xvciBwaWNrZXIgYW5kIHRoZSBjb2xvciBwaWNrZXIgaXMgdmlzaWJsZSwgd2UgaGlkZSB0aGlzIGNvbG9yIHBpY2tlci5cbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkRvY3VtZW50Q2xpY2sgKGUpIHtcbiAgICBmb3IgKGxldCBlbGVtZW50ID0gZS50YXJnZXQ7IGVsZW1lbnQ7IGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChlbGVtZW50ID09PSB0aGlzLnJlZnMucm9vdCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcm9wcy5vbkNsb3NlICYmXG4gICAgICB0aGlzLnByb3BzLm9uQ2xvc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIENhdGNoZXMgY2xpY2tzIG9uIHRoZSBlbGVtZW50IGFuZCBtYWtlcyBzdXJlIHRoYXQgbm8gY2xpY2sgZXZlbnQgaXMgdHJpZ2dlcmVkXG4gICAqIG9uIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uRWxlbWVudENsaWNrIChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGNvbG9yIGNoYW5nZXNcbiAgICogQHBhcmFtICB7Q29sb3J9IGNvbG9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Db2xvckNoYW5nZSAoY29sb3IpIHtcbiAgICB0aGlzLl92YWx1ZSA9IGNvbG9yXG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZSAmJiB0aGlzLnByb3BzLm9uQ2hhbmdlKGNvbG9yKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIGxldCBhbHBoYUNvbXBvbmVudFxuICAgIGlmICh0aGlzLnByb3BzLmFscGhhICE9PSBmYWxzZSkge1xuICAgICAgYWxwaGFDb21wb25lbnQgPSA8QWxwaGFDb21wb25lbnRcbiAgICAgICAgaW5pdGlhbFZhbHVlPXt0aGlzLl92YWx1ZX1cbiAgICAgICAgb25DaGFuZ2U9e3RoaXMuX29uQ29sb3JDaGFuZ2V9XG4gICAgICAvPlxuICAgIH1cblxuICAgIHJldHVybiAoPGRpdiBiZW09JyRiOmNvbG9yUGlja2VyICRlOm92ZXJsYXknIG9uQ2xpY2s9e3RoaXMuX29uRWxlbWVudENsaWNrfSByZWY9J3Jvb3QnPlxuICAgICAge2FscGhhQ29tcG9uZW50fVxuICAgICAgPGRpdiBiZW09J2U6Ym90dG9tJz5cbiAgICAgICAgPFNhdHVyYXRpb25Db21wb25lbnRcbiAgICAgICAgICBpbml0aWFsVmFsdWU9e3RoaXMuX3ZhbHVlfVxuICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLl9vbkNvbG9yQ2hhbmdlfVxuICAgICAgICAvPlxuICAgICAgICA8SHVlQ29tcG9uZW50XG4gICAgICAgICAgaW5pdGlhbFZhbHVlPXt0aGlzLl92YWx1ZX1cbiAgICAgICAgICBvbkNoYW5nZT17dGhpcy5fb25Db2xvckNoYW5nZX1cbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PilcbiAgfVxufVxuXG5Db2xvclBpY2tlck92ZXJsYXlDb21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29sb3ItcGlja2VyL292ZXJsYXktY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50LCBVdGlscyB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgRHJhZ2dhYmxlQ29tcG9uZW50IGZyb20gJy4uL2RyYWdnYWJsZS1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFscGhhQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uS25vYkRyYWcnLFxuICAgICAgJ19vbktub2JEcmFnU3RhcnQnXG4gICAgKVxuXG4gICAgdGhpcy5fdmFsdWUgPSB0aGlzLnByb3BzLmluaXRpYWxWYWx1ZS5jbG9uZSgpXG4gICAgdGhpcy5fdHJhbnNwYXJlbnRQYXR0ZXJuQ2FudmFzID0gVXRpbHMuY3JlYXRlVHJhbnNwYXJlbnRQYXR0ZXJuQ2FudmFzKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIExJRkVDWUNMRVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBhZnRlciB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgc3VwZXIuY29tcG9uZW50RGlkTW91bnQoKVxuICAgIHRoaXMuX3JlbmRlckNhbnZhcygpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCByZWNlaXZlcyBuZXcgcHJvcHMgb3Igc3RhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBuZXdQcm9wc1xuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlIChuZXdQcm9wcykge1xuICAgIGNvbnN0IHsgaW5pdGlhbFZhbHVlIH0gPSBuZXdQcm9wc1xuICAgIGlmIChpbml0aWFsVmFsdWUgIT09IHRoaXMuX3ZhbHVlKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IGluaXRpYWxWYWx1ZS5jbG9uZSgpXG4gICAgICB0aGlzLl9yZW5kZXJDYW52YXMoKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBEUkFHIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUga25vYlxuICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBwb3NpdGlvblxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uS25vYkRyYWdTdGFydCAocG9zaXRpb24sIGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IHRoaXMucmVmcy5rbm9iKSB7XG4gICAgICB0aGlzLl9pbml0aWFsQWxwaGEgPSB0aGlzLl92YWx1ZS5hXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NldEFscGhhRnJvbVBvc2l0aW9uKHBvc2l0aW9uKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUga25vYlxuICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBvZmZzZXRcbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbktub2JEcmFnIChvZmZzZXQsIGUpIHtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLnJlZnMuY2FudmFzXG4gICAgY29uc3QgY2FudmFzV2lkdGggPSBjYW52YXMub2Zmc2V0V2lkdGhcblxuICAgIGNvbnN0IGFscGhhQ2hhbmdlID0gb2Zmc2V0LnggLyBjYW52YXNXaWR0aFxuICAgIHRoaXMuX3NldEFscGhhKHRoaXMuX2luaXRpYWxBbHBoYSArIGFscGhhQ2hhbmdlKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gU1RZTElOR1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHlsZSBvYmplY3QgZm9yIHRoZSBrbm9iXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRLbm9iU3R5bGUgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiAodGhpcy5fdmFsdWUuYSAqIDEwMCkudG9GaXhlZCgyKSArICclJyxcbiAgICAgIHRvcDogJzUwJSdcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBNSVNDXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFscGhhIHZhbHVlIG9mIHRoZSBjb2xvciB0byB0aGUgZ2l2ZW4gb25lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0QWxwaGEgKGEpIHtcbiAgICB0aGlzLl92YWx1ZS5hID0gYVxuICAgIHRoaXMuX3ZhbHVlLmEgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCB0aGlzLl92YWx1ZS5hKSlcbiAgICB0aGlzLmZvcmNlVXBkYXRlKClcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlICYmIHRoaXMucHJvcHMub25DaGFuZ2UodGhpcy5fdmFsdWUpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYWxwaGEgZnJvbSB0aGUgZ2l2ZW4gY3Vyc29yIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gcG9zaXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRBbHBoYUZyb21Qb3NpdGlvbiAocG9zaXRpb24pIHtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLnJlZnMuY2FudmFzXG4gICAgdGhpcy5faW5pdGlhbEFscGhhID0gcG9zaXRpb24ueCAvIGNhbnZhcy5vZmZzZXRXaWR0aFxuICAgIHRoaXMuX3NldEFscGhhKHRoaXMuX2luaXRpYWxBbHBoYSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjYW52YXMgd2l0aCB0aGUgY3VycmVudCBjb2xvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckNhbnZhcyAoKSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5yZWZzLmNhbnZhc1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuXG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLm9mZnNldFdpZHRoXG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy5vZmZzZXRIZWlnaHRcblxuICAgIC8vIEZpbGwgd2l0aCBwYXR0ZXJuXG4gICAgY29uc3QgcGF0dGVybiA9IGNvbnRleHQuY3JlYXRlUGF0dGVybih0aGlzLl90cmFuc3BhcmVudFBhdHRlcm5DYW52YXMsICdyZXBlYXQnKVxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gcGF0dGVyblxuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuXG4gICAgLy8gQ3JlYXRlIGdyYWRpZW50XG4gICAgY29uc3QgZ3JhZGllbnQgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcbiAgICBsZXQgY29sb3IgPSB0aGlzLl92YWx1ZS5jbG9uZSgpXG4gICAgY29sb3IuYSA9IDBcbiAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgY29sb3IudG9SR0JBKCkpXG4gICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIHRoaXMuX3ZhbHVlLnRvSGV4KCkpXG5cbiAgICAvLyBEcmF3IGdyYWRpZW50XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBncmFkaWVudFxuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIHJldHVybiAoPGRpdiBiZW09JyRiOmNvbG9yUGlja2VyICRlOmFscGhhJz5cbiAgICAgIDxEcmFnZ2FibGVDb21wb25lbnRcbiAgICAgICAgb25TdGFydD17dGhpcy5fb25Lbm9iRHJhZ1N0YXJ0fVxuICAgICAgICBvbkRyYWc9e3RoaXMuX29uS25vYkRyYWd9PlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxjYW52YXMgYmVtPSdlOmNhbnZhcycgcmVmPSdjYW52YXMnIC8+XG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgYmVtPSdlOmtub2IgJGI6a25vYiBtOnRyYW5zcGFyZW50J1xuICAgICAgICAgICAgcmVmPSdrbm9iJ1xuICAgICAgICAgICAgc3R5bGU9e3RoaXMuX2dldEtub2JTdHlsZSgpfSAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvRHJhZ2dhYmxlQ29tcG9uZW50PlxuICAgIDwvZGl2PilcbiAgfVxufVxuXG5BbHBoYUNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb2xvci1waWNrZXIvYWxwaGEtY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50LCBDb2xvciB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgRHJhZ2dhYmxlQ29tcG9uZW50IGZyb20gJy4uL2RyYWdnYWJsZS1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNhdHVyYXRpb25Db21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25Lbm9iRHJhZycsXG4gICAgICAnX29uS25vYkRyYWdTdGFydCdcbiAgICApXG5cbiAgICB0aGlzLl92YWx1ZSA9IHRoaXMucHJvcHMuaW5pdGlhbFZhbHVlLmNsb25lKClcbiAgICBjb25zdCBoc3ZBcnIgPSB0aGlzLl92YWx1ZS50b0hTVigpXG4gICAgY29uc3QgaCA9IGhzdkFyclswXVxuICAgIGNvbnN0IHMgPSBoc3ZBcnJbMV1cbiAgICBjb25zdCB2ID0gaHN2QXJyWzJdXG4gICAgdGhpcy5faHN2Q29sb3IgPSB7IGgsIHMsIHYgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIGFmdGVyIHRoaXMgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICBzdXBlci5jb21wb25lbnREaWRNb3VudCgpXG4gICAgdGhpcy5fcmVuZGVyQ2FudmFzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IHJlY2VpdmVzIG5ldyBwcm9wcyBvciBzdGF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG5ld1Byb3BzXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBzaG91bGRDb21wb25lbnRVcGRhdGUgKG5ld1Byb3BzKSB7XG4gICAgY29uc3QgeyBpbml0aWFsVmFsdWUgfSA9IG5ld1Byb3BzXG4gICAgaWYgKGluaXRpYWxWYWx1ZSAhPT0gdGhpcy5fdmFsdWUpIHtcbiAgICAgIHRoaXMuX3ZhbHVlID0gaW5pdGlhbFZhbHVlLmNsb25lKClcbiAgICAgIGNvbnN0IGhzdkFyciA9IHRoaXMuX3ZhbHVlLnRvSFNWKClcbiAgICAgIGNvbnN0IGggPSBoc3ZBcnJbMF1cbiAgICAgIGNvbnN0IHMgPSBoc3ZBcnJbMV1cbiAgICAgIGNvbnN0IHYgPSBoc3ZBcnJbMl1cbiAgICAgIHRoaXMuX2hzdkNvbG9yID0geyBoLCBzLCB2IH1cbiAgICAgIHRoaXMuX3JlbmRlckNhbnZhcygpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIERSQUcgRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBrbm9iXG4gICAqIEBwYXJhbSAge1ZlY3Rvcn0gcG9zaXRpb25cbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbktub2JEcmFnU3RhcnQgKHBvc2l0aW9uLCBlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSB0aGlzLnJlZnMua25vYikge1xuICAgICAgdGhpcy5faW5pdGlhbFZhbHVlID0gdGhpcy5faHN2Q29sb3IudlxuICAgICAgdGhpcy5faW5pdGlhbFNhdHVyYXRpb24gPSB0aGlzLl9oc3ZDb2xvci5zXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NldFZhbHVlc0Zyb21Qb3NpdGlvbihwb3NpdGlvbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIGtub2JcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gb2Zmc2V0XG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Lbm9iRHJhZyAob2Zmc2V0LCBlKSB7XG4gICAgY29uc3QgeyBjYW52YXMgfSA9IHRoaXMucmVmc1xuICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gY2FudmFzLm9mZnNldFdpZHRoXG4gICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gY2FudmFzLm9mZnNldEhlaWdodFxuXG4gICAgY29uc3Qgc2F0dXJhdGlvbkNoYW5nZSA9IG9mZnNldC54IC8gY2FudmFzV2lkdGhcbiAgICBjb25zdCB2YWx1ZUNoYW5nZSA9IG9mZnNldC55IC8gY2FudmFzSGVpZ2h0ICogLTFcblxuICAgIGxldCB7IGggfSA9IHRoaXMuX2hzdkNvbG9yXG4gICAgdGhpcy5fc2V0SFNWKFxuICAgICAgaCxcbiAgICAgIHRoaXMuX2luaXRpYWxTYXR1cmF0aW9uICsgc2F0dXJhdGlvbkNoYW5nZSxcbiAgICAgIHRoaXMuX2luaXRpYWxWYWx1ZSArIHZhbHVlQ2hhbmdlXG4gICAgKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gU1RZTElOR1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHlsZSBvYmplY3QgZm9yIHRoZSBrbm9iXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRLbm9iU3R5bGUgKCkge1xuICAgIGNvbnN0IHsgcywgdiB9ID0gdGhpcy5faHN2Q29sb3JcblxuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiAocyAqIDEwMCkudG9GaXhlZCgyKSArICclJyxcbiAgICAgIHRvcDogKCgxIC0gdikgKiAxMDApLnRvRml4ZWQoMikgKyAnJSdcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBNSVNDXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIEhTViB2YWx1ZXMgb2YgdGhlIGNvbG9yIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRIU1YgKGgsIHMsIHYpIHtcbiAgICBzID0gTWF0aC5tYXgoMC4wMSwgTWF0aC5taW4ocywgMC45OSkpXG4gICAgdiA9IE1hdGgubWF4KDAuMDEsIE1hdGgubWluKHYsIDAuOTkpKVxuICAgIHRoaXMuX3ZhbHVlID0gQ29sb3IuZnJvbUhTVihoLCBzLCB2LCB0aGlzLl92YWx1ZS5hKVxuICAgIHRoaXMuX2hzdkNvbG9yID0geyBoLCBzLCB2IH1cblxuICAgIHRoaXMuZm9yY2VVcGRhdGUoKVxuICAgIHRoaXMucHJvcHMub25DaGFuZ2UgJiYgdGhpcy5wcm9wcy5vbkNoYW5nZSh0aGlzLl92YWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZXMgZnJvbSB0aGUgZ2l2ZW4gY3Vyc29yIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gcG9zaXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRWYWx1ZXNGcm9tUG9zaXRpb24gKHBvc2l0aW9uKSB7XG4gICAgY29uc3QgeyBjYW52YXMgfSA9IHRoaXMucmVmc1xuICAgIHRoaXMuX2luaXRpYWxTYXR1cmF0aW9uID0gcG9zaXRpb24ueCAvIGNhbnZhcy5vZmZzZXRXaWR0aFxuICAgIHRoaXMuX2luaXRpYWxWYWx1ZSA9IDEgLSAocG9zaXRpb24ueSAvIGNhbnZhcy5vZmZzZXRIZWlnaHQpXG5cbiAgICBsZXQgeyBoIH0gPSB0aGlzLl9oc3ZDb2xvclxuICAgIHRoaXMuX3NldEhTVihcbiAgICAgIGgsXG4gICAgICB0aGlzLl9pbml0aWFsU2F0dXJhdGlvbixcbiAgICAgIHRoaXMuX2luaXRpYWxWYWx1ZVxuICAgIClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjdXJyZW50IGNvbG9yIHRvIHRoZSBjYW52YXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJDYW52YXMgKCkge1xuICAgIGNvbnN0IHsgY2FudmFzIH0gPSB0aGlzLnJlZnNcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcblxuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5vZmZzZXRXaWR0aFxuICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMub2Zmc2V0SGVpZ2h0XG5cbiAgICBsZXQgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gKGNhbnZhcy5oZWlnaHQgLSB5KSAvIGNhbnZhcy5oZWlnaHRcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgY2FudmFzLndpZHRoOyB4KyspIHtcbiAgICAgICAgY29uc3Qgc2F0dXJhdGlvbiA9IHggLyBjYW52YXMud2lkdGhcbiAgICAgICAgY29uc3QgY29sb3IgPSBDb2xvci5mcm9tSFNWKHRoaXMuX2hzdkNvbG9yLmgsIHNhdHVyYXRpb24sIHZhbHVlKVxuICAgICAgICBjb25zdCB7IHIsIGcsIGIsIGEgfSA9IGNvbG9yXG5cbiAgICAgICAgY29uc3QgaW5kZXggPSAoeSAqIGNhbnZhcy53aWR0aCArIHgpICogNFxuXG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4XSA9IHIgKiAyNTVcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSA9IGcgKiAyNTVcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSA9IGIgKiAyNTVcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAzXSA9IGEgKiAyNTVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgcmV0dXJuICg8ZGl2IGJlbT0nJGI6Y29sb3JQaWNrZXIgJGU6c2F0dXJhdGlvbic+XG4gICAgICA8RHJhZ2dhYmxlQ29tcG9uZW50XG4gICAgICAgIG9uU3RhcnQ9e3RoaXMuX29uS25vYkRyYWdTdGFydH1cbiAgICAgICAgb25EcmFnPXt0aGlzLl9vbktub2JEcmFnfT5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8Y2FudmFzIGJlbT0nZTpjYW52YXMnIHJlZj0nY2FudmFzJyAvPlxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGJlbT0nZTprbm9iICRiOmtub2IgbTp0cmFuc3BhcmVudCdcbiAgICAgICAgICAgIHJlZj0na25vYidcbiAgICAgICAgICAgIHN0eWxlPXt0aGlzLl9nZXRLbm9iU3R5bGUoKX0gLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L0RyYWdnYWJsZUNvbXBvbmVudD5cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuU2F0dXJhdGlvbkNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb2xvci1waWNrZXIvc2F0dXJhdGlvbi1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQsIENvbG9yIH0gZnJvbSAnLi4vLi4vZ2xvYmFscydcbmltcG9ydCBEcmFnZ2FibGVDb21wb25lbnQgZnJvbSAnLi4vZHJhZ2dhYmxlLWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSHVlQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uS25vYkRyYWcnLFxuICAgICAgJ19vbktub2JEcmFnU3RhcnQnXG4gICAgKVxuXG4gICAgdGhpcy5fdmFsdWUgPSB0aGlzLnByb3BzLmluaXRpYWxWYWx1ZS5jbG9uZSgpXG4gICAgY29uc3QgaHN2QXJyID0gdGhpcy5fdmFsdWUudG9IU1YoKVxuICAgIGNvbnN0IGggPSBoc3ZBcnJbMF1cbiAgICBjb25zdCBzID0gaHN2QXJyWzFdXG4gICAgY29uc3QgdiA9IGhzdkFyclsyXVxuICAgIHRoaXMuX2hzdkNvbG9yID0geyBoLCBzLCB2IH1cblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB2YWx1ZTogdGhpcy5wcm9wcy5pbml0aWFsVmFsdWVcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBMSUZFQ1lDTEVcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgYWZ0ZXIgdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudERpZE1vdW50KClcbiAgICB0aGlzLl9yZW5kZXJDYW52YXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgcmVjZWl2ZXMgbmV3IHByb3BzIG9yIHN0YXRlXG4gICAqIEBwYXJhbSAge09iamVjdH0gbmV3UHJvcHNcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZSAobmV3UHJvcHMpIHtcbiAgICBjb25zdCB7IGluaXRpYWxWYWx1ZSB9ID0gbmV3UHJvcHNcbiAgICBpZiAoaW5pdGlhbFZhbHVlICE9PSB0aGlzLl92YWx1ZSkge1xuICAgICAgdGhpcy5fdmFsdWUgPSBpbml0aWFsVmFsdWUuY2xvbmUoKVxuICAgICAgY29uc3QgaHN2QXJyID0gdGhpcy5fdmFsdWUudG9IU1YoKVxuICAgICAgY29uc3QgaCA9IGhzdkFyclswXVxuICAgICAgY29uc3QgcyA9IGhzdkFyclsxXVxuICAgICAgY29uc3QgdiA9IGhzdkFyclsyXVxuICAgICAgdGhpcy5faHN2Q29sb3IgPSB7IGgsIHMsIHYgfVxuICAgICAgdGhpcy5fcmVuZGVyQ2FudmFzKClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRFJBRyBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIGtub2JcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gcG9zaXRpb25cbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbktub2JEcmFnU3RhcnQgKHBvc2l0aW9uLCBlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSB0aGlzLnJlZnMua25vYikge1xuICAgICAgdGhpcy5faW5pdGlhbEh1ZSA9IHRoaXMuX2hzdkNvbG9yLmhcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2V0VmFsdWVGcm9tUG9zaXRpb24ocG9zaXRpb24pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBrbm9iXG4gICAqIEBwYXJhbSAge1ZlY3RvcjJ9IG9mZnNldFxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uS25vYkRyYWcgKG9mZnNldCwgZSkge1xuICAgIGNvbnN0IHsgY2FudmFzIH0gPSB0aGlzLnJlZnNcbiAgICBjb25zdCBjYW52YXNIZWlnaHQgPSBjYW52YXMub2Zmc2V0SGVpZ2h0XG5cbiAgICBjb25zdCBodWVDaGFuZ2UgPSBvZmZzZXQueSAvIGNhbnZhc0hlaWdodFxuICAgIHRoaXMuX3NldEh1ZSh0aGlzLl9pbml0aWFsSHVlICsgaHVlQ2hhbmdlKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gU1RZTElOR1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHlsZSBvYmplY3QgZm9yIHRoZSBrbm9iXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRLbm9iU3R5bGUgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiAnNTAlJyxcbiAgICAgIHRvcDogKHRoaXMuX2hzdkNvbG9yLmggKiAxMDApLnRvRml4ZWQoMikgKyAnJSdcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBNSVNDXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGh1ZSB2YWx1ZSBvZiB0aGUgY29sb3IgdG8gdGhlIGdpdmVuIG9uZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldEh1ZSAoaCkge1xuICAgIGxldCB7IHMsIHYgfSA9IHRoaXMuX2hzdkNvbG9yXG4gICAgaCA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGgpKVxuICAgIHMgPSBNYXRoLm1heCgwLjAxLCBNYXRoLm1pbihzLCAwLjk5KSlcbiAgICB2ID0gTWF0aC5tYXgoMC4wMSwgTWF0aC5taW4odiwgMC45OSkpXG5cbiAgICB0aGlzLl92YWx1ZSA9IENvbG9yLmZyb21IU1YoaCwgcywgdiwgdGhpcy5fdmFsdWUuYSlcbiAgICB0aGlzLl9oc3ZDb2xvciA9IHsgaCwgcywgdiB9XG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZSAmJiB0aGlzLnByb3BzLm9uQ2hhbmdlKHRoaXMuX3ZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZyb20gdGhlIGdpdmVuIGN1cnNvciBwb3NpdGlvblxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHBvc2l0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0VmFsdWVGcm9tUG9zaXRpb24gKHBvc2l0aW9uKSB7XG4gICAgY29uc3QgeyBjYW52YXMgfSA9IHRoaXMucmVmc1xuICAgIHRoaXMuX2luaXRpYWxIdWUgPSBwb3NpdGlvbi55IC8gY2FudmFzLm9mZnNldEhlaWdodFxuICAgIHRoaXMuX3NldEh1ZSh0aGlzLl9pbml0aWFsSHVlKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGh1ZSBjb2xvcnMgdG8gdGhlIGNhbnZhc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckNhbnZhcyAoKSB7XG4gICAgY29uc3QgeyBjYW52YXMgfSA9IHRoaXMucmVmc1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuXG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLm9mZnNldFdpZHRoXG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy5vZmZzZXRIZWlnaHRcblxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgY2FudmFzLmhlaWdodDsgeSsrKSB7XG4gICAgICBjb25zdCByYXRpbyA9IHkgLyBjYW52YXMuaGVpZ2h0XG4gICAgICBjb25zdCBjb2xvciA9IENvbG9yLmZyb21IU1YocmF0aW8sIDEsIDEpXG5cbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvci50b1JHQkEoKVxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKVxuICAgICAgY29udGV4dC5tb3ZlVG8oMCwgeSlcbiAgICAgIGNvbnRleHQubGluZVRvKGNhbnZhcy53aWR0aCwgeSlcbiAgICAgIGNvbnRleHQuc3Ryb2tlKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgcmV0dXJuICg8ZGl2IGJlbT0nJGI6Y29sb3JQaWNrZXIgJGU6aHVlJz5cbiAgICAgIDxEcmFnZ2FibGVDb21wb25lbnRcbiAgICAgICAgb25TdGFydD17dGhpcy5fb25Lbm9iRHJhZ1N0YXJ0fVxuICAgICAgICBvbkRyYWc9e3RoaXMuX29uS25vYkRyYWd9PlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxjYW52YXMgYmVtPSdlOmNhbnZhcycgcmVmPSdjYW52YXMnIC8+XG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgYmVtPSdlOmtub2IgJGI6a25vYiBtOnRyYW5zcGFyZW50J1xuICAgICAgICAgICAgcmVmPSdrbm9iJ1xuICAgICAgICAgICAgc3R5bGU9e3RoaXMuX2dldEtub2JTdHlsZSgpfSAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvRHJhZ2dhYmxlQ29tcG9uZW50PlxuICAgIDwvZGl2PilcbiAgfVxufVxuXG5IdWVDb21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29sb3ItcGlja2VyL2h1ZS1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IFNjcm9sbGJhckNvbXBvbmVudCBmcm9tICcuLi8uLi9zY3JvbGxiYXItY29tcG9uZW50J1xuaW1wb3J0IEZvbnRQcmV2aWV3Q29tcG9uZW50IGZyb20gJy4vZm9udC1wcmV2aWV3LWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9udENvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb25lIG9uZSBvZiB0aGUgbGlzdCBpdGVtc1xuICAgKiBAcGFyYW0gIHtGb250VmFyaWF0aW9ufSB2YXJpYXRpb25cbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkxpc3RJdGVtQ2xpY2sgKHZhcmlhdGlvbiwgZSkge1xuICAgIHRoaXMucHJvcHMub25DaGFuZ2UgJiZcbiAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UodmFyaWF0aW9uKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElTVCBJVEVNU1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBsaXN0IGl0ZW1zXG4gICAqIEByZXR1cm4ge0FycmF5LjxSZWFjdEJFTS5FbGVtZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJMaXN0SXRlbXMgKCkge1xuICAgIGNvbnN0IHsgZm9udHMgfSA9IHRoaXMucHJvcHNcblxuICAgIHJldHVybiBmb250cy5tYXAoZm9udCA9PiB7XG4gICAgICBjb25zdCB7IHNlbGVjdGVkSWRlbnRpZmllciB9ID0gdGhpcy5wcm9wc1xuXG4gICAgICByZXR1cm4gZm9udC5nZXRWYXJpYXRpb25zKClcbiAgICAgICAgLm1hcCh2YXJpYXRpb24gPT4ge1xuICAgICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBzZWxlY3RlZElkZW50aWZpZXIgPT09IHZhcmlhdGlvbi5nZXRJZGVudGlmaWVyKClcbiAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBpc1NlbGVjdGVkID8gJ2lzLWFjdGl2ZScgOiBudWxsXG5cbiAgICAgICAgICByZXR1cm4gKDxsaVxuICAgICAgICAgICAgYmVtPSdlOml0ZW0nXG4gICAgICAgICAgICBrZXk9e3ZhcmlhdGlvbi5nZXRJZGVudGlmaWVyKCl9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uTGlzdEl0ZW1DbGljay5iaW5kKHRoaXMsIHZhcmlhdGlvbil9ID5cbiAgICAgICAgICAgIDxGb250UHJldmlld0NvbXBvbmVudFxuICAgICAgICAgICAgICBmb250RmFtaWx5PXt2YXJpYXRpb24uZ2V0Rm9udEZhbWlseSgpfVxuICAgICAgICAgICAgICBmb250V2VpZ2h0PXt2YXJpYXRpb24uZ2V0Rm9udFdlaWdodCgpfVxuICAgICAgICAgICAgICBmb250U3R5bGU9e3ZhcmlhdGlvbi5nZXRGb250U3R5bGUoKX0gLz5cbiAgICAgICAgICAgIDxkaXYgYmVtPSdlOmxhYmVsJz57Zm9udC5nZXRGb250RmFtaWx5KCl9PC9kaXY+XG4gICAgICAgICAgPC9saT4pXG4gICAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBjb25zdCBsaXN0SXRlbXMgPSB0aGlzLl9yZW5kZXJMaXN0SXRlbXMoKVxuXG4gICAgcmV0dXJuICg8ZGl2IGJlbT0nJGI6Y29udHJvbHMgZTpvdmVybGF5IG06ZGFyayBtOmxhcmdlJz5cbiAgICAgIDxTY3JvbGxiYXJDb21wb25lbnQ+XG4gICAgICAgIDx1bCBiZW09JyRiOmZvbnRGYW1pbHkgZTpsaXN0Jz5cbiAgICAgICAgICB7bGlzdEl0ZW1zfVxuICAgICAgICA8L3VsPlxuICAgICAgPC9TY3JvbGxiYXJDb21wb25lbnQ+XG4gICAgPC9kaXY+KVxuICB9XG59XG5cbkZvbnRDb21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvdGV4dC9mb250LWNvbXBvbmVudC5qc3giLCIvKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IE9wdGlvblR5cGUsIENvbmZpZ3VyYWJsZSB9IGZyb20gJ3Bob3RvZWRpdG9yc2RrJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb250IGV4dGVuZHMgQ29uZmlndXJhYmxlIHt9XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBhdmFpbGFibGUgb3B0aW9ucyBmb3IgdGhlIEZvbnQgY2xhc3NcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAaWdub3JlXG4gKi9cbkZvbnQucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIGZvbnRGYW1pbHk6IHsgdHlwZTogT3B0aW9uVHlwZS5TVFJJTkcsIHJlcXVpcmVkOiB0cnVlIH0sXG4gIHZhcmlhdGlvbnM6IHsgdHlwZTogT3B0aW9uVHlwZS5BUlJBWSwgcmVxdWlyZWQ6IHRydWUgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zaGFyZWQvYXNzZXRzL2ZvbnQuanMiLCIvKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBDb250cm9scyBmcm9tICcuLi9jb250cm9scydcbmltcG9ydCBCcnVzaENvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4vYnJ1c2gtY29udHJvbHMtY29tcG9uZW50J1xuaW1wb3J0IEJydXNoQ2FudmFzQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi9icnVzaC1jYW52YXMtY29udHJvbHMtY29tcG9uZW50J1xuXG4vKipcbiAqIFRoZSBicnVzaCBjb250cm9sc1xuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xzXG4gKi9cbmNsYXNzIEJydXNoQ29udHJvbHMgZXh0ZW5kcyBDb250cm9scyB7XG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGxlYXZlcyB0aGVzZSBjb250cm9sc1xuICAgKiBAdGhpcyB7U3RpY2tlcnNDb250cm9sc0NvbXBvbmVudH1cbiAgICogQG92ZXJyaWRlXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBvbkV4aXQgKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcblxuICAgIGVkaXRvci56b29tLnJlc3RvcmUoKVxuICAgIGVkaXRvci5mZWF0dXJlcy5lbmFibGUoJ3pvb20nLCAnZHJhZycpXG4gICAgZWRpdG9yLnJlbmRlcigpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBlbnRlcnMgdGhlc2UgY29udHJvbHNcbiAgICogQHRoaXMge0JydXNoQ29udHJvbHNDb21wb25lbnR9XG4gICAqIEBwYXJhbSB7U2hhcmVkU3RhdGV9IHNoYXJlZFN0YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBvdmVycmlkZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgb25FbnRlciAoc2hhcmVkU3RhdGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG5cbiAgICBlZGl0b3Iuem9vbS5zYXZlKClcbiAgICBlZGl0b3Iuem9vbS5zZXQoJ2F1dG8nLCAoKSA9PiB7XG4gICAgICAvLyBvcGVyYXRpb24uc2V0RW5hYmxlZChmYWxzZSlcbiAgICAgIGVkaXRvci5yZW5kZXIoKVxuICAgIH0pXG5cbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuICAgIGNvbnN0IG9wZXJhdGlvbkV4aXN0ZWRCZWZvcmUgPSBlZGl0b3Iub3BlcmF0aW9ucy5leGlzdHMoJ3Nwcml0ZScpXG4gICAgY29uc3Qgb3BlcmF0aW9uID0gZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ3Nwcml0ZScpXG4gICAgY29uc3QgYnJ1c2ggPSBvcGVyYXRpb24uY3JlYXRlQnJ1c2goKVxuICAgIGNvbnN0IGluaXRpYWxPcHRpb25zID0gb3BlcmF0aW9uLnNlcmlhbGl6ZU9wdGlvbnModW5kZWZpbmVkLCB0cnVlKVxuICAgIG9wZXJhdGlvbi5hZGRTcHJpdGUoYnJ1c2gpXG5cbiAgICBsZXQgc2l6ZSA9IE1hdGgubWF4KG91dHB1dERpbWVuc2lvbnMubWluKCkgKiAwLjA1LCAxKVxuICAgIGlmIChvcHRpb25zLnNpemVQcmVzZXRzICYmIG9wdGlvbnMuc2l6ZVByZXNldHMubGVuZ3RoID4gMCkge1xuICAgICAgc2l6ZSA9IG9wdGlvbnMuc2l6ZVByZXNldHNbMF1cbiAgICB9XG5cbiAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcigxLCAwLCAwLCAxKVxuICAgIGNvbnN0IGhhcmRuZXNzID0gMVxuXG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7XG4gICAgICBvcGVyYXRpb25FeGlzdGVkQmVmb3JlLCBvcGVyYXRpb24sIGJydXNoLCBpbml0aWFsT3B0aW9ucywgc2l6ZSwgY29sb3IsIGhhcmRuZXNzXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBjb250cm9sIGlzIGF2YWlsYWJsZSB0byB0aGUgdXNlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkVkaXRvcn0gZWRpdG9yXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBvdmVycmlkZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgaXNBdmFpbGFibGUgKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IuaXNUb29sQWxsb3dlZCgnYnJ1c2gnKSAmJlxuICAgICAgZWRpdG9yLmlzVG9vbEVuYWJsZWQoJ2JydXNoJylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhc3NldHMgdGhhdCBzaG91bGQgYmUgcHJlbG9hZGVkIGZvciB0aGlzIGNvbnRyb2xcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5FZGl0b3J9IGVkaXRvclxuICAgKiBAcmV0dXJuIHtTdHJpbmdbXX1cbiAgICovXG4gIHN0YXRpYyBnZXRQcmVsb2FkQXNzZXRzICgpIHtcbiAgICByZXR1cm4gW1xuXG4gICAgXVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgY29udHJvbHMgY29tcG9uZW50LiBVc2VkIGZvciB0aGUgbG93ZXIgY29udHJvbHMgcGFydCBvZiB0aGUgZWRpdG9yLlxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNDb21wb25lbnR9XG4gKiBAaWdub3JlXG4gKi9cbkJydXNoQ29udHJvbHMuY29udHJvbHNDb21wb25lbnQgPSBCcnVzaENvbnRyb2xzQ29tcG9uZW50XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgY2FudmFzIGNvbXBvbmVudC4gVXNlZCBmb3IgdGhlIHVwcGVyIGNvbnRyb2xzIHBhcnQgb2YgdGhlIGVkaXRvciAob25cbiAqIHRvcCBvZiB0aGUgY2FudmFzKVxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNDb21wb25lbnR9XG4gKiBAaWdub3JlXG4gKi9cbkJydXNoQ29udHJvbHMuY2FudmFzQ29udHJvbHNDb21wb25lbnQgPSBCcnVzaENhbnZhc0NvbnRyb2xzQ29tcG9uZW50XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkJydXNoQ29udHJvbHMuaWRlbnRpZmllciA9ICdicnVzaCdcblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBpY29uIHBhdGhcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAaWdub3JlXG4gKi9cbkJydXNoQ29udHJvbHMuaWNvblBhdGggPSAnY29udHJvbHMvb3ZlcnZpZXcvYnJ1c2gucG5nJ1xuXG4vKipcbiAqIFRoZSBsYW5ndWFnZSBrZXkgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhpcyBmaWx0ZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAaWdub3JlXG4gKi9cbkJydXNoQ29udHJvbHMubGFuZ3VhZ2VLZXkgPSAncGVzZGsuYnJ1c2gudGl0bGUubmFtZSdcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGlzIGNvbnRyb2xcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkJydXNoQ29udHJvbHMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHNpemVQcmVzZXRzOiBbXVxufVxuXG4vKipcbiAqIFRoZSBvcGVyYXRpb25zIHJlcXVpcmVkIGZvciB0aGlzIGNvbnRyb2wgdG8gd29yayBwcm9wZXJseVxuICogQHR5cGUge0FycmF5fVxuICovXG5CcnVzaENvbnRyb2xzLnJlcXVpcmVkT3BlcmF0aW9ucyA9IFsnc3ByaXRlJ11cblxuZXhwb3J0IGRlZmF1bHQgQnJ1c2hDb250cm9sc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9icnVzaC9pbmRleC5qcyIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBDb25zdGFudHMgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IENvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4uL2NvbnRyb2xzLWNvbXBvbmVudCdcbmltcG9ydCBTbGlkZXJDb21wb25lbnQgZnJvbSAnLi4vLi4vc2xpZGVyLWNvbXBvbmVudCdcbmltcG9ydCBTY3JvbGxiYXJDb21wb25lbnQgZnJvbSAnLi4vLi4vc2Nyb2xsYmFyLWNvbXBvbmVudCdcbmltcG9ydCBDb2xvclBpY2tlckNvbXBvbmVudCBmcm9tICcuLi8uLi9jb2xvci1waWNrZXIvY29sb3ItcGlja2VyLWNvbXBvbmVudCdcbmltcG9ydCBQcmVzZXRQcmV2aWV3SXRlbUNvbXBvbmVudCBmcm9tICcuL3ByZXNldC1wcmV2aWV3LWl0ZW0tY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCcnVzaENvbnRyb2xzQ29tcG9uZW50IGV4dGVuZHMgQ29udHJvbHNDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9oYXNEb25lQnV0dG9uID0gZmFsc2VcbiAgICB0aGlzLl9icnVzaE9wdGlvbnMgPSB7XG4gICAgICBzaXplOiB0aGlzLmdldFNoYXJlZFN0YXRlKCdzaXplJyksXG4gICAgICBjb2xvcjogdGhpcy5nZXRTaGFyZWRTdGF0ZSgnY29sb3InKS5jbG9uZSgpXG4gICAgfVxuXG4gICAgdGhpcy5faGFzUHJlc2V0cyA9IHRoaXMucHJvcHMub3B0aW9ucy5zaXplUHJlc2V0cyAmJlxuICAgICAgdGhpcy5wcm9wcy5vcHRpb25zLnNpemVQcmVzZXRzLmxlbmd0aCA+IDBcbiAgICB0aGlzLl9oYXNTbGlkZXIgPSAhdGhpcy5faGFzUHJlc2V0c1xuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25TaXplVXBkYXRlZCcsXG4gICAgICAnX29uQ29sb3JVcGRhdGVkJyxcbiAgICAgICdfb25PcGVyYXRpb25VcGRhdGVkJyxcbiAgICAgICdfb25PcGVyYXRpb25SZW1vdmVkJ1xuICAgIClcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBzaXplQ29udHJvbHNFbmFibGVkOiBmYWxzZVxuICAgIH1cblxuICAgIHRoaXMuX2V2ZW50cyA9IHtcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLk9QRVJBVElPTl9VUERBVEVEXTogdGhpcy5fb25PcGVyYXRpb25VcGRhdGVkLFxuICAgICAgW0NvbnN0YW50cy5FVkVOVFMuT1BFUkFUSU9OX1JFTU9WRURdOiB0aGlzLl9vbk9wZXJhdGlvblJlbW92ZWRcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBMSUZFQ1lDTEVcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgc3VwZXIuY29tcG9uZW50RGlkTW91bnQoKVxuXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGVkaXRvci56b29tLnNldCgnYXV0bycpXG4gICAgZWRpdG9yLmZlYXR1cmVzLmRpc2FibGUoJ3pvb20nLCAnZHJhZycpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgYSBzaXplIHByZXNldFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNpemVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblNpemVDbGljayAoc2l6ZSkge1xuICAgIHRoaXMuX29uU2l6ZVVwZGF0ZWQoc2l6ZSlcbiAgICB0aGlzLmZvcmNlVXBkYXRlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGFuIG9wZXJhdGlvbiBoYXMgYmVlbiByZW1vdmVkXG4gICAqIEBwYXJhbSAge09wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25PcGVyYXRpb25SZW1vdmVkIChvcGVyYXRpb24pIHtcbiAgICBpZiAob3BlcmF0aW9uICE9PSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKSkgcmV0dXJuXG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25DbGlja2VkKSByZXR1cm5cblxuICAgIC8vIE9wZXJhdGlvbiBjYW4gYmUgcmVtb3ZlZCBieSB0aGUgdW5kbyBidXR0b24uIFdlIG5lZWRcbiAgICAvLyB0byBtYWtlIHN1cmUgd2UgcmUtY3JlYXRlIHRoZSBvcGVyYXRpb24gZm9yIHRoZSBsaWZldGltZVxuICAgIC8vIG9mIHRoaXMgY29udHJvbFxuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBuZXdPcGVyYXRpb24gPSBlZGl0b3Iub3BlcmF0aW9ucy5nZXRPckNyZWF0ZSgnc3ByaXRlJylcblxuICAgIGNvbnN0IGJydXNoID0gbmV3T3BlcmF0aW9uLmNyZWF0ZUJydXNoKClcbiAgICBuZXdPcGVyYXRpb24uYWRkU3ByaXRlKGJydXNoKVxuXG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7XG4gICAgICBvcGVyYXRpb246IG5ld09wZXJhdGlvbixcbiAgICAgIGJydXNoLFxuICAgICAgb3BlcmF0aW9uRXhpc3RlZEJlZm9yZTogZmFsc2UsXG4gICAgICBpbml0aWFsT3B0aW9uczoge31cbiAgICB9KVxuXG4gICAgZWRpdG9yLnJlbmRlcigpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBvcGVyYXRpb24gaGFzIGJlZW4gdXBkYXRlZFxuICAgKiBAcGFyYW0gIHtPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uT3BlcmF0aW9uVXBkYXRlZCAob3BlcmF0aW9uKSB7XG4gICAgaWYgKG9wZXJhdGlvbiA9PT0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJykpIHtcbiAgICAgIC8vIFNwcml0ZU9wZXJhdGlvbiByZS1jcmVhdGVzIGFsbCBzcHJpdGVzIHdoZW4gdGhleSdyZSBtYXNzLWFzc2lnbmVkLFxuICAgICAgLy8gc28gd2UgbmVlZCB0byBmaW5kIHRoZSBuZXcgaW5zdGFuY2UgYnkgbWF0Y2hpbmcgYWdhaW5zdCB0aGUgcHJldmlvdXMgSURcbiAgICAgIGNvbnN0IHByZXZpb3VzQnJ1c2ggPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdicnVzaCcpXG4gICAgICBpZiAocHJldmlvdXNCcnVzaCkge1xuICAgICAgICBjb25zdCBicnVzaCA9IG9wZXJhdGlvbi5nZXRTcHJpdGVzKClcbiAgICAgICAgICAuZmlsdGVyKChzKSA9PiBzLmdldElkKCkgPT09IHByZXZpb3VzQnJ1c2guZ2V0SWQoKSlbMF1cbiAgICAgICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7IGJydXNoIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIFRyaWdnZXIgYnJ1c2ggY2FudmFzIHJlbmRlcmluZ1xuICAgICAgLy8gb3BlcmF0aW9uLnNldEVuYWJsZWQodHJ1ZSlcbiAgICAgIHRoaXMuY29udGV4dC5lZGl0b3IucmVuZGVyKClcbiAgICAgIC8vIHRoaXMuY29udGV4dC5lZGl0b3IucmVuZGVyKCgpID0+IHtcbiAgICAgIC8vICAgb3BlcmF0aW9uLnNldEVuYWJsZWQoZmFsc2UpXG4gICAgICAvLyAgIHRoaXMuY29udGV4dC5lZGl0b3IucmVuZGVyKClcbiAgICAgIC8vIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHNpemUgaGFzIGJlZW4gdXBkYXRlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uU2l6ZVVwZGF0ZWQgKHNpemUpIHtcbiAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHsgc2l6ZSB9KVxuICAgIHRoaXMuX2JydXNoT3B0aW9ucy5zaXplID0gc2l6ZVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGNvbG9yIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICogQHBhcmFtICB7Q29sb3J9IGNvbG9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Db2xvclVwZGF0ZWQgKGNvbG9yKSB7XG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7IGNvbG9yIH0pXG4gICAgdGhpcy5fYnJ1c2hPcHRpb25zLmNvbG9yID0gY29sb3IuY2xvbmUoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHNpemUgbGlzdCBpdGVtc1xuICAgKiBAcmV0dXJuIHtBcnJheS48UmVhY3RCRU0uRWxlbWVudD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyU2l6ZUl0ZW1zICgpIHtcbiAgICBjb25zdCB7IHNpemVQcmVzZXRzIH0gPSB0aGlzLnByb3BzLm9wdGlvbnNcbiAgICBjb25zdCBtYXhTaXplID0gTWF0aC5tYXguYXBwbHkobnVsbCwgc2l6ZVByZXNldHMpXG4gICAgcmV0dXJuIHNpemVQcmVzZXRzLm1hcCgoc2l6ZSkgPT4ge1xuICAgICAgY29uc3QgaXNBY3RpdmUgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdzaXplJykgPT09IHNpemVcbiAgICAgIHJldHVybiAoPFByZXNldFByZXZpZXdJdGVtQ29tcG9uZW50XG4gICAgICAgIHNpemU9e3NpemV9XG4gICAgICAgIG1heFNpemU9e21heFNpemV9XG4gICAgICAgIGFjdGl2ZT17aXNBY3RpdmV9XG4gICAgICAgIGtleT17c2l6ZX1cbiAgICAgICAgb25DbGljaz17dGhpcy5fb25TaXplQ2xpY2suYmluZCh0aGlzLCBzaXplKX0gLz4pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb250cm9scyBvZiB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyQ29udHJvbHMgKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCB6b29tID0gZWRpdG9yLnpvb20uZ2V0KClcbiAgICBsZXQgaXRlbXMgPSBbXVxuXG4gICAgaWYgKHRoaXMuX2hhc1NsaWRlcikge1xuICAgICAgY29uc3QgZmluYWxEaW1lbnNpb25zID0gZWRpdG9yLmdldEZpbmFsRGltZW5zaW9ucygpXG4gICAgICBjb25zdCBtaW5TaXplID0gMVxuICAgICAgY29uc3QgbWF4U2l6ZSA9IE1hdGgucm91bmQoZmluYWxEaW1lbnNpb25zLmNsb25lKCkubXVsdGlwbHkoem9vbSkubWluKCkgLyAyKVxuICAgICAgY29uc3QgY3VycmVudFdpZHRoID0gdGhpcy5fYnJ1c2hPcHRpb25zLnNpemVcblxuICAgICAgaXRlbXMucHVzaCg8ZGl2IGJlbT0nZTpjZWxsIG06c2xpZGVyJz5cbiAgICAgICAgPFNsaWRlckNvbXBvbmVudFxuICAgICAgICAgIHN0eWxlPSdsYXJnZSdcbiAgICAgICAgICBtaW5WYWx1ZT17bWluU2l6ZX1cbiAgICAgICAgICBtYXhWYWx1ZT17bWF4U2l6ZX1cbiAgICAgICAgICB2YWx1ZVVuaXQ9J3B4J1xuICAgICAgICAgIG1pZGRsZURvdD17ZmFsc2V9XG4gICAgICAgICAgbGFiZWw9e3RoaXMuX3QoJ3Blc2RrLmJydXNoLnRleHQuc2l6ZScpfVxuICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLl9vblNpemVVcGRhdGVkfVxuICAgICAgICAgIHZhbHVlPXtjdXJyZW50V2lkdGh9IC8+XG4gICAgICA8L2Rpdj4pXG4gICAgfSBlbHNlIGlmICh0aGlzLl9oYXNQcmVzZXRzKSB7XG4gICAgICBpdGVtcy5wdXNoKDxkaXYgYmVtPSdlOmNlbGwgbTpsaXN0Jz5cbiAgICAgICAgPFNjcm9sbGJhckNvbXBvbmVudD5cbiAgICAgICAgICA8dWwgYmVtPSckZTpsaXN0Jz5cbiAgICAgICAgICAgIHt0aGlzLl9yZW5kZXJTaXplSXRlbXMoKX1cbiAgICAgICAgICA8L3VsPlxuICAgICAgICA8L1Njcm9sbGJhckNvbXBvbmVudD5cbiAgICAgIDwvZGl2PilcbiAgICB9XG5cbiAgICBpdGVtcy5wdXNoKDxkaXYgYmVtPSdlOmNlbGwgbTpjb2xvclBpY2tlcic+XG4gICAgICA8Q29sb3JQaWNrZXJDb21wb25lbnRcbiAgICAgICAgaW5pdGlhbFZhbHVlPXt0aGlzLl9icnVzaE9wdGlvbnMuY29sb3IuY2xvbmUoKX1cbiAgICAgICAgb25DaGFuZ2U9e3RoaXMuX29uQ29sb3JVcGRhdGVkfSAvPlxuICAgIDwvZGl2PilcblxuICAgIHJldHVybiBpdGVtc1xuICB9XG59XG5cbkJydXNoQ29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzID0gQ29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL2JydXNoL2JydXNoLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByZXNldFByZXZpZXdJdGVtQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIExJRkVDWUNMRVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICBzdXBlci5jb21wb25lbnREaWRNb3VudCgpXG4gICAgdGhpcy5fcmVuZGVyQ2FudmFzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBhZnRlciB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiB1cGRhdGVkXG4gICAqL1xuICBjb21wb25lbnREaWRVcGRhdGUgKCkge1xuICAgIHRoaXMuX3JlbmRlckNhbnZhcygpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBDQU5WQVMgUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGN1cnJlbnQgZm9udCBmYW1pbHkgb250byB0aGUgY2FudmFzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyQ2FudmFzICgpIHtcbiAgICBjb25zdCB7IGNhbnZhcyB9ID0gdGhpcy5yZWZzXG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG5cbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMub2Zmc2V0V2lkdGhcbiAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLm9mZnNldEhlaWdodFxuXG4gICAgY29uc3QgeyBtYXhTaXplLCBzaXplIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgZGlhbWV0ZXIgPSBjYW52YXMud2lkdGggKiAoc2l6ZSAvIG1heFNpemUpXG4gICAgY29uc3QgcmFkaXVzID0gZGlhbWV0ZXIgLyAyXG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICd3aGl0ZSdcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpXG4gICAgY29udGV4dC5hcmMoY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIsIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpXG4gICAgY29udGV4dC5maWxsKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICByZXR1cm4gKDxiZW0gc3BlY2lmaWVyPSckYjpjb250cm9scyAkZTpsaXN0Jz5cbiAgICAgIDxsaVxuICAgICAgICBiZW09J2U6aXRlbSdcbiAgICAgICAgb25DbGljaz17dGhpcy5wcm9wcy5vbkNsaWNrfT5cbiAgICAgICAgPGJlbSBzcGVjaWZpZXI9JyRiOmNvbnRyb2xzJz5cbiAgICAgICAgICA8ZGl2IGJlbT0nJGU6YnV0dG9uIG06d2l0aExhYmVsJyBjbGFzc05hbWU9e3RoaXMucHJvcHMuYWN0aXZlID8gJ2lzLWFjdGl2ZScgOiBudWxsfT5cbiAgICAgICAgICAgIDxjYW52YXMgYmVtPSdlOmNhbnZhcycgcmVmPSdjYW52YXMnIC8+XG4gICAgICAgICAgICA8ZGl2IGJlbT0nZTpsYWJlbCc+e3RoaXMucHJvcHMuc2l6ZX08L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9iZW0+XG4gICAgICA8L2xpPlxuICAgIDwvYmVtPilcbiAgfVxufVxuXG5QcmVzZXRQcmV2aWV3SXRlbUNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9icnVzaC9wcmVzZXQtcHJldmlldy1pdGVtLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBTREssIFJlYWN0QkVNLCBWZWN0b3IyLCBVdGlscywgU0RLVXRpbHMsIENvbnN0YW50cyB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgU3ByaXRlc0NhbnZhc0NvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4uL3Nwcml0ZXMvc3ByaXRlcy1jYW52YXMtY29udHJvbHMtY29tcG9uZW50J1xuXG5jb25zdCB7IEJydXNoU3ByaXRlIH0gPSBTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb25cbmNvbnN0IHsgUmFkaWFsQnJ1c2ggfSA9IFNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbi5CcnVzaFNwcml0ZS5CcnVzaGVzXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJydXNoQ2FudmFzQ29udHJvbHNDb21wb25lbnQgZXh0ZW5kcyBTcHJpdGVzQ2FudmFzQ29udHJvbHNDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl93aW5kb3dSZXNpemVkID0gZmFsc2VcbiAgICB0aGlzLl9kcmF3aW5nID0gZmFsc2VcbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbk1vdXNlRW50ZXInLFxuICAgICAgJ19vbk1vdXNlTGVhdmUnLFxuICAgICAgJ19vbk1vdXNlRG93bicsXG4gICAgICAnX29uTW91c2VNb3ZlJyxcbiAgICAgICdfb25Nb3VzZVVwJyxcbiAgICAgICdfb25Nb3VzZU1vdmVPbkNhbnZhcycsXG4gICAgICAnX29uV2luZG93UmVzaXplJ1xuICAgIClcblxuICAgIHRoaXMuX2xhc3REcmF3UG9zaXRpb24gPSBudWxsXG5cbiAgICB0aGlzLl9ldmVudHMgPSBTREtVdGlscy5leHRlbmQodGhpcy5fZXZlbnRzLCB7XG4gICAgICBbQ29uc3RhbnRzLkVWRU5UUy5XSU5ET1dfUkVTSVpFXTogdGhpcy5fb25XaW5kb3dSZXNpemVcbiAgICB9KVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGN1cnNvclZpc2libGU6IGZhbHNlLFxuICAgICAgY3Vyc29yUG9zaXRpb246IG5ldyBWZWN0b3IyKClcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBMSUZFQ1lDTEVcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgc3VwZXIuY29tcG9uZW50RGlkTW91bnQoKVxuICAgIHRoaXMuX3VwZGF0ZUNvbnRhaW5lclJlY3QoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gdXBkYXRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkVXBkYXRlICgpIHtcbiAgICBpZiAodGhpcy5fd2luZG93UmVzaXplZCkge1xuICAgICAgdGhpcy5fdXBkYXRlQ29udGFpbmVyUmVjdCgpXG4gICAgICB0aGlzLl93aW5kb3dSZXNpemVkID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgd2luZG93IGhhcyBiZWVuIHJlc2l6ZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbldpbmRvd1Jlc2l6ZSAoKSB7XG4gICAgdGhpcy5fd2luZG93UmVzaXplZCA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGFuIG9wZXJhdGlvbiBoYXMgYmVlbiByZW1vdmVkXG4gICAqIEBwYXJhbSAge09wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25PcGVyYXRpb25SZW1vdmVkIChvcGVyYXRpb24pIHtcbiAgICB2b2lkIDBcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGFuIG9wZXJhdGlvbiBoYXMgYmVlbiB1cGRhdGVkXG4gICAqIEBwYXJhbSAge09wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25PcGVyYXRpb25VcGRhdGVkIChvcGVyYXRpb24pIHtcbiAgICBpZiAob3BlcmF0aW9uID09PSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKSkge1xuICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIG1vdXNlIGJ1dHRvblxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uTW91c2VEb3duIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICB0aGlzLl9vcHRpb25zQmVmb3JlRHJhdyA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpLnNlcmlhbGl6ZU9wdGlvbnMoKVxuICAgIHRoaXMuX29wZXJhdGlvbkV4aXN0ZWRCZWZvcmVEcmF3ID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uRXhpc3RlZEJlZm9yZScpXG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7IG9wZXJhdGlvbkV4aXN0ZWRCZWZvcmU6IHRydWUgfSwgZmFsc2UpXG5cbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXRPdXRwdXREaW1lbnNpb25zKClcbiAgICBjb25zdCBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuX2dldEN1cnNvclBvc2l0aW9uKGUpXG5cbiAgICBjb25zdCBicnVzaCA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2JydXNoJylcbiAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2l6ZScpIC8gb3V0cHV0RGltZW5zaW9ucy5taW4oKVxuICAgIGNvbnN0IGNvbG9yID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnY29sb3InKVxuICAgIGNvbnN0IGhhcmRuZXNzID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnaGFyZG5lc3MnKVxuICAgIHRoaXMuX2RyYXdpbmcgPSB0cnVlXG4gICAgY29uc3QgX2JydXNoID0gbmV3IFJhZGlhbEJydXNoKHsgc2l6ZSwgaGFyZG5lc3MsIGNvbG9yIH0pXG4gICAgdGhpcy5fY3VycmVudFBhdGggPSBicnVzaC5jcmVhdGVQYXRoKF9icnVzaClcbiAgICB0aGlzLl9jdXJyZW50UGF0aC5hZGRDb250cm9sUG9pbnQoY3Vyc29yUG9zaXRpb24uY2xvbmUoKS5kaXZpZGUob3V0cHV0RGltZW5zaW9ucykpXG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSlcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSlcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25Nb3VzZVVwKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgYSBtb3VzZSBidXR0b25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk1vdXNlVXAgKCkge1xuICAgIHRoaXMuX2N1cnJlbnRQYXRoLnNldENsb3NlZCh0cnVlKVxuXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG91dHB1dFRleHR1cmVEaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dFRleHR1cmVEaW1lbnNpb25zKClcbiAgICB0aGlzLmdldFNoYXJlZFN0YXRlKCdicnVzaCcpLnJlbmRlcihvdXRwdXRUZXh0dXJlRGltZW5zaW9ucylcblxuICAgIHRoaXMuX2N1cnJlbnRQYXRoID0gbnVsbFxuICAgIHRoaXMuX2RyYXdpbmcgPSBmYWxzZVxuXG4gICAgZWRpdG9yLmhpc3RvcnkuYWRkKFxuICAgICAgdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJyksXG4gICAgICB0aGlzLl9vcHRpb25zQmVmb3JlRHJhdyxcbiAgICAgIHRoaXMuX29wZXJhdGlvbkV4aXN0ZWRCZWZvcmVEcmF3KVxuXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUpXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUpXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcClcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uTW91c2VVcClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGVudGVycyB0aGUgY2FudmFzXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Nb3VzZUVudGVyIChlKSB7XG4gICAgY29uc3QgY3Vyc29yUG9zaXRpb24gPSB0aGlzLl9nZXRDdXJzb3JQb3NpdGlvbihlKVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY3Vyc29yVmlzaWJsZTogdHJ1ZSxcbiAgICAgIGN1cnNvclBvc2l0aW9uXG4gICAgfSlcbiAgICB0aGlzLl9vbk1vdXNlTW92ZShlKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgbGVhdmVzIHRoZSBjYW52YXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk1vdXNlTGVhdmUgKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY3Vyc29yVmlzaWJsZTogZmFsc2VcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIG1vdmVzIHRoZSBtb3VzZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Nb3VzZU1vdmUgKGUpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgb3V0cHV0RGltZW5zaW9ucyA9IGVkaXRvci5nZXRPdXRwdXREaW1lbnNpb25zKClcbiAgICBjb25zdCBvdXRwdXRUZXh0dXJlRGltZW5zaW9ucyA9IGVkaXRvci5nZXRPdXRwdXRUZXh0dXJlRGltZW5zaW9ucygpXG5cbiAgICBjb25zdCB6b29tID0gZWRpdG9yLnpvb20uZ2V0KClcbiAgICBjb25zdCBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuX2dldEN1cnNvclBvc2l0aW9uKGUpXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGN1cnNvclBvc2l0aW9uIH0pXG5cbiAgICBsZXQgc2hvdWxkRHJhd1xuICAgIGlmICghdGhpcy5fbGFzdERyYXdQb3NpdGlvbikge1xuICAgICAgc2hvdWxkRHJhdyA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYnJ1c2hTaXplID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2l6ZScpXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMuX2xhc3REcmF3UG9zaXRpb24uY2xvbmUoKVxuICAgICAgICAuc3VidHJhY3QoY3Vyc29yUG9zaXRpb24pXG4gICAgICAgIC5hYnMoKS5sZW4oKSAvIHpvb21cbiAgICAgIHNob3VsZERyYXcgPSBkaXN0YW5jZSA+PSBicnVzaFNpemUgLyAxMFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9kcmF3aW5nICYmIHNob3VsZERyYXcpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRQYXRoLmFkZENvbnRyb2xQb2ludChjdXJzb3JQb3NpdGlvbi5jbG9uZSgpLmRpdmlkZShvdXRwdXREaW1lbnNpb25zKSlcblxuICAgICAgdGhpcy5nZXRTaGFyZWRTdGF0ZSgnYnJ1c2gnKS5yZW5kZXIob3V0cHV0VGV4dHVyZURpbWVuc2lvbnMpXG5cbiAgICAgIHRoaXMuX2xhc3REcmF3UG9zaXRpb24gPSBjdXJzb3JQb3NpdGlvbi5jbG9uZSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIG1vdmVzIHRoZSBtb3VzZSBvbiB0b3Agb2YgdGhlIGNhbnZhcy4gVXBkYXRlc1xuICAgKiB0aGUgY3Vyc29yIGN1cnNvciBwb3NpdGlvblxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uTW91c2VNb3ZlT25DYW52YXMgKGUpIHtcbiAgICBjb25zdCBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuX2dldEN1cnNvclBvc2l0aW9uKGUpXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGN1cnNvclBvc2l0aW9uIH0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJvcHMgdGhhdCBhcmUgcGFzc2VkIHRvIHRoZSBpdGVtIGNvbXBvbmVudCBvZiB0aGUgZ2l2ZW4gc3ByaXRlXG4gICAqIEBwYXJhbSAge1Nwcml0ZX0gc3ByaXRlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRQcm9wc0ZvclNwcml0ZSAoc3ByaXRlKSB7XG4gICAgbGV0IHByb3BzID0gc3VwZXIuX2dldFByb3BzRm9yU3ByaXRlKHNwcml0ZSlcbiAgICBpZiAoc3ByaXRlIGluc3RhbmNlb2YgQnJ1c2hTcHJpdGUpIHtcbiAgICAgIHByb3BzLmhpZGVDb250ZW50ID0gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHByb3BzXG4gIH1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gU1RZTElOR1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJzb3IncyBzdHlsZSBvYmplY3RcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEN1cnNvclN0eWxlICgpIHtcbiAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2l6ZScpXG4gICAgY29uc3QgY29sb3IgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdjb2xvcicpXG5cbiAgICBjb25zdCB7IGN1cnNvclBvc2l0aW9uIH0gPSB0aGlzLnN0YXRlXG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGN1cnNvclBvc2l0aW9uLngsXG4gICAgICB0b3A6IGN1cnNvclBvc2l0aW9uLnksXG4gICAgICB3aWR0aDogc2l6ZSxcbiAgICAgIGhlaWdodDogc2l6ZSxcbiAgICAgIGJhY2tncm91bmQ6IGNvbG9yLnRvUkdCQSgpLFxuICAgICAgbWFyZ2luTGVmdDogc2l6ZSAqIC0wLjUsXG4gICAgICBtYXJnaW5Ub3A6IHNpemUgKiAtMC41XG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTUlTQ1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjb250YWluZXIgYm91bmRpbmcgcmVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZUNvbnRhaW5lclJlY3QgKCkge1xuICAgIHRoaXMuX2NvbnRhaW5lckJvdW5kaW5nUmVjdCA9IHRoaXMucmVmcy5pbm5lckNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnNvciBwb3NpdGlvbiBmb3IgdGhlIGdpdmVuIGV2ZW50XG4gICAqIEBwYXJhbSAge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEN1cnNvclBvc2l0aW9uIChldmVudCkge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gVXRpbHMuZ2V0RXZlbnRQb3NpdGlvbihldmVudClcbiAgICBjb25zdCBib3VuZGluZ1JlY3QgPSB0aGlzLl9jb250YWluZXJCb3VuZGluZ1JlY3RcbiAgICByZXR1cm4gcG9zaXRpb25cbiAgICAgIC5zdWJ0cmFjdChib3VuZGluZ1JlY3QubGVmdCwgYm91bmRpbmdSZWN0LnRvcClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcm9wZXJ0aWVzIGZvciB0aGUgb3V0ZXIgY29udGFpbmVyXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRDb250YWluZXJQcm9wcyAoKSB7XG4gICAgbGV0IHByb3BzID0gc3VwZXIuX2dldENvbnRhaW5lclByb3BzKClcblxuICAgIHByb3BzLm9uTW91c2VEb3duID0gcHJvcHMub25Ub3VjaFN0YXJ0ID0gdGhpcy5fb25Nb3VzZURvd25cbiAgICByZXR1cm4gcHJvcHNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcm9wZXJ0aWVzIGZvciB0aGUgY2FudmFzIGNvbnRhaW5lclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0SW5uZXJDb250YWluZXJQcm9wcyAoKSB7XG4gICAgbGV0IHByb3BzID0gc3VwZXIuX2dldElubmVyQ29udGFpbmVyUHJvcHMoKVxuXG4gICAgLy8gVGhpcyBkaXNhYmxlcyB0aGUgaGl0IHRlc3RpbmcgZm9yIHRoaXMgc3ViIGNvbnRyb2xcbiAgICBkZWxldGUgcHJvcHMub25DbGlja1xuXG4gICAgcHJvcHMub25Nb3VzZUVudGVyID0gdGhpcy5fb25Nb3VzZUVudGVyXG4gICAgcHJvcHMub25Nb3VzZUxlYXZlID0gdGhpcy5fb25Nb3VzZUxlYXZlXG4gICAgcHJvcHMub25Nb3VzZU1vdmUgPSB0aGlzLl9vbk1vdXNlTW92ZU9uQ2FudmFzXG4gICAgcmV0dXJuIHByb3BzXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogVGhpcyByZW5kZXJzIGNvbnRyb2xzIG9uIHRvcCBvZiB0aGUgc3ByaXRlc1xuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlck92ZXJsYXlDb250cm9scyAoKSB7XG4gICAgY29uc3QgY3Vyc29yQ2xhc3MgPSB0aGlzLnN0YXRlLmN1cnNvclZpc2libGUgPyAnaXMtdmlzaWJsZScgOiBudWxsXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgYmVtPSckYjpicnVzaENhbnZhc0NvbnRyb2xzJz5cbiAgICAgICAgPGRpdiBiZW09J2U6Y3Vyc29yJyBjbGFzc05hbWU9e2N1cnNvckNsYXNzfSBzdHlsZT17dGhpcy5fZ2V0Q3Vyc29yU3R5bGUoKX0gLz5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5CcnVzaENhbnZhc0NvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IFNwcml0ZXNDYW52YXNDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvYnJ1c2gvYnJ1c2gtY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCIvKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBDb250cm9scyBmcm9tICcuLi9jb250cm9scydcbmltcG9ydCBTZWxlY3RpdmVCbHVyQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi9zZWxlY3RpdmUtYmx1ci1jb250cm9scy1jb21wb25lbnQnXG5pbXBvcnQgU2VsZWN0aXZlQmx1ckNhbnZhc0NvbnRyb2xzQ09tcG9uZW50IGZyb20gJy4vc2VsZWN0aXZlLWJsdXItY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudCdcblxuLyoqXG4gKiBUaGUgc2VsZWN0aXZlIGJsdXIgY29udHJvbHNcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5Db250cm9sXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5Db250cm9sc1xuICovXG5jbGFzcyBTZWxlY3RpdmVCbHVyQ29udHJvbHMgZXh0ZW5kcyBDb250cm9scyB7XG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGxlYXZlcyB0aGVzZSBjb250cm9sc1xuICAgKiBAdGhpcyB7U2VsZWN0aXZlQmx1ckNvbnRyb2xzQ29tcG9uZW50fVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIG9uRXhpdCAoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpXG5cbiAgICBpZiAob3BlcmF0aW9uLmdldFBhdGhzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICBlZGl0b3Iub3BlcmF0aW9ucy5yZW1vdmUob3BlcmF0aW9uKVxuICAgIH1cblxuICAgIGVkaXRvci56b29tLnJlc3RvcmUoKVxuICAgIGVkaXRvci5mZWF0dXJlcy5lbmFibGUoJ3pvb20nLCAnZHJhZycpXG4gICAgZWRpdG9yLnJlbmRlcigpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBlbnRlcnMgdGhlc2UgY29udHJvbHNcbiAgICogQHRoaXMge1NlbGVjdGl2ZUJsdXJDb250cm9sc0NvbXBvbmVudH1cbiAgICogQHBhcmFtIHtTaGFyZWRTdGF0ZX0gc2hhcmVkU3RhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQG92ZXJyaWRlXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBvbkVudGVyIChzaGFyZWRTdGF0ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcblxuICAgIGVkaXRvci56b29tLnNhdmUoKVxuICAgIGVkaXRvci56b29tLnNldCgnYXV0bycsICgpID0+IHtcbiAgICAgIGVkaXRvci5yZW5kZXIoKVxuICAgIH0pXG5cbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuICAgIGNvbnN0IG9wZXJhdGlvbkV4aXN0ZWRCZWZvcmUgPSBlZGl0b3Iub3BlcmF0aW9ucy5leGlzdHMoJ3NlbGVjdGl2ZS1ibHVyJylcbiAgICBjb25zdCBvcGVyYXRpb24gPSBlZGl0b3Iub3BlcmF0aW9ucy5nZXRPckNyZWF0ZSgnc2VsZWN0aXZlLWJsdXInKVxuICAgIGNvbnN0IGluaXRpYWxPcHRpb25zID0gb3BlcmF0aW9uLnNlcmlhbGl6ZU9wdGlvbnMoKVxuICAgIGNvbnN0IGJydXNoID0gb3BlcmF0aW9uLmdldEJydXNoKClcblxuICAgIGxldCBzaXplID0gb3V0cHV0RGltZW5zaW9ucy5taW4oKSAqIDAuMVxuICAgIGNvbnN0IGhhcmRuZXNzID0gMVxuXG4gICAgY29uc3QgaW5wdXREaW1lbnNpb25zID0gb3BlcmF0aW9uLmdldElucHV0RGltZW5zaW9ucygpXG5cbiAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHtcbiAgICAgIG9wZXJhdGlvbkV4aXN0ZWRCZWZvcmUsIG9wZXJhdGlvbiwgYnJ1c2gsIGluaXRpYWxPcHRpb25zLCBzaXplLCBoYXJkbmVzcywgaW5wdXREaW1lbnNpb25zXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBjb250cm9sIGlzIGF2YWlsYWJsZSB0byB0aGUgdXNlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkVkaXRvcn0gZWRpdG9yXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBvdmVycmlkZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgaXNBdmFpbGFibGUgKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IuaXNUb29sRW5hYmxlZCgnc2VsZWN0aXZlLWJsdXInKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgY29udHJvbHMgY29tcG9uZW50LiBVc2VkIGZvciB0aGUgbG93ZXIgY29udHJvbHMgcGFydCBvZiB0aGUgZWRpdG9yLlxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNDb21wb25lbnR9XG4gKiBAaWdub3JlXG4gKi9cblNlbGVjdGl2ZUJsdXJDb250cm9scy5jb250cm9sc0NvbXBvbmVudCA9IFNlbGVjdGl2ZUJsdXJDb250cm9sc0NvbXBvbmVudFxuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIGNhbnZhcyBjb21wb25lbnQuIFVzZWQgZm9yIHRoZSB1cHBlciBjb250cm9scyBwYXJ0IG9mIHRoZSBlZGl0b3IgKG9uXG4gKiB0b3Agb2YgdGhlIGNhbnZhcylcbiAqIEB0eXBlIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xzQ29tcG9uZW50fVxuICogQGlnbm9yZVxuICovXG5TZWxlY3RpdmVCbHVyQ29udHJvbHMuY2FudmFzQ29udHJvbHNDb21wb25lbnQgPSBTZWxlY3RpdmVCbHVyQ2FudmFzQ29udHJvbHNDT21wb25lbnRcblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuU2VsZWN0aXZlQmx1ckNvbnRyb2xzLmlkZW50aWZpZXIgPSAnc2VsZWN0aXZlLWJsdXInXG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgaWNvbiBwYXRoXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGlnbm9yZVxuICovXG5TZWxlY3RpdmVCbHVyQ29udHJvbHMuaWNvblBhdGggPSAnY29udHJvbHMvb3ZlcnZpZXcvc2VsZWN0aXZlLWJsdXIucG5nJ1xuXG4vKipcbiAqIFRoZSBsYW5ndWFnZSBrZXkgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhpcyBmaWx0ZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAaWdub3JlXG4gKi9cblNlbGVjdGl2ZUJsdXJDb250cm9scy5sYW5ndWFnZUtleSA9ICdjb250cm9scy5vdmVydmlldy5zZWxlY3RpdmUtYmx1cidcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGlzIGNvbnRyb2xcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblNlbGVjdGl2ZUJsdXJDb250cm9scy5kZWZhdWx0T3B0aW9ucyA9IHtcblxufVxuXG4vKipcbiAqIFRoZSBvcGVyYXRpb25zIHJlcXVpcmVkIGZvciB0aGlzIGNvbnRyb2wgdG8gd29yayBwcm9wZXJseVxuICogQHR5cGUge0FycmF5fVxuICovXG5TZWxlY3RpdmVCbHVyQ29udHJvbHMucmVxdWlyZWRPcGVyYXRpb25zID0gWydzZWxlY3RpdmUtYmx1ciddXG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdGl2ZUJsdXJDb250cm9sc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9zZWxlY3RpdmUtYmx1ci9pbmRleC5qcyIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBDb25zdGFudHMgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IENvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4uL2NvbnRyb2xzLWNvbXBvbmVudCdcbmltcG9ydCBTbGlkZXJDb21wb25lbnQgZnJvbSAnLi4vLi4vc2xpZGVyLWNvbXBvbmVudCdcbmltcG9ydCBTbGlkZXJPdmVybGF5Q29tcG9uZW50IGZyb20gJy4uL3NsaWRlci1vdmVybGF5LWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJ1c2hDb250cm9sc0NvbXBvbmVudCBleHRlbmRzIENvbnRyb2xzQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5faGFzRG9uZUJ1dHRvbiA9IGZhbHNlXG4gICAgdGhpcy5fYnJ1c2hTaXplID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2l6ZScpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbk9wZXJhdGlvblVwZGF0ZWQnLFxuICAgICAgJ19vbk9wZXJhdGlvblJlbW92ZWQnLFxuICAgICAgJ19vblNpemVVcGRhdGVkJyxcbiAgICAgICdfb25CbHVyUmFkaXVzQ2hhbmdlJ1xuICAgIClcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBzaXplQ29udHJvbHNFbmFibGVkOiBmYWxzZVxuICAgIH1cblxuICAgIHRoaXMuX2V2ZW50cyA9IHtcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLk9QRVJBVElPTl9VUERBVEVEXTogdGhpcy5fb25PcGVyYXRpb25VcGRhdGVkLFxuICAgICAgW0NvbnN0YW50cy5FVkVOVFMuT1BFUkFUSU9OX1JFTU9WRURdOiB0aGlzLl9vbk9wZXJhdGlvblJlbW92ZWRcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBMSUZFQ1lDTEVcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgc3VwZXIuY29tcG9uZW50RGlkTW91bnQoKVxuXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGVkaXRvci56b29tLnNldCgnYXV0bycpXG4gICAgZWRpdG9yLmZlYXR1cmVzLmRpc2FibGUoJ3pvb20nLCAnZHJhZycpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBvcGVyYXRpb24gaGFzIGJlZW4gcmVtb3ZlZFxuICAgKiBAcGFyYW0gIHtPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uT3BlcmF0aW9uUmVtb3ZlZCAob3BlcmF0aW9uKSB7XG4gICAgaWYgKG9wZXJhdGlvbiAhPT0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJykpIHJldHVyblxuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uQ2xpY2tlZCkgcmV0dXJuXG5cbiAgICAvLyBPcGVyYXRpb24gY2FuIGJlIHJlbW92ZWQgYnkgdGhlIHVuZG8gYnV0dG9uLiBXZSBuZWVkXG4gICAgLy8gdG8gbWFrZSBzdXJlIHdlIHJlLWNyZWF0ZSB0aGUgb3BlcmF0aW9uIGZvciB0aGUgbGlmZXRpbWVcbiAgICAvLyBvZiB0aGlzIGNvbnRyb2xcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3QgbmV3T3BlcmF0aW9uID0gZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ3NlbGVjdGl2ZS1ibHVyJylcbiAgICBjb25zdCBicnVzaCA9IG5ld09wZXJhdGlvbi5nZXRCcnVzaCgpXG5cbiAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHtcbiAgICAgIG9wZXJhdGlvbjogbmV3T3BlcmF0aW9uLFxuICAgICAgYnJ1c2gsXG4gICAgICBvcGVyYXRpb25FeGlzdGVkQmVmb3JlOiBmYWxzZSxcbiAgICAgIGluaXRpYWxPcHRpb25zOiB7fVxuICAgIH0pXG5cbiAgICBlZGl0b3IucmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGFuIG9wZXJhdGlvbiBoYXMgYmVlbiB1cGRhdGVkXG4gICAqIEBwYXJhbSAge09wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25PcGVyYXRpb25VcGRhdGVkIChvcGVyYXRpb24pIHtcbiAgICBpZiAob3BlcmF0aW9uID09PSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKSkge1xuICAgICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgICAgZWRpdG9yLnJlbmRlcigpXG4gICAgICB0aGlzLmZvcmNlVXBkYXRlKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgc2l6ZSBoYXMgYmVlbiB1cGRhdGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25TaXplVXBkYXRlZCAoc2l6ZSkge1xuICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUoeyBzaXplIH0pXG4gICAgdGhpcy5fYnJ1c2hTaXplID0gc2l6ZVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHNsaWRlciB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHByZXZpb3VzVmFsdWVcbiAgICogQHBhcmFtIHtCb29sZWFufSByZWxlYXNlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQmx1clJhZGl1c0NoYW5nZSAodmFsdWUsIHByZXZpb3VzVmFsdWUsIHJlbGVhc2VkID0gZmFsc2UpIHtcbiAgICBjb25zdCBpbnB1dERpbWVuc2lvbnMgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdpbnB1dERpbWVuc2lvbnMnKVxuICAgIHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpLnNldEJsdXJSYWRpdXModmFsdWUgLyBpbnB1dERpbWVuc2lvbnMubWluKCkpXG5cbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgZWRpdG9yLnJlbmRlcigpXG5cbiAgICBpZiAocmVsZWFzZWQpIHtcbiAgICAgIGVkaXRvci5oaXN0b3J5LmFkZChcbiAgICAgICAgdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJyksXG4gICAgICAgIHsgYmx1clJhZGl1czogcHJldmlvdXNWYWx1ZSAvIGlucHV0RGltZW5zaW9ucy5taW4oKSB9LFxuICAgICAgICB0cnVlKVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvdmVybGF5IGNvbnRyb2xzIG9mIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJPdmVybGF5Q29udHJvbHMgKCkge1xuICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2lucHV0RGltZW5zaW9ucycpXG4gICAgY29uc3Qgc2hvcnRlc3RTaWRlID0gaW5wdXREaW1lbnNpb25zLm1pbigpXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKS5nZXRCbHVyUmFkaXVzKCkgKiBzaG9ydGVzdFNpZGVcblxuICAgIHJldHVybiAoPFNsaWRlck92ZXJsYXlDb21wb25lbnRcbiAgICAgIG1pblZhbHVlPXswfVxuICAgICAgbWF4VmFsdWU9e01hdGgubWluKDE4MCwgTWF0aC5yb3VuZChzaG9ydGVzdFNpZGUgKiAwLjEpKX1cbiAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgIHZhbHVlVW5pdD0ncHgnXG4gICAgICBsYWJlbD17dGhpcy5fdCgnY29udHJvbHMuc2VsZWN0aXZlQmx1ci5ibHVyUmFkaXVzJyl9XG4gICAgICBvbkNoYW5nZT17dGhpcy5fb25CbHVyUmFkaXVzQ2hhbmdlfSAvPilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb250cm9scyBvZiB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyQ29udHJvbHMgKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCB6b29tID0gZWRpdG9yLnpvb20uZ2V0KClcbiAgICBsZXQgaXRlbXMgPSBbXVxuXG4gICAgY29uc3QgZmluYWxEaW1lbnNpb25zID0gZWRpdG9yLmdldEZpbmFsRGltZW5zaW9ucygpXG4gICAgY29uc3QgbWluU2l6ZSA9IDFcbiAgICBjb25zdCBtYXhTaXplID0gTWF0aC5yb3VuZChmaW5hbERpbWVuc2lvbnMuY2xvbmUoKS5tdWx0aXBseSh6b29tKS5taW4oKSAvIDIpXG4gICAgY29uc3QgY3VycmVudFdpZHRoID0gdGhpcy5fYnJ1c2hTaXplXG5cbiAgICBpdGVtcy5wdXNoKDxkaXYgYmVtPSdlOmNlbGwgbTpzbGlkZXInPlxuICAgICAgPFNsaWRlckNvbXBvbmVudFxuICAgICAgICBzdHlsZT0nbGFyZ2UnXG4gICAgICAgIG1pblZhbHVlPXttaW5TaXplfVxuICAgICAgICBtYXhWYWx1ZT17bWF4U2l6ZX1cbiAgICAgICAgdmFsdWVVbml0PSdweCdcbiAgICAgICAgbWlkZGxlRG90PXtmYWxzZX1cbiAgICAgICAgbGFiZWw9e3RoaXMuX3QoJ2NvbnRyb2xzLmJydXNoLnNpemUnKX1cbiAgICAgICAgb25DaGFuZ2U9e3RoaXMuX29uU2l6ZVVwZGF0ZWR9XG4gICAgICAgIHZhbHVlPXtjdXJyZW50V2lkdGh9IC8+XG4gICAgPC9kaXY+KVxuXG4gICAgcmV0dXJuIGl0ZW1zXG4gIH1cbn1cblxuQnJ1c2hDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvc2VsZWN0aXZlLWJsdXIvc2VsZWN0aXZlLWJsdXItY29udHJvbHMtY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBWZWN0b3IyLCBVdGlscywgU0RLVXRpbHMsIENvbnN0YW50cyB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgU3ByaXRlc0NhbnZhc0NvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4uL3Nwcml0ZXMvc3ByaXRlcy1jYW52YXMtY29udHJvbHMtY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCcnVzaENhbnZhc0NvbnRyb2xzQ29tcG9uZW50IGV4dGVuZHMgU3ByaXRlc0NhbnZhc0NvbnRyb2xzQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fd2luZG93UmVzaXplZCA9IGZhbHNlXG4gICAgdGhpcy5fZHJhd2luZyA9IGZhbHNlXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25Nb3VzZUVudGVyJyxcbiAgICAgICdfb25Nb3VzZUxlYXZlJyxcbiAgICAgICdfb25Nb3VzZURvd24nLFxuICAgICAgJ19vbk1vdXNlTW92ZScsXG4gICAgICAnX29uTW91c2VVcCcsXG4gICAgICAnX29uTW91c2VNb3ZlT25DYW52YXMnLFxuICAgICAgJ19vbldpbmRvd1Jlc2l6ZSdcbiAgICApXG5cbiAgICB0aGlzLl9sYXN0RHJhd1Bvc2l0aW9uID0gbnVsbFxuXG4gICAgdGhpcy5fZXZlbnRzID0gU0RLVXRpbHMuZXh0ZW5kKHRoaXMuX2V2ZW50cywge1xuICAgICAgW0NvbnN0YW50cy5FVkVOVFMuV0lORE9XX1JFU0laRV06IHRoaXMuX29uV2luZG93UmVzaXplXG4gICAgfSlcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBjdXJzb3JWaXNpYmxlOiBmYWxzZSxcbiAgICAgIGN1cnNvclBvc2l0aW9uOiBuZXcgVmVjdG9yMigpXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudERpZE1vdW50KClcbiAgICB0aGlzLl91cGRhdGVDb250YWluZXJSZWN0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGhhcyBiZWVuIHVwZGF0ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZFVwZGF0ZSAoKSB7XG4gICAgaWYgKHRoaXMuX3dpbmRvd1Jlc2l6ZWQpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUNvbnRhaW5lclJlY3QoKVxuICAgICAgdGhpcy5fd2luZG93UmVzaXplZCA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHdpbmRvdyBoYXMgYmVlbiByZXNpemVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25XaW5kb3dSZXNpemUgKCkge1xuICAgIHRoaXMuX3dpbmRvd1Jlc2l6ZWQgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBvcGVyYXRpb24gaGFzIGJlZW4gcmVtb3ZlZFxuICAgKiBAcGFyYW0gIHtPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uT3BlcmF0aW9uUmVtb3ZlZCAob3BlcmF0aW9uKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGFuIG9wZXJhdGlvbiBoYXMgYmVlbiB1cGRhdGVkXG4gICAqIEBwYXJhbSAge09wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25PcGVyYXRpb25VcGRhdGVkIChvcGVyYXRpb24pIHtcbiAgICBpZiAob3BlcmF0aW9uID09PSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKSkge1xuICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIG1vdXNlIGJ1dHRvblxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uTW91c2VEb3duIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxuICAgIHRoaXMuX29wdGlvbnNCZWZvcmVEcmF3ID0gb3BlcmF0aW9uLnNlcmlhbGl6ZU9wdGlvbnMoKVxuICAgIHRoaXMuX29wZXJhdGlvbkV4aXN0ZWRCZWZvcmVEcmF3ID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uRXhpc3RlZEJlZm9yZScpXG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7IG9wZXJhdGlvbkV4aXN0ZWRCZWZvcmU6IHRydWUgfSwgZmFsc2UpXG5cbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXRPdXRwdXREaW1lbnNpb25zKClcbiAgICBjb25zdCBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuX2dldEN1cnNvclBvc2l0aW9uKGUpXG5cbiAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2l6ZScpIC8gb3V0cHV0RGltZW5zaW9ucy5taW4oKVxuICAgIGNvbnN0IGhhcmRuZXNzID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnaGFyZG5lc3MnKVxuICAgIHRoaXMuX2RyYXdpbmcgPSB0cnVlXG5cbiAgICB0aGlzLl9jdXJyZW50UGF0aCA9IG9wZXJhdGlvbi5jcmVhdGVQYXRoKHNpemUsIGhhcmRuZXNzKVxuICAgIHRoaXMuX2N1cnJlbnRQYXRoLmFkZENvbnRyb2xQb2ludChjdXJzb3JQb3NpdGlvbi5jbG9uZSgpLmRpdmlkZShvdXRwdXREaW1lbnNpb25zKSlcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXApXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vbk1vdXNlVXApXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyBhIG1vdXNlIGJ1dHRvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uTW91c2VVcCAoKSB7XG4gICAgdGhpcy5fY3VycmVudFBhdGguc2V0Q2xvc2VkKHRydWUpXG5cbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgZWRpdG9yLnJlbmRlcigpXG5cbiAgICB0aGlzLl9jdXJyZW50UGF0aCA9IG51bGxcbiAgICB0aGlzLl9kcmF3aW5nID0gZmFsc2VcblxuICAgIGVkaXRvci5oaXN0b3J5LmFkZChcbiAgICAgIHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpLFxuICAgICAgdGhpcy5fb3B0aW9uc0JlZm9yZURyYXcsXG4gICAgICB0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlRHJhdylcblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXApXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vbk1vdXNlVXApXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBlbnRlcnMgdGhlIGNhbnZhc1xuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uTW91c2VFbnRlciAoZSkge1xuICAgIGNvbnN0IGN1cnNvclBvc2l0aW9uID0gdGhpcy5fZ2V0Q3Vyc29yUG9zaXRpb24oZSlcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGN1cnNvclZpc2libGU6IHRydWUsXG4gICAgICBjdXJzb3JQb3NpdGlvblxuICAgIH0pXG4gICAgdGhpcy5fb25Nb3VzZU1vdmUoZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGxlYXZlcyB0aGUgY2FudmFzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Nb3VzZUxlYXZlICgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGN1cnNvclZpc2libGU6IGZhbHNlXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGlsZSB0aGUgdXNlciBtb3ZlcyB0aGUgbW91c2VcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uTW91c2VNb3ZlIChlKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSBlZGl0b3IuZ2V0T3V0cHV0RGltZW5zaW9ucygpXG5cbiAgICBjb25zdCB6b29tID0gZWRpdG9yLnpvb20uZ2V0KClcbiAgICBjb25zdCBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuX2dldEN1cnNvclBvc2l0aW9uKGUpXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGN1cnNvclBvc2l0aW9uIH0pXG5cbiAgICBsZXQgc2hvdWxkRHJhd1xuICAgIGlmICghdGhpcy5fbGFzdERyYXdQb3NpdGlvbikge1xuICAgICAgc2hvdWxkRHJhdyA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYnJ1c2hTaXplID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2l6ZScpXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMuX2xhc3REcmF3UG9zaXRpb24uY2xvbmUoKVxuICAgICAgICAuc3VidHJhY3QoY3Vyc29yUG9zaXRpb24pXG4gICAgICAgIC5hYnMoKS5sZW4oKSAvIHpvb21cbiAgICAgIHNob3VsZERyYXcgPSBkaXN0YW5jZSA+PSBicnVzaFNpemUgLyAxMFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9kcmF3aW5nICYmIHNob3VsZERyYXcpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRQYXRoLmFkZENvbnRyb2xQb2ludChjdXJzb3JQb3NpdGlvbi5jbG9uZSgpLmRpdmlkZShvdXRwdXREaW1lbnNpb25zKSlcbiAgICAgIHRoaXMuX2xhc3REcmF3UG9zaXRpb24gPSBjdXJzb3JQb3NpdGlvbi5jbG9uZSgpXG5cbiAgICAgIGVkaXRvci5yZW5kZXIoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGlsZSB0aGUgdXNlciBtb3ZlcyB0aGUgbW91c2Ugb24gdG9wIG9mIHRoZSBjYW52YXMuIFVwZGF0ZXNcbiAgICogdGhlIGN1cnNvciBjdXJzb3IgcG9zaXRpb25cbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk1vdXNlTW92ZU9uQ2FudmFzIChlKSB7XG4gICAgY29uc3QgY3Vyc29yUG9zaXRpb24gPSB0aGlzLl9nZXRDdXJzb3JQb3NpdGlvbihlKVxuICAgIHRoaXMuc2V0U3RhdGUoeyBjdXJzb3JQb3NpdGlvbiB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gU1RZTElOR1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJzb3IncyBzdHlsZSBvYmplY3RcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEN1cnNvclN0eWxlICgpIHtcbiAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2l6ZScpXG5cbiAgICBjb25zdCB7IGN1cnNvclBvc2l0aW9uIH0gPSB0aGlzLnN0YXRlXG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGN1cnNvclBvc2l0aW9uLngsXG4gICAgICB0b3A6IGN1cnNvclBvc2l0aW9uLnksXG4gICAgICB3aWR0aDogc2l6ZSxcbiAgICAgIGhlaWdodDogc2l6ZSxcbiAgICAgIG1hcmdpbkxlZnQ6IHNpemUgKiAtMC41LFxuICAgICAgbWFyZ2luVG9wOiBzaXplICogLTAuNVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE1JU0NcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY29udGFpbmVyIGJvdW5kaW5nIHJlY3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVDb250YWluZXJSZWN0ICgpIHtcbiAgICB0aGlzLl9jb250YWluZXJCb3VuZGluZ1JlY3QgPSB0aGlzLnJlZnMuaW5uZXJDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJzb3IgcG9zaXRpb24gZm9yIHRoZSBnaXZlbiBldmVudFxuICAgKiBAcGFyYW0gIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRDdXJzb3JQb3NpdGlvbiAoZXZlbnQpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IFV0aWxzLmdldEV2ZW50UG9zaXRpb24oZXZlbnQpXG4gICAgY29uc3QgYm91bmRpbmdSZWN0ID0gdGhpcy5fY29udGFpbmVyQm91bmRpbmdSZWN0XG4gICAgcmV0dXJuIHBvc2l0aW9uXG4gICAgICAuc3VidHJhY3QoYm91bmRpbmdSZWN0LmxlZnQsIGJvdW5kaW5nUmVjdC50b3ApXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJvcGVydGllcyBmb3IgdGhlIG91dGVyIGNvbnRhaW5lclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0Q29udGFpbmVyUHJvcHMgKCkge1xuICAgIGxldCBwcm9wcyA9IHN1cGVyLl9nZXRDb250YWluZXJQcm9wcygpXG5cbiAgICBwcm9wcy5vbk1vdXNlRG93biA9IHByb3BzLm9uVG91Y2hTdGFydCA9IHRoaXMuX29uTW91c2VEb3duXG4gICAgcmV0dXJuIHByb3BzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJvcGVydGllcyBmb3IgdGhlIGNhbnZhcyBjb250YWluZXJcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldElubmVyQ29udGFpbmVyUHJvcHMgKCkge1xuICAgIGxldCBwcm9wcyA9IHN1cGVyLl9nZXRJbm5lckNvbnRhaW5lclByb3BzKClcblxuICAgIC8vIFRoaXMgZGlzYWJsZXMgdGhlIGhpdCB0ZXN0aW5nIGZvciB0aGlzIHN1YiBjb250cm9sXG4gICAgZGVsZXRlIHByb3BzLm9uQ2xpY2tcblxuICAgIHByb3BzLm9uTW91c2VFbnRlciA9IHRoaXMuX29uTW91c2VFbnRlclxuICAgIHByb3BzLm9uTW91c2VMZWF2ZSA9IHRoaXMuX29uTW91c2VMZWF2ZVxuICAgIHByb3BzLm9uTW91c2VNb3ZlID0gdGhpcy5fb25Nb3VzZU1vdmVPbkNhbnZhc1xuICAgIHJldHVybiBwcm9wc1xuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHNwcml0ZSBpdGVtc1xuICAgKiBAcmV0dXJuIHtBcnJheS48U3ByaXRlSXRlbUNvbXBvbmVudD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyU3ByaXRlSXRlbXMgKCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvKipcbiAgICogVGhpcyByZW5kZXJzIGNvbnRyb2xzIG9uIHRvcCBvZiB0aGUgc3ByaXRlc1xuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlck92ZXJsYXlDb250cm9scyAoKSB7XG4gICAgY29uc3QgY3Vyc29yQ2xhc3MgPSB0aGlzLnN0YXRlLmN1cnNvclZpc2libGUgPyAnaXMtdmlzaWJsZScgOiBudWxsXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgYmVtPSckYjpzZWxlY3RpdmVCbHVyQ2FudmFzQ29udHJvbHMnPlxuICAgICAgICA8ZGl2IGJlbT0nZTpjdXJzb3InIGNsYXNzTmFtZT17Y3Vyc29yQ2xhc3N9IHN0eWxlPXt0aGlzLl9nZXRDdXJzb3JTdHlsZSgpfSAvPlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG5cbkJydXNoQ2FudmFzQ29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzID0gU3ByaXRlc0NhbnZhc0NvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9zZWxlY3RpdmUtYmx1ci9zZWxlY3RpdmUtYmx1ci1jYW52YXMtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBDb250cm9scyBmcm9tICcuLi9jb250cm9scydcbmltcG9ydCBGcmFtZUNvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4vZnJhbWUtY29udHJvbHMtY29tcG9uZW50J1xuXG4vKipcbiAqIFRoZSBmcmFtZSBjb250cm9sc1xuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xzXG4gKi9cbmNsYXNzIEZyYW1lQ29udHJvbHMgZXh0ZW5kcyBDb250cm9scyB7XG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGxlYXZlcyB0aGVzZSBjb250cm9sc1xuICAgKiBAdGhpcyB7RnJhbWVDb250cm9sc0NvbXBvbmVudH1cbiAgICogQG92ZXJyaWRlXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBvbkV4aXQgKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxuICAgIGNvbnN0IGluaXRpYWxPcHRpb25zID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnaW5pdGlhbE9wdGlvbnMnKVxuXG4gICAgY29uc3QgZnJhbWUgPSBvcGVyYXRpb24uZ2V0RnJhbWUoKVxuICAgIGNvbnN0IHNjYWxlID0gb3BlcmF0aW9uLmdldFNjYWxlKClcblxuICAgIGlmICgoZnJhbWUgJiYgZnJhbWUuaWRlbnRpZmllcikgIT09IChpbml0aWFsT3B0aW9ucy5mcmFtZSAmJiBpbml0aWFsT3B0aW9ucy5mcmFtZS5pZGVudGlmaWVyKSB8fFxuICAgICAgICBzY2FsZSAhPT0gaW5pdGlhbE9wdGlvbnMuc2NhbGUpIHtcbiAgICAgIGVkaXRvci5oaXN0b3J5LmFkZChcbiAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICB0aGlzLmdldFNoYXJlZFN0YXRlKCdpbml0aWFsT3B0aW9ucycpLFxuICAgICAgICB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb25FeGlzdGVkQmVmb3JlJylcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoIW9wZXJhdGlvbi5nZXRGcmFtZSgpKSB7XG4gICAgICBlZGl0b3Iub3BlcmF0aW9ucy5yZW1vdmUob3BlcmF0aW9uKVxuICAgIH1cblxuICAgIGVkaXRvci5yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgZW50ZXJzIHRoZXNlIGNvbnRyb2xzXG4gICAqIEB0aGlzIHtGcmFtZUNvbnRyb2xzQ29tcG9uZW50fVxuICAgKiBAcGFyYW0ge1NoYXJlZFN0YXRlfSBzaGFyZWRTdGF0ZVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIG9uRW50ZXIgKHNoYXJlZFN0YXRlKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG9wZXJhdGlvbkV4aXN0ZWRCZWZvcmUgPSBlZGl0b3Iub3BlcmF0aW9ucy5leGlzdHMoJ2ZyYW1lJylcbiAgICBjb25zdCBvcGVyYXRpb24gPSBlZGl0b3Iub3BlcmF0aW9ucy5nZXRPckNyZWF0ZSgnZnJhbWUnKVxuICAgIGNvbnN0IGluaXRpYWxPcHRpb25zID0gb3BlcmF0aW9uLnNlcmlhbGl6ZU9wdGlvbnMoKVxuXG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7XG4gICAgICBvcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb25FeGlzdGVkQmVmb3JlLFxuICAgICAgaW5pdGlhbE9wdGlvbnMsXG4gICAgICBpbnB1dERpbWVuc2lvbnM6IG9wZXJhdGlvbi5nZXRJbnB1dERpbWVuc2lvbnMoKSxcbiAgICAgIGZyYW1lOiBvcGVyYXRpb24uZ2V0RnJhbWUoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgY29udHJvbCBpcyBhdmFpbGFibGUgdG8gdGhlIHVzZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5FZGl0b3J9IGVkaXRvclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIGlzQXZhaWxhYmxlIChlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzVG9vbEFsbG93ZWQoJ2ZyYW1lJykgJiZcbiAgICAgIGVkaXRvci5pc1Rvb2xFbmFibGVkKCdmcmFtZScpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBjb250cm9scyBjb21wb25lbnQuIFVzZWQgZm9yIHRoZSBsb3dlciBjb250cm9scyBwYXJ0IG9mIHRoZSBlZGl0b3IuXG4gKiBAdHlwZSB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5Db250cm9sc0NvbXBvbmVudH1cbiAqIEBpZ25vcmVcbiAqL1xuRnJhbWVDb250cm9scy5jb250cm9sc0NvbXBvbmVudCA9IEZyYW1lQ29udHJvbHNDb21wb25lbnRcblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuRnJhbWVDb250cm9scy5pZGVudGlmaWVyID0gJ2ZyYW1lJ1xuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIGljb24gcGF0aFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBpZ25vcmVcbiAqL1xuRnJhbWVDb250cm9scy5pY29uUGF0aCA9ICdjb250cm9scy9vdmVydmlldy9mcmFtZS5wbmcnXG5cbi8qKlxuICogVGhlIGxhbmd1YWdlIGtleSB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gZGlzcGxheWluZyB0aGlzIGZpbHRlclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBpZ25vcmVcbiAqL1xuRnJhbWVDb250cm9scy5sYW5ndWFnZUtleSA9ICdwZXNkay5mcmFtZS50aXRsZS5uYW1lJ1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoaXMgY29udHJvbFxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0W119IFtmcmFtZXMgPSBbXV1cbiAqL1xuRnJhbWVDb250cm9scy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgZnJhbWVzOiBbXVxufVxuXG4vKipcbiAqIFRoZSBvcGVyYXRpb25zIHJlcXVpcmVkIGZvciB0aGlzIGNvbnRyb2wgdG8gd29yayBwcm9wZXJseVxuICogQHR5cGUge0FycmF5fVxuICovXG5GcmFtZUNvbnRyb2xzLnJlcXVpcmVkT3BlcmF0aW9ucyA9IFsnc3ByaXRlJ11cblxuRnJhbWVDb250cm9scy5nZXRQcmVsb2FkQXNzZXRzID0gQ29udHJvbHMuZ2V0UHJlbG9hZEFzc2V0c1xuXG5leHBvcnQgZGVmYXVsdCBGcmFtZUNvbnRyb2xzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL2ZyYW1lL2luZGV4LmpzIiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBDb25zdGFudHMgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IENvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4uL2NvbnRyb2xzLWNvbXBvbmVudCdcbmltcG9ydCBTY3JvbGxiYXJDb21wb25lbnQgZnJvbSAnLi4vLi4vc2Nyb2xsYmFyLWNvbXBvbmVudCdcbmltcG9ydCBNb2RhbE1hbmFnZXIgZnJvbSAnLi4vLi4vLi4vbGliL21vZGFsLW1hbmFnZXInXG5pbXBvcnQgRnJhbWVNYW5hZ2VyIGZyb20gJ3NoYXJlZC9tYW5hZ2Vycy9mcmFtZS1tYW5hZ2VyJ1xuaW1wb3J0IEZyYW1lSXRlbUNvbXBvbmVudCBmcm9tICcuL2ZyYW1lLWl0ZW0tY29tcG9uZW50J1xuaW1wb3J0IENvbG9yUGlja2VyQ29tcG9uZW50IGZyb20gJy4uLy4uL2NvbG9yLXBpY2tlci9jb2xvci1waWNrZXItY29tcG9uZW50J1xuaW1wb3J0IFNsaWRlck92ZXJsYXlDb21wb25lbnQgZnJvbSAnLi4vc2xpZGVyLW92ZXJsYXktY29tcG9uZW50J1xuaW1wb3J0IEZyYW1lIGZyb20gJ2xpYi9mcmFtZSdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRnJhbWVPdmVydmlld0NvbnRyb2xzQ29tcG9uZW50IGV4dGVuZHMgQ29udHJvbHNDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9vcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uU2NhbGVDaGFuZ2UnLFxuICAgICAgJ19vbkNvbG9yQ2hhbmdlJyxcbiAgICAgICdfb25PcGVyYXRpb25VcGRhdGVkJyxcbiAgICAgICdfb25PcGVyYXRpb25SZW1vdmVkJ1xuICAgIClcblxuICAgIHRoaXMuX2V2ZW50cyA9IHtcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLk9QRVJBVElPTl9VUERBVEVEXTogdGhpcy5fb25PcGVyYXRpb25VcGRhdGVkLFxuICAgICAgW0NvbnN0YW50cy5FVkVOVFMuT1BFUkFUSU9OX1JFTU9WRURdOiB0aGlzLl9vbk9wZXJhdGlvblJlbW92ZWRcbiAgICB9XG5cbiAgICB0aGlzLl9pbml0RnJhbWVNYW5hZ2VyKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEZSQU1FU1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgZnJhbWUgbWFuYWdlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRGcmFtZU1hbmFnZXIgKCkge1xuICAgIHRoaXMuX2ZyYW1lTWFuYWdlciA9IG5ldyBGcmFtZU1hbmFnZXIodGhpcy5jb250ZXh0LnVpLCB0aGlzLnByb3BzLm9wdGlvbnMpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBvcGVyYXRpb24gaGFzIGJlZW4gdXBkYXRlZFxuICAgKiBAcGFyYW0gIHtPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uT3BlcmF0aW9uVXBkYXRlZCAob3BlcmF0aW9uKSB7XG4gICAgaWYgKG9wZXJhdGlvbiA9PT0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJykpIHtcbiAgICAgIHRoaXMuZm9yY2VTaGFyZWRVcGRhdGUoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGFuIG9wZXJhdGlvbiBoYXMgYmVlbiByZW1vdmVkXG4gICAqIEBwYXJhbSAge09wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25PcGVyYXRpb25SZW1vdmVkIChvcGVyYXRpb24pIHtcbiAgICBpZiAob3BlcmF0aW9uICE9PSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKSkgcmV0dXJuXG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25DbGlja2VkKSByZXR1cm5cblxuICAgIC8vIE9wZXJhdGlvbiBjYW4gYmUgcmVtb3ZlZCBieSB0aGUgdW5kbyBidXR0b24uIFdlIG5lZWRcbiAgICAvLyB0byBtYWtlIHN1cmUgd2UgcmUtY3JlYXRlIHRoZSBvcGVyYXRpb24gZm9yIHRoZSBsaWZldGltZVxuICAgIC8vIG9mIHRoaXMgY29udHJvbFxuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBuZXdPcGVyYXRpb24gPSBlZGl0b3Iub3BlcmF0aW9ucy5nZXRPckNyZWF0ZSgnZnJhbWUnKVxuXG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7XG4gICAgICBvcGVyYXRpb246IG5ld09wZXJhdGlvbixcbiAgICAgIGZyYW1lOiBudWxsLFxuICAgICAgb3BlcmF0aW9uRXhpc3RlZEJlZm9yZTogZmFsc2UsXG4gICAgICBpbml0aWFsT3B0aW9uczoge31cbiAgICB9KVxuXG4gICAgZWRpdG9yLnJlbmRlcigpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgc2NhbGUgaGFzIGJlZW4gY2hhbmdlZFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNjYWxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25TY2FsZUNoYW5nZSAoc2NhbGUpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG5cbiAgICBjb25zdCBpbnB1dERpbWVuc2lvbnMgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdpbnB1dERpbWVuc2lvbnMnKVxuICAgIHRoaXMuX29wZXJhdGlvbi5zZXRTY2FsZShzY2FsZSAvIGlucHV0RGltZW5zaW9ucy5taW4oKSlcblxuICAgIGVkaXRvci5yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHRpbnQgY29sb3IgaGFzIGJlZW4gY2hhbmdlZFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5Db2xvcn0gY29sb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNvbG9yQ2hhbmdlIChjb2xvcikge1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpXG4gICAgb3BlcmF0aW9uLnNldFRpbnRDb2xvcihjb2xvci5jbG9uZSgpKVxuXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGVkaXRvci5yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBiYWNrIGJ1dHRvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25CYWNrQ2xpY2sgKGUpIHtcbiAgICB0aGlzLl9iYWNrQnV0dG9uQ2xpY2tlZCA9IHRydWVcbiAgICB0aGlzLnByb3BzLm9uU3dpdGNoQ29udHJvbHMoJ2hvbWUnKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYSBmcmFtZSBoYXMgYmVlbiBjbGlja2VkXG4gICAqIEBwYXJhbSAge09iamVjdH0gZnJhbWVEYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25GcmFtZUNsaWNrIChmcmFtZURhdGEpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICBpZiAoZnJhbWVEYXRhID09PSBudWxsKSB7XG4gICAgICBvcGVyYXRpb24uc2V0RnJhbWUobnVsbClcbiAgICAgIGVkaXRvci5yZW5kZXIoKVxuICAgICAgcmV0dXJuIHRoaXMuc2V0U2hhcmVkU3RhdGUoeyBmcmFtZTogbnVsbCB9KVxuICAgIH1cblxuICAgIGxldCBsb2FkaW5nTW9kYWxcbiAgICBsZXQgbG9hZFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGxvYWRpbmdNb2RhbCA9IE1vZGFsTWFuYWdlci5pbnN0YW5jZS5kaXNwbGF5TG9hZGluZyh0aGlzLl90KCdwZXNkay5jb21tb24udGV4dC5sb2FkaW5nJykpXG4gICAgfSwgMTAwKVxuXG4gICAgY29uc3QgZnJhbWUgPSBuZXcgRnJhbWUodGhpcy5jb250ZXh0LnVpLCBmcmFtZURhdGEpXG5cbiAgICBmcmFtZS5sb2FkKClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKGxvYWRpbmdNb2RhbCkgbG9hZGluZ01vZGFsLmNsb3NlKClcbiAgICAgICAgaWYgKGxvYWRUaW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGxvYWRUaW1lb3V0KVxuICAgICAgICAgIGxvYWRUaW1lb3V0ID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZnJhbWVPYmplY3QgPSBmcmFtZS5nZXRGcmFtZSgpXG4gICAgICAgIG9wZXJhdGlvbi5zZXRGcmFtZShmcmFtZU9iamVjdClcblxuICAgICAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgICAgIGVkaXRvci5yZW5kZXIoKVxuXG4gICAgICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUoeyBmcmFtZSB9KVxuICAgICAgfSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvdmVybGF5IGNvbnRyb2xzIG9mIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJPdmVybGF5Q29udHJvbHMgKCkge1xuICAgIGNvbnN0IGZyYW1lID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnZnJhbWUnKVxuXG4gICAgaWYgKCFmcmFtZSkgcmV0dXJuIG51bGxcblxuICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2lucHV0RGltZW5zaW9ucycpXG5cbiAgICBjb25zdCBtaW5TaXplID0gNVxuICAgIGNvbnN0IG1heFNpemUgPSBNYXRoLnJvdW5kKDAuMyAqIGlucHV0RGltZW5zaW9ucy5taW4oKSlcbiAgICBjb25zdCBjdXJyZW50U2NhbGUgPSB0aGlzLl9vcGVyYXRpb24uZ2V0U2NhbGUoKSAqIGlucHV0RGltZW5zaW9ucy5taW4oKVxuXG4gICAgcmV0dXJuICg8U2xpZGVyT3ZlcmxheUNvbXBvbmVudFxuICAgICAgbWluVmFsdWU9e21pblNpemV9XG4gICAgICBtYXhWYWx1ZT17bWF4U2l6ZX1cbiAgICAgIHZhbHVlPXtjdXJyZW50U2NhbGV9XG4gICAgICB2YWx1ZVVuaXQ9J3B4J1xuICAgICAgbWlkZGxlRG90PXtmYWxzZX1cbiAgICAgIGxhYmVsPXt0aGlzLl90KCdwZXNkay5mcmFtZS50ZXh0LnNjYWxlJyl9XG4gICAgICBvbkNoYW5nZT17dGhpcy5fb25TY2FsZUNoYW5nZX0gLz4pXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgbGlzdCBpdGVtcyBmb3IgdGhpcyBjb250cm9sXG4gICAqIEByZXR1cm4ge0FycmF5LjxSZWFjdEJFTS5FbGVtZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJMaXN0SXRlbXMgKCkge1xuICAgIGNvbnN0IGZyYW1lcyA9IHRoaXMuX2ZyYW1lTWFuYWdlci5nZXRGcmFtZXNGb3JDYXRlZ29yeSgnYWxsJylcbiAgICBjb25zdCBjdXJyZW50RnJhbWUgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKS5nZXRGcmFtZSgpXG5cbiAgICBjb25zdCBub0ZyYW1lSXRlbSA9ICg8bGlcbiAgICAgIGJlbT0nZTppdGVtJ1xuICAgICAga2V5PSduby1mcmFtZSdcbiAgICAgIG9uQ2xpY2s9e3RoaXMuX29uRnJhbWVDbGljay5iaW5kKHRoaXMsIG51bGwpfT5cbiAgICAgIDxiZW0gc3BlY2lmaWVyPSckYjpjb250cm9scyc+XG4gICAgICAgIDxkaXYgYmVtPSckZTpidXR0b24gbTp3aXRoTGFiZWwnXG4gICAgICAgICAgY2xhc3NOYW1lPXshY3VycmVudEZyYW1lID8gJ2lzLWFjdGl2ZScgOiBudWxsfT5cbiAgICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aChgY29udHJvbHMvZnJhbWUvbm8tZnJhbWUucG5nYCwgdHJ1ZSl9IC8+XG4gICAgICAgICAgPGRpdiBiZW09J2U6bGFiZWwnPnt0aGlzLl90KCdwZXNkay5mcmFtZS5idXR0b24ubm9uZScpfTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvYmVtPlxuICAgIDwvbGk+KVxuXG4gICAgcmV0dXJuIFtub0ZyYW1lSXRlbV0uY29uY2F0KGZyYW1lcy5tYXAoKGZyYW1lLCBpKSA9PiB7XG4gICAgICByZXR1cm4gKDxGcmFtZUl0ZW1Db21wb25lbnRcbiAgICAgICAgZnJhbWU9e2ZyYW1lfVxuICAgICAgICBhY3RpdmU9e2N1cnJlbnRGcmFtZSAmJiBjdXJyZW50RnJhbWUuaWRlbnRpZmllciA9PT0gZnJhbWUuaWRlbnRpZmllcn1cbiAgICAgICAgb25DbGljaz17dGhpcy5fb25GcmFtZUNsaWNrLmJpbmQodGhpcywgZnJhbWUpfSAvPilcbiAgICB9KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb250cm9scyBvZiB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyQ29udHJvbHMgKCkge1xuICAgIGNvbnN0IGZyYW1lID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJykuZ2V0RnJhbWUoKVxuICAgIGNvbnN0IGxpc3RJdGVtcyA9IHRoaXMuX3JlbmRlckxpc3RJdGVtcygpXG5cbiAgICBjb25zdCBpdGVtcyA9IFsoPGRpdiBiZW09J2U6Y2VsbCBtOmxpc3QnPlxuICAgICAgPFNjcm9sbGJhckNvbXBvbmVudCByZWY9J3Njcm9sbGJhcic+XG4gICAgICAgIDx1bCBiZW09JyRlOmxpc3QnPlxuICAgICAgICAgIHtsaXN0SXRlbXN9XG4gICAgICAgIDwvdWw+XG4gICAgICA8L1Njcm9sbGJhckNvbXBvbmVudD5cbiAgICA8L2Rpdj4pXVxuXG4gICAgaWYgKGZyYW1lICYmIGZyYW1lLnRpbnRhYmxlKSB7XG4gICAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxuICAgICAgaXRlbXMucHVzaCg8ZGl2IGJlbT0nZTpjZWxsIG06Y29sb3JQaWNrZXInPlxuICAgICAgICA8Q29sb3JQaWNrZXJDb21wb25lbnRcbiAgICAgICAgICBpbml0aWFsVmFsdWU9e29wZXJhdGlvbi5nZXRUaW50Q29sb3IoKS5jbG9uZSgpfVxuICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLl9vbkNvbG9yQ2hhbmdlfSAvPlxuICAgICAgPC9kaXY+KVxuICAgIH1cblxuICAgIHJldHVybiBpdGVtc1xuICB9XG59XG5cbkZyYW1lT3ZlcnZpZXdDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvZnJhbWUvZnJhbWUtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCwgVmVjdG9yMiB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZyYW1lSXRlbUNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZnJhbWU6IHRoaXMucHJvcHMuZnJhbWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgdGhpcy5fcmVuZGVyRnJhbWUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgYWJvdXQgdG8gcmVjZWl2ZSBuZXcgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IG5leHRQcm9wc1xuICAgKi9cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAobmV4dFByb3BzKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuZnJhbWUgIT09IG5leHRQcm9wcy5mcmFtZSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGZyYW1lOiBuZXh0UHJvcHMuZnJhbWUgfSwgKCkgPT4ge1xuICAgICAgICB0aGlzLl9yZW5kZXJGcmFtZSgpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBmcmFtZSBvbnRvIHRoZSBjYW52YXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJGcmFtZSAoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IHNkayA9IGVkaXRvci5nZXRTREsoKVxuXG4gICAgY29uc3QgeyBmcmFtZSB9ID0gdGhpcy5wcm9wc1xuXG4gICAgY29uc3QgcmVzb2x2ZWRGcmFtZVBhdGggPSB0aGlzLl9nZXRBc3NldFBhdGgoZnJhbWUudGh1bWJuYWlsKVxuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMucmVmc1tgY2FudmFzLSR7ZnJhbWUuaWRlbnRpZmllcn1gXVxuXG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IHNkay5nZXRQaXhlbFJhdGlvKClcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMub2Zmc2V0V2lkdGggKiBwaXhlbFJhdGlvXG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy5vZmZzZXRIZWlnaHQgKiBwaXhlbFJhdGlvXG5cbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHtjYW52YXMub2Zmc2V0V2lkdGh9cHhgXG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2NhbnZhcy5vZmZzZXRIZWlnaHR9cHhgXG5cbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcblxuICAgIGNvbnN0IGltYWdlID0gbmV3IHdpbmRvdy5JbWFnZSgpXG4gICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5taW4oY2FudmFzLndpZHRoIC8gaW1hZ2Uud2lkdGgsIGNhbnZhcy5oZWlnaHQgLyBpbWFnZS5oZWlnaHQpXG4gICAgICBjb25zdCBkcmF3U2l6ZSA9IG5ldyBWZWN0b3IyKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpXG4gICAgICAgIC5tdWx0aXBseShzY2FsZSlcbiAgICAgIGNvbnN0IGRyYXdQb3NpdGlvbiA9IG5ldyBWZWN0b3IyKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcbiAgICAgICAgLmRpdmlkZSgyKVxuICAgICAgICAuc3VidHJhY3QoZHJhd1NpemUuY2xvbmUoKS5kaXZpZGUoMikpXG5cbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLFxuICAgICAgICAwLCAwLFxuICAgICAgICBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LFxuICAgICAgICBkcmF3UG9zaXRpb24ueCwgZHJhd1Bvc2l0aW9uLnksXG4gICAgICAgIGRyYXdTaXplLngsIGRyYXdTaXplLnkpXG4gICAgfSlcbiAgICBpbWFnZS5jcm9zc09yaWdpbiA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0Q3Jvc3NPcmlnaW4oKVxuICAgIGltYWdlLnNyYyA9IHJlc29sdmVkRnJhbWVQYXRoXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGVsZW1lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uZWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIHJldHVybiAoPGJlbSBzcGVjaWZpZXI9J2I6Y29udHJvbHMgZTpsaXN0Jz5cbiAgICAgIDxsaVxuICAgICAgICBiZW09J2U6aXRlbSdcbiAgICAgICAga2V5PXt0aGlzLnByb3BzLmZyYW1lLmlkZW50aWZpZXJ9XG4gICAgICAgIG9uQ2xpY2s9e3RoaXMucHJvcHMub25DbGlja30+XG4gICAgICAgIDxiZW0gc3BlY2lmaWVyPSckYjpjb250cm9scyc+XG4gICAgICAgICAgPGRpdiBiZW09JyRlOmJ1dHRvbiBtOndpdGhJbmxpbmVMYWJlbCc+XG4gICAgICAgICAgICA8Y2FudmFzIGJlbT0nZTpjYW52YXMgbTpsYXJnZScgcmVmPXtgY2FudmFzLSR7dGhpcy5wcm9wcy5mcmFtZS5pZGVudGlmaWVyfWB9IC8+XG4gICAgICAgICAgICA8ZGl2IGJlbT0nJGU6aW5saW5lTGFiZWwnIGNsYXNzTmFtZT17dGhpcy5wcm9wcy5hY3RpdmUgPyAnaXMtYWN0aXZlJyA6IG51bGx9PlxuICAgICAgICAgICAgICA8ZGl2IGJlbT0nZTpsYWJlbCc+e3RoaXMuX3QoYHBlc2RrLmZyYW1lLmFzc2V0LiR7dGhpcy5wcm9wcy5mcmFtZS5pZGVudGlmaWVyfWApIHx8IHRoaXMucHJvcHMuZnJhbWUuZGVmYXVsdE5hbWV9PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9iZW0+XG4gICAgICA8L2xpPlxuICAgIDwvYmVtPilcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9mcmFtZS9mcmFtZS1pdGVtLWNvbXBvbmVudC5qc3giLCIvKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IENvbnN0YW50cyB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVkaXRvckZlYXR1cmVzIHtcbiAgY29uc3RydWN0b3IgKGVkaXRvciwgc2RrLCBtZWRpYXRvcikge1xuICAgIHRoaXMuX2VkaXRvciA9IGVkaXRvclxuICAgIHRoaXMuX3NkayA9IHNka1xuICAgIHRoaXMuX21lZGlhdG9yID0gbWVkaWF0b3JcblxuICAgIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9lZGl0b3IuZ2V0T3B0aW9ucygpXG5cbiAgICB0aGlzLl9mZWF0dXJlcyA9IHtcbiAgICAgIGRyYWc6IHRoaXMuX29wdGlvbnMuZWRpdG9yLmVuYWJsZURyYWcsXG4gICAgICB6b29tOiB0aGlzLl9vcHRpb25zLmVkaXRvci5lbmFibGVab29tXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZmVhdHVyZSB3aXRoIHRoZSBnaXZlbiBpZGVudGlmaWVyIGlzIGVuYWJsZWRcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgaWRlbnRpZmllclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNFbmFibGVkIChpZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY2FwaXRhbGl6ZWRJZGVudGlmaWVyID0gaWRlbnRpZmllci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGlkZW50aWZpZXIuc2xpY2UoMSlcbiAgICBjb25zdCBvcHRpb25FbmFibGVkID0gdGhpcy5fb3B0aW9ucy5lZGl0b3JbYGVuYWJsZSR7Y2FwaXRhbGl6ZWRJZGVudGlmaWVyfWBdXG4gICAgcmV0dXJuIHRoaXMuX2ZlYXR1cmVzW2lkZW50aWZpZXJdICYmIG9wdGlvbkVuYWJsZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGVzIHRoZSBmZWF0dXJlcyB3aXRoIHRoZSBnaXZlbiBpZGVudGlmaWVyc1xuICAgKiBAcGFyYW0gIHtTdHJpbmdbXX0gaWRlbnRpZmllcnNcbiAgICovXG4gIGVuYWJsZSAoLi4uaWRlbnRpZmllcnMpIHtcbiAgICBpZGVudGlmaWVycy5mb3JFYWNoKChpZGVudGlmaWVyKSA9PiB7XG4gICAgICB0aGlzLl9mZWF0dXJlc1tpZGVudGlmaWVyXSA9IHRydWVcbiAgICB9KVxuICAgIHRoaXMuX21lZGlhdG9yLmVtaXQoQ29uc3RhbnRzLkVWRU5UUy5GRUFUVVJFU19FTkFCTEVELCBpZGVudGlmaWVycylcbiAgICB0aGlzLl9tZWRpYXRvci5lbWl0KENvbnN0YW50cy5FVkVOVFMuRkVBVFVSRVNfVVBEQVRFRCwgaWRlbnRpZmllcnMpXG4gIH1cblxuICAvKipcbiAgICogRGlzYWJsZXMgdGhlIGZlYXR1cmVzIHdpdGggdGhlIGdpdmVuIGlkZW50aWZpZXJzXG4gICAqIEBwYXJhbSAge1N0cmluZ1tdfSBpZGVudGlmaWVyc1xuICAgKi9cbiAgZGlzYWJsZSAoLi4uaWRlbnRpZmllcnMpIHtcbiAgICBpZGVudGlmaWVycy5mb3JFYWNoKChpZGVudGlmaWVyKSA9PiB7XG4gICAgICB0aGlzLl9mZWF0dXJlc1tpZGVudGlmaWVyXSA9IGZhbHNlXG4gICAgfSlcbiAgICB0aGlzLl9tZWRpYXRvci5lbWl0KENvbnN0YW50cy5FVkVOVFMuRkVBVFVSRVNfRElTQUJMRUQsIGlkZW50aWZpZXJzKVxuICAgIHRoaXMuX21lZGlhdG9yLmVtaXQoQ29uc3RhbnRzLkVWRU5UUy5GRUFUVVJFU19VUERBVEVELCBpZGVudGlmaWVycylcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL2VkaXRvci9mZWF0dXJlcy5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgU0RLVXRpbHMsIFZlY3RvcjIsIEV2ZW50RW1pdHRlciB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5cbmNvbnN0IE1JTl9aT09NX0RJTUVOU0lPTlMgPSAzMDBcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWRpdG9yWm9vbSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChlZGl0b3IsIHNkaywgbWVkaWF0b3IpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fZWRpdG9yID0gZWRpdG9yXG4gICAgdGhpcy5fc2RrID0gc2RrXG4gICAgdGhpcy5fbWVkaWF0b3IgPSBtZWRpYXRvclxuXG4gICAgdGhpcy5faXNEZWZhdWx0Wm9vbSA9IGZhbHNlXG4gICAgdGhpcy5fem9vbSA9IHRoaXMuX3Nkay5nZXRab29tKClcbiAgICB0aGlzLl9vcHRpb25zID0gdGhpcy5fZWRpdG9yLmdldE9wdGlvbnMoKVxuXG4gICAgdGhpcy5fem9vbUxldmVscyA9IFtcbiAgICAgIDEsIDIsIDMsIDQsIDUsXG4gICAgICA2LjI1LCA4LjMzLCAxMi41LFxuICAgICAgMTYuNjYsIDI1LCAzMy4zMywgNTAsIDY2LjY2LCAxMDAsXG4gICAgICAyMDAsIDMwMCwgNDAwLCA1MDAsIDYwMCwgNzAwLCA4MDAsXG4gICAgICAxMjAwLCAxNjAwLCAzMjAwXG4gICAgXS5tYXAoKHopID0+IHogLyAxMDApXG4gIH1cblxuICAvKipcbiAgICogWm9vbXMgaW4gdGhlIGVkaXRvclxuICAgKi9cbiAgaW4gKCkge1xuICAgIGNvbnN0IG5ld1pvb20gPSB0aGlzLl9nZXRDbG9zZXN0Wm9vbUxldmVsKHRoaXMuX3pvb20gKyAwLjAwMSwgKzEpXG4gICAgaWYgKCFuZXdab29tKSByZXR1cm4gdGhpcy5fem9vbUxldmVsc1t0aGlzLl96b29tTGV2ZWxzLmxlbmd0aCAtIDFdXG4gICAgdGhpcy5zZXQobmV3Wm9vbSlcbiAgfVxuXG4gIC8qKlxuICAgKiBab29tcyBvdXQgdGhlIGVkaXRvclxuICAgKi9cbiAgb3V0ICgpIHtcbiAgICBjb25zdCBuZXdab29tID0gdGhpcy5fZ2V0Q2xvc2VzdFpvb21MZXZlbCh0aGlzLl96b29tIC0gMC4wMDEsIC0xKVxuICAgIGlmICghbmV3Wm9vbSkgcmV0dXJuIHRoaXMuX3pvb21MZXZlbHNbMF1cbiAgICB0aGlzLnNldChuZXdab29tKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNsb3Nlc3Qgem9vbSBsZXZlbCB0byB0aGUgZ2l2ZW4gb25lXG4gICAqIEBwYXJhbSAge051bWJlcn0gem9vbUxldmVsXG4gICAqIEBwYXJhbSAge051bWJlcn0gZGlyZWN0aW9uXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRDbG9zZXN0Wm9vbUxldmVsICh6b29tTGV2ZWwsIGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT09IC0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5fem9vbUxldmVsc1xuICAgICAgICAuZmlsdGVyKChsKSA9PiBsIDwgem9vbUxldmVsKVxuICAgICAgICAucG9wKClcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3pvb21MZXZlbHNcbiAgICAgICAgLmZpbHRlcigobCkgPT4gbCA+IHpvb21MZXZlbClbMF1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3dpdGNoZXMgdG8gdGhlIHByZXZpb3VzIHpvb21cbiAgICovXG4gIHJlc3RvcmUgKCkge1xuICAgIGlmICghdGhpcy5fcHJldmlvdXNab29tKSByZXR1cm5cbiAgICB0aGlzLnNldCh0aGlzLl9wcmV2aW91c1pvb20pXG4gICAgdGhpcy5fcHJldmlvdXNab29tID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgY3VycmVudCB6b29tIGxldmVsLCBjYW4gYmUgcmVzdG9yZWQgd2l0aCAucmVzdG9yZSgpXG4gICAqL1xuICBzYXZlICgpIHtcbiAgICB0aGlzLl9wcmV2aW91c1pvb20gPSB0aGlzLl96b29tXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgem9vbSB0byB0aGUgZ2l2ZW4gb25lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB6b29tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICogQHBhcmFtIHtCb29sZWFufSBbY29uc2lkZXJNaW5pbXVtID0gdHJ1ZV1cbiAgICovXG4gIHNldCAoem9vbSwgY2FsbGJhY2ssIGNvbnNpZGVyTWluaW11bSA9IHRydWUpIHtcbiAgICBpZiAoIXRoaXMuX2VkaXRvci5pc1JlYWR5KCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBuZXdab29tID0gem9vbVxuICAgIGNvbnN0IGRlZmF1bHRab29tID0gdGhpcy5nZXREZWZhdWx0KClcbiAgICBpZiAoem9vbSA9PT0gJ2F1dG8nIHx8IG5ld1pvb20gPT09IGRlZmF1bHRab29tKSB7XG4gICAgICBuZXdab29tID0gZGVmYXVsdFpvb21cbiAgICAgIHpvb20gPSAnYXV0bydcblxuICAgICAgdGhpcy5faXNEZWZhdWx0Wm9vbSA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faXNEZWZhdWx0Wm9vbSA9IGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgbWF4Wm9vbSA9IE1hdGgubWF4KDEsIGRlZmF1bHRab29tICogMilcbiAgICBjb25zdCBtaW5ab29tID0gY29uc2lkZXJNaW5pbXVtID8gdGhpcy5nZXRNaW5pbXVtKCkgOiAwXG4gICAgbmV3Wm9vbSA9IE1hdGgubWF4KG1pblpvb20sIE1hdGgubWluKG1heFpvb20sIG5ld1pvb20pKVxuXG4gICAgdGhpcy5fem9vbSA9IG5ld1pvb21cbiAgICB0aGlzLl9zZGsuc2V0Wm9vbSh0aGlzLl96b29tKVxuICAgIHRoaXMuX3Nkay5zZXRUZXh0dXJlUXVhbGl0eShNYXRoLm1pbih0aGlzLl96b29tLCAxKSlcbiAgICB0aGlzLmVtaXQoJ3NldCcsIHRoaXMuX3pvb20sIGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlZmF1bHQgem9vbSBsZXZlbFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXREZWZhdWx0ICgpIHtcbiAgICBjb25zdCBmaW5hbERpbWVuc2lvbnMgPSB0aGlzLl9lZGl0b3IuZ2V0RmluYWxEaW1lbnNpb25zKGZhbHNlKVxuICAgIGNvbnN0IGNhbnZhc0RpbWVuc2lvbnMgPSB0aGlzLl9lZGl0b3IuZ2V0Q2FudmFzRGltZW5zaW9ucygpXG4gICAgY29uc3QgZGVmYXVsdERpbWVuc2lvbnMgPSBTREtVdGlscy5yZXNpemVWZWN0b3JUb0ZpdChmaW5hbERpbWVuc2lvbnMsIGNhbnZhc0RpbWVuc2lvbnMpXG5cbiAgICByZXR1cm4gZGVmYXVsdERpbWVuc2lvbnNcbiAgICAgIC5kaXZpZGUoZmluYWxEaW1lbnNpb25zKVxuICAgICAgLnhcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWxcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0TWluaW11bSAoKSB7XG4gICAgY29uc3QgZmluYWxEaW1lbnNpb25zID0gdGhpcy5fZWRpdG9yLmdldEZpbmFsRGltZW5zaW9ucygpXG4gICAgY29uc3QgbWluaW11bURpbWVuc2lvbnMgPSBTREtVdGlscy5yZXNpemVWZWN0b3JUb0ZpdChcbiAgICAgIGZpbmFsRGltZW5zaW9ucyxcbiAgICAgIG5ldyBWZWN0b3IyKE1JTl9aT09NX0RJTUVOU0lPTlMsIE1JTl9aT09NX0RJTUVOU0lPTlMpXG4gICAgKVxuXG4gICAgcmV0dXJuIG1pbmltdW1EaW1lbnNpb25zXG4gICAgICAuZGl2aWRlKGZpbmFsRGltZW5zaW9ucylcbiAgICAgIC54XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBlZGl0b3IgaXMgYXQgdGhlIGRlZmF1bHQgem9vbSBsZXZlbFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNEZWZhdWx0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNEZWZhdWx0Wm9vbVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgKCkge1xuICAgIHJldHVybiB0aGlzLl96b29tXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9lZGl0b3Ivem9vbS5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgQ29uc3RhbnRzLCBFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFZGl0b3JIaXN0b3J5IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKGVkaXRvciwgc2RrLCBtZWRpYXRvcikge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuX2VkaXRvciA9IGVkaXRvclxuICAgIHRoaXMuX3NkayA9IHNka1xuICAgIHRoaXMuX21lZGlhdG9yID0gbWVkaWF0b3JcblxuICAgIHRoaXMuX2hpc3RvcnkgPSBbXVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGVyZSBhcmUgYW55IGhpc3RvcnkgaXRlbXMgYXZhaWxhYmxlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0F2YWlsYWJsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hpc3RvcnkubGVuZ3RoICE9PSAwXG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gZGF0YSB0byB0aGUgaGlzdG9yeVxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXhpc3RlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3VuZG9dXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGFkZCAob3BlcmF0aW9uLCBvcHRpb25zLCBleGlzdGVudCwgdW5kbyA9IG51bGwpIHtcbiAgICBsZXQgaGlzdG9yeUl0ZW1cbiAgICBpZiAob3BlcmF0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGNvbnN0IGl0ZW1zID0gb3BlcmF0aW9uXG4gICAgICB0aGlzLl9oaXN0b3J5LnB1c2goaXRlbXMpXG4gICAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIHRoaXMuX21lZGlhdG9yLmVtaXQoQ29uc3RhbnRzLkVWRU5UUy5ISVNUT1JZX1VQREFURUQsIGl0ZW0ub3BlcmF0aW9uKVxuICAgICAgfSlcblxuICAgICAgaGlzdG9yeUl0ZW0gPSBpdGVtc1xuICAgIH0gZWxzZSB7XG4gICAgICBoaXN0b3J5SXRlbSA9IHtcbiAgICAgICAgb3BlcmF0aW9uLCBvcHRpb25zLCBleGlzdGVudCwgdW5kb1xuICAgICAgfVxuICAgICAgdGhpcy5faGlzdG9yeS5wdXNoKGhpc3RvcnlJdGVtKVxuICAgICAgdGhpcy5fbWVkaWF0b3IuZW1pdChDb25zdGFudHMuRVZFTlRTLkhJU1RPUllfVVBEQVRFRCwgb3BlcmF0aW9uKVxuICAgIH1cbiAgICByZXR1cm4gaGlzdG9yeUl0ZW1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXZlcnRzIHRoZSBsYXN0IGNoYW5nZVxuICAgKi9cbiAgdW5kbyAoKSB7XG4gICAgY29uc3QgeyBvcGVyYXRpb25zIH0gPSB0aGlzLl9lZGl0b3JcbiAgICBjb25zdCBsYXN0SXRlbSA9IHRoaXMuX2hpc3RvcnkucG9wKClcbiAgICBpZiAobGFzdEl0ZW0pIHtcbiAgICAgIGNvbnN0IGl0ZW1zID0gW10uY29uY2F0KGxhc3RJdGVtKVxuXG4gICAgICBpdGVtc1xuICAgICAgICAuZm9yRWFjaCgoaGlzdG9yeU9iamVjdCkgPT4ge1xuICAgICAgICAgIGxldCB7IG9wZXJhdGlvbiwgZXhpc3RlbnQsIG9wdGlvbnMsIHVuZG8gfSA9IGhpc3RvcnlPYmplY3RcbiAgICAgICAgICB0aGlzLl9tZWRpYXRvci5lbWl0KENvbnN0YW50cy5FVkVOVFMuSElTVE9SWV9CRUZPUkVfVU5ETywgaGlzdG9yeU9iamVjdClcblxuICAgICAgICAgIGlmICghZXhpc3RlbnQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbnMucmVtb3ZlKG9wZXJhdGlvbilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gb3BlcmF0aW9ucy5nZXRPckNyZWF0ZShvcGVyYXRpb24uY29uc3RydWN0b3IuaWRlbnRpZmllcilcbiAgICAgICAgICAgIG9wZXJhdGlvbi5zZXQob3B0aW9ucylcbiAgICAgICAgICAgIHRoaXMuX21lZGlhdG9yLmVtaXQoQ29uc3RhbnRzLkVWRU5UUy5PUEVSQVRJT05fVVBEQVRFRCwgb3BlcmF0aW9uKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2YgdW5kbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdW5kbyhvcGVyYXRpb24sIG9wdGlvbnMpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fbWVkaWF0b3IuZW1pdChDb25zdGFudHMuRVZFTlRTLkhJU1RPUllfVVBEQVRFRCwgb3BlcmF0aW9uKVxuICAgICAgICAgIHRoaXMuX21lZGlhdG9yLmVtaXQoQ29uc3RhbnRzLkVWRU5UUy5ISVNUT1JZX1VORE8sIG9wZXJhdGlvbilcbiAgICAgICAgfSlcblxuICAgICAgdGhpcy5lbWl0KCd1bmRvJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBoaXN0b3J5XG4gICAqL1xuICByZXNldCAoKSB7XG4gICAgdGhpcy5faGlzdG9yeSA9IFtdXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9lZGl0b3IvaGlzdG9yeS5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IFNlcmlhbGl6ZXIgZnJvbSAnLi9zZXJpYWxpemVyJ1xuaW1wb3J0IERlc2VyaWFsaXplciBmcm9tICcuL2Rlc2VyaWFsaXplcidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VyaWFsaXphdGlvbiB7XG4gIGNvbnN0cnVjdG9yIChlZGl0b3IpIHtcbiAgICB0aGlzLl9lZGl0b3IgPSBlZGl0b3JcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBlZGl0b3Igc3RhdGVcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHNlcmlhbGl6ZSAoLi4uYXJncykge1xuICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgU2VyaWFsaXplcih0aGlzLl9lZGl0b3IpXG4gICAgcmV0dXJuIHNlcmlhbGl6ZXIuc2VyaWFsaXplKC4uLmFyZ3MpXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBkYXRhXG4gICAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgZGVzZXJpYWxpemUgKGRhdGEpIHtcbiAgICBjb25zdCBkZXNlcmlhbGl6ZXIgPSBuZXcgRGVzZXJpYWxpemVyKHRoaXMuX2VkaXRvciwgZGF0YSlcbiAgICByZXR1cm4gZGVzZXJpYWxpemVyLmRlc2VyaWFsaXplKClcbiAgfVxufVxuXG5TZXJpYWxpemF0aW9uLnZlcnNpb24gPSAnMS4wLjAnXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9zZXJpYWxpemF0aW9uLzEuMC4wL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8vIFRoaXMgbWV0aG9kIG9mIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBuZWVkcyB0byBiZVxuLy8ga2VwdCBpZGVudGljYWwgdG8gdGhlIHdheSBpdCBpcyBvYnRhaW5lZCBpbiBydW50aW1lLmpzXG52YXIgZyA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG5cbi8vIFVzZSBgZ2V0T3duUHJvcGVydHlOYW1lc2AgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY2FsbGluZ1xuLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgZ2xvYmFsIGBzZWxmYCBvYmplY3QgaW4gYSB3b3JrZXIuIFNlZSAjMTgzLlxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnKS5pbmRleE9mKFwicmVnZW5lcmF0b3JSdW50aW1lXCIpID49IDA7XG5cbi8vIFNhdmUgdGhlIG9sZCByZWdlbmVyYXRvclJ1bnRpbWUgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZXN0b3JlZCBsYXRlci5cbnZhciBvbGRSdW50aW1lID0gaGFkUnVudGltZSAmJiBnLnJlZ2VuZXJhdG9yUnVudGltZTtcblxuLy8gRm9yY2UgcmVldmFsdXRhdGlvbiBvZiBydW50aW1lLmpzLlxuZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcnVudGltZVwiKTtcblxuaWYgKGhhZFJ1bnRpbWUpIHtcbiAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcnVudGltZS5cbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xufSBlbHNlIHtcbiAgLy8gUmVtb3ZlIHRoZSBnbG9iYWwgcHJvcGVydHkgYWRkZWQgYnkgcnVudGltZS5qcy5cbiAgdHJ5IHtcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEluIHNsb3BweSBtb2RlLCB1bmJvdW5kIGB0aGlzYCByZWZlcnMgdG8gdGhlIGdsb2JhbCBvYmplY3QsIGZhbGxiYWNrIHRvXG4gIC8vIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGlmIHdlJ3JlIGluIGdsb2JhbCBzdHJpY3QgbW9kZS4gVGhhdCBpcyBzYWRseSBhIGZvcm1cbiAgLy8gb2YgaW5kaXJlY3QgZXZhbCB3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cbiAgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9KSgpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKVxuKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcbi8vIG1vZHVsZSBpZCA9IDE3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IENvbnN0YW50cyB9IGZyb20gJ2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJydXNoTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yICh1aSwgb3B0aW9ucykge1xuICAgIHRoaXMuX3VpID0gdWlcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMuX2JydXNoZXMgPSBbXVxuICAgIHRoaXMuX2JydXNoZXNCeUlkID0ge31cblxuICAgIHRoaXMuX2FkZEJydXNoZXMoQ29uc3RhbnRzLkRFRkFVTFRTLkJSVVNIRVMpXG5cbiAgICBjb25zdCB7IGJydXNoZXMsIHJlcGxhY2VCcnVzaGVzLCBhdmFpbGFibGVCcnVzaGVzIH0gPSB0aGlzLl9vcHRpb25zXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuYnJ1c2hlcykge1xuICAgICAgdGhpcy5fYWRkQnJ1c2hlcyhicnVzaGVzLCByZXBsYWNlQnJ1c2hlcylcbiAgICB9XG5cbiAgICBpZiAoYXZhaWxhYmxlQnJ1c2hlcykge1xuICAgICAgdGhpcy5fYnJ1c2hlcyA9IHRoaXMuX2JydXNoZXMuZmlsdGVyKGJydXNoID0+IGF2YWlsYWJsZUJydXNoZXMuaW5kZXhPZihicnVzaC5pZGVudGlmaWVyKSAhPT0gLTEpXG4gICAgfVxuICB9XG5cbiAgX2FkZEJydXNoZXMgKGJydXNoZXMsIHJlcGxhY2VCcnVzaGVzKSB7XG4gICAgaWYgKHJlcGxhY2VCcnVzaGVzKSB7XG4gICAgICB0aGlzLl9icnVzaGVzID0gW11cbiAgICAgIHRoaXMuX2JydXNoZXNCeUlkID0ge31cbiAgICB9XG5cbiAgICBicnVzaGVzLmZvckVhY2goYnJ1c2ggPT4ge1xuICAgICAgdGhpcy5fYnJ1c2hlcy5wdXNoKGJydXNoKVxuICAgICAgdGhpcy5fYnJ1c2hlc0J5SWRbYnJ1c2guaWRlbnRpZmllcl0gPSBicnVzaFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYnJ1c2ggd2l0aCB0aGUgZ2l2ZW4gaWRlbnRpZmllclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGlkZW50aWZpZXJcbiAgICovXG4gIGdldEJydXNoQnlJZGVudGlmaWVyIChpZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JydXNoZXNCeUlkW2lkZW50aWZpZXJdXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgYnJ1c2hlc1xuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbi5CcnVzaFNwcml0ZS5CcnVzaFtdfVxuICAgKi9cbiAgZ2V0QnJ1c2hlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JydXNoZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBhdmFpbGFibGUgYnJ1c2hcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb24uQnJ1c2hTcHJpdGUuQnJ1c2h9XG4gICAqL1xuICBnZXRGaXJzdEJydXNoICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYnJ1c2hlc1swXVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9tYW5hZ2Vycy9icnVzaC1tYW5hZ2VyLmpzIiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgQmFzZUZvbnRMb2FkZXIgZnJvbSAnLi9iYXNlLWZvbnQtbG9hZGVyJ1xuXG5jb25zdCBGT05UX1NUWUxFUyA9IHtcbiAgaXRhbGljOiAnaSdcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR29vZ2xlRm9udExvYWRlciBleHRlbmRzIEJhc2VGb250TG9hZGVyIHtcbiAgbG9hZCAoKSB7XG4gICAgaWYgKHRoaXMuX2ZvbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fYWRkU3R5bGVzaGVldFRhZygpXG4gICAgfVxuICAgIHJldHVybiBzdXBlci5sb2FkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmRzIHRoZSA8bGluaz4gdGFnIHRvIHRoZSBoZWFkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYWRkU3R5bGVzaGVldFRhZyAoKSB7XG4gICAgY29uc3QgZmFtaWxpZXMgPSB0aGlzLl9nZXRGYW1pbGllc1N0cmluZygpXG4gICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKVxuICAgIGxpbmsucmVsID0gJ3N0eWxlc2hlZXQnXG4gICAgbGluay5ocmVmID0gYGh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT0ke2ZhbWlsaWVzfWBcblxuICAgIGNvbnN0IGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdXG4gICAgaGVhZC5hcHBlbmRDaGlsZChsaW5rKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbGwgR29vZ2xlIEZvbnRzIGZhbWlsaWVzIHRoYXRcbiAgICogc2hvdWxkIGJlIGxvYWRlZFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0RmFtaWxpZXNTdHJpbmcgKCkge1xuICAgIGNvbnN0IGZhbWlsaWVzID0ge31cbiAgICB0aGlzLl9mb250cy5mb3JFYWNoKChmb250KSA9PiB7XG4gICAgICBjb25zdCBmb250RmFtaWx5ID0gZm9udC5nZXRGb250RmFtaWx5KClcbiAgICAgIGNvbnN0IGZvbnRTdHlsZSA9IGZvbnQuZ2V0Rm9udFN0eWxlKClcbiAgICAgIGNvbnN0IGZvbnRXZWlnaHQgPSBmb250LmdldEZvbnRXZWlnaHQoKVxuICAgICAgZmFtaWxpZXNbZm9udEZhbWlseV0gPSBmYW1pbGllc1tmb250RmFtaWx5XSB8fCBbXVxuICAgICAgaWYgKHR5cGVvZiBmb250V2VpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBmYW1pbGllc1tmb250RmFtaWx5XS5wdXNoKFxuICAgICAgICAgIGAke2ZvbnRXZWlnaHR9JHtGT05UX1NUWUxFU1tmb250U3R5bGVdIHx8ICcnfWBcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmFtaWxpZXNbZm9udEZhbWlseV0ucHVzaCg0MDApIC8vIGRlZmF1bHQgd2VpZ2h0XG4gICAgICB9XG4gICAgfSlcblxuICAgIGNvbnN0IGZhbWlseVN0cmluZ3MgPSBbXVxuICAgIGZvciAobGV0IG5hbWUgaW4gZmFtaWxpZXMpIHtcbiAgICAgIGNvbnN0IHZhcmlhbnRzID0gZmFtaWxpZXNbbmFtZV1cbiAgICAgIGNvbnN0IHZhcmlhbnRzU3RyaW5nID0gKHZhcmlhbnRzLmxlbmd0aCA/IGA6JHt2YXJpYW50cy5qb2luKCcsJyl9YCA6ICcnKVxuICAgICAgY29uc3QgbmFtZVN0cmluZyA9IG5hbWUucmVwbGFjZSgnICcsICcrJykgKyB2YXJpYW50c1N0cmluZ1xuICAgICAgZmFtaWx5U3RyaW5ncy5wdXNoKG5hbWVTdHJpbmcpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbWlseVN0cmluZ3Muam9pbignfCcpXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9mb250LWxvYWRlci9sb2FkZXJzL2dvb2dsZS1mb250LWxvYWRlci5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZvbnRSdWxlciBmcm9tICcuL2ZvbnQtcnVsZXInXG5cbmNvbnN0IG5vdyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vd1xuICA/IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cuYmluZCh3aW5kb3cucGVyZm9ybWFuY2UpXG4gIDogcmVxdWlyZSgncGVyZm9ybWFuY2Utbm93JykpXG5cbmNvbnN0IE9CU0VSVkVfSU5URVJWQUwgPSA1MFxuY29uc3QgT0JTRVJWRV9USU1FT1VUID0gNTAwMFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb250T2JzZXJ2ZXIge1xuICBjb25zdHJ1Y3RvciAoZm9udFZhcmlhdGlvbikge1xuICAgIHRoaXMuX2ZvbnRWYXJpYXRpb24gPSBmb250VmFyaWF0aW9uXG5cbiAgICB0aGlzLl9kZWZhdWx0Rm9udFJ1bGVyID0gbmV3IEZvbnRSdWxlcigpXG4gICAgdGhpcy5fY3VzdG9tRm9udFJ1bGVyID0gbmV3IEZvbnRSdWxlcih0aGlzLl9mb250VmFyaWF0aW9uKVxuICB9XG5cbiAgb2JzZXJ2ZSAoKSB7XG4gICAgY29uc3Qgc3RhcnRlZEF0ID0gbm93KClcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBpbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLl9kZWZhdWx0Rm9udFJ1bGVyLmdldFdpZHRoKCkgIT09IHRoaXMuX2N1c3RvbUZvbnRSdWxlci5nZXRXaWR0aCgpXG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpXG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChub3coKSAtIHN0YXJ0ZWRBdCA+PSBPQlNFUlZFX1RJTUVPVVQpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBmb250ICR7dGhpcy5fZm9udFZhcmlhdGlvbi5nZXRGb250RmFtaWx5KCl9LmApXG4gICAgICAgICAgICBlcnJvci5mb250ID0gdGhpcy5fZm9udFZhcmlhdGlvblxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIE9CU0VSVkVfSU5URVJWQUwpXG4gICAgfSlcbiAgfVxuXG4gIGRpc3Bvc2UgKCkge1xuICAgIHRoaXMuX2RlZmF1bHRGb250UnVsZXIuZGlzcG9zZSgpXG4gICAgdGhpcy5fY3VzdG9tRm9udFJ1bGVyLmRpc3Bvc2UoKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvZm9udC1sb2FkZXIvZm9udC1vYnNlcnZlci5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZvbnRWYXJpYXRpb24gZnJvbSAnc2hhcmVkL2Fzc2V0cy9mb250LXZhcmlhdGlvbidcblxuY29uc3QgRk9OVF9TSVpFID0gMzBcbmNvbnN0IENIQVJBQ1RFUlMgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4enknXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvbnRSdWxlciB7XG4gIGNvbnN0cnVjdG9yIChmb250VmFyaWF0aW9uKSB7XG4gICAgdGhpcy5fZm9udFZhcmlhdGlvbiA9IGZvbnRWYXJpYXRpb24gfHwgbmV3IEZvbnRWYXJpYXRpb24oe1xuICAgICAgZm9udEZhbWlseTogJ1RpbWVzIE5ldyBSb21hbicsXG4gICAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgICAgIGZvbnRTdHlsZTogJ25vcm1hbCdcbiAgICB9KVxuXG4gICAgdGhpcy5fY3JlYXRlUnVsZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIHJ1bGVyIGFuZCBhdHRhY2hlcyBpdCB0byB0aGUgRE9NXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlUnVsZXIgKCkge1xuICAgIHRoaXMuX3J1bGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB0aGlzLl9ydWxlci5pbm5lclRleHQgPSBDSEFSQUNURVJTXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9ydWxlcilcbiAgICB0aGlzLl9zZXRSdWxlclN0eWxlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHlsZXMgdGhlIHJ1bGVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0UnVsZXJTdHlsZSAoKSB7XG4gICAgdGhpcy5fcnVsZXIuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHRvcDogLTk5OTlweDtcbiAgICAgIGxlZnQ6IC05OTk5cHg7XG4gICAgICBvcGFjaXR5OiAwO1xuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgZm9udDogJHt0aGlzLl9mb250VmFyaWF0aW9uLmdldEZvbnRTdHlsZSgpfSAke3RoaXMuX2ZvbnRWYXJpYXRpb24uZ2V0Rm9udFdlaWdodCgpfSAke0ZPTlRfU0laRX1weCAke3RoaXMuX2ZvbnRWYXJpYXRpb24uZ2V0Rm9udEZhbWlseSgpfTtcbiAgICBgXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZm9udCB2YXJpYXRpb24gdG8gdGhlIGdpdmVuIG9uZVxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuRm9udFZhcmlhdGlvbn0gZm9udFZhcmlhdGlvblxuICAgKi9cbiAgc2V0Rm9udFZhcmlhdGlvbiAoZm9udFZhcmlhdGlvbikge1xuICAgIHRoaXMuX2ZvbnRWYXJpYXRpb24gPSBmb250VmFyaWF0aW9uXG4gICAgdGhpcy5fc2V0UnVsZXJTdHlsZSgpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhpcyBydWxlclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRXaWR0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3J1bGVyLm9mZnNldFdpZHRoXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGlzIHJ1bGVyIGZyb20gdGhlIERPTVxuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG4gICAgaWYgKHRoaXMuX3J1bGVyKSB7XG4gICAgICB0aGlzLl9ydWxlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX3J1bGVyKVxuICAgICAgdGhpcy5fcnVsZXIgPSBudWxsXG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvZm9udC1sb2FkZXIvZm9udC1ydWxlci5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEJhc2VGb250TG9hZGVyIGZyb20gJy4vYmFzZS1mb250LWxvYWRlcidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsZUZvbnRMb2FkZXIgZXh0ZW5kcyBCYXNlRm9udExvYWRlciB7XG4gIGxvYWQgKCkge1xuICAgIGNvbnN0IGZvbnRGYWNlc0NTUyA9IFtdXG5cbiAgICB0aGlzLl9mb250cy5mb3JFYWNoKHZhcmlhdGlvbiA9PiB7XG4gICAgICBjb25zdCBmb250UGF0aCA9IHRoaXMuX3VpLmdldEFzc2V0UGF0aCh2YXJpYXRpb24uZ2V0RmlsZVBhdGgoKSwgZmFsc2UsIHRydWUpXG4gICAgICBmb250RmFjZXNDU1MucHVzaChgQGZvbnQtZmFjZSB7XG4gICAgICAgIGZvbnQtZmFtaWx5OiBcIiR7dmFyaWF0aW9uLmdldEZvbnRGYW1pbHkoKX1cIjtcbiAgICAgICAgc3JjOiB1cmwoJyR7Zm9udFBhdGh9JykgZm9ybWF0KCd3b2ZmJyk7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiAke3ZhcmlhdGlvbi5nZXRGb250V2VpZ2h0KCl9O1xuICAgICAgICBmb250LXN0eWxlOiAke3ZhcmlhdGlvbi5nZXRGb250U3R5bGUoKX07XG4gICAgICB9YClcbiAgICB9KVxuXG4gICAgY29uc3QgY3NzID0gZm9udEZhY2VzQ1NTLmpvaW4oJ1xcbicpXG5cbiAgICBjb25zdCBzdHlsZVRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgICBzdHlsZVRhZy5pbm5lckhUTUwgPSBjc3NcblxuICAgIGNvbnN0IGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdXG4gICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZVRhZylcblxuICAgIHJldHVybiBzdXBlci5sb2FkKClcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL2ZvbnQtbG9hZGVyL2xvYWRlcnMvZmlsZS1mb250LWxvYWRlci5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IFNlcmlhbGl6ZXIgZnJvbSAnLi9zZXJpYWxpemVyJ1xuaW1wb3J0IERlc2VyaWFsaXplciBmcm9tICcuL2Rlc2VyaWFsaXplcidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VyaWFsaXphdGlvbiB7XG4gIGNvbnN0cnVjdG9yIChlZGl0b3IpIHtcbiAgICB0aGlzLl9lZGl0b3IgPSBlZGl0b3JcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBlZGl0b3Igc3RhdGVcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHNlcmlhbGl6ZSAoLi4uYXJncykge1xuICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgU2VyaWFsaXplcih0aGlzLl9lZGl0b3IpXG4gICAgcmV0dXJuIHNlcmlhbGl6ZXIuc2VyaWFsaXplKC4uLmFyZ3MpXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBkYXRhXG4gICAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgZGVzZXJpYWxpemUgKGRhdGEpIHtcbiAgICBjb25zdCBkZXNlcmlhbGl6ZXIgPSBuZXcgRGVzZXJpYWxpemVyKHRoaXMuX2VkaXRvciwgZGF0YSlcbiAgICByZXR1cm4gZGVzZXJpYWxpemVyLmRlc2VyaWFsaXplKClcbiAgfVxufVxuXG5TZXJpYWxpemF0aW9uLnZlcnNpb24gPSAnMS4wLjEnXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9zZXJpYWxpemF0aW9uLzEuMC4xL2luZGV4LmpzIiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgU2VyaWFsaXplciBmcm9tICcuL3NlcmlhbGl6ZXInXG5pbXBvcnQgRGVzZXJpYWxpemVyIGZyb20gJy4vZGVzZXJpYWxpemVyJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXJpYWxpemF0aW9uIHtcbiAgY29uc3RydWN0b3IgKGVkaXRvcikge1xuICAgIHRoaXMuX2VkaXRvciA9IGVkaXRvclxuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIGVkaXRvciBzdGF0ZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgc2VyaWFsaXplICguLi5hcmdzKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplciA9IG5ldyBTZXJpYWxpemVyKHRoaXMuX2VkaXRvcilcbiAgICByZXR1cm4gc2VyaWFsaXplci5zZXJpYWxpemUoLi4uYXJncylcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZXMgdGhlIGdpdmVuIGRhdGFcbiAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBkZXNlcmlhbGl6ZSAoZGF0YSkge1xuICAgIGNvbnN0IGRlc2VyaWFsaXplciA9IG5ldyBEZXNlcmlhbGl6ZXIodGhpcy5fZWRpdG9yLCBkYXRhKVxuICAgIHJldHVybiBkZXNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoKVxuICB9XG59XG5cblNlcmlhbGl6YXRpb24udmVyc2lvbiA9ICcyLjAuMCdcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvanMvc2hhcmVkL3NlcmlhbGl6YXRpb24vMi4wLjAvaW5kZXguanMiLCIvKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFNoYXJlZENvbnN0YW50cyB9IGZyb20gJ2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE92ZXJsYXlNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IgKHVpLCBvcHRpb25zKSB7XG4gICAgdGhpcy5fdWkgPSB1aVxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5fb3ZlcmxheXMgPSBTaGFyZWRDb25zdGFudHMuREVGQVVMVFMuT1ZFUkxBWVMuc2xpY2UoMClcbiAgICB0aGlzLl9vdmVybGF5c0J5SWRlbnRpZmllciA9IHt9XG5cbiAgICBpZiAob3B0aW9ucy5vdmVybGF5cykge1xuICAgICAgaWYgKG9wdGlvbnMucmVwbGFjZU92ZXJsYXlzKSB7XG4gICAgICAgIHRoaXMuX292ZXJsYXlzID0gb3B0aW9ucy5vdmVybGF5c1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fb3ZlcmxheXMgPSB0aGlzLl9vdmVybGF5cy5jb25jYXQob3B0aW9ucy5vdmVybGF5cylcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgYXZhaWxhYmxlXG4gICAgaWYgKG9wdGlvbnMuYXZhaWxhYmxlT3ZlcmxheXMpIHtcbiAgICAgIHRoaXMuX292ZXJsYXlzID0gdGhpcy5fb3ZlcmxheXMuZmlsdGVyKG8gPT5cbiAgICAgICAgb3B0aW9ucy5hdmFpbGFibGVPdmVybGF5cy5pbmRleE9mKG8uaWRlbnRpZmllcikgIT09IC0xXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy5fb3ZlcmxheXMuZm9yRWFjaChvdmVybGF5ID0+IHtcbiAgICAgIHRoaXMuX292ZXJsYXlzQnlJZGVudGlmaWVyW292ZXJsYXkuaWRlbnRpZmllcl0gPSBvdmVybGF5XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvdmVybGF5c1xuICAgKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAgICovXG4gIGdldE92ZXJsYXlzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3ZlcmxheXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvdmVybGF5IHdpdGggdGhlIGdpdmVuIGlkZW50aWZpZXJcbiAgICogQHBhcmFtICB7U3RyaW5nfSBpZGVudGlmaWVyXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldE92ZXJsYXlCeUlkZW50aWZpZXIgKGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fb3ZlcmxheXNCeUlkZW50aWZpZXJbaWRlbnRpZmllcl1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zaGFyZWQvbWFuYWdlcnMvb3ZlcmxheS1tYW5hZ2VyLmpzIiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgU2VyaWFsaXplciBmcm9tICcuL3NlcmlhbGl6ZXInXG5pbXBvcnQgRGVzZXJpYWxpemVyIGZyb20gJy4vZGVzZXJpYWxpemVyJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXJpYWxpemF0aW9uIHtcbiAgY29uc3RydWN0b3IgKGVkaXRvcikge1xuICAgIHRoaXMuX2VkaXRvciA9IGVkaXRvclxuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIGVkaXRvciBzdGF0ZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgc2VyaWFsaXplICguLi5hcmdzKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplciA9IG5ldyBTZXJpYWxpemVyKHRoaXMuX2VkaXRvcilcbiAgICByZXR1cm4gc2VyaWFsaXplci5zZXJpYWxpemUoLi4uYXJncylcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZXMgdGhlIGdpdmVuIGRhdGFcbiAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBkZXNlcmlhbGl6ZSAoZGF0YSkge1xuICAgIGNvbnN0IGRlc2VyaWFsaXplciA9IG5ldyBEZXNlcmlhbGl6ZXIodGhpcy5fZWRpdG9yLCBkYXRhKVxuICAgIHJldHVybiBkZXNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoKVxuICB9XG59XG5cblNlcmlhbGl6YXRpb24udmVyc2lvbiA9ICcyLjAuMSdcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvanMvc2hhcmVkL3NlcmlhbGl6YXRpb24vMi4wLjEvaW5kZXguanMiLCIvKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBQcmV2aW91c1NlcmlhbGl6ZXIgZnJvbSAnLi4vMi4wLjAvc2VyaWFsaXplcidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgdjIwMVNlcmlhbGl6ZXIgZXh0ZW5kcyBQcmV2aW91c1NlcmlhbGl6ZXIgeyB9XG5cbnYyMDFTZXJpYWxpemVyLnZlcnNpb24gPSAnMi4wLjAnXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9zZXJpYWxpemF0aW9uLzIuMC4xL3NlcmlhbGl6ZXIuanMiLCIvKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBQcmV2aW91c0Rlc2VyaWFsaXplciBmcm9tICcuLi8yLjAuMC9kZXNlcmlhbGl6ZXInXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHYyMDFEZXNlcmlhbGl6ZXIgZXh0ZW5kcyBQcmV2aW91c0Rlc2VyaWFsaXplciB7IH1cblxudjIwMURlc2VyaWFsaXplci52ZXJzaW9uID0gJzIuMC4xJ1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zaGFyZWQvc2VyaWFsaXphdGlvbi8yLjAuMS9kZXNlcmlhbGl6ZXIuanMiLCIvKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBTZXJpYWxpemVyIGZyb20gJy4vc2VyaWFsaXplcidcbmltcG9ydCBEZXNlcmlhbGl6ZXIgZnJvbSAnLi9kZXNlcmlhbGl6ZXInXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlcmlhbGl6YXRpb24ge1xuICBjb25zdHJ1Y3RvciAoZWRpdG9yKSB7XG4gICAgdGhpcy5fZWRpdG9yID0gZWRpdG9yXG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZWRpdG9yIHN0YXRlXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBzZXJpYWxpemUgKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBzZXJpYWxpemVyID0gbmV3IFNlcmlhbGl6ZXIodGhpcy5fZWRpdG9yKVxuICAgIHJldHVybiBzZXJpYWxpemVyLnNlcmlhbGl6ZSguLi5hcmdzKVxuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplcyB0aGUgZ2l2ZW4gZGF0YVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGFcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIGRlc2VyaWFsaXplIChkYXRhKSB7XG4gICAgY29uc3QgZGVzZXJpYWxpemVyID0gbmV3IERlc2VyaWFsaXplcih0aGlzLl9lZGl0b3IsIGRhdGEpXG4gICAgcmV0dXJuIGRlc2VyaWFsaXplci5kZXNlcmlhbGl6ZSgpXG4gIH1cbn1cblxuU2VyaWFsaXphdGlvbi52ZXJzaW9uID0gJzMuMC4wJ1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zaGFyZWQvc2VyaWFsaXphdGlvbi8zLjAuMC9pbmRleC5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IFNlcmlhbGl6ZXIgZnJvbSAnLi9zZXJpYWxpemVyJ1xuaW1wb3J0IERlc2VyaWFsaXplciBmcm9tICcuL2Rlc2VyaWFsaXplcidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VyaWFsaXphdGlvbiB7XG4gIGNvbnN0cnVjdG9yIChlZGl0b3IpIHtcbiAgICB0aGlzLl9lZGl0b3IgPSBlZGl0b3JcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBlZGl0b3Igc3RhdGVcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHNlcmlhbGl6ZSAoLi4uYXJncykge1xuICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgU2VyaWFsaXplcih0aGlzLl9lZGl0b3IpXG4gICAgcmV0dXJuIHNlcmlhbGl6ZXIuc2VyaWFsaXplKC4uLmFyZ3MpXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBkYXRhXG4gICAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgZGVzZXJpYWxpemUgKGRhdGEpIHtcbiAgICBjb25zdCBkZXNlcmlhbGl6ZXIgPSBuZXcgRGVzZXJpYWxpemVyKHRoaXMuX2VkaXRvciwgZGF0YSlcbiAgICByZXR1cm4gZGVzZXJpYWxpemVyLmRlc2VyaWFsaXplKClcbiAgfVxufVxuXG5TZXJpYWxpemF0aW9uLnZlcnNpb24gPSAnMy4xLjAnXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL21udC9jL0ZpbGVzL1Byb2plY3RzL1dvcmsvSW1nTHkvcGVzZGstaHRtbDUvc3JjL2pzL3NoYXJlZC9zZXJpYWxpemF0aW9uLzMuMS4wL2luZGV4LmpzIiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBTREtVdGlscywgQ29sb3IgfSBmcm9tICdnbG9iYWxzJ1xuaW1wb3J0IFByZXZpb3VzU2VyaWFsaXplciBmcm9tICcuLi8zLjAuMC9zZXJpYWxpemVyJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB2MzEwU2VyaWFsaXplciBleHRlbmRzIFByZXZpb3VzU2VyaWFsaXplciB7XG4gIF9zZXJpYWxpemVUZXh0RGVzaWduIChvcGVyYXRpb24sIHNwcml0ZSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBzcHJpdGUuc2VyaWFsaXplT3B0aW9ucyhbXG4gICAgICAncG9zaXRpb24nLCAncm90YXRpb24nLCAnZmxpcEhvcml6b250YWxseScsICdmbGlwVmVydGljYWxseScsXG4gICAgICAndGV4dCcsICdjb2xvcicsICd3aWR0aCcsICdzZWVkJywgJ2ludmVydGVkJ1xuICAgIF0sIHRydWUpXG5cbiAgICBvcHRpb25zLmNvbG9yID0ge1xuICAgICAgcmdiYTogb3B0aW9ucy5jb2xvclxuICAgIH1cblxuICAgIGNvbnN0IGxheW91dCA9IHNwcml0ZS5nZXRMYXlvdXQoKVxuXG4gICAgaWYgKGxheW91dCkge1xuICAgICAgb3B0aW9ucy5pZGVudGlmaWVyID0gbGF5b3V0LmNvbnN0cnVjdG9yLmlkZW50aWZpZXJcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3RleHRkZXNpZ24nLFxuICAgICAgb3B0aW9uc1xuICAgIH1cbiAgfVxufVxuXG52MzEwU2VyaWFsaXplci52ZXJzaW9uID0gJzMuMS4wJ1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9tbnQvYy9GaWxlcy9Qcm9qZWN0cy9Xb3JrL0ltZ0x5L3Blc2RrLWh0bWw1L3NyYy9qcy9zaGFyZWQvc2VyaWFsaXphdGlvbi8zLjEuMC9zZXJpYWxpemVyLmpzIiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBDb2xvciwgQ29uc3RhbnRzIH0gZnJvbSAnZ2xvYmFscydcbmltcG9ydCBQcmV2aW91c0Rlc2VyaWFsaXplciBmcm9tICcuLi8zLjAuMC9kZXNlcmlhbGl6ZXInXG5pbXBvcnQgVGV4dERlc2lnbk1hbmFnZXIgZnJvbSAnc2hhcmVkL21hbmFnZXJzL3RleHQtZGVzaWduLW1hbmFnZXInXG5pbXBvcnQgRm9udE1hbmFnZXIgZnJvbSAnc2hhcmVkL21hbmFnZXJzL2ZvbnQtbWFuYWdlcidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgdjMxMERlc2VyaWFsaXplciBleHRlbmRzIFByZXZpb3VzRGVzZXJpYWxpemVyIHtcbiAgX2Rlc2VyaWFsaXplVGV4dERlc2lnbiAob3BlcmF0aW9uLCBzcHJpdGUpIHtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHNwcml0ZVxuICAgIGNvbnN0IHsgcG9zaXRpb24sIHJvdGF0aW9uLCBmbGlwSG9yaXpvbnRhbGx5LCBmbGlwVmVydGljYWxseSxcbiAgICAgIHRleHQsIGNvbG9yLCB3aWR0aCwgc2VlZCwgaW52ZXJ0ZWQsIGlkZW50aWZpZXIgfSA9IG9wdGlvbnNcblxuICAgIGNvbnN0IHRleHREZXNpZ25NYW5hZ2VyID0gbmV3IFRleHREZXNpZ25NYW5hZ2VyKHRoaXMuX3VpLCB0aGlzLl9nZXRPcHRpb25zKCd0ZXh0ZGVzaWduJykpXG4gICAgY29uc3QgZm9udE1hbmFnZXIgPSBuZXcgRm9udE1hbmFnZXIodGhpcy5fdWksIHsgZm9udHM6IENvbnN0YW50cy5ERUZBVUxUUy5URVhUX0RFU0lHTl9GT05UUywgcmVwbGFjZUZvbnRzOiB0cnVlIH0pXG4gICAgY29uc3QgQXNzZXRNYW5hZ2VyID0gb3BlcmF0aW9uLmNvbnN0cnVjdG9yLlRleHREZXNpZ25TcHJpdGUuQXNzZXRNYW5hZ2VyXG4gICAgY29uc3QgZm9udExvYWRlciA9IHRoaXMuX3VpLmdldEZvbnRMb2FkZXIoKVxuXG4gICAgY29uc3QgTGF5b3V0ID0gdGV4dERlc2lnbk1hbmFnZXIuZ2V0TGF5b3V0QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpXG5cbiAgICBjb25zdCBsYXlvdXQgPSBuZXcgTGF5b3V0KClcblxuICAgIGZvbnRMb2FkZXIuc2V0Rm9udHMoZm9udE1hbmFnZXIuZ2V0Rm9udHMoKSlcblxuICAgIEFzc2V0TWFuYWdlci5zZXRGb250cyh7XG4gICAgICAuLi5Bc3NldE1hbmFnZXIuZ2V0Rm9udHMoKSxcbiAgICAgIC4uLmZvbnRNYW5hZ2VyLmdldFZhcmlhdGlvbnNCeUlkZW50aWZpZXIoKVxuICAgIH0pXG5cbiAgICByZXR1cm4gZm9udExvYWRlclxuICAgICAgLmxvYWQoKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBjb25zdCBpbWFnZXMgPSBsYXlvdXQuZ2V0SW1hZ2VQYXRocygpLm1hcChwYXRoID0+ICh7IHBhdGgsIGZ1bGxQYXRoOiB0aGlzLl91aS5nZXRBc3NldFBhdGgocGF0aCksIGltYWdlOiBudWxsIH0pKVxuICAgICAgICByZXR1cm4gQXNzZXRNYW5hZ2VyXG4gICAgICAgICAgLmxvYWRJbWFnZXMoaW1hZ2VzKVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGxheW91dC5vbkltYWdlc0xvYWRlZCgpXG5cbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24uY3JlYXRlVGV4dERlc2lnbih7XG4gICAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICAgICAgZmxpcEhvcml6b250YWxseSxcbiAgICAgICAgICAgICAgZmxpcFZlcnRpY2FsbHksXG4gICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgIGNvbG9yOiBDb2xvci5mcm9tQXJyYXkoY29sb3IucmdiYSksXG4gICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICBzZWVkLFxuICAgICAgICAgICAgICBpbnZlcnRlZCxcbiAgICAgICAgICAgICAgbGF5b3V0XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICB9KVxuICB9XG59XG5cbnYzMTBEZXNlcmlhbGl6ZXIudmVyc2lvbiA9ICczLjEuMCdcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvbW50L2MvRmlsZXMvUHJvamVjdHMvV29yay9JbWdMeS9wZXNkay1odG1sNS9zcmMvanMvc2hhcmVkL3NlcmlhbGl6YXRpb24vMy4xLjAvZGVzZXJpYWxpemVyLmpzIiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IExvYWRpbmdNb2RhbENvbXBvbmVudCBmcm9tICcuL21vZGFscy9sb2FkaW5nLW1vZGFsLWNvbXBvbmVudCdcbmltcG9ydCBXYXJuaW5nTW9kYWxDb21wb25lbnQgZnJvbSAnLi9tb2RhbHMvd2FybmluZy1tb2RhbC1jb21wb25lbnQnXG5pbXBvcnQgRXJyb3JNb2RhbENvbXBvbmVudCBmcm9tICcuL21vZGFscy9lcnJvci1tb2RhbC1jb21wb25lbnQnXG5pbXBvcnQgUHJvZ3Jlc3NNb2RhbENvbXBvbmVudCBmcm9tICcuL21vZGFscy9wcm9ncmVzcy1tb2RhbC1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGFsQ29udGFpbmVyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX21vZGFsTWFuYWdlciA9IHRoaXMucHJvcHMubW9kYWxNYW5hZ2VyXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25Nb2RhbE1hbmFnZXJVcGRhdGUnXG4gICAgKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudERpZE1vdW50KClcblxuICAgIHRoaXMuX21vZGFsTWFuYWdlci5vbigndXBkYXRlJywgdGhpcy5fb25Nb2RhbE1hbmFnZXJVcGRhdGUpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyBhYm91dCB0byBiZSB1bm1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50ICgpIHtcbiAgICBzdXBlci5jb21wb25lbnRXaWxsVW5tb3VudCgpXG5cbiAgICB0aGlzLl9tb2RhbE1hbmFnZXIub2ZmKCd1cGRhdGUnLCB0aGlzLl9vbk1vZGFsTWFuYWdlclVwZGF0ZSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBtb2RhbCBtYW5hZ2VyIHVwZGF0ZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk1vZGFsTWFuYWdlclVwZGF0ZSAoKSB7XG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhIG1vZGFsIGlzIGNsb3NlZC4gUmVtb3ZlcyBpdCBmcm9tIHRoZSBtYW5hZ2VyLlxuICAgKiBAcGFyYW0gIHtNb2RhbH0gbW9kYWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk1vZGFsQ2xvc2VkIChtb2RhbCkge1xuICAgIHRoaXMuX21vZGFsTWFuYWdlci5yZW1vdmVNb2RhbChtb2RhbClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBtb2RhbHNcbiAgICogQHJldHVybiB7QXJyYXkuPFJlYWN0LkNvbXBvbmVudD59XG4gICAqL1xuICBfcmVuZGVyTW9kYWxzICgpIHtcbiAgICBjb25zdCBtb2RhbHMgPSB0aGlzLl9tb2RhbE1hbmFnZXIuZ2V0TW9kYWxzKClcbiAgICByZXR1cm4gbW9kYWxzLm1hcCgobW9kYWwpID0+IHtcbiAgICAgIGxldCBNb2RhbENvbXBvbmVudFxuXG4gICAgICBzd2l0Y2ggKG1vZGFsLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnbG9hZGluZyc6XG4gICAgICAgICAgTW9kYWxDb21wb25lbnQgPSBMb2FkaW5nTW9kYWxDb21wb25lbnRcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgICAgICBNb2RhbENvbXBvbmVudCA9IFdhcm5pbmdNb2RhbENvbXBvbmVudFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICBNb2RhbENvbXBvbmVudCA9IEVycm9yTW9kYWxDb21wb25lbnRcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdwcm9ncmVzcyc6XG4gICAgICAgICAgTW9kYWxDb21wb25lbnQgPSBQcm9ncmVzc01vZGFsQ29tcG9uZW50XG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICg8TW9kYWxDb21wb25lbnRcbiAgICAgICAgbW9kYWw9e21vZGFsfVxuICAgICAgICBvbkNsb3NlPXt0aGlzLl9vbk1vZGFsQ2xvc2VkLmJpbmQodGhpcywgbW9kYWwpfSAvPilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIHJldHVybiAoPGRpdj57dGhpcy5fcmVuZGVyTW9kYWxzKCl9PC9kaXY+KVxuICB9XG59XG5cbk1vZGFsQ29udGFpbmVyQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL21vZGFsLWNvbnRhaW5lci1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUHJvcFR5cGVzLCBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvYWRpbmdNb2RhbENvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgY29uc3QgbW9kYWwgPSB0aGlzLnByb3BzLm1vZGFsXG4gICAgcmV0dXJuIChcbiAgICAgIDxiZW0gc3BlY2lmaWVyPSckYjptb2RhbHMnPlxuICAgICAgICA8ZGl2IGJlbT0nZTpvdmVybGF5Jz5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTptb2RhbCBtOmxvYWRpbmcnPlxuICAgICAgICAgICAgPGRpdiBiZW09J2U6dGV4dCc+e21vZGFsLnRleHR9PC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9iZW0+XG4gICAgKVxuICB9XG59XG5cbkxvYWRpbmdNb2RhbENvbXBvbmVudC5wcm9wVHlwZXMgPSB7XG4gIG1vZGFsOiBQcm9wVHlwZXMub2JqZWN0XG59XG5cbkxvYWRpbmdNb2RhbENvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9tb2RhbHMvbG9hZGluZy1tb2RhbC1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUHJvcFR5cGVzLCBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdhcm5pbmdNb2RhbENvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgY29uc3QgbW9kYWwgPSB0aGlzLnByb3BzLm1vZGFsXG4gICAgcmV0dXJuIChcbiAgICAgIDxiZW0gc3BlY2lmaWVyPSckYjptb2RhbHMnPlxuICAgICAgICA8ZGl2IGJlbT0nZTptb2RhbCBtOndhcm5pbmcnPlxuICAgICAgICAgIDxkaXYgYmVtPSdlOnRpdGxlJz57bW9kYWwudGl0bGV9PC9kaXY+XG4gICAgICAgICAgPGRpdiBiZW09J2U6dGV4dCc+e21vZGFsLnRleHR9PC9kaXY+XG4gICAgICAgICAgPGRpdiBiZW09J2U6YnV0dG9uIGI6YnV0dG9uIG06aW5saW5lJyBvbkNsaWNrPXt0aGlzLnByb3BzLm9uQ2xvc2V9Pk9LPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9iZW0+XG4gICAgKVxuICB9XG59XG5cbldhcm5pbmdNb2RhbENvbXBvbmVudC5wcm9wVHlwZXMgPSB7XG4gIG1vZGFsOiBQcm9wVHlwZXMub2JqZWN0XG59XG5cbldhcm5pbmdNb2RhbENvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9tb2RhbHMvd2FybmluZy1tb2RhbC1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUHJvcFR5cGVzLCBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVycm9yTW9kYWxDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuICAgIHRoaXMuX2JpbmRBbGwoJ19vbkNsb3NlJylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgY2xvc2UgYnV0dG9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25DbG9zZSAoKSB7XG4gICAgdGhpcy5wcm9wcy5tb2RhbC5jbG9zZSgpXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgY29uc3QgbW9kYWwgPSB0aGlzLnByb3BzLm1vZGFsXG5cbiAgICBjb25zdCBtb2RhbEVsZW1lbnQgPSAoPGRpdiBiZW09J2U6bW9kYWwgbTplcnJvcic+XG4gICAgICA8ZGl2IGJlbT0nZTp0aXRsZSc+e21vZGFsLnRpdGxlfTwvZGl2PlxuICAgICAgPGRpdiBiZW09J2U6dGV4dCc+e21vZGFsLnRleHR9PC9kaXY+XG4gICAgICA8ZGl2IGJlbT0nZTpidXR0b24gYjpidXR0b24gbTppbmxpbmUnIG9uQ2xpY2s9e3RoaXMuX29uQ2xvc2V9Pk9LPC9kaXY+XG4gICAgPC9kaXY+KVxuXG4gICAgY29uc3QgY29udGVudCA9IG1vZGFsLm92ZXJsYXlcbiAgICAgID8gKDxkaXYgYmVtPSdlOm92ZXJsYXknPnttb2RhbEVsZW1lbnR9PC9kaXY+KVxuICAgICAgOiBtb2RhbEVsZW1lbnRcblxuICAgIHJldHVybiAoXG4gICAgICA8YmVtIHNwZWNpZmllcj0nJGI6bW9kYWxzJz5cbiAgICAgICAge2NvbnRlbnR9XG4gICAgICA8L2JlbT5cbiAgICApXG4gIH1cbn1cblxuRXJyb3JNb2RhbENvbXBvbmVudC5wcm9wVHlwZXMgPSB7XG4gIG1vZGFsOiBQcm9wVHlwZXMub2JqZWN0XG59XG5cbkVycm9yTW9kYWxDb21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvbW9kYWxzL2Vycm9yLW1vZGFsLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBQcm9wVHlwZXMsIFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vZ2xvYmFscydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvZ3Jlc3NNb2RhbENvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgY29uc3QgbW9kYWwgPSB0aGlzLnByb3BzLm1vZGFsXG4gICAgY29uc3QgeyBwcm9ncmVzcyB9ID0gbW9kYWwuZGF0YVxuICAgIGNvbnN0IHByb2dyZXNzU3R5bGUgPSB7XG4gICAgICB3aWR0aDogKChwcm9ncmVzcyB8fCAwKSAqIDEwMCkudG9GaXhlZCgyKSArICclJ1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgPGJlbSBzcGVjaWZpZXI9JyRiOm1vZGFscyc+XG4gICAgICAgIDxkaXYgYmVtPSdlOm92ZXJsYXknPlxuICAgICAgICAgIDxkaXYgYmVtPSdlOm1vZGFsIG06bG9hZGluZyc+XG4gICAgICAgICAgICA8ZGl2IGJlbT0nZTp0ZXh0Jz57bW9kYWwudGV4dH08L2Rpdj5cbiAgICAgICAgICAgIDxiZW0gc3BlY2lmaWVyPSdiOmxvYWRpbmdNb2RhbCc+XG4gICAgICAgICAgICAgIDxkaXYgYmVtPSckZTpwcm9ncmVzc0Jhcic+XG4gICAgICAgICAgICAgICAgPGRpdiBiZW09J2U6cHJvZ3Jlc3MnIHN0eWxlPXtwcm9ncmVzc1N0eWxlfSAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvYmVtPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvYmVtPlxuICAgIClcbiAgfVxufVxuXG5Qcm9ncmVzc01vZGFsQ29tcG9uZW50LnByb3BUeXBlcyA9IHtcbiAgbW9kYWw6IFByb3BUeXBlcy5vYmplY3Rcbn1cblxuUHJvZ3Jlc3NNb2RhbENvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9tb2RhbHMvcHJvZ3Jlc3MtbW9kYWwtY29tcG9uZW50LmpzeCIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgU0RLVXRpbHMsIExvZywgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vZ2xvYmFscydcbmltcG9ydCBFZGl0b3IgZnJvbSAnLi9lZGl0b3InXG5cbmNvbnN0IExPQURfVElNRU9VVCA9IDUwMDBcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJlbG9hZGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKHVpLCBvcHRpb25zLCBtZWRpYXRvcikge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuX3VpID0gdWlcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMuX21lZGlhdG9yID0gbWVkaWF0b3JcblxuICAgIHRoaXMuX2Fzc2V0cyA9IHt9XG5cbiAgICAvLyBBIHNoYWxsb3cgRWRpdG9yIGluc3RhbmNlIHRoYXQgaXMgb25seSB0aGVyZSB0byBjaGVjayBmb3IgZmVhdHVyZXMgZXRjLlxuICAgIHRoaXMuX2VkaXRvciA9IG5ldyBFZGl0b3IodWksIG9wdGlvbnMsIG1lZGlhdG9yLCB0cnVlKVxuXG4gICAgLy8gR2VuZXJpYyBhc3NldHMgdGhhdCBhcmUgcHJldHR5IG11Y2ggYWx3YXlzIHJlcXVpcmVkXG4gICAgdGhpcy5fYXNzZXRzID0gW1xuICAgICAgJ2NvbnRyb2xzL2JhY2sucG5nJyxcbiAgICAgICdjb250cm9scy9taW51cy5wbmcnLFxuICAgICAgJ2NvbnRyb2xzL3BsdXMucG5nJyxcbiAgICAgICdjb250cm9scy90aWNrLnBuZycsXG4gICAgICAnY29udHJvbHMvd2ViY2FtL3NodXR0ZXIucG5nJyxcbiAgICAgICdjb250cm9scy9rbm9icy9yZW1vdmUucG5nJyxcbiAgICAgICdjb250cm9scy9rbm9icy9yZXNpemUtZGlhZ29uYWwtZG93bi5wbmcnLFxuICAgICAgJ2NvbnRyb2xzL2tub2JzL3Jlc2l6ZS1kaWFnb25hbC11cC5wbmcnLFxuICAgICAgJ2NvbnRyb2xzL2tub2JzL3JvdGF0ZS5wbmcnLFxuICAgICAgJ2VkaXRvci9leHBvcnQucG5nJyxcbiAgICAgICdlZGl0b3IvbmV3LnBuZycsXG4gICAgICAnZWRpdG9yL3VuZG8ucG5nJyxcbiAgICAgIFsnc3BsYXNoL3Bob3RvLXJvbGwucG5nJywgZmFsc2UsIHRydWVdLFxuICAgICAgWydzcGxhc2gvd2ViY2FtLnBuZycsIGZhbHNlLCB0cnVlXSxcbiAgICAgICd0b3AtYmFyL2JhY2sucG5nJyxcbiAgICAgICdjbG9zZS5wbmcnXG4gICAgXVxuICAgIHRoaXMuX2FwcGVuZENvbnRyb2xzQXNzZXRzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBjb250cm9sLXNwZWNpZmljIGFzc2V0cyBpZiBuZWNlc3NhcnlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBlbmRDb250cm9sc0Fzc2V0cyAoKSB7XG4gICAgY29uc3QgY29udHJvbHMgPSB0aGlzLl9lZGl0b3IuY29udHJvbHMuZ2V0QXZhaWxhYmxlKClcbiAgICBmb3IgKGxldCBrZXkgaW4gY29udHJvbHMpIHtcbiAgICAgIGNvbnN0IENvbnRyb2wgPSBjb250cm9sc1trZXldXG4gICAgICBpZiAodGhpcy5fZWRpdG9yLmNvbnRyb2xzLmlzRW5hYmxlZChrZXkpKSB7XG4gICAgICAgIHRoaXMuX2Fzc2V0cyA9IHRoaXMuX2Fzc2V0cy5jb25jYXQoQ29udHJvbC5nZXRQcmVsb2FkQXNzZXRzKHRoaXMuX2VkaXRvcikpXG4gICAgICAgIHRoaXMuX2Fzc2V0cy5wdXNoKENvbnRyb2wuaWNvblBhdGgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBhc3NldHMsIGVtaXRzIHByb2dyZXNzIGV2ZW50c1xuICAgKi9cbiAgbG9hZCAoKSB7XG4gICAgY29uc3QgYXNzZXRzID0gdGhpcy5fYXNzZXRzLnNsaWNlKClcbiAgICBjb25zdCBhc3NldHNDb3VudCA9IGFzc2V0cy5sZW5ndGhcbiAgICBsZXQgYXNzZXRzTG9hZGVkID0gMFxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYW4gYXNzZXQgaGFzIGJlZW4gbG9hZGVkLiBJbmNyZWFzZXMgdGhlIGFzc2V0IGNvdW50ZXIgYW5kIGVtaXRzIGEgcHJvZ3Jlc3NcbiAgICAgKiBldmVudFxuICAgICAqL1xuICAgIGNvbnN0IGFzc2V0TG9hZGVkID0gKCkgPT4ge1xuICAgICAgYXNzZXRzTG9hZGVkKytcbiAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCBhc3NldHNMb2FkZWQgLyBhc3NldHNDb3VudClcbiAgICAgIGlmIChhc3NldHNMb2FkZWQgPT09IGFzc2V0c0NvdW50KSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZG9uZScpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9ncyBhIHdhcm5pbmcgbWVzc2FnZSB0aGF0IHRoZSBnaXZlbiBhc3NldCBmYWlsZWQgdG8gbG9hZCBmb3IgdGhlIGdpdmVuIHJlYXNvblxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gcGF0aFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gcmVhc29uXG4gICAgICovXG4gICAgY29uc3QgYXNzZXRMb2FkRmFpbGVkID0gKHBhdGgsIHJlYXNvbiA9ICd0aW1lZCBvdXQnKSA9PiB7XG4gICAgICBMb2cud2FybignUHJlbG9hZGVyJywgYCR7cGF0aH0gJHtyZWFzb259LmApXG4gICAgICBhc3NldExvYWRlZCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRpbWVvdXQgZm9yIHRoZSBnaXZlbiBhc3NldCBwYXRoLiBBc3N1bWVzIGFuIGFzc2V0IGZhaWxlZCB0byBsb2FkIHdoZW4gdGltZW91dFxuICAgICAqIHJ1bnMgb3V0XG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBwYXRoXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGNvbnN0IGxvYWRUaW1lb3V0ID0gKHBhdGgpID0+IHtcbiAgICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGFzc2V0TG9hZEZhaWxlZChwYXRoKVxuICAgICAgfSwgTE9BRF9USU1FT1VUKVxuICAgIH1cblxuICAgIGFzc2V0cy5mb3JFYWNoKChhc3NldCkgPT4ge1xuICAgICAgbGV0IHJldGluYUFzc2V0ID0gdHJ1ZVxuICAgICAgbGV0IHVpQXNzZXQgPSB0cnVlXG4gICAgICBpZiAoU0RLVXRpbHMuaXNBcnJheShhc3NldCkpIHtcbiAgICAgICAgdWlBc3NldCA9IGFzc2V0WzJdXG4gICAgICAgIHJldGluYUFzc2V0ID0gYXNzZXRbMV1cbiAgICAgICAgYXNzZXQgPSBhc3NldFswXVxuICAgICAgfVxuXG4gICAgICBjb25zdCBhc3NldFBhdGggPSB0aGlzLl91aS5nZXRBc3NldFBhdGgoYXNzZXQsIHVpQXNzZXQsICFyZXRpbmFBc3NldClcbiAgICAgIGNvbnN0IGltYWdlID0gbmV3IHdpbmRvdy5JbWFnZSgpXG4gICAgICBjb25zdCB0aW1lb3V0ID0gbG9hZFRpbWVvdXQoYXNzZXRQYXRoKVxuICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgdGhpcy5fYXNzZXRzW2Fzc2V0UGF0aF0gPSBpbWFnZVxuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgICAgIGFzc2V0TG9hZGVkKClcbiAgICAgIH0pXG4gICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgICAgICBhc3NldExvYWRGYWlsZWQoYXNzZXRQYXRoLCAnd2FzIG5vdCBmb3VuZCcpXG4gICAgICB9KVxuICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBTREtVdGlscy5nZXRDcm9zc09yaWdpblZhbHVlKHRoaXMuX29wdGlvbnMuY3Jvc3NPcmlnaW4pIC8vIHRoaXMuX3VpLmdldFNESygpLmdldENyb3NzT3JpZ2luKClcbiAgICAgIGltYWdlLnNyYyA9IGFzc2V0UGF0aFxuICAgIH0pXG4gIH1cblxuICBnZXRBc3NldCAoYXNzZXRQYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fzc2V0c1thc3NldFBhdGhdXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9wcmVsb2FkZXIuanMiLCIvKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgUHJvdmlkZXIgfSBmcm9tICcuL3Byb3ZpZGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaWJyYXJ5IH0gZnJvbSAnLi9saWJyYXJ5J1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZWFyY2hTdWdnZXN0aW9uIH0gZnJvbSAnLi9zZWFyY2gtc3VnZ2VzdGlvbidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUGhvdG8gfSBmcm9tICcuL3Bob3RvJ1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL3Bob3RvLXJvbGwvaW5kZXguanMiLCIvKiBAbW9kdWxlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IExvZywgUHJvbWlzZSB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb3ZpZGVyIHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpYnJhcmllc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGdldExpYnJhcmllcyAoKSB7XG4gICAgTG9nLndhcm4odGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCAnYGdldExpYnJhcmllc2AgaXMgYWJzdHJhY3QgYW5kIG5vdCBpbXBsZW1lbnRlZC4nKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzZWFyY2ggc3VnZ2VzdGlvbnMgc2hvd24gb24gdGhlIG92ZXJ2aWV3IGFuZCBcIm5vIHJlc3VsdHNcIiBwYWdlXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgZ2V0U2VhcmNoU3VnZ2VzdGlvbnMgKCkge1xuICAgIExvZy53YXJuKHRoaXMuY29uc3RydWN0b3IubmFtZSwgJ2BnZXRTZWFyY2hTdWdnZXN0aW9uc2AgaXMgYWJzdHJhY3QgYW5kIG5vdCBpbXBsZW1lbnRlZC4nKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGhvdG9zIGZvciB0aGUgZ2l2ZW4gbGlicmFyeVxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuUGhvdG9Sb2xsLkxpYnJhcnl9IGxpYnJhcnlcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBnZXRQaG90b3NGb3JMaWJyYXJ5IChsaWJyYXJ5KSB7XG4gICAgTG9nLndhcm4odGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCAnYGdldFBob3Rvc0ZvckxpYnJhcnlgIGlzIGFic3RyYWN0IGFuZCBub3QgaW1wbGVtZW50ZWQuJylcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKVxuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaGVzIGZvciBwaG90b3Mgd2l0aCB0aGUgZ2l2ZW4gcXVlcnlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5XG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBzZWFyY2hQaG90b3MgKHF1ZXJ5KSB7XG4gICAgTG9nLndhcm4odGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCAnYHNlYXJjaFBob3Rvc2AgaXMgYWJzdHJhY3QgYW5kIG5vdCBpbXBsZW1lbnRlZC4nKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9waG90by1yb2xsL3Byb3ZpZGVyLmpzIiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaWJyYXJ5IHtcbiAgY29uc3RydWN0b3IgKGRhdGEpIHtcbiAgICB0aGlzLm5hbWUgPSBkYXRhLm5hbWVcbiAgICB0aGlzLmNvdmVySW1hZ2UgPSBkYXRhLmNvdmVySW1hZ2VcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL3Bob3RvLXJvbGwvbGlicmFyeS5qcyIsIi8qIEBtb2R1bGUgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VhcmNoU3VnZ2VzdGlvbiB7XG4gIGNvbnN0cnVjdG9yIChkYXRhKSB7XG4gICAgdGhpcy5xdWVyeSA9IGRhdGEucXVlcnlcbiAgICB0aGlzLm5hbWUgPSB0aGlzLnF1ZXJ5XG4gICAgdGhpcy5jb3ZlckltYWdlID0gZGF0YS5jb3ZlckltYWdlXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9waG90by1yb2xsL3NlYXJjaC1zdWdnZXN0aW9uLmpzIiwiLyogQG1vZHVsZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQaG90byB7XG4gIGNvbnN0cnVjdG9yIChsaWJyYXJ5LCBkYXRhKSB7XG4gICAgdGhpcy5saWJyYXJ5ID0gbGlicmFyeVxuICAgIHRoaXMudGl0bGUgPSBkYXRhLnRpdGxlXG4gICAgdGhpcy51cmxzID0gZGF0YS51cmxzXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9waG90by1yb2xsL3Bob3RvLmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XCJwZXNka1wiOntcImFkanVzdG1lbnRzXCI6e1widGl0bGVcIjp7XCJuYW1lXCI6XCJLb3JyZWt0dXJlblwifSxcInRleHRcIjp7XCJicmlnaHRuZXNzXCI6XCJIZWxsaWdrZWl0XCIsXCJzYXR1cmF0aW9uXCI6XCJTw6R0dGlndW5nXCIsXCJjb250cmFzdFwiOlwiS29udHJhc3RcIixcImdhbW1hXCI6XCJHYW1tYVwiLFwiY2xhcml0eVwiOlwiS2xhcmhlaXRcIixcImV4cG9zdXJlXCI6XCJCZWxpY2h0dW5nXCIsXCJzaGFkb3dzXCI6XCJTY2hhdHRlblwiLFwiaGlnaGxpZ2h0c1wiOlwiTGljaHRlclwifX0sXCJicnVzaFwiOntcInRpdGxlXCI6e1wibmFtZVwiOlwiTWFsZW5cIn0sXCJ0ZXh0XCI6e1wic2l6ZVwiOlwiRGlja2VcIn19LFwiY2FtZXJhXCI6e1widGl0bGVcIjp7XCJoZWFkbGluZVwiOlwiTWFjaGUgZWluIEZvdG8hXCJ9LFwidGV4dFwiOntcIndlYmNhbVVuYXZhaWxhYmxlXCI6XCJXZWJjYW0tQmlsZCBrYW5uIG5pY2h0IGRhcmdlc3RlbGx0IHdlcmRlbi4gKEZlaGxlcjogJHtlcnJvcn0pXCJ9fSxcImNvbW1vblwiOntcInRpdGxlXCI6e1wiZXJyb3JcIjpcIkVzIGlzdCBlaW4gRmVobGVyIGF1ZmdldHJldGVuXCIsXCJpbWFnZUxvYWRGYWlsXCI6XCJCaWxkIGtvbm50ZSBuaWNodCBnZWxhZGVuIHdlcmRlblwifSxcInRleHRcIjp7XCJjb2xvclwiOlwiRmFyYmVcIixcImxvYWRpbmdcIjpcIkxhZGUuLi5cIixcImltYWdlTG9hZEZhaWxcIjpcIkJlaW0gTGFkZW4gZGVzIEJpbGRlcyB1bnRlciAke3BhdGh9IGlzdCBlaW4gRmVobGVyIGF1ZmdldHJldGVuLlwifSxcImJ1dHRvblwiOntcImJhY2tcIjpcIlp1csO8Y2tcIixcImNhbmNlbFwiOlwiQWJicmVjaGVuXCJ9fSxcImVkaXRvclwiOntcInRpdGxlXCI6e1wiem9vbVwiOlwiWm9vbVwiLFwicmVuZGVyaW5nRXJyb3JcIjpcIlJlbmRlcmluZy1GZWhsZXJcIixcImltYWdlUmVzaXplZF9tYXhNZWdhUGl4ZWxzXCI6XCJCaWxkIHZlcmtsZWluZXJ0XCIsXCJpbWFnZVJlc2l6ZWRfbWF4RGltZW5zaW9uc1wiOlwiQmlsZCB2ZXJrbGVpbmVydFwifSxcImJ1dHRvblwiOntcImV4cG9ydFwiOlwiU3BlaWNoZXJuXCIsXCJiYWNrZ3JvdW5kSW1hZ2VcIjpcIkhpbnRlcmdydW5kYmlsZFwiLFwibmV3XCI6XCJOZXVcIixcInVuZG9cIjpcIlLDvGNrZ8OkbmdpZ1wifSxcInRleHRcIjp7XCJpbnZhbGlkRmlsZVR5cGVcIjpcIkRlciBEYXRlaXR5cCAke2ZpbGVUeXBlfSB3aXJkIG5pY2h0IHVudGVyc3TDvHR6dC5cIixcImV4cG9ydGluZ1wiOlwiRXhwb3J0aWVyZS4uLlwiLFwicmVuZGVyaW5nRXJyb3JcIjpcIkJlaW0gUmVuZGVybiBkZXMgQmlsZGVzIGlzdCBlaW4gRmVobGVyIGF1ZmdldHJldGVuLlwiLFwicmVzaXppbmdcIjpcIkJpbGQgd2lyZCBiZWFyYmVpdGV0Li4uXCIsXCJpbWFnZVJlc2l6ZWRfbWF4TWVnYVBpeGVsc1wiOlwiRGEgZGVpbiBCaWxkIGRpZSBtYXhpbWFsZSBHcsO2w59lIHZvbiAke21heE1lZ2FQaXhlbHN9IE1lZ2FwaXhlbG4gw7xiZXJzY2hyZWl0ZXQsIHd1cmRlIGVzIGF1ZiAke3dpZHRofXgke2hlaWdodH0gUGl4ZWwgdmVya2xlaW5lcnQuXCIsXCJpbWFnZVJlc2l6ZWRfbWF4RGltZW5zaW9uc1wiOlwiQXVmZ3J1bmQgdm9uIEhhcmR3YXJlLUJlc2NocsOkbmt1bmdlbiB3dXJkZSBkYXMgQmlsZCBhdWYgJHt3aWR0aH14JHtoZWlnaHR9IFBpeGVsIHZlcmtsZWluZXJ0LlwifX0sXCJmaWx0ZXJcIjp7XCJ0aXRsZVwiOntcIm5hbWVcIjpcIkZpbHRlclwifSxcInRleHRcIjp7XCJpbnRlbnNpdHlcIjpcIkludGVuc2l0w6R0XCJ9LFwiYXNzZXRcIjp7XCJpZGVudGl0eVwiOlwiT3JpZ2luYWxcIixcImltZ2x5X2x1dF9jZWxzaXVzXCI6XCJDZWxzaXVzXCIsXCJpbWdseV9sdXRfY2hlc3RcIjpcIkNoZXN0XCIsXCJpbWdseV9sdXRfZml4aWVcIjpcIkZpeGllXCIsXCJpbWdseV9sdXRfZnJpZGdlXCI6XCJGcmlkZ2VcIixcImltZ2x5X2x1dF9mcm9udFwiOlwiRnJvbnRcIixcImltZ2x5X2x1dF9rMlwiOlwiSzJcIixcImltZ2x5X2x1dF9tZWxsb3dcIjpcIk1lbGxvd1wiLFwiaW1nbHlfbHV0X3NpblwiOlwiU2luXCIsXCJpbWdseV9sdXRfdGV4YXNcIjpcIlRleGFzXCIsXCJpbWdseV9sdXRfYWQxOTIwXCI6XCIxOTIwIEEuRC5cIixcImltZ2x5X2x1dF9hbmNpZW50XCI6XCJBbmNpZW50XCIsXCJpbWdseV9sdXRfYmxlYWNoZWRcIjpcIkJsZWFjaGVkXCIsXCJpbWdseV9sdXRfYmxlYWNoZWRibHVlXCI6XCJCbGVhY2hlZCBCbHVlXCIsXCJpbWdseV9sdXRfYmx1ZXNcIjpcIkJsdWVzXCIsXCJpbWdseV9sdXRfYmx1ZXNoYWRvd3NcIjpcIkJsdWUgU2hhZG93c1wiLFwiaW1nbHlfbHV0X2JyZWV6ZVwiOlwiQnJlZXplXCIsXCJpbWdseV9sdXRfYndcIjpcIkIgJiBXXCIsXCJpbWdseV9sdXRfY2xhc3NpY1wiOlwiQ2xhc3NpY1wiLFwiaW1nbHlfbHV0X2NvbG9yZnVsXCI6XCJDb2xvcmZ1bFwiLFwiaW1nbHlfbHV0X2Nvb2xcIjpcIkNvb2xcIixcImltZ2x5X2x1dF9jb3R0b25jYW5keVwiOlwiQ290dG9uIENhbmR5XCIsXCJpbWdseV9sdXRfY3JlYW15XCI6XCJDcmVhbXlcIixcImltZ2x5X2x1dF9laWdodGllc1wiOlwiRWlnaHRpZXNcIixcImltZ2x5X2x1dF9lbGRlclwiOlwiRWxkZXJcIixcImltZ2x5X2x1dF9ldmVuaW5nXCI6XCJFdmVuaW5nXCIsXCJpbWdseV9sdXRfZmFsbFwiOlwiRmFsbFwiLFwiaW1nbHlfbHV0X2Zvb2RcIjpcIkZvb2RcIixcImltZ2x5X2x1dF9nbGFtXCI6XCJHbGFtXCIsXCJpbWdseV9sdXRfZ29iYmxpblwiOlwiR29iYmxpblwiLFwiaW1nbHlfbHV0X2hpZ2hjYXJiXCI6XCJIaWdoIENhcmJcIixcImltZ2x5X2x1dF9oaWdoY29udHJhc3RcIjpcIkhpZ2ggQ29udHJhc3RcIixcImltZ2x5X2x1dF9rMVwiOlwiSzFcIixcImltZ2x5X2x1dF9rNlwiOlwiSzZcIixcImltZ2x5X2x1dF9rZHluYW1pY1wiOlwiS0R5bmFtaWNcIixcImltZ2x5X2x1dF9rZWVuXCI6XCJLZWVuXCIsXCJpbWdseV9sdXRfbGVuaW5cIjpcIkxlbmluXCIsXCJpbWdseV9sdXRfbGl0aG9cIjpcIkxpdGhvXCIsXCJpbWdseV9sdXRfbG9tbzEwMFwiOlwiTG9tbyAxMDBcIixcImltZ2x5X2x1dF9sdWNpZFwiOlwiTHVjaWRcIixcImltZ2x5X2x1dF9uZWF0XCI6XCJOZWF0XCIsXCJpbWdseV9sdXRfbm9ncmVlblwiOlwiTm8gR3JlZW5cIixcImltZ2x5X2x1dF9vcmNoaWRcIjpcIk9yY2hpZFwiLFwiaW1nbHlfbHV0X3BhbGVcIjpcIlBhbGVcIixcImltZ2x5X2x1dF9waXRjaGVkXCI6XCJQaXRjaGVkXCIsXCJpbWdseV9sdXRfcGxhdGVcIjpcIlBsYXRlXCIsXCJpbWdseV9sdXRfcG9sYTY2OVwiOlwiUG9sYSA2NjlcIixcImltZ2x5X2x1dF9wb2xhc3hcIjpcIlBvbGEgU1hcIixcImltZ2x5X2x1dF9wcm80MDBcIjpcIlBybyA0MDBcIixcImltZ2x5X2x1dF9xdW96aVwiOlwiUXVvemlcIixcImltZ2x5X2x1dF9zZXBpYWhpZ2hcIjpcIlNlcGlhIEhpZ2hcIixcImltZ2x5X2x1dF9zZXR0bGVkXCI6XCJTZXR0bGVkXCIsXCJpbWdseV9sdXRfc2V2ZW50aWVzXCI6XCJTZXZlbnRpZXNcIixcImltZ2x5X2x1dF9zb2Z0XCI6XCJTb2Z0XCIsXCJpbWdseV9sdXRfc3RlZWxcIjpcIlN0ZWVsXCIsXCJpbWdseV9sdXRfc3VtbWVyXCI6XCJTdW1tZXJcIixcImltZ2x5X2x1dF9zdW5zZXRcIjpcIlN1bnNldFwiLFwiaW1nbHlfbHV0X3RlbmRlclwiOlwiVGVuZGVyXCIsXCJpbWdseV9sdXRfdHdpbGlnaHRcIjpcIlR3aWxpZ2h0XCIsXCJpbWdseV9sdXRfd2ludGVyXCI6XCJXaW50ZXJcIixcImltZ2x5X2x1dF94NDAwXCI6XCJYNDAwXCIsXCJpbWdseV9maWx0ZXJzX2FuYWxvZ1wiOlwiQW5hbG9nXCIsXCJpbWdseV9maWx0ZXJzX2J3XCI6XCJCbGFjayAmIFdoaXRlXCIsXCJpbWdseV9maWx0ZXJzX3JldHJvXCI6XCJSZXRyb1wiLFwiaW1nbHlfZmlsdGVyc19zcGVjaWFsXCI6XCJTcGVjaWFsXCIsXCJpbWdseV9maWx0ZXJzX3N1bW1lclwiOlwiU3VtbWVyXCIsXCJpbWdseV9maWx0ZXJzX3dpbnRlclwiOlwiV2ludGVyXCIsXCJhbGxcIjpcIkFsbGVcIn19LFwiZm9jdXNcIjp7XCJ0aXRsZVwiOntcIm5hbWVcIjpcIkZvY3VzXCJ9LFwidGV4dFwiOntcImJsdXJSYWRpdXNcIjpcIlJhZGl1c1wifSxcImJ1dHRvblwiOntcIm5vbmVcIjpcIk9yaWdpbmFsXCIsXCJyYWRpYWxcIjpcIktyZWlzZsO2cm1pZ1wiLFwibWlycm9yZWRcIjpcIkdlc3BpZWdlbHRcIn19LFwiZnJhbWVcIjp7XCJ0aXRsZVwiOntcIm5hbWVcIjpcIlJhaG1lblwifSxcInRleHRcIjp7XCJzY2FsZVwiOlwiR3LDtsOfZVwifSxcImJ1dHRvblwiOntcIm5vbmVcIjpcIktlaW4gUmFobWVuXCJ9LFwiYXNzZXRcIjp7XCJpbWdseV9mcmFtZV9kaWFcIjpcIkRpYVwiLFwiaW1nbHlfZnJhbWVfYXJ0X2RlY29yXCI6XCJBcnQgRGVjb3JcIixcImltZ2x5X2ZyYW1lX2JsYWNrX3Bhc3NlcGFydG91dFwiOlwiQmxhY2sgUGFzc2VwYXJ0b3V0XCIsXCJpbWdseV9mcmFtZV9sb3dwb2x5X3NoYWRvd1wiOlwiTG93IFBvbHlcIixcImltZ2x5X2ZyYW1lX3dvb2RfcGFzc2VwYXJ0b3V0XCI6XCJXb29kIFBhc3NlcGFydG91dFwifX0sXCJsaWJyYXJ5XCI6e1widGl0bGVcIjp7XCJzZWFyY2hSZXN1bHRzXCI6XCJTdWNoZXJnZWJuaXNzZSBmw7xyIFxcXCIke3F1ZXJ5fVxcXCJcIixcInBob3RvUm9sbExvYWRGYWlsXCI6XCJMYWRlbiBkZXIgUGhvdG8gUm9sbCBmZWhsZ2VzY2hsYWdlblwifSxcInRleHRcIjp7XCJwaG90b1JvbGxMb2FkRmFpbFwiOlwiRmFpbGVkIHRvIGxvYWQgcGhvdG9zIGZvciB0aGUgcGhvdG8gcm9sbDogJHtlcnJvcn1cIixcIm5vU2VhcmNoUmVzdWx0c1wiOlwiRGllIFBob3RvIFJvbGwga29ubnRlIG5pY2h0IGdlbGFkZW4gd2VyZGVuOiAke2Vycm9yfVwifSxcInBsYWNlaG9sZGVyXCI6e1wic2VhcmNoXCI6XCJOYWNoIEZvdG9zIHN1Y2hlblwifX0sXCJzcGxhc2hcIjp7XCJidXR0b25cIjp7XCJ1cGxvYWRcIjpcIkxhZGUgZWluIEZvdG8gaG9jaFwifSxcInRpdGxlXCI6e1wicGhvdG9Sb2xsXCI6XCJLb3N0ZW5sb3NlcyBCaWxkbWF0ZXJpYWxcIixcIndlYmNhbVwiOlwiV2ViY2FtXCJ9LFwidGV4dFwiOntcInBob3RvUm9sbFwiOlwiU3VjaGUgZGlyIGVpbmVzIHZvbiB0YXVzZW5kZW4gU3RvY2sgUGhvdG9zIGF1cy5cIixcInVwbG9hZFwiOlwiS2xpY2tlIGhpZXIsIHVtIGVpbiBGb3RvIHZvbiBkZWluZW0gUmVjaG5lciBob2NoenVsYWRlbiBvZGVyIGxhZGUgZXMgcGVyIERyYWctYW5kLURyb3AgaG9jaFwiLFwid2ViY2FtXCI6XCJLbGlja2UgaGllciwgdW0gZWluIEZvdG8gbWl0IGRlaW5lciBXZWJjYW0genUgbWFjaGVuXCJ9fSxcInN0aWNrZXJcIjp7XCJ0aXRsZVwiOntcIm5hbWVcIjpcIlN0aWNrZXJcIixcImxvYWRpbmdTdGlja2Vyc0ZhaWxlZFwiOlwiTGFkZW4gZGVyIFN0aWNrZXIgZmVobGdlc2NobGFnZW5cIn0sXCJhc3NldFwiOntcImFsbFwiOlwiQWxsZVwiLFwiaW1nbHlfc3RpY2tlcl9lbW90aWNvbnNcIjpcIkVtb3RpY29uc1wiLFwiaW1nbHlfc3RpY2tlcl9zaGFwZXNcIjpcIlNoYXBlc1wifX0sXCJ0ZXh0XCI6e1widGl0bGVcIjp7XCJuYW1lXCI6XCJUZXh0XCIsXCJsb2FkaW5nRm9udHNGYWlsZWRcIjpcIkxhZGVuIGRlciBTY2hyaWZ0YXJ0ZW4gZmVobGdlc2NobGFnZW5cIn0sXCJ0ZXh0XCI6e1wibG9hZGluZ0ZvbnRzRmFpbGVkXCI6XCJFaW5pZ2UgU2NocmlmdGFydGVuIHNpbmQgbcO2Z2xpY2hlcndlaXNlIG5pY2h0IHZlcmbDvGdiYXIuXCJ9LFwiYnV0dG9uXCI6e1wic2l6ZVwiOlwiR3LDtsOfZVwiLFwiZm9udFwiOlwiU2NocmlmdGFydFwiLFwiYWxpZ25tZW50XCI6XCJBdXNyaWNodHVuZ1wiLFwiZm9yZWdyb3VuZFwiOlwiVm9yZGVyZ3J1bmRcIixcImJhY2tncm91bmRcIjpcIkhpbnRlcmdydW5kXCIsXCJ0YWtlVG9Gcm9udFwiOlwiTmFjaCBvYmVuXCJ9LFwicGxhY2Vob2xkZXJcIjp7XCJkZWZhdWx0VGV4dFwiOlwiRG9wcGVsa2xpY2sgenVtIEJlYXJiZWl0ZW4hXCJ9fSxcInRyYW5zZm9ybVwiOntcInRpdGxlXCI6e1wibmFtZVwiOlwiWnVzY2huZWlkZW5cIn0sXCJidXR0b25cIjp7XCJub25lXCI6XCJPcmlnaW5hbFwifSxcInRleHRcIjp7XCJyb3RhdGlvblwiOlwiRHJlaHVuZ1wifSxcImFzc2V0XCI6e1wiaW1nbHlfdHJhbnNmb3JtX2NvbW1vbl9jdXN0b21cIjpcIkZyZWlcIixcImltZ2x5X3RyYW5zZm9ybV9jb21tb25fc3F1YXJlXCI6XCJRdWFkcmF0aXNjaFwiLFwiaW1nbHlfdHJhbnNmb3JtX2NvbW1vbl80LTNcIjpcIjQ6M1wiLFwiaW1nbHlfdHJhbnNmb3JtX2NvbW1vbl8xNi05XCI6XCIxNjo5XCIsXCJpbWdseV90cmFuc2Zvcm1fZmFjZWJvb2tfYWRcIjpcIkZCIEFkXCIsXCJpbWdseV90cmFuc2Zvcm1fZmFjZWJvb2tfcG9zdFwiOlwiRkIgUG9zdFwiLFwiaW1nbHlfdHJhbnNmb3JtX2ZhY2Vib29rX2NvdmVyXCI6XCJGQiBDb3ZlclwiLFwiaW1nbHlfdHJhbnNmb3JtX2ZhY2Vib29rX3Byb2ZpbGVcIjpcIkZCIFByb2ZpbGVcIn19fX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xhbmcvZGUuanNvblxuLy8gbW9kdWxlIGlkID0gMjAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSB7XCJwZXNka1wiOntcImFkanVzdG1lbnRzXCI6e1widGl0bGVcIjp7XCJuYW1lXCI6XCJBZGp1c3RcIn0sXCJ0ZXh0XCI6e1wiYnJpZ2h0bmVzc1wiOlwiQnJpZ2h0bmVzc1wiLFwic2F0dXJhdGlvblwiOlwiU2F0dXJhdGlvblwiLFwiY29udHJhc3RcIjpcIkNvbnRyYXN0XCIsXCJnYW1tYVwiOlwiR2FtbWFcIixcImNsYXJpdHlcIjpcIkNsYXJpdHlcIixcImV4cG9zdXJlXCI6XCJFeHBvc3VyZVwiLFwic2hhZG93c1wiOlwiU2hhZG93c1wiLFwiaGlnaGxpZ2h0c1wiOlwiSGlnaGxpZ2h0c1wiLFwid2hpdGVzXCI6XCJXaGl0ZXNcIixcImJsYWNrc1wiOlwiQmxhY2tzXCIsXCJ0ZW1wZXJhdHVyZVwiOlwiVGVtcGVyYXR1cmVcIn19LFwiYnJ1c2hcIjp7XCJ0aXRsZVwiOntcIm5hbWVcIjpcIkJydXNoXCJ9LFwidGV4dFwiOntcInNpemVcIjpcIlNpemVcIn19LFwiY2FtZXJhXCI6e1widGl0bGVcIjp7XCJoZWFkbGluZVwiOlwiVGFrZSBhIHBob3RvIVwifSxcInRleHRcIjp7XCJ3ZWJjYW1VbmF2YWlsYWJsZVwiOlwiVW5hYmxlIHRvIGRpc3BsYXkgd2ViY2FtIGltYWdlIChFcnJvcjogJHtlcnJvcn0pXCJ9fSxcImNvbW1vblwiOntcInRpdGxlXCI6e1wiZXJyb3JcIjpcIkFuIGVycm9yIGhhcyBvY2N1cnJlZFwiLFwiaW1hZ2VMb2FkRmFpbFwiOlwiRmFpbGVkIHRvIGxvYWQgaW1hZ2VcIn0sXCJ0ZXh0XCI6e1wiY29sb3JcIjpcIkNvbG9yXCIsXCJsb2FkaW5nXCI6XCJMb2FkaW5nLi4uXCIsXCJpbWFnZUxvYWRGYWlsXCI6XCJGYWlsZWQgdG8gbG9hZCB0aGUgaW1hZ2UgYXQgJHtwYXRofVwifSxcImJ1dHRvblwiOntcImJhY2tcIjpcIkJhY2tcIixcImNhbmNlbFwiOlwiQ2FuY2VsXCJ9fSxcImVkaXRvclwiOntcInRpdGxlXCI6e1wiem9vbVwiOlwiWm9vbVwiLFwicmVuZGVyaW5nRXJyb3JcIjpcIkVycm9yIHdoaWxlIHJlbmRlcmluZ1wiLFwiaW1hZ2VSZXNpemVkX21heE1lZ2FQaXhlbHNcIjpcIkltYWdlIHJlc2l6ZWRcIixcImltYWdlUmVzaXplZF9tYXhEaW1lbnNpb25zXCI6XCJJbWFnZSByZXNpemVkXCJ9LFwiYnV0dG9uXCI6e1wiZXhwb3J0XCI6XCJFeHBvcnRcIixcImJhY2tncm91bmRJbWFnZVwiOlwiQmFja2dyb3VuZCBJbWFnZVwiLFwibmV3XCI6XCJOZXdcIixcInVuZG9cIjpcIlVuZG9cIn0sXCJ0ZXh0XCI6e1wiaW52YWxpZEZpbGVUeXBlXCI6XCJUaGUgZmlsZSB0eXBlICR7ZmlsZVR5cGV9IGlzIG5vdCBzdXBwb3J0ZWQuXCIsXCJleHBvcnRpbmdcIjpcIkV4cG9ydGluZy4uLlwiLFwicmVuZGVyaW5nRXJyb3JcIjpcIkFuIGVycm9yIGhhcyBvY2N1cnJlZCB3aGlsZSByZW5kZXJpbmcgdGhlIGltYWdlLlwiLFwicmVzaXppbmdcIjpcIlJlc2l6aW5nLi4uXCIsXCJpbWFnZVJlc2l6ZWRfbWF4TWVnYVBpeGVsc1wiOlwiWW91ciBpbWFnZSBleGNlZWRzIHRoZSBtYXhpbXVtIHNpemUgb2YgJHttYXhNZWdhUGl4ZWxzfSBtZWdhcGl4ZWxzIGFuZCBoYXMgdGhlcmVmb3JlIGJlZW4gcmVzaXplZCB0byAke3dpZHRofXgke2hlaWdodH0gcGl4ZWxzLlwiLFwiaW1hZ2VSZXNpemVkX21heERpbWVuc2lvbnNcIjpcIkR1ZSB0byBoYXJkd2FyZSBsaW1pdGF0aW9ucyB5b3VyIGltYWdlIGhhcyBiZWVuIHJlc2l6ZWQgdG8gJHt3aWR0aH14JHtoZWlnaHR9IHBpeGVscy5cIn19LFwiZmlsdGVyXCI6e1widGl0bGVcIjp7XCJuYW1lXCI6XCJGaWx0ZXJzXCJ9LFwidGV4dFwiOntcImludGVuc2l0eVwiOlwiSW50ZW5zaXR5XCJ9LFwiYXNzZXRcIjp7XCJpZGVudGl0eVwiOlwiTm9uZVwiLFwiaW1nbHlfbHV0X2NlbHNpdXNcIjpcIkNlbHNpdXNcIixcImltZ2x5X2x1dF9jaGVzdFwiOlwiQ2hlc3RcIixcImltZ2x5X2x1dF9maXhpZVwiOlwiRml4aWVcIixcImltZ2x5X2x1dF9mcmlkZ2VcIjpcIkZyaWRnZVwiLFwiaW1nbHlfbHV0X2Zyb250XCI6XCJGcm9udFwiLFwiaW1nbHlfbHV0X2syXCI6XCJLMlwiLFwiaW1nbHlfbHV0X21lbGxvd1wiOlwiTWVsbG93XCIsXCJpbWdseV9sdXRfc2luXCI6XCJTaW5cIixcImltZ2x5X2x1dF90ZXhhc1wiOlwiVGV4YXNcIixcImltZ2x5X2x1dF9hZDE5MjBcIjpcIjE5MjAgQS5ELlwiLFwiaW1nbHlfbHV0X2FuY2llbnRcIjpcIkFuY2llbnRcIixcImltZ2x5X2x1dF9ibGVhY2hlZFwiOlwiQmxlYWNoZWRcIixcImltZ2x5X2x1dF9ibGVhY2hlZGJsdWVcIjpcIkJsZWFjaGVkIEJsdWVcIixcImltZ2x5X2x1dF9ibHVlc1wiOlwiQmx1ZXNcIixcImltZ2x5X2x1dF9ibHVlc2hhZG93c1wiOlwiQmx1ZSBTaGFkb3dzXCIsXCJpbWdseV9sdXRfYnJlZXplXCI6XCJCcmVlemVcIixcImltZ2x5X2x1dF9id1wiOlwiQiAmIFdcIixcImltZ2x5X2x1dF9jbGFzc2ljXCI6XCJDbGFzc2ljXCIsXCJpbWdseV9sdXRfY29sb3JmdWxcIjpcIkNvbG9yZnVsXCIsXCJpbWdseV9sdXRfY29vbFwiOlwiQ29vbFwiLFwiaW1nbHlfbHV0X2NvdHRvbmNhbmR5XCI6XCJDb3R0b24gQ2FuZHlcIixcImltZ2x5X2x1dF9jcmVhbXlcIjpcIkNyZWFteVwiLFwiaW1nbHlfbHV0X2VpZ2h0aWVzXCI6XCJFaWdodGllc1wiLFwiaW1nbHlfbHV0X2VsZGVyXCI6XCJFbGRlclwiLFwiaW1nbHlfbHV0X2V2ZW5pbmdcIjpcIkV2ZW5pbmdcIixcImltZ2x5X2x1dF9mYWxsXCI6XCJGYWxsXCIsXCJpbWdseV9sdXRfZm9vZFwiOlwiRm9vZFwiLFwiaW1nbHlfbHV0X2dsYW1cIjpcIkdsYW1cIixcImltZ2x5X2x1dF9nb2JibGluXCI6XCJHb2JibGluXCIsXCJpbWdseV9sdXRfaGlnaGNhcmJcIjpcIkhpZ2ggQ2FyYlwiLFwiaW1nbHlfbHV0X2hpZ2hjb250cmFzdFwiOlwiSGlnaCBDb250cmFzdFwiLFwiaW1nbHlfbHV0X2sxXCI6XCJLMVwiLFwiaW1nbHlfbHV0X2s2XCI6XCJLNlwiLFwiaW1nbHlfbHV0X2tkeW5hbWljXCI6XCJLRHluYW1pY1wiLFwiaW1nbHlfbHV0X2tlZW5cIjpcIktlZW5cIixcImltZ2x5X2x1dF9sZW5pblwiOlwiTGVuaW5cIixcImltZ2x5X2x1dF9saXRob1wiOlwiTGl0aG9cIixcImltZ2x5X2x1dF9sb21vMTAwXCI6XCJMb21vIDEwMFwiLFwiaW1nbHlfbHV0X2x1Y2lkXCI6XCJMdWNpZFwiLFwiaW1nbHlfbHV0X25lYXRcIjpcIk5lYXRcIixcImltZ2x5X2x1dF9ub2dyZWVuXCI6XCJObyBHcmVlblwiLFwiaW1nbHlfbHV0X29yY2hpZFwiOlwiT3JjaGlkXCIsXCJpbWdseV9sdXRfcGFsZVwiOlwiUGFsZVwiLFwiaW1nbHlfbHV0X3BpdGNoZWRcIjpcIlBpdGNoZWRcIixcImltZ2x5X2x1dF9wbGF0ZVwiOlwiUGxhdGVcIixcImltZ2x5X2x1dF9wb2xhNjY5XCI6XCJQb2xhIDY2OVwiLFwiaW1nbHlfbHV0X3BvbGFzeFwiOlwiUG9sYSBTWFwiLFwiaW1nbHlfbHV0X3BybzQwMFwiOlwiUHJvIDQwMFwiLFwiaW1nbHlfbHV0X3F1b3ppXCI6XCJRdW96aVwiLFwiaW1nbHlfbHV0X3NlcGlhaGlnaFwiOlwiU2VwaWEgSGlnaFwiLFwiaW1nbHlfbHV0X3NldHRsZWRcIjpcIlNldHRsZWRcIixcImltZ2x5X2x1dF9zZXZlbnRpZXNcIjpcIlNldmVudGllc1wiLFwiaW1nbHlfbHV0X3NvZnRcIjpcIlNvZnRcIixcImltZ2x5X2x1dF9zdGVlbFwiOlwiU3RlZWxcIixcImltZ2x5X2x1dF9zdW1tZXJcIjpcIlN1bW1lclwiLFwiaW1nbHlfbHV0X3N1bnNldFwiOlwiU3Vuc2V0XCIsXCJpbWdseV9sdXRfdGVuZGVyXCI6XCJUZW5kZXJcIixcImltZ2x5X2x1dF90d2lsaWdodFwiOlwiVHdpbGlnaHRcIixcImltZ2x5X2x1dF93aW50ZXJcIjpcIldpbnRlclwiLFwiaW1nbHlfbHV0X3g0MDBcIjpcIlg0MDBcIixcImltZ2x5X2ZpbHRlcnNfYW5hbG9nXCI6XCJBbmFsb2dcIixcImltZ2x5X2ZpbHRlcnNfYndcIjpcIkJsYWNrICYgV2hpdGVcIixcImltZ2x5X2ZpbHRlcnNfcmV0cm9cIjpcIlJldHJvXCIsXCJpbWdseV9maWx0ZXJzX3NwZWNpYWxcIjpcIlNwZWNpYWxcIixcImltZ2x5X2ZpbHRlcnNfc3VtbWVyXCI6XCJTdW1tZXJcIixcImltZ2x5X2ZpbHRlcnNfd2ludGVyXCI6XCJXaW50ZXJcIixcImFsbFwiOlwiQWxsXCJ9fSxcImZvY3VzXCI6e1widGl0bGVcIjp7XCJuYW1lXCI6XCJGb2N1c1wifSxcInRleHRcIjp7XCJibHVyUmFkaXVzXCI6XCJCbHVyIHJhZGl1c1wifSxcImJ1dHRvblwiOntcIm5vbmVcIjpcIk5vbmVcIixcInJhZGlhbFwiOlwiUmFkaWFsXCIsXCJtaXJyb3JlZFwiOlwiTWlycm9yZWRcIn19LFwiZnJhbWVcIjp7XCJ0aXRsZVwiOntcIm5hbWVcIjpcIkZyYW1lXCJ9LFwidGV4dFwiOntcInNjYWxlXCI6XCJTY2FsZVwifSxcImJ1dHRvblwiOntcIm5vbmVcIjpcIk5vbmVcIn0sXCJhc3NldFwiOntcImltZ2x5X2ZyYW1lX2RpYVwiOlwiRGlhXCIsXCJpbWdseV9mcmFtZV9hcnRfZGVjb3JcIjpcIkFydCBEZWNvclwiLFwiaW1nbHlfZnJhbWVfYmxhY2tfcGFzc2VwYXJ0b3V0XCI6XCJCbGFjayBQYXNzZXBhcnRvdXRcIixcImltZ2x5X2ZyYW1lX2xvd3BvbHlfc2hhZG93XCI6XCJMb3cgUG9seVwiLFwiaW1nbHlfZnJhbWVfd29vZF9wYXNzZXBhcnRvdXRcIjpcIldvb2QgUGFzc2VwYXJ0b3V0XCJ9fSxcImxpYnJhcnlcIjp7XCJ0aXRsZVwiOntcInNlYXJjaFJlc3VsdHNcIjpcIlNlYXJjaCByZXN1bHRzIGZvciBcXFwiJHtxdWVyeX1cXFwiXCIsXCJwaG90b1JvbGxMb2FkRmFpbFwiOlwiRmFpbGVkIHRvIGxvYWQgUGhvdG8gUm9sbFwifSxcInRleHRcIjp7XCJwaG90b1JvbGxMb2FkRmFpbFwiOlwiRmFpbGVkIHRvIGxvYWQgcGhvdG9zIGZvciB0aGUgcGhvdG8gcm9sbDogJHtlcnJvcn1cIixcIm5vU2VhcmNoUmVzdWx0c1wiOlwiU29ycnksIGJ1dCB3ZSBjb3VsZG4ndCBmaW5kIGFueSBwaG90b3MgZm9yIDxzdHJvbmc+XFxcIiR7cXVlcnl9XFxcIjwvc3Ryb25nPi5cIn0sXCJwbGFjZWhvbGRlclwiOntcInNlYXJjaFwiOlwiU2VhcmNoIGZvciBwaG90b3NcIn19LFwic3BsYXNoXCI6e1wiYnV0dG9uXCI6e1widXBsb2FkXCI6XCJVcGxvYWQgeW91ciBpbWFnZVwifSxcInRpdGxlXCI6e1wicGhvdG9Sb2xsXCI6XCJGcmVlIHN0b2NrIGZvb3RhZ2VcIixcIndlYmNhbVwiOlwiV2ViY2FtXCJ9LFwidGV4dFwiOntcInBob3RvUm9sbFwiOlwiU2VsZWN0IGZyb20gdGhvdXNhbmRzIG9mIEZyZWUgU3RvY2sgUGhvdG9zXCIsXCJ1cGxvYWRcIjpcIlVwbG9hZCBhIHBpY3R1cmUgZnJvbSB5b3VyIGxpYnJhcnkgb3IganVzdCBkcmFnIGFuZCBkcm9wXCIsXCJ3ZWJjYW1cIjpcIlRha2UgYSBwaWN0dXJlIHdpdGggeW91ciB3ZWJjYW0gb3IgcGhvbmVcIn19LFwic3RpY2tlclwiOntcInRpdGxlXCI6e1wibmFtZVwiOlwiU3RpY2tlclwiLFwibG9hZGluZ1N0aWNrZXJzRmFpbGVkXCI6XCJGYWlsZWQgdG8gbG9hZCBzdGlja2Vyc1wifSxcImFzc2V0XCI6e1wiYWxsXCI6XCJBbGxcIixcImltZ2x5X3N0aWNrZXJfZW1vdGljb25zXCI6XCJFbW90aWNvbnNcIixcImltZ2x5X3N0aWNrZXJfc2hhcGVzXCI6XCJTaGFwZXNcIn19LFwidGV4dFwiOntcInRpdGxlXCI6e1wibmFtZVwiOlwiVGV4dFwiLFwibG9hZGluZ0ZvbnRzRmFpbGVkXCI6XCJGYWlsZWQgdG8gbG9hZCBmb250c1wifSxcInRleHRcIjp7XCJsb2FkaW5nRm9udHNGYWlsZWRcIjpcIlNvbWUgZm9udHMgbWlnaHQgbm90IGJlIGF2YWlsYWJsZS5cIn0sXCJidXR0b25cIjp7XCJzaXplXCI6XCJTaXplXCIsXCJmb250XCI6XCJGb250XCIsXCJhbGlnbm1lbnRcIjpcIkFsaWdubWVudFwiLFwiZm9yZWdyb3VuZFwiOlwiRm9yZWdyb3VuZFwiLFwiYmFja2dyb3VuZFwiOlwiQmFja2dyb3VuZFwiLFwidGFrZVRvRnJvbnRcIjpcIlRvIEZyb250XCJ9LFwicGxhY2Vob2xkZXJcIjp7XCJkZWZhdWx0VGV4dFwiOlwiRG91YmxlLWNsaWNrIHRvIGVkaXRcIn19LFwidHJhbnNmb3JtXCI6e1widGl0bGVcIjp7XCJuYW1lXCI6XCJUcmFuc2Zvcm1cIn0sXCJidXR0b25cIjp7XCJub25lXCI6XCJPcmlnaW5hbFwifSxcInRleHRcIjp7XCJyb3RhdGlvblwiOlwiUm90YXRpb25cIn0sXCJhc3NldFwiOntcImltZ2x5X3RyYW5zZm9ybV9jb21tb25fY3VzdG9tXCI6XCJDdXN0b21cIixcImltZ2x5X3RyYW5zZm9ybV9jb21tb25fc3F1YXJlXCI6XCJTcXVhcmVcIixcImltZ2x5X3RyYW5zZm9ybV9jb21tb25fNC0zXCI6XCI0OjNcIixcImltZ2x5X3RyYW5zZm9ybV9jb21tb25fMTYtOVwiOlwiMTY6OVwiLFwiaW1nbHlfdHJhbnNmb3JtX2ZhY2Vib29rX2FkXCI6XCJGQiBBZFwiLFwiaW1nbHlfdHJhbnNmb3JtX2ZhY2Vib29rX3Bvc3RcIjpcIkZCIFBvc3RcIixcImltZ2x5X3RyYW5zZm9ybV9mYWNlYm9va19jb3ZlclwiOlwiRkIgQ292ZXJcIixcImltZ2x5X3RyYW5zZm9ybV9mYWNlYm9va19wcm9maWxlXCI6XCJGQiBQcm9maWxlXCJ9fX19XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9sYW5nL2VuLmpzb25cbi8vIG1vZHVsZSBpZCA9IDIwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJzb3VyY2VSb290IjoiIn0=